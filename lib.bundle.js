(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Lib.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./fluid/lib/graphics.fld":
/*!********************************!*\
  !*** ./fluid/lib/graphics.fld ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// typedef Colour = Str\n// typedef Colours = List Colour\n// typedef Cat = Str\n\n// Simplistic but something more general may require primitives which take data values for input.\n// Application module GraphicsRenderer must be loaded for these definitions to work.\n// Str → Num\nprimitive textWidth;\n\n// Str → Num\nprimitive textHeight;\n\n// Group has location (0, 0) because it doesn't interfere with positioning of its children.\n// GraphicsElement → Point\nletrec fun coords {\n   Group(gs) → Point(0, 0);\n   Rect(x, y, _, _, _) → Point(x, y);\n   Text(x, y, _, _, _) → Point(x, y);\n   Viewport(x, y, _, _, _, _, _, _, _) → Point(x, y)\n};\n\n// GraphicsElement → Num\nlet get_x = fun g → match coords g as Point(x, _) → x;\n\n// GraphicsElement → Num\nlet get_y = fun g → match coords g as Point(_, y) → x;\n\n// Want some kind of typeclass mechanism plus record accessors/updaters.\n// Num → GraphicsElement → GraphicsElement\nletrec fun set_x x {\n   Group(gs) → error \"Group has immutable coordinates\";\n   Rect(_, y, w, h, fill) → Rect(x, y, w, h, fill);\n   Text(_, y, str, anchor, baseline) → Text(x, y, str, anchor, baseline);\n   Viewport(_, y, w, h, fill, margin, scale, translate, g) → \n      Viewport(x, y, w, h, fill, margin, scale, translate, g)\n};\n\n// (Point, Point) → Point\nlet dimensions2 = fun (Point(x1, y1), Point(x2, y2)) →\n   Point(max2 (x1, x2), max2 (y1, y2));\n\n// For Group, dimensions are relative to implicit coords of (0, 0), since a Group's children are effectively\n// positioned relative to parent of Group. For Polymarker, will probably have to ignore the markers themselves, \n// since they are scale-invariant.\n// GraphicsElement → Point\nletrec \n   fun dimensions {\n      Group(gs) → foldl dimensions2 Point(0, 0) (map (coords_op) gs);\n      Polyline(ps, _, _) → foldl dimensions2 Point(0, 0) ps;\n      Rect(_, _, w, h, _) → Point(w, h);\n      Text(_, _, _, _, _) → Point(0, 0); // treat text like markers; scale-invariant\n      Viewport(_, _, w, h, _, _, _, _, _) → Point(w, h)\n   };\n\n   fun coords_op g → \n      match prod coords dimensions g as \n      (Point(x, y), Point(w, h)) → Point(x + w, y + h);\n\n// GraphicsElement → Num\nlet width = fun g → match dimensions g as Point(w, _) → w;\n\n// GraphicsElement → Num\nlet height = fun g → match dimensions g as Point(_, h) → h;\n\n// Num → Num → List GraphicsElement → List GraphicsElement\nlet spaceRight = fun z sep gs →\n   zipWith (uncurry set_x) (iterate (length gs) (fun x → x + sep) z) gs;\n\n// Bake colour decisions into the library for the time being. Provide two palettes, so we can have two\n// different sets of categorical values (e.g. countries and energy types). Palettes from colorbrewer2.org.\nlet colours1 = [\"#66c2a5\", \"#a6d854\", \"#ffd92f\", \"#e5c494\", \"#fc8d62\", \"#b3b3b3\", \"#8da0cb\", \"#e78ac3\"];\nlet colours2 = [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\", \"#ffff33\", \"#a65628\", \"#f781bf\"];\n\n// Compositionality principle: child coords/dimensions are always expressed directly using parent reference \n// frame, to avoid depending on content of child, and so are not themselves scaled. Polyline can't be scaled\n// directly because it inherits its frame of reference from its parent. For Viewport, margin will shrink the\n// available area, possibly to zero, at which point nothing will be rendered.\n// Num → GraphicsElement → GraphicsElement\nletrec fun scaleToWidth w {\n   Rect(x, y, _, h, fill) → Rect(x, y, w, h, fill);\n   Viewport(x, y, w0, h, fill, margin, Scale(x_scale, y_scale), translate, g) → \n      let scale = Scale(x_scale * w / w0, y_scale) in Viewport(x, y, w, h, fill, margin, scale, translate, g)\n};\n\n// Num → List GraphicsElement → List GraphicsElement\nlet stackRight = fun sep gs →\n   map (scaleToWidth (1 - sep)) (spaceRight (sep / 2) 1 gs);\n\n// Num → List GraphicsElement → GraphicsElement\nlet groupRight = fun sep gs →\n   Viewport(0, 0, length gs, max (map height gs), \"none\", 0, Scale(1, 1), Translate(0, 0), Group(stackRight sep gs));\n\n// Heuristic saying how often to place a tick on an axis of length n.\n// Num → Num\nlet tickEvery = fun n →\n   let m = floor (logBase 10 n) in\n   match n <= 2 * 10 ** m as {\n      True → 2 * 10 ** (m - 1);\n      False → 10 ** m\n   };\n\nlet axisStrokeWidth = 0.5;\nlet axisColour = \"black\";\nlet backgroundColour = \"white\";\nlet defaultMargin = 24;\nlet markerRadius = 3.5;\nlet tickLength = 4;\n\n// Helpers for axis functions.\n// Orient → Colour → Num → GraphicsElement\nlet tick = fun {\n   Horiz colour len →\n      Line(Point(0, 0), Point(0, 0 - len), colour, axisStrokeWidth);\n   Vert colour len →\n      Line(Point(0, 0), Point(0 - len, 0), colour, axisStrokeWidth)\n   };\n\n// Orient → Num → Num → Str → GraphicsElement\nlet label = fun {\n   Horiz x distance str → Text(x, (0 - 4) - distance, str, \"middle\", \"hanging\"); // -4 , ugh\n   Vert x distance str → Text(0 - distance, x, str, \"end\", \"central\")\n};\n\n// Orient → Colour → Num → Str → GraphicsElement\nlet labelledTick = fun orient colour len str →\n   Group([tick orient colour len, label orient 0 len str]);\n\n// Orient → Num → Num → Point\nlet mkPoint = fun {\n   Horiz x y → Point(y, x);\n   Vert x y → Point(x, y)\n};\n\n// x is position of this axis on the other axis. Returns axis and position of last tick.\n// Orient → Num → Num → GraphicsElement \nlet axis = fun orient x start end →\n   let tickSp = tickEvery (end - start);\n   let firstTick = ceilingToNearest start tickSp;\n   let lastTick = ceilingToNearest end tickSp;\n   let n = floor ((end - firstTick) / tickSp) + 1;\n   let ys = iterate n (fun y → y + tickSp) firstTick;\n   // avoid redundant start and end points\n   let ys = match firstTick > start as {\n      True → [start, ...ys];\n      False → ys\n   };\n   let ys = match lastTick > end as {\n      True → concat ys [lastTick];\n      False → ys\n   };\n   let ps = map (mkPoint orient x) ys;\n   let ax = Group([\n      Line(head ps, last ps, axisColour, axisStrokeWidth),\n      Polymarkers(ps, flip map ys (compose (labelledTick orient axisColour tickLength) numToStr))\n   ])\n   in (ax, lastTick);\n\n// x is position of this axis on the other axis.\n// Orient → Num → Num → List Cat → GraphicsElement \nlet catAxis = fun orient x catValues →\n   let ys = iterate (length catValues + 1) (fun y → y + 1) 0;\n   let ps = map (mkPoint orient x) ys\n   in Group([\n      Line(head ps, last ps, axisColour, axisStrokeWidth),\n      Polymarkers(tail ps, map (const (tick orient axisColour tickLength)) catValues),\n      Polymarkers(flip map (tail ps) (fun Point(x, y) → Point(x - 0.5, y)), map (label orient -0.5 0) catValues)\n   ]);\n\n// Num → Num → Num → Num → List GraphicsElement → GraphicsElement\nlet viewport = fun x_start x_finish y_finish margin gs →\n   Viewport(0, 0, x_finish - x_start, y_finish, backgroundColour, margin, Scale(1, 1), Translate(0 - x_start, 0), Group(gs));\n\n// Plot a map of x values to lists of (categorical value, y value) pairs. Importantly, assume all data is uniform \n// (categorical keys are the same for each x value and are ordered the same each time).\n// Bool → Colours → Num → List (Num, List (Cat, Num)) → GraphicsElement\nlet lineChart = fun withAxes colours x_start data →\n   let xs = map fst data;\n   let nCat = length (snd (head data));\n   // (Num, Colour) → GraphicsElement\n   let plot = fun (n, colour) →\n      let ps = map (fun (x, kvs) → Point(x, snd (nth n kvs))) data\n      in Group([\n         Polyline(ps, colour, 1),\n         Polymarkers(ps, repeat (length ps) Circle(0, 0, markerRadius, colour))\n      ]);\n   // List GraphicsElement\n   let lines = zipWith plot (iterate nCat (fun n → n + 1) 0) colours;\n   let x_finish = last xs;\n   let y_finish = max (flip map data (fun (_, kvs) → max (map snd kvs)))\n   in match withAxes as {\n      True →\n         match axis Horiz 0 x_start x_finish as\n         (x_axis, x_finish) → match axis Vert x_start 0 y_finish as \n         (y_axis, y_finish') → viewport x_start x_finish y_finish' defaultMargin [x_axis, y_axis, ...lines];\n      False → viewport x_start x_finish y_finish 0 lines\n   };\n\n// Plot a chart of categorical values on the x-axis and renderings of the corresponding a-value on the y-axis.\n// (Colours → List a → GraphicsElement) → Bool → Colours → Num → List (Cat, a) → GraphicsElement\nlet categoricalChart = fun plotValue withAxes colours sep data →\n   let gs = stackRight sep (plotValue colours (map snd data));\n   let w = length gs;\n   let h = max (map height gs)\n   in match withAxes as {\n      True → \n         match catAxis Horiz 0 (map fst data) as \n         x_axis → match axis Vert 0 0 h as\n         (y_axis, h') → viewport 0 w h' defaultMargin (concat gs [x_axis, y_axis]); // axes on top\n      False → viewport 0 w h 0 gs\n   };\n\n// Colours → List a → GraphicsElement\nlet rects = fun colours ns →\n   zipWith (fun (colour, n) → Rect(0, 0, 1, n, colour)) colours ns;\n\n// First component of data (categorical value) currently ignored; values just mapped positionally to colors.\n// Can we use Group instead of Viewport here?\n// Colours → List (a, Num) → GraphicsElement\nlet stackedBar = fun colours ns →\n   let heights = (map snd ns);\n   let subtotals = scanl1 (fun (x, y) → x + y) 0 heights;\n   let dims = zip [0, ...subtotals] heights;\n   let rects = map \n      (fun ((y, height), colour) → Rect(0, y, 1, height, colour))\n      (zip dims colours)\n   in Viewport(0, 0, 1, last subtotals, \"none\", 0, Scale(1, 1), Translate(0, 0), Group(rects));\n\n// Bool → Colours → Num → List (a, Num) → GraphicsElement\nlet barChart = categoricalChart rects;\n\n// For each categorical value of type a, plot a bar chart for the corresponding b-indexed data.\n// Bool → Colours → Num → List (a, List (b, Num)) → GraphicsElement\nlet groupedBarChart = categoricalChart (compose map (flip (barChart False) 0));\n\n// See stackedBar for strong (unjustified) assumption about uniformity of data.\n// Bool → Colours → Num → List (a, List (b, Num)) → GraphicsElement\nlet stackedBarChart = categoricalChart (compose map stackedBar);\n\n// Bit of a hack, but how text fits into our model is a bit unclear at the moment.\n// Str → GraphicsElement → GraphicsElement\nlet caption = fun str Viewport(x, y, w, h, fill, margin, scale, translate, g) →\n   let g' = Group([\n      Text(x + w / 2, -2, str, \"middle\", \"hanging\"), // -3, ugh\n      Viewport(0, 0, w, h, fill, margin, scale, translate, g)\n   ])\n   in Viewport(x, y, w, h, backgroundColour, defaultMargin / 2 + 4, Scale(1, 1), Translate(0, 0), g')\n");

/***/ }),

/***/ "./fluid/lib/prelude.fld":
/*!*******************************!*\
  !*** ./fluid/lib/prelude.fld ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// Num → Num\nprimitive ceiling;\n\n// Str → a\nprimitive error;\n\n// Num → Num\nprimitive floor;\n\n// Natural logarithm.\n// Num → Num\nprimitive log;\n\n// Num → Str\nprimitive numToStr;\n\n// Print argument to the console and return it.\n// a → a\nprimitive debugLog;\n\n// Bool → Bool\nlet or = fun {\n   True x → True;\n   False True → True;\n   False False → False\n};\n\n// Bool → Bool\nlet not = fun {\n   True → False;\n   False → True\n};\n\n// (b → c) → (a → b) → a → c\n// Would like infix operators. \nlet compose = fun f g x → f (g x);\n\n// a → b → a\nlet const = fun x _ → x;\n\n// (a → b) → (a, c) → (b, c)\nlet first = fun f (a, c) → (f a, c);\n\n// (a, b) → a\nlet fst = fun (x, y) → x;\n\n// List a → a\nlet head = fun [x, ...xs] → x;\n\n// a → a\nlet id = fun x → x;\n\n// (a → b) → (a → c) → a → (b, c)\nlet prod = fun f g x → (f x, g x);\n\n// Num → Num → Ordering\nlet compare =\n   fun (x, y) →\n      match x < y as {\n         True → LT;\n         False → match x > y as {\n            True → GT;\n            False → EQ\n         }\n      };\n\n// List a → List a → List a\nletrec fun concat {\n   [] ys → ys;\n   [x, ...xs] ys → [x, ...concat xs ys]\n};\n\n// a → List a → Bool (where a ∈ {Num, Str})\nletrec fun elem x {\n   [] → False;\n   [x', ...xs] → or (x == x') (elem x xs)\n};\n\n// (a → Bool) → List a → List a\nletrec fun filter p {\n   [] → [];\n   [x, ...xs] →\n      let ys = filter p xs in\n      match p x as {\n         True → [x, ...ys];\n         False → ys\n      }\n};\n\n// (a → b → c) → b → a → c\nlet flip = fun f x y → f y x;\n\n// ((a, b) → a) → a → List b → a\nletrec fun foldl op z {\n   [] → z;\n   [x, ...xs] → foldl op (op (z, x)) xs\n};\n\n// ((a, b) → a) → List b → a\nletrec fun foldl1 op {\n   [x, ...xs] → foldl op x xs\n};\n\n// ((a, b) → b) → b → List a → b\nletrec fun foldr op z {\n   [] → z;\n   [x, ...xs] → op (x, foldr op z xs)\n};\n\n// ((a, b) → b) → List a → b\nletrec fun foldr1 op {\n   [x] → x;\n   [x, y, ...xs] → op (x, foldr1 op [y, ...xs])\n};\n\n// ((a, b) → a) → a → List b -> List a\nletrec fun scanl1 op z xs → \n   let go = fun (x, continue) acc → \n      let next = op (acc, x) in [next, ...continue next] in\n   foldr go (const []) xs z;\n\n// ((a, b) → a) → a → List b -> List a\nlet scanl = fun op z xs → \n   [z, ...scanl1 op z xs];\n\n// List a → a → List a\nletrec fun intersperse {\n   [] sep → [];\n   [x] sep → [x];\n   [x, y, ...ys] sep → [x, sep, ...intersperse [y, ...ys]]\n};\n\n// List a → a\nletrec fun last {\n   [x] → x;\n   [x, y, ...xs] → last [y, ...xs]\n};\n\n// Log of x in base y.\n// Num → Num → Num\nlet logBase = fun x y → log y / log x;\n\n// (a → b) → List a → List b\nletrec fun map f {\n   [] → [];\n   [x, ...xs] → [f x, ...map f xs]\n};\n\n// Num → (a → a) → a → List a\nletrec fun iterate n f z → match n == 0 as {\n   True → [];\n   False → [z, ...map f (iterate (n - 1) f z)]\n};\n\n// List a → Num\nletrec fun length {\n   [] → 0;\n   [x, ...xs] → 1 + length xs\n};\n\n// Num → Num\nlet negate = fun n → 0 - n;\n\n// List a → List a\nletrec fun reverse {\n   [] → [];\n   [x, ...xs] → concat (reverse xs) [x]\n};\n\n// List (a, b) → (List a, List b)\nletrec fun unzip {\n   [] → ([], []);\n   [(x, y), ...xys] → \n      match unzip xys as (xs, ys) → ([x, ...xs], [y, ...ys])\n};\n\n// ((a, b) → c) → List a → List b → List c\nletrec fun zipWith op {\n   [] ys → [];\n   [x, ...xs] {\n      [] → [];\n      [y, ...ys] → [op (x, y), ...zipWith op xs ys]\n   }\n};\n\nlet zip = zipWith id;\n\n// Num → a → List a\nlet repeat = flip iterate id;\n\n// a → List (a, b) → b (where a ∈ {Num, Str})\nletrec fun lookup k [(k', v), ...kvs] → \n   match k == k' as {\n      True → v;\n      False → lookup k kvs\n   };\n\n// (Num, Num) → Num\nlet max2 = fun (n, m) →\n   match n > m as { True → n; False → m };\n\n// (Num, Num) → Num\nlet min2 = fun (n, m) →\n   match n < m as { True → n; False → m };\n\n// List Num → Num\nlet max = foldr1 max2;\n\n// List Num → Num\nlet min = foldr1 min2;\n\n// Expects non-negative integer as first argument and non-empty list as second argument.\n// Num → List a → a\nletrec fun nth n [x, ...xs] → match n == 0 as {\n   True → x;\n   False → nth (n - 1) xs\n};\n\n// Num → Num → Num\nlet ceilingToNearest = fun n m → \n   ceiling (n / m) * m;\n\n// (a → b) → (c, a) → (c, b)\nlet second = fun f (c, a) → (c, f a);\n\n// (a, b) → b\nlet snd = fun (x, y) → y;\n\n// List Num → Num\nlet sum = fun xs → \n   foldr (fun (x, y) → x + y) 0 xs;\n\n// (a, b) → (b, a)\nlet swap = fun (a, b) → (b, a);\n\n// List a → List a\nlet tail = fun [x, ...xs] → xs;\n\n// (a, b) → c) → a → b → c\nlet curry = fun f x y → f (x, y);\n\n// (a → b → c) → (a, b) → c\nlet uncurry = fun f (x, y) → f x y;\n\nletrec fun take n xs →\n   match n <= 0 as {\n      True → [];\n      False → match xs as {\n         [] → [];\n         [x, ...xs] → [x, ...take (n - 1) xs]\n      }\n   };\n\nletrec fun drop n xs →\n   match n <= 0 as {\n      True → xs;\n      False → match xs as {\n         [] → [];\n         [_, ...xs] → drop (n - 1) xs\n      }\n   };\n\n// Num → List a → List a\nlet lastN = fun n xs →\n   foldl (uncurry (compose const (drop 1))) xs (drop n xs)\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/dist/tippy.css":
/*!************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/dist/tippy.css ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".tippy-tooltip[data-animation=fade][data-state=hidden]{opacity:0}.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{pointer-events:none;max-width:calc(100vw - 10px);transition-timing-function:cubic-bezier(.165,.84,.44,1);transition-property:transform}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;background-color:#333;transition-property:visibility,opacity,transform;outline:0}.tippy-tooltip[data-placement^=top]>.tippy-arrow{border-width:8px 8px 0;border-top-color:#333;margin:0 3px;transform-origin:50% 0;bottom:-7px}.tippy-tooltip[data-placement^=bottom]>.tippy-arrow{border-width:0 8px 8px;border-bottom-color:#333;margin:0 3px;transform-origin:50% 7px;top:-7px}.tippy-tooltip[data-placement^=left]>.tippy-arrow{border-width:8px 0 8px 8px;border-left-color:#333;margin:3px 0;transform-origin:0 50%;right:-7px}.tippy-tooltip[data-placement^=right]>.tippy-arrow{border-width:8px 8px 8px 0;border-right-color:#333;margin:3px 0;transform-origin:7px 50%;left:-7px}.tippy-tooltip[data-interactive][data-state=visible]{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{position:absolute;border-color:transparent;border-style:solid}.tippy-content{padding:5px 9px}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/themes/light-border.css":
/*!*********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/themes/light-border.css ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".tippy-tooltip.light-border-theme{background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,8,16,.15);color:#26323d;box-shadow:0 4px 14px -2px rgba(0,8,16,.08)}.tippy-tooltip.light-border-theme>.tippy-backdrop{background-color:#fff}.tippy-tooltip.light-border-theme>.tippy-arrow:after,.tippy-tooltip.light-border-theme>.tippy-arrow:before,.tippy-tooltip.light-border-theme>.tippy-svg-arrow:after,.tippy-tooltip.light-border-theme>.tippy-svg-arrow:before{content:\"\";position:absolute;z-index:-1}.tippy-tooltip.light-border-theme>.tippy-svg-arrow{fill:#fff}.tippy-tooltip.light-border-theme>.tippy-svg-arrow:after{background-image:url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNDE0IiB2aWV3Qm94PSIwIDAgMTggNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMCA3czIuMDIxLS4wMTUgNS4yNTMtNC4yMThDNi41ODQgMS4wNTEgNy43OTcuMDA3IDkgMGMxLjIwMy0uMDA3IDIuNDE2IDEuMDM1IDMuNzYxIDIuNzgyQzE2LjAxMiA3LjAwNSAxOCA3IDE4IDd6IiBmaWxsPSIjMzMzIiBmaWxsLW9wYWNpdHk9Ii4yMzUiIGZpbGwtcnVsZT0ibm9uemVybyIvPjwvc3ZnPg==);background-size:18px 7px;width:18px;height:7px;left:0;top:0;fill:rgba(0,8,16,.15)}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-svg-arrow:after{top:1px;transform:rotate(180deg)}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow{border-top-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:after{border-top:7px solid #fff;top:-7px}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:before{border-top:7px solid rgba(0,8,16,.2);bottom:-1px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-svg-arrow:after{top:-1px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow{border-bottom-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:after{border-bottom:7px solid #fff;bottom:-7px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:before{border-bottom:7px solid rgba(0,8,16,.2);bottom:-6px}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-svg-arrow:after{left:1px;top:0;transform:rotate(90deg)}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow{border-left-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:after{border-left:7px solid #fff;left:-7px}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:before{border-left:7px solid rgba(0,8,16,.2);left:-6px}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-svg-arrow:after{left:-1px;top:0;transform:rotate(-90deg)}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow{border-right-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:after{border-right:7px solid #fff;right:-7px}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:before{border-right:7px solid rgba(0,8,16,.2);right:-6px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-svg-arrow,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-svg-arrow{transform:translateX(-1px)}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:before,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:before{left:-7px;border-left:7px solid transparent;border-right:7px solid transparent}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-svg-arrow,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-svg-arrow{transform:translateY(-1px)}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:before,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:before{top:-7px;border-top:7px solid transparent;border-bottom:7px solid transparent}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/app/styles.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/app/styles.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(/*! ./inconsolata-webfont.woff */ "./src/app/inconsolata-webfont.woff");
var ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(/*! ./Slabo13px-Regular.woff */ "./src/app/Slabo13px-Regular.woff");
var ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(/*! ./AvenirLTStd-Book.woff */ "./src/app/AvenirLTStd-Book.woff");
exports = ___CSS_LOADER_API_IMPORT___(false);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);
// Module
exports.push([module.i, "@font-face {\n   font-family: \"inconsolata\";\n   font-style: normal;\n   font-weight: 400;\n   src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") format('woff');\n}\n\n@font-face {\n   font-family: \"Slabo 13px\";\n   font-style: normal;\n   font-weight: 400;\n   src: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") format('woff');\n}\n\n@font-face {\n   font-family: \"AvenirLTStd-Book\";\n   font-style: normal;\n   font-weight: 400;\n   src: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") format('woff');\n}\n\n.code {\n   font-family: \"inconsolata\";\n   stroke: none;\n}\n\n.label {\n   font-family: \"AvenirLTStd-Book\";\n   stroke: none;\n}\n\n.unchanged {\n   fill: black;\n}\n\n.changed {\n   fill: blue;\n}\n\n.new {\n   fill: limegreen;\n}\n\n.tippy-tooltip {\n   font-family: \"inconsolata\";\n}\n\n.tippy-tooltip.light-border-theme {\n   font-size: 9pt;\n}\n\n.focus {\n   stroke: black;\n   stroke-opacity: 0.1;\n   fill-opacity: 0.7;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/moo/moo.js":
/*!*********************************!*\
  !*** ./node_modules/moo/moo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) /* global define */
  } else {}
}(this, function() {
  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty
  var toString = Object.prototype.toString
  var hasSticky = typeof new RegExp().sticky === 'boolean'

  /***************************************************************************/

  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }
  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }

  function reEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
  }
  function reGroups(s) {
    var re = new RegExp('|' + s)
    return re.exec('').length - 1
  }
  function reCapture(s) {
    return '(' + s + ')'
  }
  function reUnion(regexps) {
    if (!regexps.length) return '(?!)'
    var source =  regexps.map(function(s) {
      return "(?:" + s + ")"
    }).join('|')
    return "(?:" + source + ")"
  }

  function regexpOrLiteral(obj) {
    if (typeof obj === 'string') {
      return '(?:' + reEscape(obj) + ')'

    } else if (isRegExp(obj)) {
      // TODO: consider /u support
      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')
      if (obj.global) throw new Error('RegExp /g flag is implied')
      if (obj.sticky) throw new Error('RegExp /y flag is implied')
      if (obj.multiline) throw new Error('RegExp /m flag is implied')
      return obj.source

    } else {
      throw new Error('Not a pattern: ' + obj)
    }
  }

  function objectToRules(object) {
    var keys = Object.getOwnPropertyNames(object)
    var result = []
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      var thing = object[key]
      var rules = [].concat(thing)
      if (key === 'include') {
        for (var j = 0; j < rules.length; j++) {
          result.push({include: rules[j]})
        }
        continue
      }
      var match = []
      rules.forEach(function(rule) {
        if (isObject(rule)) {
          if (match.length) result.push(ruleOptions(key, match))
          result.push(ruleOptions(key, rule))
          match = []
        } else {
          match.push(rule)
        }
      })
      if (match.length) result.push(ruleOptions(key, match))
    }
    return result
  }

  function arrayToRules(array) {
    var result = []
    for (var i = 0; i < array.length; i++) {
      var obj = array[i]
      if (obj.include) {
        var include = [].concat(obj.include)
        for (var j = 0; j < include.length; j++) {
          result.push({include: include[j]})
        }
        continue
      }
      if (!obj.type) {
        throw new Error('Rule has no type: ' + JSON.stringify(obj))
      }
      result.push(ruleOptions(obj.type, obj))
    }
    return result
  }

  function ruleOptions(type, obj) {
    if (!isObject(obj)) {
      obj = { match: obj }
    }
    if (obj.include) {
      throw new Error('Matching rules cannot also include states')
    }

    // nb. error and fallback imply lineBreaks
    var options = {
      defaultType: type,
      lineBreaks: !!obj.error || !!obj.fallback,
      pop: false,
      next: null,
      push: null,
      error: false,
      fallback: false,
      value: null,
      type: null,
      shouldThrow: false,
    }

    // Avoid Object.assign(), so we support IE9+
    for (var key in obj) {
      if (hasOwnProperty.call(obj, key)) {
        options[key] = obj[key]
      }
    }

    // type transform cannot be a string
    if (typeof options.type === 'string' && type !== options.type) {
      throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')")
    }

    // convert to array
    var match = options.match
    options.match = Array.isArray(match) ? match : match ? [match] : []
    options.match.sort(function(a, b) {
      return isRegExp(a) && isRegExp(b) ? 0
           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length
    })
    return options
  }

  function toRules(spec) {
    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)
  }

  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})
  function compileRules(rules, hasStates) {
    var errorRule = null
    var fast = Object.create(null)
    var fastAllowed = true
    var unicodeFlag = null
    var groups = []
    var parts = []

    // If there is a fallback rule, then disable fast matching
    for (var i = 0; i < rules.length; i++) {
      if (rules[i].fallback) {
        fastAllowed = false
      }
    }

    for (var i = 0; i < rules.length; i++) {
      var options = rules[i]

      if (options.include) {
        // all valid inclusions are removed by states() preprocessor
        throw new Error('Inheritance is not allowed in stateless lexers')
      }

      if (options.error || options.fallback) {
        // errorRule can only be set once
        if (errorRule) {
          if (!options.fallback === !errorRule.fallback) {
            throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')")
          } else {
            throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')")
          }
        }
        errorRule = options
      }

      var match = options.match.slice()
      if (fastAllowed) {
        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {
          var word = match.shift()
          fast[word.charCodeAt(0)] = options
        }
      }

      // Warn about inappropriate state-switching options
      if (options.pop || options.push || options.next) {
        if (!hasStates) {
          throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')")
        }
        if (options.fallback) {
          throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')")
        }
      }

      // Only rules with a .match are included in the RegExp
      if (match.length === 0) {
        continue
      }
      fastAllowed = false

      groups.push(options)

      // Check unicode flag is used everywhere or nowhere
      for (var j = 0; j < match.length; j++) {
        var obj = match[j]
        if (!isRegExp(obj)) {
          continue
        }

        if (unicodeFlag === null) {
          unicodeFlag = obj.unicode
        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
          throw new Error('If one rule is /u then all must be')
        }
      }

      // convert to RegExp
      var pat = reUnion(match.map(regexpOrLiteral))

      // validate
      var regexp = new RegExp(pat)
      if (regexp.test("")) {
        throw new Error("RegExp matches empty string: " + regexp)
      }
      var groupCount = reGroups(pat)
      if (groupCount > 0) {
        throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: … ) instead")
      }

      // try and detect rules matching newlines
      if (!options.lineBreaks && regexp.test('\n')) {
        throw new Error('Rule should declare lineBreaks: ' + regexp)
      }

      // store regex
      parts.push(reCapture(pat))
    }


    // If there's no fallback rule, use the sticky flag so we only look for
    // matches at the current index.
    //
    // If we don't support the sticky flag, then fake it using an irrefutable
    // match (i.e. an empty pattern).
    var fallbackRule = errorRule && errorRule.fallback
    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'
    var suffix = hasSticky || fallbackRule ? '' : '|'

    if (unicodeFlag === true) flags += "u"
    var combined = new RegExp(reUnion(parts) + suffix, flags)
    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}
  }

  function compile(rules) {
    var result = compileRules(toRules(rules))
    return new Lexer({start: result}, 'start')
  }

  function checkStateGroup(g, name, map) {
    var state = g && (g.push || g.next)
    if (state && !map[state]) {
      throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')")
    }
    if (g && g.pop && +g.pop !== 1) {
      throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')")
    }
  }
  function compileStates(states, start) {
    var all = states.$all ? toRules(states.$all) : []
    delete states.$all

    var keys = Object.getOwnPropertyNames(states)
    if (!start) start = keys[0]

    var ruleMap = Object.create(null)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      ruleMap[key] = toRules(states[key]).concat(all)
    }
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      var rules = ruleMap[key]
      var included = Object.create(null)
      for (var j = 0; j < rules.length; j++) {
        var rule = rules[j]
        if (!rule.include) continue
        var splice = [j, 1]
        if (rule.include !== key && !included[rule.include]) {
          included[rule.include] = true
          var newRules = ruleMap[rule.include]
          if (!newRules) {
            throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')")
          }
          for (var k = 0; k < newRules.length; k++) {
            var newRule = newRules[k]
            if (rules.indexOf(newRule) !== -1) continue
            splice.push(newRule)
          }
        }
        rules.splice.apply(rules, splice)
        j--
      }
    }

    var map = Object.create(null)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      map[key] = compileRules(ruleMap[key], true)
    }

    for (var i = 0; i < keys.length; i++) {
      var name = keys[i]
      var state = map[name]
      var groups = state.groups
      for (var j = 0; j < groups.length; j++) {
        checkStateGroup(groups[j], name, map)
      }
      var fastKeys = Object.getOwnPropertyNames(state.fast)
      for (var j = 0; j < fastKeys.length; j++) {
        checkStateGroup(state.fast[fastKeys[j]], name, map)
      }
    }

    return new Lexer(map, start)
  }

  function keywordTransform(map) {
    var reverseMap = Object.create(null)
    var byLength = Object.create(null)
    var types = Object.getOwnPropertyNames(map)
    for (var i = 0; i < types.length; i++) {
      var tokenType = types[i]
      var item = map[tokenType]
      var keywordList = Array.isArray(item) ? item : [item]
      keywordList.forEach(function(keyword) {
        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)
        if (typeof keyword !== 'string') {
          throw new Error("keyword must be string (in keyword '" + tokenType + "')")
        }
        reverseMap[keyword] = tokenType
      })
    }

    // fast string lookup
    // https://jsperf.com/string-lookups
    function str(x) { return JSON.stringify(x) }
    var source = ''
    source += 'switch (value.length) {\n'
    for (var length in byLength) {
      var keywords = byLength[length]
      source += 'case ' + length + ':\n'
      source += 'switch (value) {\n'
      keywords.forEach(function(keyword) {
        var tokenType = reverseMap[keyword]
        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\n'
      })
      source += '}\n'
    }
    source += '}\n'
    return Function('value', source) // type
  }

  /***************************************************************************/

  var Lexer = function(states, state) {
    this.startState = state
    this.states = states
    this.buffer = ''
    this.stack = []
    this.reset()
  }

  Lexer.prototype.reset = function(data, info) {
    this.buffer = data || ''
    this.index = 0
    this.line = info ? info.line : 1
    this.col = info ? info.col : 1
    this.queuedToken = info ? info.queuedToken : null
    this.queuedThrow = info ? info.queuedThrow : null
    this.setState(info ? info.state : this.startState)
    this.stack = info && info.stack ? info.stack.slice() : []
    return this
  }

  Lexer.prototype.save = function() {
    return {
      line: this.line,
      col: this.col,
      state: this.state,
      stack: this.stack.slice(),
      queuedToken: this.queuedToken,
      queuedThrow: this.queuedThrow,
    }
  }

  Lexer.prototype.setState = function(state) {
    if (!state || this.state === state) return
    this.state = state
    var info = this.states[state]
    this.groups = info.groups
    this.error = info.error
    this.re = info.regexp
    this.fast = info.fast
  }

  Lexer.prototype.popState = function() {
    this.setState(this.stack.pop())
  }

  Lexer.prototype.pushState = function(state) {
    this.stack.push(this.state)
    this.setState(state)
  }

  var eat = hasSticky ? function(re, buffer) { // assume re is /y
    return re.exec(buffer)
  } : function(re, buffer) { // assume re is /g
    var match = re.exec(buffer)
    // will always match, since we used the |(?:) trick
    if (match[0].length === 0) {
      return null
    }
    return match
  }

  Lexer.prototype._getGroup = function(match) {
    var groupCount = this.groups.length
    for (var i = 0; i < groupCount; i++) {
      if (match[i + 1] !== undefined) {
        return this.groups[i]
      }
    }
    throw new Error('Cannot find token type for matched text')
  }

  function tokenToString() {
    return this.value
  }

  Lexer.prototype.next = function() {
    var index = this.index

    // If a fallback token matched, we don't need to re-run the RegExp
    if (this.queuedGroup) {
      var token = this._token(this.queuedGroup, this.queuedText, index)
      this.queuedGroup = null
      this.queuedText = ""
      return token
    }

    var buffer = this.buffer
    if (index === buffer.length) {
      return // EOF
    }

    // Fast matching for single characters
    var group = this.fast[buffer.charCodeAt(index)]
    if (group) {
      return this._token(group, buffer.charAt(index), index)
    }

    // Execute RegExp
    var re = this.re
    re.lastIndex = index
    var match = eat(re, buffer)

    // Error tokens match the remaining buffer
    var error = this.error
    if (match == null) {
      return this._token(error, buffer.slice(index, buffer.length), index)
    }

    var group = this._getGroup(match)
    var text = match[0]

    if (error.fallback && match.index !== index) {
      this.queuedGroup = group
      this.queuedText = text

      // Fallback tokens contain the unmatched portion of the buffer
      return this._token(error, buffer.slice(index, match.index), index)
    }

    return this._token(group, text, index)
  }

  Lexer.prototype._token = function(group, text, offset) {
    // count line breaks
    var lineBreaks = 0
    if (group.lineBreaks) {
      var matchNL = /\n/g
      var nl = 1
      if (text === '\n') {
        lineBreaks = 1
      } else {
        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }
      }
    }

    var token = {
      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,
      value: typeof group.value === 'function' ? group.value(text) : text,
      text: text,
      toString: tokenToString,
      offset: offset,
      lineBreaks: lineBreaks,
      line: this.line,
      col: this.col,
    }
    // nb. adding more props to token object will make V8 sad!

    var size = text.length
    this.index += size
    this.line += lineBreaks
    if (lineBreaks !== 0) {
      this.col = size - nl + 1
    } else {
      this.col += size
    }

    // throw, if no rule with {error: true}
    if (group.shouldThrow) {
      throw new Error(this.formatError(token, "invalid syntax"))
    }

    if (group.pop) this.popState()
    else if (group.push) this.pushState(group.push)
    else if (group.next) this.setState(group.next)

    return token
  }

  if (typeof Symbol !== 'undefined' && Symbol.iterator) {
    var LexerIterator = function(lexer) {
      this.lexer = lexer
    }

    LexerIterator.prototype.next = function() {
      var token = this.lexer.next()
      return {value: token, done: !token}
    }

    LexerIterator.prototype[Symbol.iterator] = function() {
      return this
    }

    Lexer.prototype[Symbol.iterator] = function() {
      return new LexerIterator(this)
    }
  }

  Lexer.prototype.formatError = function(token, message) {
    if (token == null) {
      // An undefined token indicates EOF
      var text = this.buffer.slice(this.index)
      var token = {
        text: text,
        offset: this.index,
        lineBreaks: text.indexOf('\n') === -1 ? 0 : 1,
        line: this.line,
        col: this.col,
      }
    }
    var start = Math.max(0, token.offset - token.col + 1)
    var eol = token.lineBreaks ? token.text.indexOf('\n') : token.text.length
    var firstLine = this.buffer.substring(start, token.offset + eol)
    message += " at line " + token.line + " col " + token.col + ":\n\n"
    message += "  " + firstLine + "\n"
    message += "  " + Array(token.col).join(" ") + "^"
    return message
  }

  Lexer.prototype.clone = function() {
    return new Lexer(this.states, this.state)
  }

  Lexer.prototype.has = function(tokenType) {
    return true
  }


  return {
    compile: compile,
    states: compileStates,
    error: Object.freeze({error: true}),
    fallback: Object.freeze({fallback: true}),
    keywords: keywordTransform,
  }

}));


/***/ }),

/***/ "./node_modules/nearley/lib/nearley.js":
/*!*********************************************!*\
  !*** ./node_modules/nearley/lib/nearley.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(root, factory) {
    if ( true && module.exports) {
        module.exports = factory();
    } else {
        root.nearley = factory();
    }
}(this, function() {

    function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;        // a list of literal | regex class | nonterminal
        this.postprocess = postprocess;
        return this;
    }
    Rule.highestId = 0;

    Rule.prototype.toString = function(withCursorAt) {
        function stringifySymbolSequence (e) {
            return e.literal ? JSON.stringify(e.literal) :
                   e.type ? '%' + e.type : e.toString();
        }
        var symbolSequence = (typeof withCursorAt === "undefined")
                             ? this.symbols.map(stringifySymbolSequence).join(' ')
                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')
                                 + " ● "
                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );
        return this.name + " → " + symbolSequence;
    }


    // a State is a rule at a position from a given starting point in the input stream (reference)
    function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
    }

    State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    };

    State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
            state.data = state.build();
        }
        return state;
    };

    State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
            children.push(node.right.data);
            node = node.left;
        } while (node.left);
        children.reverse();
        return children;
    };

    State.prototype.finish = function() {
        if (this.rule.postprocess) {
            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
    };


    function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {}; // states indexed by the non-terminal they expect
        this.scannable = []; // list of states that expect a token
        this.completed = {}; // states that are nullable
    }


    Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;

        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration
            var state = states[w];

            if (state.isComplete) {
                state.finish();
                if (state.data !== Parser.fail) {
                    // complete
                    var wantedBy = state.wantedBy;
                    for (var i = wantedBy.length; i--; ) { // this line is hot
                        var left = wantedBy[i];
                        this.complete(left, state);
                    }

                    // special-case nullables
                    if (state.reference === this.index) {
                        // make sure future predictors of this rule get completed.
                        var exp = state.rule.name;
                        (this.completed[exp] = this.completed[exp] || []).push(state);
                    }
                }

            } else {
                // queue scannable states
                var exp = state.rule.symbols[state.dot];
                if (typeof exp !== 'string') {
                    this.scannable.push(state);
                    continue;
                }

                // predict
                if (wants[exp]) {
                    wants[exp].push(state);

                    if (completed.hasOwnProperty(exp)) {
                        var nulls = completed[exp];
                        for (var i = 0; i < nulls.length; i++) {
                            var right = nulls[i];
                            this.complete(state, right);
                        }
                    }
                } else {
                    wants[exp] = [state];
                    this.predict(exp);
                }
            }
        }
    }

    Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];

        for (var i = 0; i < rules.length; i++) {
            var r = rules[i];
            var wantedBy = this.wants[exp];
            var s = new State(r, 0, this.index, wantedBy);
            this.states.push(s);
        }
    }

    Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
    }


    function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
            if (!byName.hasOwnProperty(rule.name)) {
                byName[rule.name] = [];
            }
            byName[rule.name].push(rule);
        });
    }

    // So we can allow passing (rules, start) directly to Parser for backwards compatibility
    Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });
        var g = new Grammar(rules, start);
        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable
        return g;
    }


    function StreamLexer() {
      this.reset("");
    }

    StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
    }

    StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
            var ch = this.buffer[this.index++];
            if (ch === '\n') {
              this.line += 1;
              this.lastLineBreak = this.index;
            }
            return {value: ch};
        }
    }

    StreamLexer.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak,
      }
    }

    StreamLexer.prototype.formatError = function(token, message) {
        // nb. this gets called after consuming the offending token,
        // so the culprit is index-1
        var buffer = this.buffer;
        if (typeof buffer === 'string') {
            var nextLineBreak = buffer.indexOf('\n', this.index);
            if (nextLineBreak === -1) nextLineBreak = buffer.length;
            var line = buffer.substring(this.lastLineBreak, nextLineBreak)
            var col = this.index - this.lastLineBreak;
            message += " at line " + this.line + " col " + col + ":\n\n";
            message += "  " + line + "\n"
            message += "  " + Array(col).join(" ") + "^"
            return message;
        } else {
            return message + " at index " + (this.index - 1);
        }
    }


    function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
            var grammar = rules;
            var options = start;
        } else {
            var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;

        // Read options
        this.options = {
            keepHistory: false,
            lexer: grammar.lexer || new StreamLexer,
        };
        for (var key in (options || {})) {
            this.options[key] = options[key];
        }

        // Setup lexer
        this.lexer = this.options.lexer;
        this.lexerState = undefined;

        // Setup a table
        var column = new Column(grammar, 0);
        var table = this.table = [column];

        // I could be expecting anything.
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        // TODO what if start rule is nullable?
        column.process();
        this.current = 0; // token index
    }

    // create a reserved token for indicating a parse fail
    Parser.fail = {};

    Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);

        var token;
        while (token = lexer.next()) {
            // We add new states to table[current+1]
            var column = this.table[this.current];

            // GC unused states
            if (!this.options.keepHistory) {
                delete this.table[this.current - 1];
            }

            var n = this.current + 1;
            var nextColumn = new Column(this.grammar, n);
            this.table.push(nextColumn);

            // Advance all tokens that expect the symbol
            var literal = token.text !== undefined ? token.text : token.value;
            var value = lexer.constructor === StreamLexer ? token.value : token;
            var scannable = column.scannable;
            for (var w = scannable.length; w--; ) {
                var state = scannable[w];
                var expect = state.rule.symbols[state.dot];
                // Try to consume the token
                // either regex or literal
                if (expect.test ? expect.test(value) :
                    expect.type ? expect.type === token.type
                                : expect.literal === literal) {
                    // Add it
                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});
                    nextColumn.states.push(next);
                }
            }

            // Next, for each of the rules, we either
            // (a) complete it, and try to see if the reference row expected that
            //     rule
            // (b) predict the next nonterminal it expects by adding that
            //     nonterminal's start state
            // To prevent duplication, we also keep track of rules we have already
            // added

            nextColumn.process();

            // If needed, throw an error:
            if (nextColumn.states.length === 0) {
                // No states at all! This is not good.
                var err = new Error(this.reportError(token));
                err.offset = this.current;
                err.token = token;
                throw err;
            }

            // maybe save lexer state
            if (this.options.keepHistory) {
              column.lexerState = lexer.save()
            }

            this.current++;
        }
        if (column) {
          this.lexerState = lexer.save()
        }

        // Incrementally keep track of results
        this.results = this.finish();

        // Allow chaining, for whatever it's worth
        return this;
    };

    Parser.prototype.reportError = function(token) {
        var lines = [];
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);
        lines.push(this.lexer.formatError(token, "Syntax error"));
        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\n');
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states
            .filter(function(state) {
                var nextSymbol = state.rule.symbols[state.dot];
                return nextSymbol && typeof nextSymbol !== "string";
            });

        // Display a "state stack" for each expectant state
        // - which shows you how this state came to be, step by step.
        // If there is more than one derivation, we only display the first one.
        var stateStacks = expectantStates
            .map(function(state) {
                return this.buildFirstStateStack(state, []);
            }, this);
        // Display each state that is expecting a terminal symbol next.
        stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push('A ' + symbolDisplay + ' based on:');
            this.displayStateStack(stateStack, lines);
        }, this);

        lines.push("");
        return lines.join("\n");
    };

    Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
            var state = stateStack[j];
            var display = state.rule.toString(state.dot);
            if (display === lastDisplay) {
                sameDisplayCount++;
            } else {
                if (sameDisplayCount > 0) {
                    lines.push('    ⬆ ︎' + sameDisplayCount + ' more lines identical to this');
                }
                sameDisplayCount = 0;
                lines.push('    ' + display);
            }
            lastDisplay = display;
        }
    };

    Parser.prototype.getSymbolDisplay = function(symbol) {
        var type = typeof symbol;
        if (type === "string") {
            return symbol;
        } else if (type === "object" && symbol.literal) {
            return JSON.stringify(symbol.literal);
        } else if (type === "object" && symbol instanceof RegExp) {
            return 'character matching ' + symbol;
        } else if (type === "object" && symbol.type) {
            return symbol.type + ' token';
        } else {
            throw new Error('Unknown symbol type: ' + symbol);
        }
    };

    /*
    Builds a the first state stack. You can think of a state stack as the call stack
    of the recursive-descent parser which the Nearley parse algorithm simulates.
    A state stack is represented as an array of state objects. Within a
    state stack, the first item of the array will be the starting
    state, with each successive item in the array going further back into history.

    This function needs to be given a starting state and an empty array representing
    the visited states, and it returns an single state stack.

    */
    Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
            // Found cycle, return null
            // to eliminate this path from the results, because
            // we don't know how to display it meaningfully
            return null;
        }
        if (state.wantedBy.length === 0) {
            return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
            return null;
        }
        return [state].concat(childResult);
    };

    Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
    };

    Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;

        // Incrementally keep track of results
        this.results = this.finish();
    };

    // nb. deprecated: use save/restore instead!
    Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
            throw new Error('set option `keepHistory` to enable rewinding')
        }
        // nb. recall column (table) indicies fall between token indicies.
        //        col 0   --   token 0   --   col 1
        this.restore(this.table[index]);
    };

    Parser.prototype.finish = function() {
        // Return the possible parsings
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1]
        column.states.forEach(function (t) {
            if (t.rule.name === start
                    && t.dot === t.rule.symbols.length
                    && t.reference === 0
                    && t.data !== Parser.fail) {
                considerations.push(t);
            }
        });
        return considerations.map(function(c) {return c.data; });
    };

    return {
        Parser: Parser,
        Grammar: Grammar,
        Rule: Rule,
    };

}));


/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.chunk.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.chunk.esm.js ***!
  \*******************************************************/
/*! exports provided: B, R, _, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, r, s, t, u, w */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return BACKDROP_CLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return ROUND_ARROW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_", function() { return _extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isUCBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isMouseEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return errorWhen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return currentInput; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getOwnerDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return closestCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getBasePlacement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return arrayFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return hideAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return createTippyWithPlugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return normalizeToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return removeProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return setVisibilityState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return tippy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return useIfDefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return warnWhen; });
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/**!
* tippy.js v5.1.4
* (c) 2017-2020 atomiks
* MIT License
*/


function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var version = "5.1.4";

/**
 * Triggers reflow
 */
function reflow(element) {
  void element.offsetHeight;
}
/**
 * Sets the innerHTML of an element
 */

function setInnerHTML(element, html) {
  element[innerHTML()] = html;
}
/**
 * Determines if the value is a reference element
 */

function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
/**
 * Returns an array of elements based on the value
 */

function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
/**
 * Returns a value at a given index depending on if it's an array or number
 */

function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */

function getModifier(obj, key) {
  return obj && obj.modifiers && obj.modifiers[key];
}
/**
 * Determines if the value is of type
 */

function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
/**
 * Determines if the value is of type Element
 */

function isElement(value) {
  return isType(value, 'Element');
}
/**
 * Determines if the value is of type NodeList
 */

function isNodeList(value) {
  return isType(value, 'NodeList');
}
/**
 * Determines if the value is of type MouseEvent
 */

function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick
 * it
 */

function innerHTML() {
  return 'innerHTML';
}
/**
 * Evaluates a function if one, or returns the value
 */

function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
/**
 * Sets a popperInstance modifier's property to a value
 */

function setModifierValue(modifiers, name, property, value) {
  modifiers.filter(function (m) {
    return m.name === name;
  })[0][property] = value;
}
/**
 * Returns a new `div` element
 */

function div() {
  return document.createElement('div');
}
/**
 * Applies a transition duration to a list of elements
 */

function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
/**
 * Sets the visibility state to elements so they can begin to transition
 */

function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */

function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
/**
 * Preserves the original function invocation when another function replaces it
 */

function preserveInvocation(originalFn, currentFn, args) {
  if (originalFn && originalFn !== currentFn) {
    originalFn.apply(void 0, args);
  }
}
/**
 * Deletes properties from an object (pure)
 */

function removeProperties(obj, keys) {
  var clone = _extends({}, obj);

  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */

function arrayFrom(value) {
  return [].slice.call(value);
}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */

function closestCallback(element, callback) {
  while (element) {
    if (callback(element)) {
      return element;
    }

    element = element.parentElement;
  }

  return null;
}
/**
 * Determines if an array or string includes a string
 */

function includes(a, b) {
  return a.indexOf(b) > -1;
}
/**
 * Creates an array from string of values separated by whitespace
 */

function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
/**
 * Returns the `nextValue` if `nextValue` is not `undefined`, otherwise returns
 * `currentValue`
 */

function useIfDefined(nextValue, currentValue) {
  return nextValue !== undefined ? nextValue : currentValue;
}
/**
 * Converts a value that's an array or single value to an array
 */

function normalizeToArray(value) {
  return [].concat(value);
}
/**
 * Returns the ownerDocument of the first available element, otherwise global
 * document
 */

function getOwnerDocument(elementOrElements) {
  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0];

  return element ? element.ownerDocument || document : document;
}
/**
 * Adds item to array if array does not contain it
 */

function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
/**
 * Adds `px` if value is a number, or returns it directly
 */

function appendPxIfNumber(value) {
  return typeof value === 'number' ? value + "px" : value;
}
/**
 * Filters out duplicate elements in an array
 */

function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
/**
 * Returns number from number or CSS units string
 */

function getNumber(value) {
  return typeof value === 'number' ? value : parseFloat(value);
}
/**
 * Gets number or CSS string units in pixels (e.g. `1rem` -> 16)
 */

function getUnitsInPx(doc, value) {
  var isRem = typeof value === 'string' && includes(value, 'rem');
  var html = doc.documentElement;
  var rootFontSize = 16;

  if (html && isRem) {
    return parseFloat(getComputedStyle(html).fontSize || String(rootFontSize)) * getNumber(value);
  }

  return getNumber(value);
}
/**
 * Adds the `distancePx` value to the placement of a Popper.Padding object
 */

function getComputedPadding(basePlacement, padding, distancePx) {
  if (padding === void 0) {
    padding = 5;
  }

  var freshPaddingObject = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  var keys = Object.keys(freshPaddingObject);
  return keys.reduce(function (obj, key) {
    obj[key] = typeof padding === 'number' ? padding : padding[key];

    if (basePlacement === key) {
      obj[key] = typeof padding === 'number' ? padding + distancePx : padding[basePlacement] + distancePx;
    }

    return obj;
  }, freshPaddingObject);
}

function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return "\n    " + method + "() was called on a" + txt + "destroyed instance. This is a no-op but\n    indicates a potential memory leak.\n  ";
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}

function getFormattedMessage(message) {
  return [getDevMessage(message), // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
  'line-height: 1.5', // footer
  'color: #a6a095;'];
}
/**
 * Helpful wrapper around `console.warn()`.
 * TODO: Should we use a cache so it only warns a single time and not spam the
 * console? (Need to consider hot reloading and invalidation though). Chrome
 * already batches warnings as well.
 */

function warnWhen(condition, message) {
  if (condition) {
    var _console;

    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
/**
 * Helpful wrapper around `console.error()`
 */

function errorWhen(condition, message) {
  if (condition) {
    var _console2;

    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
/**
 * Validates the `targets` value passed to `tippy()`
 */

function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element, Element[],', 'or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is no longer supported as an argument.', 'See: https://atomiks.github.io/tippyjs/misc/#custom-position'].join(' '));
}

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var defaultProps = _extends({
  allowHTML: true,
  animation: 'fade',
  appendTo: function appendTo() {
    return document.body;
  },
  aria: 'describedby',
  arrow: true,
  boundary: 'scrollParent',
  content: '',
  delay: 0,
  distance: 10,
  duration: [300, 250],
  flip: true,
  flipBehavior: 'flip',
  flipOnUpdate: false,
  hideOnClick: true,
  ignoreAttributes: false,
  inertia: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  lazy: true,
  maxWidth: 350,
  multiple: false,
  offset: 0,
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  role: 'tooltip',
  showOnCreate: false,
  theme: '',
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null,
  updateDuration: 0,
  zIndex: 9999
}, pluginProps);
var defaultKeys = Object.keys(defaultProps);
/**
 * If the setProps() method encounters one of these, the popperInstance must be
 * recreated
 */

var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
/**
 * Mutates the defaultProps object by setting the props specified
 */

var setDefaultProps = function setDefaultProps(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
/**
 * Returns an extended props object including plugin props
 */

function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return _extends({}, passedProps, {}, pluginProps);
}
/**
 * Returns an object of optional props from data-tippy-* attributes
 */

function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(_extends({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
/**
 * Evaluates the props object by merging data attributes and disabling
 * conflicting props where necessary
 */

function evaluateProps(reference, props) {
  var out = _extends({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));

  if (out.interactive) {
    out.aria = null;
  }

  return out;
}
/**
 * Validates props with the valid `defaultProps` object
 */

function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var value = partialProps[prop];
    var didSpecifyPlacementInPopperOptions = prop === 'popperOptions' && value !== null && typeof value === 'object' && hasOwnProperty(value, 'placement');
    var nonPluginProps = removeProperties(defaultProps, ['animateFill', 'followCursor', 'inlinePositioning', 'sticky']); // These props have custom warnings

    var customWarningProps = ['a11y', 'arrowType', 'showOnInit', 'size', 'target', 'touchHold'];
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop) && !includes(customWarningProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }

    warnWhen(prop === 'target', ['The `target` prop was removed in v5 and replaced with the delegate() addon', 'in order to conserve bundle size.', 'See: https://atomiks.github.io/tippyjs/addons/#event-delegation'].join(' '));
    warnWhen(prop === 'a11y', ['The `a11y` prop was removed in v5. Make sure the element you are giving a', 'tippy to is natively focusable, such as <button> or <input>, not <div>', 'or <span>.'].join(' '));
    warnWhen(prop === 'showOnInit', 'The `showOnInit` prop was renamed to `showOnCreate` in v5.');
    warnWhen(prop === 'arrowType', ['The `arrowType` prop was removed in v5 in favor of overloading the `arrow`', 'prop.', '\n\n', '"round" string was replaced with importing the string from the package.', '\n\n', "* import {roundArrow} from 'tippy.js'; (ESM version)\n", '* const {roundArrow} = tippy; (IIFE CDN version)', '\n\n', 'Before: {arrow: true, arrowType: "round"}\n', 'After: {arrow: roundArrow}`'].join(' '));
    warnWhen(prop === 'touchHold', ['The `touchHold` prop was removed in v5 in favor of overloading the `touch`', 'prop.', '\n\n', 'Before: {touchHold: true}\n', 'After: {touch: "hold"}'].join(' '));
    warnWhen(prop === 'size', ['The `size` prop was removed in v5. Instead, use a theme that specifies', 'CSS padding and font-size properties.'].join(' '));
    warnWhen(prop === 'theme' && value === 'google', 'The included theme "google" was renamed to "material" in v5.');
    warnWhen(didSpecifyPlacementInPopperOptions, ['Specifying placement in `popperOptions` is not supported. Use the base-level', '`placement` prop instead.', '\n\n', 'Before: {popperOptions: {placement: "bottom"}}\n', 'After: {placement: "bottom"}'].join(' '));
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's a", 'plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'In v5, the following props were turned into plugins:', '\n\n', '* animateFill\n', '* followCursor\n', '* sticky', '\n\n', 'All props: https://atomiks.github.io/tippyjs/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/plugins/'].join(' '));
  });
}

var PASSIVE = {
  passive: true
};
var ROUND_ARROW = '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>';
var IOS_CLASS = "tippy-iOS";
var POPPER_CLASS = "tippy-popper";
var TOOLTIP_CLASS = "tippy-tooltip";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var POPPER_SELECTOR = "." + POPPER_CLASS;
var TOOLTIP_SELECTOR = "." + TOOLTIP_CLASS;
var CONTENT_SELECTOR = "." + CONTENT_CLASS;
var ARROW_SELECTOR = "." + ARROW_CLASS;
var SVG_ARROW_SELECTOR = "." + SVG_ARROW_CLASS;

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
/**
 * Adds the needed global event listeners
 */

function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, _extends({}, PASSIVE, {
    capture: true
  }));
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);
var isUCBrowser = /UCBrowser\//.test(ua);
var isIOS = isBrowser && /iPhone|iPad|iPod/.test(navigator.platform);
function updateIOSClass(isAdd) {
  var shouldAdd = isAdd && isIOS && currentInput.isTouch;
  document.body.classList[shouldAdd ? 'add' : 'remove'](IOS_CLASS);
}

/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */

function getBasePlacement(placement) {
  return placement.split('-')[0];
}
/**
 * Adds `data-inertia` attribute
 */

function addInertia(tooltip) {
  tooltip.setAttribute('data-inertia', '');
}
/**
 * Removes `data-inertia` attribute
 */

function removeInertia(tooltip) {
  tooltip.removeAttribute('data-inertia');
}
/**
 * Adds interactive-related attributes
 */

function addInteractive(tooltip) {
  tooltip.setAttribute('data-interactive', '');
}
/**
 * Removes interactive-related attributes
 */

function removeInteractive(tooltip) {
  tooltip.removeAttribute('data-interactive');
}
/**
 * Sets the content of a tooltip
 */

function setContent(contentEl, props) {
  if (isElement(props.content)) {
    setInnerHTML(contentEl, '');
    contentEl.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    var key = props.allowHTML ? 'innerHTML' : 'textContent';
    contentEl[key] = props.content;
  }
}
/**
 * Returns the child elements of a popper element
 */

function getChildren(popper) {
  return {
    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
    content: popper.querySelector(CONTENT_SELECTOR),
    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(SVG_ARROW_SELECTOR)
  };
}
/**
 * Creates an arrow element and returns it
 */

function createArrowElement(arrow) {
  var arrowElement = div();

  if (arrow === true) {
    arrowElement.className = ARROW_CLASS;
  } else {
    arrowElement.className = SVG_ARROW_CLASS;

    if (isElement(arrow)) {
      arrowElement.appendChild(arrow);
    } else {
      setInnerHTML(arrowElement, arrow);
    }
  }

  return arrowElement;
}
/**
 * Constructs the popper element and returns it
 */

function createPopperElement(id, props) {
  var popper = div();
  popper.className = POPPER_CLASS;
  popper.style.position = 'absolute';
  popper.style.top = '0';
  popper.style.left = '0';
  var tooltip = div();
  tooltip.className = TOOLTIP_CLASS;
  tooltip.id = "tippy-" + id;
  tooltip.setAttribute('data-state', 'hidden');
  tooltip.setAttribute('tabindex', '-1');
  updateTheme(tooltip, 'add', props.theme);
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');

  if (props.interactive) {
    addInteractive(tooltip);
  }

  if (props.arrow) {
    tooltip.setAttribute('data-arrow', '');
    tooltip.appendChild(createArrowElement(props.arrow));
  }

  if (props.inertia) {
    addInertia(tooltip);
  }

  setContent(content, props);
  tooltip.appendChild(content);
  popper.appendChild(tooltip);
  updatePopperElement(popper, props, props);
  return popper;
}
/**
 * Updates the popper element based on the new props
 */

function updatePopperElement(popper, prevProps, nextProps) {
  var _getChildren = getChildren(popper),
      tooltip = _getChildren.tooltip,
      content = _getChildren.content,
      arrow = _getChildren.arrow;

  popper.style.zIndex = '' + nextProps.zIndex;
  tooltip.setAttribute('data-animation', nextProps.animation);
  tooltip.style.maxWidth = appendPxIfNumber(nextProps.maxWidth);

  if (nextProps.role) {
    tooltip.setAttribute('role', nextProps.role);
  } else {
    tooltip.removeAttribute('role');
  }

  if (prevProps.content !== nextProps.content) {
    setContent(content, nextProps);
  } // arrow


  if (!prevProps.arrow && nextProps.arrow) {
    // false to true
    tooltip.appendChild(createArrowElement(nextProps.arrow));
    tooltip.setAttribute('data-arrow', '');
  } else if (prevProps.arrow && !nextProps.arrow) {
    // true to false
    tooltip.removeChild(arrow);
    tooltip.removeAttribute('data-arrow');
  } else if (prevProps.arrow !== nextProps.arrow) {
    // true to 'round' or vice-versa
    tooltip.removeChild(arrow);
    tooltip.appendChild(createArrowElement(nextProps.arrow));
  } // interactive


  if (!prevProps.interactive && nextProps.interactive) {
    addInteractive(tooltip);
  } else if (prevProps.interactive && !nextProps.interactive) {
    removeInteractive(tooltip);
  } // inertia


  if (!prevProps.inertia && nextProps.inertia) {
    addInertia(tooltip);
  } else if (prevProps.inertia && !nextProps.inertia) {
    removeInertia(tooltip);
  } // theme


  if (prevProps.theme !== nextProps.theme) {
    updateTheme(tooltip, 'remove', prevProps.theme);
    updateTheme(tooltip, 'add', nextProps.theme);
  }
}
/**
 * Add/remove transitionend listener from tooltip
 */

function updateTransitionEndListener(tooltip, action, listener) {
  var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
  tooltip[action + 'EventListener'](eventName, listener);
}
/**
 * Adds/removes theme from tooltip's classList
 */

function updateTheme(tooltip, action, theme) {
  splitBySpaces(theme).forEach(function (name) {
    tooltip.classList[action](name + "-theme");
  });
}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */

function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        tooltipRect = _ref.tooltipRect,
        interactiveBorder = _ref.interactiveBorder;
    // Get min/max bounds of both the popper and tooltip rects due to
    // `distance` offset
    var mergedRect = {
      top: Math.min(popperRect.top, tooltipRect.top),
      right: Math.max(popperRect.right, tooltipRect.right),
      bottom: Math.max(popperRect.bottom, tooltipRect.bottom),
      left: Math.min(popperRect.left, tooltipRect.left)
    };
    var exceedsTop = mergedRect.top - clientY > interactiveBorder;
    var exceedsBottom = clientY - mergedRect.bottom > interactiveBorder;
    var exceedsLeft = mergedRect.left - clientX > interactiveBorder;
    var exceedsRight = clientX - mergedRect.right > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}

var idCounter = 1;
var mouseMoveListeners = [];
/**
 * Used by `hideAll()`
 */

var mountedInstances = [];
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */

function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, _extends({}, defaultProps, {}, getExtendedPassedProps(passedProps))); // If the reference shouldn't have multiple tippys, return null early

  if (!props.multiple && reference._tippy) {
    return null;
  }
  /* ======================= 🔒 Private members 🔒 ======================= */


  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isBeingDestroyed = false;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var popperUpdates = 0;
  var lastTriggerEvent;
  var currentMountCallback;
  var currentTransitionEndListener;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget; // Support iframe contexts
  // Static check that assumes any of the `triggerTarget` or `reference`
  // nodes will never change documents, even when they are updated

  var doc = getOwnerDocument(props.triggerTarget || reference);
  /* ======================= 🔑 Public members 🔑 ======================= */

  var id = idCounter++;
  var popper = createPopperElement(id, props);
  var popperChildren = getChildren(popper);
  var popperInstance = null;
  var plugins = unique(props.plugins); // These two elements are static

  var tooltip = popperChildren.tooltip,
      content = popperChildren.content;
  var transitionableElements = [tooltip, content];
  var state = {
    // The current real placement (`data-placement` attribute)
    currentPlacement: null,
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: popper,
    popperChildren: popperChildren,
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    enable: enable,
    disable: disable,
    destroy: destroy
  };
  /* ==================== Initial instance mutations =================== */

  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  addListenersToTriggerTarget();
  handleAriaExpandedAttribute();

  if (!props.lazy) {
    createPopperInstance();
  }

  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function () {
    if (instance.props.interactive && includes(instance.props.trigger, 'mouseenter')) {
      doc.addEventListener('mousemove', debouncedOnMouseMove);
    }
  });
  return instance;
  /* ======================= 🔒 Private methods 🔒 ======================= */

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (hasOwnProperty(pluginHooks, hook)) {
        // @ts-ignore
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      // @ts-ignore
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaDescribedByAttribute() {
    var aria = instance.props.aria;

    if (!aria) {
      return;
    }

    var attr = "aria-" + aria;
    var id = tooltip.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    doc.body.removeEventListener('mouseleave', scheduleHide);
    doc.removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentMouseDown(event) {
    // Clicked on interactive popper
    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
        return;
      }
    }

    if (instance.props.hideOnClick === true) {
      isVisibleFromClick = false;
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentMouseDownListener();
      }
    }
  }

  function addDocumentMouseDownListener() {
    doc.addEventListener('mousedown', onDocumentMouseDown, true);
  }

  function removeDocumentMouseDownListener() {
    doc.removeEventListener('mousedown', onDocumentMouseDown, true);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    function listener(event) {
      if (event.target === tooltip) {
        updateTransitionEndListener(tooltip, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(tooltip, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListenersToTriggerTarget() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, PASSIVE);
      on('touchend', onMouseLeave, PASSIVE);
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlur);
          break;
      }
    });
  }

  function removeListenersFromTriggerTarget() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (!includes(instance.props.trigger, 'mouseenter') || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      var _getNormalizedTouchSe = getNormalizedTouchSettings(),
          value = _getNormalizedTouchSe[0],
          duration = _getNormalizedTouchSe[1];

      if (currentInput.isTouch && value === 'hold' && duration) {
        // We can hijack the show timeout here, it will be cleared by
        // `scheduleHide()` when necessary
        showTimeout = setTimeout(function () {
          scheduleShow(event);
        }, duration);
      } else {
        scheduleShow(event);
      }
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var isCursorOverReferenceOrPopper = closestCallback(event.target, function (el) {
      return el === reference || el === popper;
    });

    if (isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = arrayFrom(popper.querySelectorAll(POPPER_SELECTOR)).concat(popper).map(function (popper) {
      var instance = popper._tippy;
      var tooltip = instance.popperChildren.tooltip;
      var interactiveBorder = instance.props.interactiveBorder;
      return {
        popperRect: popper.getBoundingClientRect(),
        tooltipRect: tooltip.getBoundingClientRect(),
        interactiveBorder: interactiveBorder
      };
    });

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    if (isEventListenerStopped(event)) {
      return;
    }

    if (includes(instance.props.trigger, 'click') && isVisibleFromClick) {
      return;
    }

    if (instance.props.interactive) {
      doc.body.addEventListener('mouseleave', scheduleHide);
      doc.addEventListener('mousemove', debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      return;
    }

    scheduleHide(event);
  }

  function onBlur(event) {
    if (event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    var supportsTouch = 'ontouchstart' in window;
    var isTouchEvent = includes(event.type, 'touch');
    var isCustomTouch = getIsCustomTouchBehavior();
    return supportsTouch && currentInput.isTouch && isCustomTouch && !isTouchEvent || currentInput.isTouch && !isCustomTouch && isTouchEvent;
  }

  function createPopperInstance() {
    var popperOptions = instance.props.popperOptions;
    var arrow = instance.popperChildren.arrow;
    var flipModifier = getModifier(popperOptions, 'flip');
    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
    var distancePx;

    function applyMutations(data) {
      var prevPlacement = instance.state.currentPlacement;
      instance.state.currentPlacement = data.placement;

      if (instance.props.flip && !instance.props.flipOnUpdate) {
        if (data.flipped) {
          instance.popperInstance.options.placement = data.placement;
        }

        setModifierValue(instance.popperInstance.modifiers, 'flip', 'enabled', false);
      }

      tooltip.setAttribute('data-placement', data.placement);

      if (data.attributes['x-out-of-boundaries'] !== false) {
        tooltip.setAttribute('data-out-of-boundaries', '');
      } else {
        tooltip.removeAttribute('data-out-of-boundaries');
      }

      var basePlacement = getBasePlacement(data.placement);
      var isVerticalPlacement = includes(['top', 'bottom'], basePlacement);
      var isSecondaryPlacement = includes(['bottom', 'right'], basePlacement); // Apply `distance` prop

      tooltip.style.top = '0';
      tooltip.style.left = '0';
      tooltip.style[isVerticalPlacement ? 'top' : 'left'] = (isSecondaryPlacement ? 1 : -1) * distancePx + 'px'; // Careful not to cause an infinite loop here
      // Fixes https://github.com/FezVrasta/popper.js/issues/784

      if (prevPlacement && prevPlacement !== data.placement) {
        instance.popperInstance.update();
      }
    }

    var config = _extends({
      eventsEnabled: false,
      placement: instance.props.placement
    }, popperOptions, {
      modifiers: _extends({}, popperOptions && popperOptions.modifiers, {
        // We can't use `padding` on the popper el because of these bugs when
        // flipping from a vertical to horizontal placement or vice-versa,
        // there is severe flickering.
        // https://github.com/FezVrasta/popper.js/issues/720
        // This workaround increases bundle size by 250B minzip unfortunately,
        // due to need to custom compute the distance (since Popper rect does
        // not get affected by the inner tooltip's distance offset)
        tippyDistance: {
          enabled: true,
          order: 0,
          fn: function fn(data) {
            // `html` fontSize may change while `popperInstance` is alive
            // e.g. on resize in media queries
            distancePx = getUnitsInPx(doc, instance.props.distance);
            var basePlacement = getBasePlacement(data.placement);
            var computedPreventOverflowPadding = getComputedPadding(basePlacement, preventOverflowModifier && preventOverflowModifier.padding, distancePx);
            var computedFlipPadding = getComputedPadding(basePlacement, flipModifier && flipModifier.padding, distancePx);
            var instanceModifiers = instance.popperInstance.modifiers;
            setModifierValue(instanceModifiers, 'preventOverflow', 'padding', computedPreventOverflowPadding);
            setModifierValue(instanceModifiers, 'flip', 'padding', computedFlipPadding);
            return data;
          }
        },
        preventOverflow: _extends({
          boundariesElement: instance.props.boundary
        }, preventOverflowModifier),
        flip: _extends({
          enabled: instance.props.flip,
          behavior: instance.props.flipBehavior
        }, flipModifier),
        arrow: _extends({
          element: arrow,
          enabled: !!arrow
        }, getModifier(popperOptions, 'arrow')),
        offset: _extends({
          offset: instance.props.offset
        }, getModifier(popperOptions, 'offset'))
      }),
      onCreate: function onCreate(data) {
        applyMutations(data);
        preserveInvocation(popperOptions && popperOptions.onCreate, config.onCreate, [data]);
        runMountCallback();
      },
      onUpdate: function onUpdate(data) {
        applyMutations(data);
        preserveInvocation(popperOptions && popperOptions.onUpdate, config.onUpdate, [data]);
        runMountCallback();
      }
    });

    instance.popperInstance = new popper_js__WEBPACK_IMPORTED_MODULE_0__["default"](reference, popper, config);
  }

  function runMountCallback() {
    // Only invoke currentMountCallback after 2 updates
    // This fixes some bugs in Popper.js (TODO: aim for only 1 update)
    if (popperUpdates === 0) {
      popperUpdates++; // 1

      instance.popperInstance.update();
    } else if (currentMountCallback && popperUpdates === 1) {
      popperUpdates++; // 2

      reflow(popper);
      currentMountCallback();
    }
  }

  function mount() {
    // The mounting callback (`currentMountCallback`) is only run due to a
    // popperInstance update/create
    popperUpdates = 0;
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper.js needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    if (true) {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard navigation', 'because it is not directly after the reference element in the DOM source', 'order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element solves', 'this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle keyboard', 'navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/accessibility/#interactivity'].join(' '));
    }

    setModifierValue(instance.popperInstance.modifiers, 'flip', 'enabled', instance.props.flip);
    instance.popperInstance.enableEventListeners(); // Mounting callback invoked in `onUpdate`

    instance.popperInstance.update();
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (!instance.popperInstance) {
      createPopperInstance();
    }

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentMouseDownListener();
    var delay = getDelay(true);

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentMouseDownListener();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (includes(instance.props.trigger, 'mouseenter') && includes(instance.props.trigger, 'click') && includes(['mouseleave', 'mousemove'], event.type) && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  }
  /* ======================= 🔑 Public methods 🔑 ======================= */


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    if (true) {
      validateProps(partialProps, plugins);
      warnWhen(partialProps.plugins ? partialProps.plugins.length !== plugins.length || plugins.some(function (p, i) {
        if (partialProps.plugins && partialProps.plugins[i]) {
          return p !== partialProps.plugins[i];
        } else {
          return true;
        }
      }) : false, "Cannot update plugins");
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListenersFromTriggerTarget();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, _extends({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    nextProps.ignoreAttributes = useIfDefined(partialProps.ignoreAttributes, prevProps.ignoreAttributes);
    instance.props = nextProps;
    addListenersToTriggerTarget();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }

    updatePopperElement(popper, prevProps, nextProps);
    instance.popperChildren = getChildren(popper); // Ensure stale aria-expanded attributes are removed

    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();

    if (instance.popperInstance) {
      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
        return hasOwnProperty(partialProps, prop) && partialProps[prop] !== prevProps[prop];
      })) {
        var currentReference = instance.popperInstance.reference;
        instance.popperInstance.destroy();
        createPopperInstance();
        instance.popperInstance.reference = currentReference;

        if (instance.state.isVisible) {
          instance.popperInstance.enableEventListeners();
        }
      } else {
        instance.popperInstance.update();
      }
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show(duration) {
    if (duration === void 0) {
      duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    }

    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    if (!instance.popperInstance) {
      createPopperInstance();
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    addDocumentMouseDownListener();
    popper.style.visibility = 'visible';
    instance.state.isVisible = true; // Prevent a transition of the popper from its previous position and of the
    // elements at a different placement
    // Check if the tippy was fully unmounted before `show()` was called, to
    // allow for smooth transition for `createSingleton()`

    if (!instance.state.isMounted) {
      setTransitionDuration(transitionableElements.concat(popper), 0);
    }

    currentMountCallback = function currentMountCallback() {
      if (!instance.state.isVisible) {
        return;
      }

      setTransitionDuration([popper], instance.props.updateDuration);
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, 'visible');
      handleAriaDescribedByAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      updateIOSClass(true);
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);
      onTransitionedIn(duration, function () {
        instance.state.isShown = true;
        invokeHook('onShown', [instance]);
      });
    };

    mount();
  }

  function hide(duration) {
    if (duration === void 0) {
      duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    }

    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out


    var isAlreadyHidden = !instance.state.isVisible && !isBeingDestroyed;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled && !isBeingDestroyed;

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
      return;
    }

    removeDocumentMouseDownListener();
    popper.style.visibility = 'hidden';
    instance.state.isVisible = false;
    instance.state.isShown = false;
    setTransitionDuration(transitionableElements, duration);
    setVisibilityState(transitionableElements, 'hidden');
    handleAriaDescribedByAttribute();
    handleAriaExpandedAttribute();
    onTransitionedOut(duration, function () {
      instance.popperInstance.disableEventListeners();
      instance.popperInstance.options.placement = instance.props.placement;
      popper.parentNode.removeChild(popper);
      mountedInstances = mountedInstances.filter(function (i) {
        return i !== instance;
      });

      if (mountedInstances.length === 0) {
        updateIOSClass(false);
      }

      instance.state.isMounted = false;
      invokeHook('onHidden', [instance]);
    });
  }

  function destroy() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    isBeingDestroyed = true;
    instance.clearDelayTimeouts();
    instance.hide(0);
    removeListenersFromTriggerTarget();
    delete reference._tippy;

    if (instance.popperInstance) {
      instance.popperInstance.destroy();
    }

    isBeingDestroyed = false;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps,
/** @deprecated use Props.plugins */
plugins) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  plugins = defaultProps.plugins.concat(optionalProps.plugins || plugins);

  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }

  bindGlobalEventListeners();

  var passedProps = _extends({}, optionalProps, {
    plugins: plugins
  });

  var elements = getArrayOfElements(targets);

  if (true) {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than one tippy', 'instance was created by this invocation. This means the content element will', 'only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that returns a', 'cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.version = version;
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
/**
 * Hides all visible poppers on the document
 */

var hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  mountedInstances.forEach(function (instance) {
    var isExcluded = false;

    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }

    if (!isExcluded) {
      instance.hide(duration);
    }
  });
};
/**
 * Returns a proxy wrapper function that passes the plugins
 * @deprecated use tippy.setDefaultProps({plugins: [...]});
 */

function createTippyWithPlugins(outerPlugins) {
  if (true) {
    warnWhen(true, ['createTippyWithPlugins([...]) has been deprecated.', '\n\n', 'Use tippy.setDefaultProps({plugins: [...]}) instead.'].join(' '));
  }

  var tippyPluginsWrapper = function tippyPluginsWrapper(targets, optionalProps, innerPlugins) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }

    if (innerPlugins === void 0) {
      innerPlugins = [];
    }

    innerPlugins = optionalProps.plugins || innerPlugins;
    return tippy(targets, _extends({}, optionalProps, {
      plugins: [].concat(outerPlugins, innerPlugins)
    }));
  };

  tippyPluginsWrapper.version = version;
  tippyPluginsWrapper.defaultProps = defaultProps;
  tippyPluginsWrapper.setDefaultProps = setDefaultProps;
  tippyPluginsWrapper.currentInput = currentInput; // @ts-ignore

  return tippyPluginsWrapper;
}


//# sourceMappingURL=tippy.chunk.esm.js.map


/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.css":
/*!**********************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./tippy.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/dist/tippy.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/*! exports provided: createTippyWithPlugins, default, hideAll, roundArrow, animateFill, createSingleton, delegate, followCursor, inlinePositioning, sticky */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateFill", function() { return animateFill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSingleton", function() { return createSingleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delegate", function() { return delegate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "followCursor", function() { return followCursor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inlinePositioning", function() { return inlinePositioning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sticky", function() { return sticky; });
/* harmony import */ var _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tippy.chunk.esm.js */ "./node_modules/tippy.js/dist/tippy.chunk.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTippyWithPlugins", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["m"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hideAll", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "roundArrow", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["R"]; });

/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/**!
* tippy.js v5.1.4
* (c) 2017-2020 atomiks
* MIT License
*/




/**
 * Re-uses a single tippy element for many different tippy instances.
 * Replaces v4's `tippy.group()`.
 */

var createSingleton = function createSingleton(tippyInstances, optionalProps,
/** @deprecated use Props.plugins */
plugins) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  if (true) {
    Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["e"])(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of tippy', 'instances. The passed value was', String(tippyInstances)].join(' '));
  }

  plugins = optionalProps.plugins || plugins;
  tippyInstances.forEach(function (instance) {
    instance.disable();
  });

  var userAria = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["d"], {}, optionalProps).aria;

  var currentAria;
  var currentTarget;
  var shouldSkipUpdate = false;
  var references = tippyInstances.map(function (instance) {
    return instance.reference;
  });
  var singleton = {
    fn: function fn(instance) {
      function handleAriaDescribedByAttribute(isShow) {
        if (!currentAria) {
          return;
        }

        var attr = "aria-" + currentAria;

        if (isShow && !instance.props.interactive) {
          currentTarget.setAttribute(attr, instance.popperChildren.tooltip.id);
        } else {
          currentTarget.removeAttribute(attr);
        }
      }

      return {
        onAfterUpdate: function onAfterUpdate(_, _ref) {
          var aria = _ref.aria;

          // Ensure `aria` for the singleton instance stays `null`, while
          // changing the `userAria` value
          if (aria !== undefined && aria !== userAria) {
            if (!shouldSkipUpdate) {
              userAria = aria;
            } else {
              shouldSkipUpdate = true;
              instance.setProps({
                aria: null
              });
              shouldSkipUpdate = false;
            }
          }
        },
        onDestroy: function onDestroy() {
          tippyInstances.forEach(function (instance) {
            instance.enable();
          });
        },
        onMount: function onMount() {
          handleAriaDescribedByAttribute(true);
        },
        onUntrigger: function onUntrigger() {
          handleAriaDescribedByAttribute(false);
        },
        onTrigger: function onTrigger(_, event) {
          var target = event.currentTarget;
          var index = references.indexOf(target); // bail-out

          if (target === currentTarget) {
            return;
          }

          currentTarget = target;
          currentAria = userAria;

          if (instance.state.isVisible) {
            handleAriaDescribedByAttribute(true);
          }

          instance.popperInstance.reference = target;
          instance.setContent(tippyInstances[index].props.content);
        }
      };
    }
  };
  return Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"])(Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["a"])(), Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, optionalProps, {
    plugins: [singleton].concat(plugins),
    aria: null,
    triggerTarget: references
  }));
};

var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props,
/** @deprecated use Props.plugins */
plugins) {
  if (plugins === void 0) {
    plugins = [];
  }

  if (true) {
    Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["e"])(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }

  plugins = props.plugins || plugins;
  var listeners = [];
  var childTippyInstances = [];
  var target = props.target;
  var nativeProps = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["r"])(props, ['target']);

  var parentProps = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, nativeProps, {
    plugins: plugins,
    trigger: 'manual'
  });

  var childProps = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, nativeProps, {
    plugins: plugins,
    showOnCreate: true
  });

  var returnValue = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"])(targets, parentProps);
  var normalizedReturnValue = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["n"])(returnValue);

  function onTrigger(event) {
    if (!event.target) {
      return;
    }

    var targetNode = event.target.closest(target);

    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`


    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["d"].trigger; // Only create the instance if the bubbling event matches the trigger type

    if (!Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["i"])(trigger, BUBBLING_EVENTS_MAP[event.type])) {
      return;
    }

    var instance = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"])(targetNode, childProps);

    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }

  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }

  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }

  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function applyMutations(instance) {
    var originalDestroy = instance.destroy;

    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }

      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }

      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };

    addEventListeners(instance);
  }

  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}

var animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$popperChild = instance.popperChildren,
        tooltip = _instance$popperChild.tooltip,
        content = _instance$popperChild.content;
    var backdrop = instance.props.animateFill && !_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["b"] ? createBackdropElement() : null;

    function addBackdropToPopperChildren() {
      instance.popperChildren.backdrop = backdrop;
    }

    return {
      onCreate: function onCreate() {
        if (backdrop) {
          addBackdropToPopperChildren();
          tooltip.insertBefore(backdrop, tooltip.firstElementChild);
          tooltip.setAttribute('data-animatefill', '');
          tooltip.style.overflow = 'hidden';
          instance.setProps({
            animation: 'shift-away',
            arrow: false
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = tooltip.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["s"])([backdrop], 'visible'); // Warn if the stylesheets are not loaded

          if (true) {
            Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["w"])(getComputedStyle(backdrop).position !== 'absolute', "The `tippy.js/dist/backdrop.css` stylesheet has not been\n              imported!\n              \n              The `animateFill` plugin requires this stylesheet to work.");
            Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["w"])(getComputedStyle(tooltip).transform === 'none', "The `tippy.js/animations/shift-away.css` stylesheet has not\n              been imported!\n              \n              The `animateFill` plugin requires this stylesheet to work.");
          }
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["s"])([backdrop], 'hidden');
        }
      },
      onAfterUpdate: function onAfterUpdate() {
        // With this type of prop, it's highly unlikely it will be changed
        // dynamically. We'll leave out the diff/update logic it to save bytes.
        // `popperChildren` is assigned a new object onAfterUpdate
        addBackdropToPopperChildren();
      }
    };
  }
};

function createBackdropElement() {
  var backdrop = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["a"])();
  backdrop.className = _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["B"];
  Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["s"])([backdrop], 'hidden');
  return backdrop;
}

var followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;
    var originalReference = null; // Support iframe contexts
    // Static check that assumes any of the `triggerTarget` or `reference`
    // nodes will never change documents, even when they are updated

    var doc = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["g"])(instance.props.triggerTarget || reference); // Internal state

    var lastMouseMoveEvent;
    var mouseCoords = null;
    var isInternallySettingControlledProp = false; // These are controlled by this plugin, so we need to store the user's
    // original prop value

    var userProps = instance.props;

    function setUserProps(props) {
      var keys = Object.keys(props);
      keys.forEach(function (prop) {
        userProps[prop] = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["u"])(props[prop], userProps[prop]);
      });
    }

    function getIsManual() {
      return instance.props.trigger.trim() === 'manual';
    }

    function getIsEnabled() {
      // #597
      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard "click"
      mouseCoords !== null && !(mouseCoords.clientX === 0 && mouseCoords.clientY === 0);
      return instance.props.followCursor && isValidMouseEvent;
    }

    function getIsInitialBehavior() {
      return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["f"].isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;
    }

    function resetReference() {
      if (instance.popperInstance && originalReference) {
        instance.popperInstance.reference = originalReference;
      }
    }

    function handlePlacement() {
      // Due to `getVirtualOffsets()`, we need to reverse the placement if it's
      // shifted (start -> end, and vice-versa)
      // Early bail-out
      if (!getIsEnabled() && instance.props.placement === userProps.placement) {
        return;
      }

      var placement = userProps.placement;
      var shift = placement.split('-')[1];
      isInternallySettingControlledProp = true;
      instance.setProps({
        placement: getIsEnabled() && shift ? placement.replace(shift, shift === 'start' ? 'end' : 'start') : placement
      });
      isInternallySettingControlledProp = false;
    }

    function handlePopperListeners() {
      if (!instance.popperInstance) {
        return;
      } // Popper's scroll listeners make sense for `true` only. TODO: work out
      // how to only listen horizontal scroll for "horizontal" and vertical
      // scroll for "vertical"


      if (getIsEnabled() && (getIsInitialBehavior() || instance.props.followCursor !== true)) {
        instance.popperInstance.disableEventListeners();
      }
    }

    function handleMouseMoveListener() {
      if (getIsEnabled()) {
        addListener();
      } else {
        resetReference();
      }
    }

    function triggerLastMouseMove() {
      if (getIsEnabled()) {
        onMouseMove(lastMouseMoveEvent);
      }
    }

    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }

    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }

    function onMouseMove(event) {
      var _lastMouseMoveEvent = lastMouseMoveEvent = event,
          clientX = _lastMouseMoveEvent.clientX,
          clientY = _lastMouseMoveEvent.clientY;

      if (!instance.popperInstance || !instance.state.currentPlacement) {
        return;
      } // If the instance is interactive, avoid updating the position unless it's
      // over the reference element


      var isCursorOverReference = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["h"])(event.target, function (el) {
        return el === reference;
      });
      var rect = reference.getBoundingClientRect();
      var followCursor = instance.props.followCursor;
      var isHorizontal = followCursor === 'horizontal';
      var isVertical = followCursor === 'vertical';
      var isVerticalPlacement = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["i"])(['top', 'bottom'], Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["j"])(instance.state.currentPlacement)); // The virtual reference needs some size to prevent itself from overflowing

      var _getVirtualOffsets = getVirtualOffsets(popper, isVerticalPlacement),
          size = _getVirtualOffsets.size,
          x = _getVirtualOffsets.x,
          y = _getVirtualOffsets.y;

      if (isCursorOverReference || !instance.props.interactive) {
        // Preserve custom position ReferenceObjects, which may not be the
        // original targets reference passed as an argument
        if (originalReference === null) {
          originalReference = instance.popperInstance.reference;
        }

        instance.popperInstance.reference = {
          referenceNode: reference,
          // These `client` values don't get used by Popper.js if they are 0
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            return {
              width: isVerticalPlacement ? size : 0,
              height: isVerticalPlacement ? 0 : size,
              top: (isHorizontal ? rect.top : clientY) - y,
              bottom: (isHorizontal ? rect.bottom : clientY) + y,
              left: (isVertical ? rect.left : clientX) - x,
              right: (isVertical ? rect.right : clientX) + x
            };
          }
        };
        instance.popperInstance.update();
      }

      if (getIsInitialBehavior()) {
        removeListener();
      }
    }

    return {
      onAfterUpdate: function onAfterUpdate(_, partialProps) {
        if (!isInternallySettingControlledProp) {
          setUserProps(partialProps);

          if (partialProps.placement) {
            handlePlacement();
          }
        } // A new placement causes the popperInstance to be recreated


        if (partialProps.placement) {
          handlePopperListeners();
        } // Wait for `.update()` to set `instance.state.currentPlacement` to
        // the new placement


        requestAnimationFrame(triggerLastMouseMove);
      },
      onMount: function onMount() {
        triggerLastMouseMove();
        handlePopperListeners();
      },
      onShow: function onShow() {
        if (getIsManual()) {
          // Since there's no trigger event to use, we have to use these as
          // baseline coords
          mouseCoords = {
            clientX: 0,
            clientY: 0
          }; // Ensure `lastMouseMoveEvent` doesn't access any other properties
          // of a MouseEvent here

          lastMouseMoveEvent = mouseCoords;
          handlePlacement();
          handleMouseMoveListener();
        }
      },
      onTrigger: function onTrigger(_, event) {
        // Tapping on touch devices can trigger `mouseenter` then `focus`
        if (mouseCoords) {
          return;
        }

        if (Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["c"])(event)) {
          mouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
          lastMouseMoveEvent = event;
        }

        handlePlacement();
        handleMouseMoveListener();
      },
      onUntrigger: function onUntrigger() {
        // If untriggered before showing (`onHidden` will never be invoked)
        if (!instance.state.isVisible) {
          removeListener();
          mouseCoords = null;
        }
      },
      onHidden: function onHidden() {
        removeListener();
        resetReference();
        mouseCoords = null;
      }
    };
  }
};
function getVirtualOffsets(popper, isVerticalPlacement) {
  var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
  return {
    size: size,
    x: isVerticalPlacement ? size : 0,
    y: isVerticalPlacement ? 0 : size
  };
}

// position. This will require the `followCursor` plugin's fixes for overflow
// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)

var inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;

    function getIsEnabled() {
      return !!instance.props.inlinePositioning;
    }

    return {
      onHidden: function onHidden() {
        if (getIsEnabled()) {
          instance.popperInstance.reference = reference;
        }
      },
      onShow: function onShow() {
        if (!getIsEnabled()) {
          return;
        }

        instance.popperInstance.reference = {
          referenceNode: reference,
          // These `client` values don't get used by Popper.js if they are 0
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            return getInlineBoundingClientRect(instance.state.currentPlacement && Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["j"])(instance.state.currentPlacement), reference.getBoundingClientRect(), Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["k"])(reference.getClientRects()));
          }
        };
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  }

  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }

    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;

        var _width = _right - _left;

        var _height = _bottom - _top;

        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }

    default:
      {
        return boundingRect;
      }
  }
}

var sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;

    function getReference() {
      return instance.popperInstance ? instance.popperInstance.reference : reference;
    }

    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }

    var prevRefRect = null;
    var prevPopRect = null;

    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        instance.popperInstance.update();
      }

      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }

    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};

function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }

  return true;
}


//# sourceMappingURL=tippy.esm.js.map


/***/ }),

/***/ "./node_modules/tippy.js/themes/light-border.css":
/*!*******************************************************!*\
  !*** ./node_modules/tippy.js/themes/light-border.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./light-border.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/themes/light-border.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/Annotation.ts":
/*!***************************!*\
  !*** ./src/Annotation.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ./util/Lattice */ "./src/util/Lattice.ts");
const Set_1 = __webpack_require__(/*! ./util/Set */ "./src/util/Set.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
function annotated(v) {
    return v instanceof Expr_1.Expr.SyntaxNode || v instanceof DataValue_1.ExplValue;
}
exports.annotated = annotated;
function isα(v) {
    return exports.__slice.is(v);
}
exports.isα = isα;
// Currently no deltas are associated with annotations.
function setα(α, v) {
    exports.__slice.set(v, α);
}
exports.setα = setα;
function setjoinα(α, v) {
    setα(Lattice_1.bool_.join(α, isα(v)), v);
}
exports.setjoinα = setjoinα;
function setmeetα(α, v) {
    setα(Lattice_1.bool_.meet(α, isα(v)), v);
}
exports.setmeetα = setmeetα;
var Direction;
(function (Direction) {
    Direction[Direction["Fwd"] = 0] = "Fwd";
    Direction[Direction["Bwd"] = 1] = "Bwd";
})(Direction = exports.Direction || (exports.Direction = {}));
class Annotations {
    constructor() {
        this.ann = new Set(); // unavailable nodes (fwd) or needed nodes (bwd)
        this.direction = Direction.Fwd;
    }
    // Whether v is needed (going backward) or available (going forward).
    is(v) {
        if (this.direction === Direction.Fwd) {
            return Lattice_1.bool_.negate(this.ann.has(v));
        }
        else {
            return this.ann.has(v);
        }
    }
    // Going forward, annotation updates must be decreasing; going backward, increasing. This is because 
    // forward slicing propagates non-availability, whereas backward slicing propagates demand.
    set(v, α) {
        const current = this.is(v);
        if (this.direction === Direction.Fwd && α < current ||
            this.direction === Direction.Bwd && α > current) {
            this.ann.add(v);
        }
        else if (this.direction === Direction.Fwd && α > current ||
            this.direction === Direction.Bwd && α < current) {
            Core_1.absurd(`Incompatible update of annotation from ${current} to ${α}.`, current, α);
        }
        else {
            // idempotent
        }
    }
    reset(direction) {
        this.direction = direction;
        this.ann = new Set();
    }
    restrictTo(tvs) {
        return Set_1.intersection(this.ann, Set_1.union(...tvs.map(tv => explDescendants(tv))));
    }
}
exports.Annotations = Annotations;
function explDescendants(tv) {
    const desc = new Set();
    explDescendants_aux(tv, desc);
    return desc;
}
function explDescendants_aux(tv, desc) {
    desc.add(tv);
    if (tv.v instanceof DataValue_1.DataValue) {
        const { t, v } = tv;
        Expl_1.Expl.explChildren(t, v).forEach((tv) => {
            explDescendants_aux(tv, desc);
        });
    }
}
exports.__slice = new Annotations();


/***/ }),

/***/ "./src/BaseTypes.ts":
/*!**************************!*\
  !*** ./src/BaseTypes.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// See Env for convention regarding instance members on reflected datatypes.
class Bool extends DataValue_1.DataValue {
}
exports.Bool = Bool;
class True extends Bool {
}
exports.True = True;
function true_() {
    return Versioned_1.at(True);
}
exports.true_ = true_;
class False extends Bool {
}
exports.False = False;
function false_() {
    return Versioned_1.at(False);
}
exports.false_ = false_;
class List extends DataValue_1.DataValue {
    static fromArray(x̅) {
        let x̅ʹ = nil();
        for (let n = x̅.length - 1; n >= 0; --n) {
            x̅ʹ = cons(x̅[n], x̅ʹ);
        }
        return x̅ʹ;
    }
    toArray() {
        const x̅ = [];
        this.toArray_(x̅);
        return x̅;
    }
    toArray_(x̅) {
        if (Cons.is(this)) {
            x̅.push(this.head);
            this.tail.toArray_(x̅);
        }
        else if (Nil.is(this)) {
        }
        else {
            return Core_1.absurd();
        }
    }
}
exports.List = List;
class Nil extends List {
    static is(xs) {
        return xs instanceof Nil;
    }
}
exports.Nil = Nil;
function nil() {
    return Value_1.make(Nil);
}
exports.nil = nil;
class Cons extends List {
    constructor() {
        super(...arguments);
        this.head = Value_1._;
        this.tail = Value_1._;
    }
    static is(xs) {
        return xs instanceof Cons;
    }
}
exports.Cons = Cons;
function cons(head, tail) {
    return Value_1.make(Cons, head, tail);
}
exports.cons = cons;
class Pair extends DataValue_1.DataValue {
    constructor() {
        super(...arguments);
        this.fst = Value_1._;
        this.snd = Value_1._;
    }
}
exports.Pair = Pair;
function pair(fst, snd) {
    return Value_1.make(Pair, fst, snd);
}
exports.pair = pair;
class Tree extends DataValue_1.DataValue {
    toArray() {
        const x̅ = [];
        this.toArray_(x̅);
        return x̅;
    }
    toArray_(x̅) {
        if (NonEmpty.is(this)) {
            this.left.toArray_(x̅);
            x̅.push(this.t);
            this.right.toArray_(x̅);
        }
        else if (Empty.is(this)) {
        }
        else {
            return Core_1.absurd();
        }
    }
}
exports.Tree = Tree;
class Empty extends Tree {
    static is(t) {
        return t instanceof Empty;
    }
}
exports.Empty = Empty;
function empty() {
    return Value_1.make(Empty);
}
exports.empty = empty;
class NonEmpty extends Tree {
    constructor() {
        super(...arguments);
        this.left = Value_1._;
        this.t = Value_1._;
        this.right = Value_1._;
    }
    static is(t) {
        return t instanceof NonEmpty;
    }
}
exports.NonEmpty = NonEmpty;
function nonEmpty(left, t, right) {
    return Value_1.make(NonEmpty, left, t, right);
}
exports.nonEmpty = nonEmpty;
class Option extends DataValue_1.DataValue {
}
exports.Option = Option;
class None extends Option {
    static is(o) {
        return o instanceof None;
    }
}
exports.None = None;
class Some extends Option {
    constructor() {
        super(...arguments);
        this.t = Value_1._;
    }
    static is(o) {
        return o instanceof Some;
    }
}
exports.Some = Some;
class Ordering extends DataValue_1.DataValue {
}
exports.Ordering = Ordering;
class LT extends Ordering {
}
exports.LT = LT;
class GT extends Ordering {
}
exports.GT = GT;
class EQ extends Ordering {
}
exports.EQ = EQ;
DataType_1.initDataType(Bool, [True, False]);
DataType_1.initDataType(List, [Nil, Cons]);
DataType_1.initDataType(Option, [Some, None]);
DataType_1.initDataType(Ordering, [LT, GT, EQ]);
DataType_1.initDataType(Pair, [Pair]);
DataType_1.initDataType(Tree, [Empty, NonEmpty]);


/***/ }),

/***/ "./src/DataType.ts":
/*!*************************!*\
  !*** ./src/DataType.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
class PrimType {
    constructor(name, C) {
        this.name = name;
        this.C = C;
    }
}
exports.PrimType = PrimType;
// Neither of these is currently reflective because of non-standard fields.
class DataType {
    constructor(name, elimC, ctrs, exprC̅, explC̅) {
        this.name = name;
        this.elimC = elimC;
        this.ctrs = ctrs;
        this.exprC̅ = exprC̅;
        this.explC̅ = explC̅;
    }
}
exports.DataType = DataType;
// Constructor of a datatype, not to be confused with an instance of such a thing (DataValue) or name of such a thing
// (Lex.Ctr). Fields have a total ordering given by the order of definition in the corresponding class.
class Ctr {
    constructor(C, f̅) {
        this.C = C;
        this.f̅ = f̅;
    }
    get arity() {
        return this.f̅.length;
    }
    get c() {
        return this.C.name;
    }
}
exports.Ctr = Ctr;
function ctrFor(c) {
    return Core_1.__nonNull(exports.ctrToDataType.get(c), `Unknown constructor ${c}.`).ctrs.get(c);
}
exports.ctrFor = ctrFor;
function explClass(C) {
    return Core_1.__nonNull(exports.ctrToDataType.get(C.name)).explC̅.get(C.name);
}
exports.explClass = explClass;
function exprClass(C) {
    return Core_1.__nonNull(exports.ctrToDataType.get(C.name)).exprC̅.get(C.name);
}
exports.exprClass = exprClass;
function valueClass(C) {
    return ctrFor(C.name).C;
}
exports.valueClass = valueClass;
// Populated by initDataTypes(). Constructors are not yet first-class.
exports.types = new Map;
exports.ctrToDataType = new Map;
exports.elimToDataType = new Map;
// See https://stackoverflow.com/questions/33605775 for the dynamic class-naming idiom.
function initDataType(D, C̅) {
    C̅.sort((C, Cʹ) => C.name.localeCompare(Cʹ.name)); // consistent with Str.leq
    const ctrs = C̅.map((C) => [C.name, new Ctr(C, Value_1.fields(new C))]), elimC = {
        [D.name]: class extends Match_1.DataElim {
            constructor() {
                super();
                // lexicographical order hopefully preserved by getOwnPropertyNames()
                C̅.forEach((C) => {
                    this[C.name] = Value_1._;
                });
            }
        }
    }[D.name], exprC̅ = ctrs.map(([c_str, c]) => {
        return [c_str, {
                [c_str]: class extends Expr_1.Expr.DataExpr {
                    constructor() {
                        super();
                        c.f̅.forEach((f) => {
                            this[f] = Value_1._;
                        });
                    }
                }
            }[c_str]];
    }), explC̅ = ctrs.map(([c_str, c]) => {
        return [c_str, {
                [c_str]: class extends Expl_1.Expl.DataExpl {
                    constructor() {
                        super();
                        c.f̅.forEach((f) => {
                            this[f] = Value_1._;
                        });
                    }
                }
            }[c_str]];
    }), d = new DataType(Versioned_1.str(D.name)(Versioned_1.ν()), elimC, new Map(ctrs), new Map(exprC̅), new Map(explC̅));
    C̅.forEach((C) => {
        exports.ctrToDataType.set(C.name, d);
    });
    exports.elimToDataType.set(D.name, d);
    exports.types.set(d.name.val, d);
}
exports.initDataType = initDataType;
exports.types.set(Value_1.Num.name, new PrimType(Versioned_1.str(Value_1.Num.name)(Versioned_1.ν()), Value_1.Num));
exports.types.set(Value_1.Str.name, new PrimType(Versioned_1.str(Value_1.Str.name)(Versioned_1.ν()), Value_1.Str));


/***/ }),

/***/ "./src/DataValue.ts":
/*!**************************!*\
  !*** ./src/DataValue.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
// Value of a datatype constructor; children are always user-level values (i.e. not ES6 primitives).
class DataValue extends Value_1.Value {
    get ctr() {
        return Core_1.className(this);
    }
    __child(k) {
        return super.__child(k);
    }
    get __children() {
        return super.__children;
    }
}
exports.DataValue = DataValue;
// Here to break cyclic dependency.
class ExplValue extends DataValue {
    constructor() {
        super(...arguments);
        this.t = Value_1._;
        this.v = Value_1._;
    }
}
exports.ExplValue = ExplValue;
function explValue(t, v) {
    return Value_1.make(ExplValue, t, v);
}
exports.explValue = explValue;


/***/ }),

/***/ "./src/Delta.ts":
/*!**********************!*\
  !*** ./src/Delta.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
function leq(s1, s2) {
    return Object.keys(s1).every((prop) => {
        return s2.hasOwnProperty(prop) && s1[prop].before === s2[prop].before && s1[prop].after === s2[prop].after;
    });
}
exports.leq = leq;
function empty(ẟ) {
    return Value_1.fields(ẟ).length === 0;
}
class Deltas {
    constructor() {
        this.ẟ̅ = new Map();
    }
    get size() {
        return this.ẟ̅.size;
    }
    // Change sets must be disjoint at a given revision. Because of sharing within a revision, 
    // a node may first appear new (or reclassified) and then later appear changed, but the 
    // subsequent change sets must be empty.
    changed(v, s_ẟ) {
        let v_ẟ = this.ẟ̅.get(v);
        if (v_ẟ === undefined) {
            this.ẟ̅.set(v, new Change(s_ẟ));
        }
        else if (v_ẟ instanceof Change) {
            Value_1.mergeInto(v_ẟ.changed, s_ẟ);
        }
        else if (v_ẟ instanceof New || v_ẟ instanceof Reclassify) {
            Core_1.assert(empty(s_ẟ));
        }
        else {
            Core_1.absurd();
        }
    }
    // A value cannot be reclassified twice at the same revision.
    reclassified(v) {
        let v_ẟ = this.ẟ̅.get(v);
        if (v_ẟ === undefined) {
            this.ẟ̅.set(v, new Reclassify());
        }
        else {
            Core_1.absurd();
        }
    }
    // A value cannot be created twice at the same revision.
    created(v) {
        let v_ẟ = this.ẟ̅.get(v);
        if (v_ẟ === undefined) {
            this.ẟ̅.set(v, new New());
        }
        else {
            Core_1.absurd();
        }
    }
    clear() {
        this.ẟ̅.clear();
    }
}
exports.Deltas = Deltas;
exports.__deltas = new Deltas();
class Delta {
    eq(ẟ) {
        return this.leq(ẟ) && ẟ.leq(this);
    }
}
exports.Delta = Delta;
class New extends Delta {
    constructor() {
        super();
    }
    leq(ẟ) {
        return ẟ instanceof New;
    }
}
exports.New = New;
class Change extends Delta {
    constructor(changed) {
        super();
        this.changed = changed;
    }
    leq(ẟ) {
        return ẟ instanceof Change && leq(this.changed, ẟ.changed);
    }
    hasChanged(prop) {
        return Value_1.fields(this.changed).includes(prop);
    }
}
exports.Change = Change;
// Constructor has changed, and therefore fields may not align. More sophisticated reclassification
// delta could allow for fields to be shared when an object changes class.
class Reclassify extends Delta {
    constructor() {
        super();
    }
    leq(ẟ) {
        return ẟ instanceof Reclassify;
    }
}
exports.Reclassify = Reclassify;


/***/ }),

/***/ "./src/Env.ts":
/*!********************!*\
  !*** ./src/Env.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
// Environments are snoc lists; the values are "explained" because usage information is recorded on traces.
class Env extends DataValue_1.DataValue {
    get(k) {
        if (this instanceof EmptyEnv) {
            return undefined;
        }
        else if (this instanceof ExtendEnv) {
            if (this.k.val === k.val) {
                return this.tv;
            }
            else {
                return this.ρ.get(k);
            }
        }
        else {
            return Core_1.absurd();
        }
    }
    has(k) {
        return this.get(k) !== undefined;
    }
    static singleton(k, tv) {
        return extendEnv(emptyEnv(), k, tv);
    }
    concat(ρ) {
        if (ρ instanceof EmptyEnv) {
            return this;
        }
        else if (ρ instanceof ExtendEnv) {
            return extendEnv(this.concat(ρ.ρ), ρ.k, ρ.tv);
        }
        else {
            return Core_1.absurd();
        }
    }
    values() {
        const tvs = [];
        for (let ρ = this; ρ instanceof ExtendEnv; ρ = ρ.ρ) {
            tvs.push(ρ.tv);
        }
        return tvs;
    }
}
exports.Env = Env;
class EmptyEnv extends Env {
}
exports.EmptyEnv = EmptyEnv;
function emptyEnv() {
    return Value_1.make(EmptyEnv);
}
exports.emptyEnv = emptyEnv;
class ExtendEnv extends Env {
    constructor() {
        super(...arguments);
        this.ρ = Value_1._;
        this.k = Value_1._;
        this.tv = Value_1._;
    }
}
exports.ExtendEnv = ExtendEnv;
function extendEnv(ρ, k, tv) {
    return Value_1.make(ExtendEnv, ρ, k, tv);
}
exports.extendEnv = extendEnv;


/***/ }),

/***/ "./src/Eval.ts":
/*!*********************!*\
  !*** ./src/Eval.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ./util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ./util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ./Annotation */ "./src/Annotation.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const FiniteMap_1 = __webpack_require__(/*! ./FiniteMap */ "./src/FiniteMap.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Primitive_1 = __webpack_require__(/*! ./Primitive */ "./src/Primitive.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
var Eval;
(function (Eval) {
    // ρ plus bindings in δ are closing for f.
    class Closure extends DataValue_1.DataValue {
        constructor() {
            super(...arguments);
            this.ρ = Value_1._;
            this.δ = Value_1._;
            this.f = Value_1._;
        }
    }
    Eval.Closure = Closure;
    function closure(ρ, δ, f) {
        return Versioned_1.at(Closure, ρ, δ, f);
    }
    // Environments are snoc-lists, so this (inconsequentially) reverses declaration order.
    function recDefs(δ_0, ρ, δ) {
        if (BaseTypes_1.Cons.is(δ)) {
            const def = δ.head, [δₜ, ρ_ext] = recDefs(δ_0, ρ, δ.tail), k = Value_1.memoId(recDefs, arguments), tf = DataValue_1.explValue(Expl_1.Expl.fun(def.σ)(k.tag("t")), closure(ρ, δ_0, def.σ)(k.tag("v")));
            return [BaseTypes_1.cons(Expl_1.Expl.recDef(def.x, tf)(k), δₜ), Env_1.extendEnv(ρ_ext, def.x, tf)];
        }
        else if (BaseTypes_1.Nil.is(δ)) {
            return [BaseTypes_1.nil(), Env_1.emptyEnv()];
        }
        else {
            return Core_1.absurd();
        }
    }
    function recDefs_(dir, δ) {
        if (BaseTypes_1.Cons.is(δ)) {
            Array_1.zip(δ.head.tf.v.δ.toArray(), δ.toArray()).map(([def, defₜ]) => {
                Core_1.assert(def.x.eq(defₜ.x));
                if (dir === Annotation_1.Direction.Fwd) {
                    Annotation_1.setα(Annotation_1.isα(def), defₜ.tf);
                }
                else {
                    Annotation_1.setjoinα(Annotation_1.isα(defₜ.tf), def);
                }
            });
        }
        else if (BaseTypes_1.Nil.is(δ)) {
        }
        else {
            return Core_1.absurd();
        }
    }
    // Here we mustn't invert definition order.
    function defs(ρ, def̅, ρ_ext) {
        const k = Value_1.memoId(defs, arguments);
        if (BaseTypes_1.Cons.is(def̅)) {
            const def = def̅.head;
            if (def instanceof Expr_1.Expr.Let) {
                const tv = eval_(ρ.concat(ρ_ext), def.e), [def̅ₜ, ρ_extʹ] = defs(ρ, def̅.tail, Env_1.extendEnv(ρ_ext, def.x, tv));
                return [BaseTypes_1.cons(Expl_1.Expl.let_(def.x, tv)(k), def̅ₜ), ρ_extʹ];
            }
            else if (def instanceof Expr_1.Expr.Prim) {
                // first-class primitives currently happen to be unary
                if (Primitive_1.unaryOps.has(def.x.val)) {
                    const t_op = Primitive_1.unaryOps.get(def.x.val), [def̅ₜ, ρ_extʹ] = defs(ρ, def̅.tail, Env_1.extendEnv(ρ_ext, def.x, t_op));
                    return [BaseTypes_1.cons(Expl_1.Expl.prim(def.x, t_op)(k), def̅ₜ), ρ_extʹ];
                }
                else {
                    return Core_1.userError(`No implementation found for primitive "${def.x.val}".`);
                }
            }
            else if (def instanceof Expr_1.Expr.LetRec) {
                const [δ, ρᵟ] = recDefs(def.δ, ρ.concat(ρ_ext), def.δ), [def̅ₜ, ρ_extʹ] = defs(ρ, def̅.tail, ρ_ext.concat(ρᵟ));
                return [BaseTypes_1.cons(Expl_1.Expl.letRec(δ)(k), def̅ₜ), ρ_extʹ];
            }
            else {
                return Core_1.absurd();
            }
        }
        else if (BaseTypes_1.Nil.is(def̅)) {
            return [BaseTypes_1.nil(), ρ_ext];
        }
        else {
            return Core_1.absurd();
        }
    }
    Eval.defs = defs;
    function defs_fwd(def̅, def̅ₜ) {
        Array_1.zip(def̅.toArray(), def̅ₜ.toArray()).forEach(([def, defₜ]) => {
            if (def instanceof Expr_1.Expr.Let && defₜ instanceof Expl_1.Expl.Let) {
                eval_fwd(def.e, defₜ.tv);
                Annotation_1.setmeetα(Annotation_1.isα(def), defₜ.tv);
            }
            else if (def instanceof Expr_1.Expr.Prim && defₜ instanceof Expl_1.Expl.Prim) {
                Annotation_1.setα(Annotation_1.isα(def), defₜ.t_op);
            }
            else if (def instanceof Expr_1.Expr.LetRec && defₜ instanceof Expl_1.Expl.LetRec) {
                recDefs_(Annotation_1.Direction.Fwd, defₜ.δ);
            }
            else {
                Core_1.absurd();
            }
        });
    }
    function defs_bwd(def̅, def̅ₜ) {
        Array_1.zip(def̅.toArray(), def̅ₜ.toArray()).reverse().forEach(([def, defₜ]) => {
            if (def instanceof Expr_1.Expr.Let && defₜ instanceof Expl_1.Expl.Let) {
                Annotation_1.setjoinα(Annotation_1.isα(defₜ.tv), def);
                eval_bwd(def.e, defₜ.tv);
            }
            else if (def instanceof Expr_1.Expr.Prim && defₜ instanceof Expl_1.Expl.Prim) {
                Annotation_1.setjoinα(Annotation_1.isα(defₜ.t_op), def);
            }
            else if (def instanceof Expr_1.Expr.LetRec && defₜ instanceof Expl_1.Expl.LetRec) {
                recDefs_(Annotation_1.Direction.Bwd, defₜ.δ);
            }
            else {
                Core_1.absurd();
            }
        });
    }
    function eval_(ρ, e) {
        const k = Value_1.memoId(eval_, arguments), [kₜ, kᵥ] = [k.tag("t"), k.tag("v")];
        if (e instanceof Expr_1.Expr.ConstNum) {
            return DataValue_1.explValue(Expl_1.Expl.const_()(kₜ), Versioned_1.num(e.val.val)(kᵥ));
        }
        else if (e instanceof Expr_1.Expr.ConstStr) {
            return DataValue_1.explValue(Expl_1.Expl.const_()(kₜ), Versioned_1.str(e.val.val)(kᵥ));
        }
        else if (e instanceof Expr_1.Expr.Fun) {
            return DataValue_1.explValue(Expl_1.Expl.fun(e.σ)(kₜ), closure(ρ, BaseTypes_1.nil(), e.σ)(kᵥ));
        }
        else if (e instanceof Expr_1.Expr.DataExpr) {
            const tv̅ = e.__children.map((e) => eval_(ρ, e)), C = DataType_1.valueClass(Core_1.classOf(e)), t = Versioned_1.at(DataType_1.explClass(C), ...tv̅.map(({ t }) => t))(kₜ), v = Versioned_1.at(C, ...tv̅.map(({ v }) => v))(kᵥ);
            return DataValue_1.explValue(t, v);
        }
        else if (e instanceof Expr_1.Expr.Quote) {
            return DataValue_1.explValue(Expl_1.Expl.quote()(kₜ), e.e);
        }
        else if (e instanceof Expr_1.Expr.Var) {
            if (ρ.has(e.x)) {
                const { t, v } = ρ.get(e.x);
                return DataValue_1.explValue(Expl_1.Expl.var_(e.x, t)(kₜ), v);
            }
            else {
                return Core_1.userError(`Variable "${e.x.val}" not found.`);
            }
        }
        else if (e instanceof Expr_1.Expr.App) {
            const [tf, tu] = [eval_(ρ, e.f), eval_(ρ, e.e)], [v, u] = [tf.v, tu.v];
            if (v instanceof Closure) {
                const [δ, ρᵟ] = recDefs(v.δ, v.ρ, v.δ), [ρʹ, ξκ] = v.f.apply(tu), { t, v: vʹ } = eval_(v.ρ.concat(ρᵟ.concat(ρʹ)), ξκ.κ);
                return DataValue_1.explValue(Expl_1.Expl.app(tf, tu, δ, ξκ, t)(kₜ), vʹ);
            }
            else if (v instanceof Primitive_1.UnaryOp) {
                if (u instanceof Value_1.Num || u instanceof Value_1.Str) {
                    return DataValue_1.explValue(Expl_1.Expl.unaryApp(tf, tu)(kₜ), v.op(u)(kᵥ));
                }
                else {
                    return Core_1.userError(`Applying "${v.name}" to non-primitive value.`, u);
                }
            }
            else {
                return Core_1.userError(`Cannot apply ${Core_1.className(v)}`);
            }
        }
        else 
        // Binary operators are (currently) "syntax", rather than first-class.
        if (e instanceof Expr_1.Expr.BinaryApp) {
            if (Primitive_1.binaryOps.has(e.opName.val)) {
                const op = Primitive_1.binaryOps.get(e.opName.val).v, [tv1, tv2] = [eval_(ρ, e.e1), eval_(ρ, e.e2)], [v1, v2] = [tv1.v, tv2.v];
                if ((v1 instanceof Value_1.Num || v1 instanceof Value_1.Str) && (v2 instanceof Value_1.Num || v2 instanceof Value_1.Str)) {
                    const k = Value_1.memoId(op.op, [v1, v2]);
                    return DataValue_1.explValue(Expl_1.Expl.binaryApp(tv1, e.opName, tv2)(kₜ), op.op(v1, v2)(k));
                }
                else {
                    return Core_1.userError(`Applying "${e.opName.val}" to non-primitive value.`, v1, v2);
                }
            }
            else {
                return Core_1.userError(`Binary primitive "${e.opName.val}" not found.`);
            }
        }
        else if (e instanceof Expr_1.Expr.Defs) {
            const [def̅ₜ, ρʹ] = defs(ρ, e.def̅, Env_1.emptyEnv()), { t, v } = eval_(ρ.concat(ρʹ), e.e);
            return DataValue_1.explValue(Expl_1.Expl.defs(def̅ₜ, t)(kₜ), v);
        }
        else if (e instanceof Expr_1.Expr.MatchAs) {
            const tu = eval_(ρ, e.e), [ρʹ, ξκ] = e.σ.apply(tu), { t, v } = eval_(ρ.concat(ρʹ), ξκ.κ);
            return DataValue_1.explValue(Expl_1.Expl.matchAs(tu, ξκ, t)(kₜ), v);
        }
        else if (e instanceof Expr_1.Expr.Typematch) {
            const tu = eval_(ρ, e.e), d = DataType_1.ctrToDataType.get(Core_1.className(tu.v)) || DataType_1.types.get(Core_1.className(tu.v)), eʹ = FiniteMap_1.get(e.cases, d.name);
            if (eʹ === undefined) {
                return Core_1.userError(`Typecase mismatch: no clause for ${Core_1.className(tu.v)}.`);
            }
            else {
                const { t, v } = eval_(ρ, eʹ);
                return DataValue_1.explValue(Expl_1.Expl.typematch(tu, d.name, t)(kₜ), v);
            }
        }
        else {
            return Core_1.absurd(`Unimplemented expression form: ${Core_1.className(e)}.`);
        }
    }
    Eval.eval_ = eval_;
    function eval_fwd(e, tv) {
        const { t, v } = tv;
        if (t instanceof Expl_1.Expl.Const && (v instanceof Value_1.Num || v instanceof Value_1.Str)) {
            Annotation_1.setα(Annotation_1.isα(e), tv);
        }
        else if (t instanceof Expl_1.Expl.Fun && v instanceof Closure) {
            Annotation_1.setα(Annotation_1.isα(e), tv);
        }
        else if (t instanceof Expl_1.Expl.Quote) {
            Annotation_1.setα(Annotation_1.isα(e), tv);
        }
        else if (t instanceof Expl_1.Expl.Var) {
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            if (v instanceof DataValue_1.DataValue) {
                const eʹ = Core_1.as(e, Expr_1.Expr.DataExpr);
                Array_1.zip(Expl_1.Expl.explChildren(t, v), eʹ.__children).map(([tv, e]) => eval_fwd(e, tv));
                Annotation_1.setα(Annotation_1.isα(e), tv);
            }
            else {
                Core_1.absurd();
            }
        }
        else if (t instanceof Expl_1.Expl.App) {
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_fwd(eʹ.f, t.tf);
            eval_fwd(eʹ.e, t.tu);
            recDefs_(Annotation_1.Direction.Fwd, t.δ);
            eval_fwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(t.tf), Match_1.apply_fwd(t.ξ), Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.UnaryApp) {
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_fwd(eʹ.f, t.tf);
            eval_fwd(eʹ.e, t.tv);
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(t.tf), Annotation_1.isα(t.tv), Annotation_1.isα(e)), tv);
        }
        else if (t instanceof Expl_1.Expl.BinaryApp) {
            const eʹ = Core_1.as(e, Expr_1.Expr.BinaryApp);
            eval_fwd(eʹ.e1, t.tv1);
            eval_fwd(eʹ.e2, t.tv2);
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(t.tv1), Annotation_1.isα(t.tv2), Annotation_1.isα(e)), tv);
        }
        else if (t instanceof Expl_1.Expl.Defs) {
            const eʹ = Core_1.as(e, Expr_1.Expr.Defs);
            defs_fwd(eʹ.def̅, t.def̅);
            eval_fwd(eʹ.e, DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.MatchAs) {
            const eʹ = Core_1.as(e, Expr_1.Expr.MatchAs);
            eval_fwd(eʹ.e, t.tu);
            eval_fwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Match_1.apply_fwd(t.ξ), Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.Typematch) {
            const eʹ = Core_1.as(e, Expr_1.Expr.Typematch);
            eval_fwd(eʹ.e, t.tu);
            eval_fwd(FiniteMap_1.get(eʹ.cases, t.d), DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else {
            Core_1.absurd();
        }
    }
    Eval.eval_fwd = eval_fwd;
    // Avoid excessive joins via a merging implementation; requires all annotations to have been cleared first.
    function eval_bwd(e, tv) {
        const { t, v } = tv;
        if (t instanceof Expl_1.Expl.Const && (v instanceof Value_1.Num || v instanceof Value_1.Str)) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Fun && v instanceof Closure) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            if (v instanceof DataValue_1.DataValue) {
                const eʹ = Core_1.as(e, Expr_1.Expr.DataExpr);
                // reverse order but shouldn't matter in absence of side-effects:
                Array_1.zip(Expl_1.Expl.explChildren(t, v), eʹ.__children).map(([tv, e]) => eval_bwd(e, tv));
                Annotation_1.setjoinα(Annotation_1.isα(tv), e);
            }
            else {
                Core_1.absurd();
            }
        }
        else if (t instanceof Expl_1.Expl.Quote) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Var) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.App) {
            Core_1.assert(t.tf.v instanceof Closure);
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            eval_bwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Match_1.apply_bwd(t.ξ, Annotation_1.isα(tv));
            recDefs_(Annotation_1.Direction.Bwd, t.δ);
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tf);
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_bwd(eʹ.f, t.tf);
            eval_bwd(eʹ.e, t.tu);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.UnaryApp) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tf);
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tv);
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_bwd(eʹ.f, t.tf);
            eval_bwd(eʹ.e, t.tv);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.BinaryApp) {
            Core_1.assert(Primitive_1.binaryOps.has(t.opName.val));
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tv1);
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tv2);
            const eʹ = Core_1.as(e, Expr_1.Expr.BinaryApp);
            eval_bwd(eʹ.e1, t.tv1);
            eval_bwd(eʹ.e2, t.tv2);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Defs) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            const eʹ = Core_1.as(e, Expr_1.Expr.Defs);
            eval_bwd(eʹ.e, DataValue_1.explValue(t.t, v));
            defs_bwd(eʹ.def̅, t.def̅);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.MatchAs) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            const eʹ = Core_1.as(e, Expr_1.Expr.MatchAs);
            eval_bwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Match_1.apply_bwd(t.ξ, Annotation_1.isα(tv));
            eval_bwd(eʹ.e, t.tu);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Typematch) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            const eʹ = Core_1.as(e, Expr_1.Expr.Typematch);
            eval_bwd(FiniteMap_1.get(eʹ.cases, t.d), DataValue_1.explValue(t.t, v));
            eval_bwd(eʹ.e, t.tu);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else {
            Core_1.absurd();
        }
    }
    Eval.eval_bwd = eval_bwd;
})(Eval = exports.Eval || (exports.Eval = {}));
DataType_1.initDataType(Expr_1.Expr.Expr, [Expr_1.Expr.App, Expr_1.Expr.BinaryApp, Expr_1.Expr.ConstNum, Expr_1.Expr.ConstStr, Expr_1.Expr.DataExpr, Expr_1.Expr.Defs, Expr_1.Expr.Fun, Expr_1.Expr.MatchAs, Expr_1.Expr.Quote, Expr_1.Expr.Var]);


/***/ }),

/***/ "./src/Expl.ts":
/*!*********************!*\
  !*** ./src/Expl.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
var Expl;
(function (Expl_1) {
    class Expl extends DataValue_1.DataValue {
    }
    Expl_1.Expl = Expl;
    class NonTerminal extends Expl {
    }
    Expl_1.NonTerminal = NonTerminal;
    class Terminal extends Expl {
    }
    Expl_1.Terminal = Terminal;
    class App extends NonTerminal {
        constructor() {
            super(...arguments);
            this.tf = Value_1._;
            this.tu = Value_1._;
            this.δ = Value_1._; // additional recursive functions bound at this step
            this.ξ = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.App = App;
    function app(tf, tu, δ, ξ, t) {
        return Versioned_1.at(App, tf, tu, δ, ξ, t);
    }
    Expl_1.app = app;
    class UnaryApp extends Terminal {
        constructor() {
            super(...arguments);
            this.tf = Value_1._;
            this.tv = Value_1._;
        }
    }
    Expl_1.UnaryApp = UnaryApp;
    function unaryApp(tf, tv) {
        return Versioned_1.at(UnaryApp, tf, tv);
    }
    Expl_1.unaryApp = unaryApp;
    class BinaryApp extends Terminal {
        constructor() {
            super(...arguments);
            this.tv1 = Value_1._;
            this.opName = Value_1._;
            this.tv2 = Value_1._;
        }
    }
    Expl_1.BinaryApp = BinaryApp;
    function binaryApp(tv1, opName, tv2) {
        return Versioned_1.at(BinaryApp, tv1, opName, tv2);
    }
    Expl_1.binaryApp = binaryApp;
    // Has a concrete subclass for each datatype.
    class DataExpl extends Terminal {
        get ctr() {
            return Core_1.className(this);
        }
        get __children() {
            return super.__children;
        }
    }
    Expl_1.DataExpl = DataExpl;
    class Def extends DataValue_1.DataValue {
    }
    Expl_1.Def = Def;
    class Let extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.tv = Value_1._;
        }
    }
    Expl_1.Let = Let;
    function let_(x, tv) {
        return Versioned_1.at(Let, x, tv);
    }
    Expl_1.let_ = let_;
    class Prim extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.t_op = Value_1._;
        }
    }
    Expl_1.Prim = Prim;
    function prim(x, t_op) {
        return Versioned_1.at(Prim, x, t_op);
    }
    Expl_1.prim = prim;
    class RecDef extends DataValue_1.DataValue {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.tf = Value_1._;
        }
    }
    Expl_1.RecDef = RecDef;
    function recDef(x, tf) {
        return Versioned_1.at(RecDef, x, tf);
    }
    Expl_1.recDef = recDef;
    class LetRec extends Def {
        constructor() {
            super(...arguments);
            this.δ = Value_1._;
        }
    }
    Expl_1.LetRec = LetRec;
    function letRec(δ) {
        return Versioned_1.at(LetRec, δ);
    }
    Expl_1.letRec = letRec;
    class Defs extends NonTerminal {
        constructor() {
            super(...arguments);
            this.def̅ = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.Defs = Defs;
    function defs(def̅, t) {
        return Versioned_1.at(Defs, def̅, t);
    }
    Expl_1.defs = defs;
    class Const extends Terminal {
    }
    Expl_1.Const = Const;
    function const_() {
        return Versioned_1.at(Const);
    }
    Expl_1.const_ = const_;
    class Fun extends Terminal {
        constructor() {
            super(...arguments);
            this.σ = Value_1._;
        }
    }
    Expl_1.Fun = Fun;
    function fun(σ) {
        return Versioned_1.at(Fun, σ);
    }
    Expl_1.fun = fun;
    class MatchAs extends NonTerminal {
        constructor() {
            super(...arguments);
            this.tu = Value_1._;
            this.ξ = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.MatchAs = MatchAs;
    function matchAs(tu, ξ, t) {
        return Versioned_1.at(MatchAs, tu, ξ, t);
    }
    Expl_1.matchAs = matchAs;
    class Quote extends Terminal {
    }
    Expl_1.Quote = Quote;
    function quote() {
        return Versioned_1.at(Quote);
    }
    Expl_1.quote = quote;
    class Typematch extends NonTerminal {
        constructor() {
            super(...arguments);
            this.tu = Value_1._;
            this.d = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.Typematch = Typematch;
    function typematch(tu, d, t) {
        return Versioned_1.at(Typematch, tu, d, t);
    }
    Expl_1.typematch = typematch;
    class Var extends NonTerminal {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.Var = Var;
    function var_(x, t) {
        return Versioned_1.at(Var, x, t);
    }
    Expl_1.var_ = var_;
    // Should probably do a better job of restricting k to be a bona fide field name.
    function explChild(t, v, prop) {
        if (t instanceof Terminal) {
            Core_1.assert(t instanceof DataExpl);
            return DataValue_1.explValue(t.__child(prop), v.__child(prop));
        }
        else if (t instanceof NonTerminal) {
            return explChild(t.t, v, prop);
        }
        else {
            // Primitive applications are currently "terminal" forms, which is technically inconsistent with the fact 
            // that they can return structured data. In practice this doesn't matter because they only return values 
            // like True and False, which have no children. Probably primitives should be non-terminal.
            return Core_1.absurd();
        }
    }
    Expl_1.explChild = explChild;
    function explChildren(t, v) {
        return Value_1.fields(v).map(k => explChild(t, v, k));
    }
    Expl_1.explChildren = explChildren;
})(Expl = exports.Expl || (exports.Expl = {}));


/***/ }),

/***/ "./src/Expr.ts":
/*!*********************!*\
  !*** ./src/Expr.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Set_1 = __webpack_require__(/*! ./util/Set */ "./src/util/Set.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Constants used for parsing, and also for toString() implementations.
exports.strings = {
    arrow: "→",
    as: "as",
    bracketL: "[",
    bracketR: "]",
    comma: ",",
    curlyL: "{",
    curlyR: "}",
    ellipsis: "...",
    equals: "=",
    fun: "fun",
    in_: "in",
    let_: "let",
    letRec: "letrec",
    match: "match",
    primitive: "primitive",
    parenL: "(",
    parenR: ")",
    quotes: '"',
    semicolon: ";",
    typematch: "typematch"
};
var Expr;
(function (Expr_1) {
    class SyntaxNode extends DataValue_1.DataValue {
    }
    Expr_1.SyntaxNode = SyntaxNode;
    class Expr extends SyntaxNode {
    }
    Expr_1.Expr = Expr;
    class App extends Expr {
        constructor() {
            super(...arguments);
            this.f = Value_1._;
            this.e = Value_1._;
        }
    }
    Expr_1.App = App;
    function app(f, e) {
        return Versioned_1.at(App, f, e);
    }
    Expr_1.app = app;
    class BinaryApp extends Expr {
        constructor() {
            super(...arguments);
            this.e1 = Value_1._;
            this.opName = Value_1._;
            this.e2 = Value_1._;
        }
    }
    Expr_1.BinaryApp = BinaryApp;
    function binaryApp(e1, opName, e2) {
        return Versioned_1.at(BinaryApp, e1, opName, e2);
    }
    Expr_1.binaryApp = binaryApp;
    class ConstNum extends Expr {
        constructor() {
            super(...arguments);
            this.val = Value_1._;
        }
    }
    Expr_1.ConstNum = ConstNum;
    function constNum(val) {
        return Versioned_1.at(ConstNum, val);
    }
    Expr_1.constNum = constNum;
    class ConstStr extends Expr {
        constructor() {
            super(...arguments);
            this.val = Value_1._;
        }
    }
    Expr_1.ConstStr = ConstStr;
    function constStr(val) {
        return Versioned_1.at(ConstStr, val);
    }
    Expr_1.constStr = constStr;
    // Has a concrete subclass for each datatype. Should this be parameterised by T extends DataValue?
    class DataExpr extends Expr {
        get ctr() {
            return Core_1.className(this);
        }
        __child(prop) {
            return super.__child(prop);
        }
        get __children() {
            return super.__children;
        }
    }
    Expr_1.DataExpr = DataExpr;
    class Def extends SyntaxNode {
    }
    Expr_1.Def = Def;
    class Let extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.e = Value_1._;
        }
    }
    Expr_1.Let = Let;
    function let_(x, e) {
        return Versioned_1.at(Let, x, e);
    }
    Expr_1.let_ = let_;
    class Prim extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
        }
    }
    Expr_1.Prim = Prim;
    function prim(x) {
        return Versioned_1.at(Prim, x);
    }
    Expr_1.prim = prim;
    class RecDef extends SyntaxNode {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.σ = Value_1._;
        }
    }
    Expr_1.RecDef = RecDef;
    function recDef(x, σ) {
        return Versioned_1.at(RecDef, x, σ);
    }
    Expr_1.recDef = recDef;
    class LetRec extends Def {
        constructor() {
            super(...arguments);
            this.δ = Value_1._;
        }
    }
    Expr_1.LetRec = LetRec;
    function letRec(δ) {
        return Versioned_1.at(LetRec, δ);
    }
    Expr_1.letRec = letRec;
    class Defs extends Expr {
        constructor() {
            super(...arguments);
            this.def̅ = Value_1._;
            this.e = Value_1._;
        }
    }
    Expr_1.Defs = Defs;
    function defs(def̅, e) {
        return Versioned_1.at(Defs, def̅, e);
    }
    Expr_1.defs = defs;
    class Fun extends Expr {
        constructor() {
            super(...arguments);
            this.σ = Value_1._;
        }
    }
    Expr_1.Fun = Fun;
    function fun(σ) {
        return Versioned_1.at(Fun, σ);
    }
    Expr_1.fun = fun;
    class MatchAs extends Expr {
        constructor() {
            super(...arguments);
            this.e = Value_1._;
            this.σ = Value_1._;
        }
    }
    Expr_1.MatchAs = MatchAs;
    function matchAs(e, σ) {
        return Versioned_1.at(MatchAs, e, σ);
    }
    Expr_1.matchAs = matchAs;
    class Quote extends Expr {
        constructor() {
            super(...arguments);
            this.e = Value_1._;
        }
    }
    Expr_1.Quote = Quote;
    function quote(e) {
        return Versioned_1.at(Quote, e);
    }
    Expr_1.quote = quote;
    // Bring in line with the current eliminator design, i.e. optimise into an object?
    class Typematch extends Expr {
        constructor() {
            super(...arguments);
            this.e = Value_1._;
            this.cases = Value_1._;
        }
    }
    Expr_1.Typematch = Typematch;
    function typematch(e, cases) {
        return Versioned_1.at(Typematch, e, cases);
    }
    Expr_1.typematch = typematch;
    class Var extends Expr {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
        }
    }
    Expr_1.Var = Var;
    function var_(x) {
        return Versioned_1.at(Var, x);
    }
    Expr_1.var_ = var_;
    // used by Wrattler
    function freeVars(e) {
        if (e instanceof ConstNum) {
            return new Set();
        }
        else if (e instanceof ConstStr) {
            return new Set();
        }
        else if (e instanceof Fun) {
            return freeVarsElim(e.σ);
        }
        else if (e instanceof DataExpr) {
            return Set_1.union(...e.__children.map(freeVars));
        }
        else if (e instanceof Quote) {
            return freeVars(e.e);
        }
        else if (e instanceof Var) {
            return new Set([e.x.val]);
        }
        else if (e instanceof App) {
            return Set_1.union(freeVars(e.f), freeVars(e.e));
        }
        else if (e instanceof BinaryApp) {
            return Set_1.union(freeVars(e.e1), freeVars(e.e2));
        }
        else if (e instanceof Defs) {
            const [bound, free] = freeVarsDefs(e.def̅, new Set());
            return Set_1.union(Set_1.diff(freeVars(e.e), bound), free);
        }
        else if (e instanceof MatchAs) {
            return Set_1.union(freeVars(e.e), freeVarsElim(e.σ));
        }
        else if (e instanceof Typematch) {
            return Set_1.union(freeVars(e.e), ...e.cases.toArray().map(({ snd }) => freeVars(snd)));
        }
        else {
            return Core_1.absurd();
        }
    }
    Expr_1.freeVars = freeVars;
    function freeVarsCont(κ) {
        if (κ instanceof Expr) {
            return freeVars(κ);
        }
        else if (κ instanceof Match_1.Elim) {
            return freeVarsElim(κ);
        }
        else {
            return Core_1.absurd();
        }
    }
    function freeVarsElim(σ) {
        if (Match_1.VarElim.is(σ)) {
            return Set_1.diff(freeVarsCont(σ.κ), new Set([σ.x.val]));
        }
        else if (Match_1.DataElim.is(σ)) {
            return Set_1.union(...σ.__children.map(freeVarsCont));
        }
        else {
            return Core_1.absurd();
        }
    }
    // (bound, free) vars - not necessarily disjoint, because the defs nest
    function freeVarsDefs(def̅, bound) {
        if (BaseTypes_1.Cons.is(def̅)) {
            const def = def̅.head;
            if (def instanceof Prim) {
                const x̅ = new Set([def.x.val]), [boundʹ, free] = freeVarsDefs(def̅.tail, bound);
                return [boundʹ, Set_1.diff(free, x̅)];
            }
            else if (def instanceof Let) {
                const x̅ = new Set([def.x.val]), [boundʹ, free] = freeVarsDefs(def̅.tail, Set_1.union(bound, x̅));
                return [boundʹ, Set_1.union(Set_1.diff(free, x̅), freeVars(def.e))];
            }
            else if (def instanceof LetRec) {
                const f̅ = def.δ.toArray(), x̅ = new Set(f̅.map(f => f.x.val)), [boundʹ, free] = freeVarsDefs(def̅.tail, Set_1.union(bound, x̅));
                return [boundʹ, Set_1.diff(Set_1.union(free, ...f̅.map(f => freeVarsElim(f.σ))), x̅)];
            }
            else {
                return Core_1.absurd();
            }
        }
        else if (BaseTypes_1.Nil.is(def̅)) {
            return [bound, new Set()];
        }
        else {
            return Core_1.absurd();
        }
    }
})(Expr = exports.Expr || (exports.Expr = {}));


/***/ }),

/***/ "./src/FiniteMap.ts":
/*!**************************!*\
  !*** ./src/FiniteMap.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
function get(m, k) {
    if (BaseTypes_1.NonEmpty.is(m)) {
        if (k.leq(m.t.fst)) {
            if (m.t.fst.leq(k)) {
                return m.t.snd;
            }
            else {
                return get(m.left, k);
            }
        }
        else {
            return get(m.right, k);
        }
    }
    else if (BaseTypes_1.Empty.is(m)) {
        return undefined;
    }
    else {
        return Core_1.absurd();
    }
}
exports.get = get;
function insert(m, k, v) {
    if (BaseTypes_1.NonEmpty.is(m)) {
        if (k.leq(m.t.fst)) {
            if (m.t.fst.leq(k)) {
                return BaseTypes_1.nonEmpty(m.left, BaseTypes_1.pair(k, v), m.right);
            }
            else {
                return BaseTypes_1.nonEmpty(insert(m.left, k, v), m.t, m.right);
            }
        }
        else {
            return BaseTypes_1.nonEmpty(m.left, m.t, insert(m.right, k, v));
        }
    }
    else if (BaseTypes_1.Empty.is(m)) {
        return BaseTypes_1.nonEmpty(m, BaseTypes_1.pair(k, v), m);
    }
    else {
        return Core_1.absurd();
    }
}
exports.insert = insert;
function singleton(k, v) {
    return insert(BaseTypes_1.empty(), k, v);
}
exports.singleton = singleton;
// Union with a combining function. If keys are equal, right-hand key will be used in the output.
// Avoid primes in signature; seems to be incompatible with version of ts-loader used by Wrattler.
function unionWith(m1, m2, f) {
    if (BaseTypes_1.NonEmpty.is(m2)) {
        const k = m2.t.fst, v = m2.t.snd, vʹ = get(m1, k), u = vʹ === undefined ? v : f(v, vʹ);
        return unionWith(insert(unionWith(m1, m2.left, f), k, u), m2.right, f);
    }
    else if (BaseTypes_1.Empty.is(m2)) {
        return m1;
    }
    else {
        return Core_1.absurd();
    }
}
exports.unionWith = unionWith;


/***/ }),

/***/ "./src/Graphics.ts":
/*!*************************!*\
  !*** ./src/Graphics.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
class Point extends DataValue_1.DataValue {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
    }
}
exports.Point = Point;
// Isomorphic to Bool
class Orient extends DataValue_1.DataValue {
}
exports.Orient = Orient;
class Horiz extends Orient {
}
exports.Horiz = Horiz;
class Vert extends Orient {
}
exports.Vert = Vert;
class GraphicsElement extends DataValue_1.DataValue {
}
exports.GraphicsElement = GraphicsElement;
class Circle extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.radius = Value_1._;
        this.fill = Value_1._;
    }
}
exports.Circle = Circle;
class Group extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.gs = Value_1._;
    }
}
exports.Group = Group;
class Line extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.p1 = Value_1._;
        this.p2 = Value_1._;
        this.stroke = Value_1._;
        this.strokeWidth = Value_1._;
    }
}
exports.Line = Line;
class Polyline extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.points = Value_1._;
        this.stroke = Value_1._;
        this.strokeWidth = Value_1._;
    }
}
exports.Polyline = Polyline;
class Polymarkers extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.points = Value_1._;
        this.markers = Value_1._;
    }
}
exports.Polymarkers = Polymarkers;
class Rect extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.width = Value_1._;
        this.height = Value_1._;
        this.fill = Value_1._;
    }
}
exports.Rect = Rect;
class Text extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.str = Value_1._;
        this.anchor = Value_1._; // SVG text-anchor
        this.baseline = Value_1._; // SVG alignment-baseline
    }
}
exports.Text = Text;
class Viewport extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.width = Value_1._;
        this.height = Value_1._;
        this.fill = Value_1._;
        this.margin = Value_1._; // in *parent* reference frame
        this.scale = Value_1._;
        this.translate = Value_1._; // scaling applies to translated coordinates
        this.g = Value_1._;
    }
}
exports.Viewport = Viewport;
class Transform extends DataValue_1.DataValue {
}
exports.Transform = Transform;
class Scale extends Transform {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
    }
}
exports.Scale = Scale;
class Translate extends Transform {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
    }
}
exports.Translate = Translate;
class Marker extends DataValue_1.DataValue {
}
exports.Marker = Marker;
class Arrowhead extends Marker {
}
exports.Arrowhead = Arrowhead;
DataType_1.initDataType(Point, [Point]);
DataType_1.initDataType(Orient, [Horiz, Vert]);
DataType_1.initDataType(GraphicsElement, [Circle, Group, Line, Polyline, Polymarkers, Rect, Text, Viewport]);
DataType_1.initDataType(Transform, [Scale, Translate]);
DataType_1.initDataType(Marker, [Arrowhead]);


/***/ }),

/***/ "./src/Lib.ts":
/*!********************!*\
  !*** ./src/Lib.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// "typings" property of package.json requires a single TypeScript interface.
__webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts"); // need these early because of a Webpack dependency problem
const Pane_1 = __webpack_require__(/*! ./app/Pane */ "./src/app/Pane.ts");
exports.Pane = Pane_1.Pane;
const PaneCoordinator_1 = __webpack_require__(/*! ./app/PaneCoordinator */ "./src/app/PaneCoordinator.ts");
exports.PaneCoordinator = PaneCoordinator_1.PaneCoordinator;
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
exports.Env = Env_1.Env;
exports.emptyEnv = Env_1.emptyEnv;
const Eval_1 = __webpack_require__(/*! ./Eval */ "./src/Eval.ts");
exports.Eval = Eval_1.Eval;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
exports.Expr = Expr_1.Expr;
const Module_1 = __webpack_require__(/*! ./Module */ "./src/Module.ts");
exports.bindDataset = Module_1.bindDataset;
exports.openDatasetAs = Module_1.openDatasetAs;
exports.parseWithImports = Module_1.parseWithImports;


/***/ }),

/***/ "./src/Match.ts":
/*!**********************!*\
  !*** ./src/Match.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ./util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Ord_1 = __webpack_require__(/*! ./util/Ord */ "./src/util/Ord.ts");
const Lattice_1 = __webpack_require__(/*! ./util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ./Annotation */ "./src/Annotation.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Unrelated to the annotation lattice. Expr case intentionally only defined for higher-order (function) case.
function join(κ, κʹ) {
    const k = Value_1.memoId(join, arguments);
    if (κ instanceof Elim && κʹ instanceof Elim) {
        return DataElim.join(κ, κʹ);
    }
    else if (κ instanceof Expr_1.Expr.Fun && κʹ instanceof Expr_1.Expr.Fun) {
        return Expr_1.Expr.fun(join(κ.σ, κʹ.σ))(k);
    }
    else {
        return Core_1.absurd("Undefined join.", κ, κʹ);
    }
}
class Match extends DataValue_1.DataValue {
    constructor() {
        super(...arguments);
        this.tv̅ = Value_1._;
        this.κ = Value_1._;
    }
}
exports.Match = Match;
function match(ξ, κ) {
    return Value_1.make(Match, ξ, κ);
}
exports.match = match;
// See GitHub issue #128.
class Elim extends DataValue_1.DataValue {
    // could have called this "match", but conflicts with factory method of same name
    apply(tv) {
        return apply_(this, tv, BaseTypes_1.nil());
    }
}
exports.Elim = Elim;
function apply_(σ, tv, u̅) {
    if (VarElim.is(σ)) {
        const ρ = σ.x.val === "_" ? Env_1.emptyEnv() : Env_1.Env.singleton(σ.x, tv);
        return [ρ, match(u̅, σ.κ)];
    }
    else if (DataElim.is(σ)) {
        const v = tv.v, c = Core_1.className(v);
        if (v instanceof DataValue_1.DataValue) {
            const κ = σ[c];
            if (κ !== undefined) {
                const tv̅ = Expl_1.Expl.explChildren(tv.t, v), [ρ, ξ] = matchArgs(κ, tv̅, u̅);
                return [ρ, match(BaseTypes_1.cons(tv, ξ.tv̅), ξ.κ)];
            }
            else {
                const d = DataType_1.elimToDataType.get(Core_1.className(σ));
                if (d.ctrs.has(c)) {
                    return Core_1.userError(`Pattern mismatch: "${c}" case undefined for ${d.name.val}.`);
                }
                else {
                    return Core_1.userError(`Pattern mismatch: found ${c}, expected ${d.name.val}.`);
                }
            }
        }
        else {
            return Core_1.userError(`Pattern mismatch: ${c} is not a datatype.`, v, σ);
        }
    }
    else {
        return Core_1.absurd();
    }
}
// Parser ensures constructor calls are saturated.
function matchArgs(κ, tv̅, u̅) {
    if (tv̅.length === 0) {
        return [Env_1.emptyEnv(), match(u̅, κ)];
    }
    else {
        const [tv, ...tv̅ʹ] = tv̅;
        if (κ instanceof Elim) {
            const σ = κ, // "unfold" K into Elim<K>
            [ρ, ξ] = apply_(σ, tv, u̅), [ρʹ, ξʹ] = matchArgs(ξ.κ, tv̅ʹ, ξ.tv̅);
            return [ρ.concat(ρʹ), ξʹ];
        }
        else {
            return Core_1.absurd("Too many arguments to constructor.");
        }
    }
}
// Concrete instances have a field per constructor, in *lexicographical* order.
class DataElim extends Elim {
    static is(σ) {
        return σ instanceof DataElim;
    }
    static join(σ, τ) {
        const k = Value_1.memoId(DataElim.join, arguments);
        if (VarElim.is(σ) && VarElim.is(τ) && Ord_1.eq(σ.x, τ.x)) {
            return varElim(σ.x, join(σ.κ, τ.κ))(k);
        }
        else if (DataElim.is(σ) && DataElim.is(τ)) {
            // Both maps (which are non-empty) can (inductively) be assumed to have keys taken from the 
            // same datatype. Ensure that invariant is preserved:
            const c_σ = Value_1.fields(σ)[0], c_τ = Value_1.fields(τ)[0];
            if (DataType_1.ctrToDataType.get(c_σ) !== DataType_1.ctrToDataType.get(c_τ)) {
                Core_1.userError(`${c_σ} and ${c_τ} are constructors of different datatypes.`);
            }
            const cκ̅1 = Array_1.zip(Value_1.fields(σ), σ.__children), cκ̅2 = Array_1.zip(Value_1.fields(τ), τ.__children);
            Core_1.assert(cκ̅1.length === cκ̅2.length);
            const cκ̅ = Array_1.zipWith(([c1, κ1], [c2, κ2]) => {
                Core_1.assert(c1 === c2);
                return [c1, κ1 === undefined ? κ2 : (κ2 === undefined ? κ1 : join(κ1, κ2))];
            })(cκ̅1, cκ̅2);
            return dataElim(...cκ̅)(k);
        }
        else {
            return Core_1.absurd("Undefined join.", σ, τ);
        }
    }
}
exports.DataElim = DataElim;
// cκ̅ non-empty and constructors all of the same datatype.
function dataElim(...cκ̅) {
    const d = Core_1.__nonNull(DataType_1.ctrToDataType.get(cκ̅[0][0])), c̅ = cκ̅.map((([c, _]) => c)), c̅ʹ = [...d.ctrs.keys()], // sorted
    f̅ = [];
    let n = 0;
    for (let nʹ = 0; nʹ < c̅ʹ.length; ++nʹ) {
        if (c̅.includes(c̅ʹ[nʹ])) {
            f̅.push(cκ̅[n++][1]);
        }
        else {
            f̅.push(undefined);
        }
    }
    return Versioned_1.at(d.elimC, ...f̅);
}
exports.dataElim = dataElim;
class VarElim extends Elim {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.κ = Value_1._;
    }
    static is(σ) {
        return σ instanceof VarElim;
    }
}
exports.VarElim = VarElim;
function varElim(x, κ) {
    return Versioned_1.at(VarElim, x, κ);
}
exports.varElim = varElim;
function apply_fwd(ξ) {
    return ξ.tv̅.toArray().reduce((α, tv) => Lattice_1.bool_.meet(α, Annotation_1.isα(tv)), Lattice_1.bool_.top);
}
exports.apply_fwd = apply_fwd;
function apply_bwd(ξ, α) {
    ξ.tv̅.toArray().forEach((tv) => Annotation_1.setjoinα(α, tv));
}
exports.apply_bwd = apply_bwd;


/***/ }),

/***/ "./src/Module.ts":
/*!***********************!*\
  !*** ./src/Module.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const nearley_1 = __webpack_require__(/*! nearley */ "./node_modules/nearley/lib/nearley.js");
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
const Eval_1 = __webpack_require__(/*! ./Eval */ "./src/Eval.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
__webpack_require__(/*! ./Graphics */ "./src/Graphics.ts"); // for datatypes
const Parse_1 = __webpack_require__(/*! ./Parse */ "./src/Parse.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Kindergarten modules.
const prelude_fld_1 = __webpack_require__(/*! ../fluid/lib/prelude.fld */ "./fluid/lib/prelude.fld");
const graphics_fld_1 = __webpack_require__(/*! ../fluid/lib/graphics.fld */ "./fluid/lib/graphics.fld");
var Module;
(function (Module) {
    function initialise() {
        exports.module_prelude = loadModule(Env_1.emptyEnv(), prelude_fld_1.default);
        exports.module_graphics = loadModule(exports.module_prelude, graphics_fld_1.default);
    }
    Module.initialise = initialise;
})(Module = exports.Module || (exports.Module = {}));
function import_(...modules) {
    if (modules.length === 0) {
        return Env_1.emptyEnv();
    }
    else {
        const [m, ...ms] = modules;
        return m.concat(import_(...ms));
    }
}
function loadTestFile(folder, file) {
    let text;
    const xmlhttp = new XMLHttpRequest;
    xmlhttp.open("GET", "./" + folder + "/" + file + ".fld", false);
    xmlhttp.send();
    if (xmlhttp.status === 200) {
        text = xmlhttp.responseText;
    }
    return Core_1.__nonNull(text);
}
exports.loadTestFile = loadTestFile;
// Not sure if Nearley can parse arbitrary non-terminal, as opposed to root.
function loadModule(ρ, src) {
    const srcʹ = src + " in 0", e = Core_1.as(successfulParse(srcʹ), Expr_1.Expr.Defs);
    return Eval_1.Eval.defs(ρ, e.def̅, Env_1.emptyEnv())[1];
}
exports.loadModule = loadModule;
function openWithImports(file, ...modules) {
    return parseWithImports(loadTestFile("fluid/example", file), ...modules);
}
exports.openWithImports = openWithImports;
function openDatasetAs(file, x) {
    const [ρ, e] = parseWithImports(loadTestFile("fluid/dataset", file));
    return Env_1.Env.singleton(Versioned_1.str(x)(Versioned_1.ν()), Eval_1.Eval.eval_(ρ, e));
}
exports.openDatasetAs = openDatasetAs;
function parseWithImports(src, ...modules) {
    return [import_(Core_1.__nonNull(exports.module_prelude), Core_1.__nonNull(exports.module_graphics), ...modules), successfulParse(src)];
}
exports.parseWithImports = parseWithImports;
// https://github.com/kach/nearley/issues/276#issuecomment-324162234
function successfulParse(str) {
    const { results } = new nearley_1.Parser(nearley_1.Grammar.fromCompiled(Parse_1.default)).feed(str);
    if (results.length > 1) {
        Core_1.userError("Ambiguous parse.");
    }
    else if (results.length === 0) {
        Core_1.userError("Unsuccessful parse.");
    }
    return results[0];
}
exports.successfulParse = successfulParse;
// create an expression and evaluate it, so we have an explained value
function bindDataset(ρ, vs, x) {
    return Env_1.extendEnv(ρ, Versioned_1.str(x)(Versioned_1.ν()), Eval_1.Eval.eval_(ρ, asList(vs.map(asRecord))));
}
exports.bindDataset = bindDataset;
function asRecord(v) {
    return asList(Object.getOwnPropertyNames(v).map(k => asPair(k, v[k])));
}
function asPair(k, v) {
    return Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Pair), asPrimValue(k), asPrimValue(v))(Versioned_1.ν());
}
function asList(e̅) {
    let e̅ʹ = Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Nil))(Versioned_1.ν());
    for (let e of [...e̅].reverse()) {
        e̅ʹ = Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Cons), e, e̅ʹ)(Versioned_1.ν());
    }
    return e̅ʹ;
}
function asPrimValue(v) {
    if (typeof v === "number") {
        return Expr_1.Expr.constNum(Versioned_1.num(v)(Versioned_1.ν()))(Versioned_1.ν());
    }
    else if (typeof v === "string") {
        return Expr_1.Expr.constStr(Versioned_1.str(v)(Versioned_1.ν()))(Versioned_1.ν());
    }
    else {
        return Core_1.userError(`Ill-formed data: expected string or number, found ${typeof v}.`);
    }
}


/***/ }),

/***/ "./src/Parse.ts":
/*!**********************!*\
  !*** ./src/Parse.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Generated automatically by nearley, version 2.19.0
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
const moo = __webpack_require__(/*! moo */ "./node_modules/moo/moo.js");
const lexer = moo.compile({
    ident: {
        match: /[a-zA-Z_][0-9a-zA-Z_]*'*/,
        type: moo.keywords({
            keyword: ["_", "as", "match", "fun", "in", "let", "letrec", "primitive", "typematch"],
        })
    },
    whitespace: {
        match: /[ \f\t\r\n]+/,
        lineBreaks: true
    },
    singleLineComment: /\/\/.*$/,
    // JSON grammar for numbers, https://tools.ietf.org/html/rfc7159.html#section-6.
    // Seems Moo requires us to use non-capturing groups (?:)
    number: /\-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[e|E][-|+]?[0-9]+)?/,
    string: /"(?:\\["\\]|[^\n"\\])*"/,
    // not quite sure why I can't use literals here:
    sumOp: /\-|\+\+|\+/,
    exponentOp: /\*\*/,
    productOp: /\*|\//,
    compareOp: /==|<=|<|>=|>/,
    symbol: ["(", ")", "=", "→", ";", "{", "}", ",", "[", "]", "..."],
});
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const FiniteMap_1 = __webpack_require__(/*! ./FiniteMap */ "./src/FiniteMap.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Constructors must start with an uppercase letter, a la Haskell. Will fix this as part of issue #49.
function isCtr(str) {
    const ch = str.charAt(0);
    return ch === ch.toUpperCase() && ch !== ch.toLowerCase();
}
function compose(mk_κ1, mk_κ2) {
    return (κ) => mk_κ1(mk_κ2(κ));
}
;
;
;
;
const grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "rootExpr", "symbols": ["_", "expr"], "postprocess": ([, e]) => e },
        { "name": "rootExpr", "symbols": ["expr"], "postprocess": id },
        { "name": "_$ebnf$1$subexpression$1", "symbols": [(lexer.has("whitespace") ? { type: "whitespace" } : whitespace)] },
        { "name": "_$ebnf$1$subexpression$1", "symbols": [(lexer.has("singleLineComment") ? { type: "singleLineComment" } : singleLineComment)] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1$subexpression$1"] },
        { "name": "_$ebnf$1$subexpression$2", "symbols": [(lexer.has("whitespace") ? { type: "whitespace" } : whitespace)] },
        { "name": "_$ebnf$1$subexpression$2", "symbols": [(lexer.has("singleLineComment") ? { type: "singleLineComment" } : singleLineComment)] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "_$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_", "symbols": ["_$ebnf$1"] },
        { "name": "expr", "symbols": ["compareExpr"], "postprocess": id },
        { "name": "expr", "symbols": ["defs1"], "postprocess": id },
        { "name": "expr", "symbols": ["fun"], "postprocess": id },
        { "name": "expr", "symbols": ["matchAs"], "postprocess": id },
        { "name": "expr", "symbols": ["typematch"], "postprocess": id },
        { "name": "defs1$macrocall$2", "symbols": [{ "literal": "in" }] },
        { "name": "defs1$macrocall$1$macrocall$2", "symbols": ["defs1$macrocall$2"] },
        { "name": "defs1$macrocall$1$macrocall$1", "symbols": ["defs1$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "defs1$macrocall$1$macrocall$1", "symbols": ["defs1$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "defs1$macrocall$1", "symbols": ["defs1$macrocall$1$macrocall$1"] },
        { "name": "defs1", "symbols": ["defList", "defs1$macrocall$1", "expr"], "postprocess": ([defs, , e]) => Expr_1.Expr.defs(defs, e)(Versioned_1.ν()) },
        { "name": "compareExpr", "symbols": ["compareExpr", "compareOp", "sumExpr"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "compareExpr", "symbols": ["sumExpr"], "postprocess": id },
        { "name": "sumExpr", "symbols": ["sumExpr", "sumOp", "productExpr"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "sumExpr", "symbols": ["productExpr"], "postprocess": id },
        { "name": "productExpr", "symbols": ["productExpr", "productOp", "exponentExpr"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "productExpr", "symbols": ["exponentExpr"], "postprocess": id },
        { "name": "exponentExpr", "symbols": ["exponentExpr", "exponentOp", "appChain"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "exponentExpr", "symbols": ["appChain"], "postprocess": id },
        { "name": "appChain", "symbols": ["simpleExpr"], "postprocess": id },
        { "name": "appChain", "symbols": ["appChain", "simpleExpr"], "postprocess": ([e1, e2]) => Expr_1.Expr.app(e1, e2)(Versioned_1.ν()) },
        { "name": "simpleExpr", "symbols": ["variable"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["string"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["number"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["parenthExpr"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["pair"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["list"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["constr"], "postprocess": id },
        { "name": "variable", "symbols": ["var"], "postprocess": ([x]) => Expr_1.Expr.var_(x)(Versioned_1.ν()) },
        { "name": "var$macrocall$2", "symbols": [(lexer.has("ident") ? { type: "ident" } : ident)] },
        { "name": "var$macrocall$1", "symbols": ["var$macrocall$2"], "postprocess": id },
        { "name": "var$macrocall$1", "symbols": ["var$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "var", "symbols": ["var$macrocall$1"], "postprocess": ([[x]], _, reject) => {
                if (isCtr(x.value)) {
                    return reject;
                }
                return Versioned_1.str(x.value)(Versioned_1.ν());
            } },
        { "name": "string$macrocall$2", "symbols": [(lexer.has("string") ? { type: "string" } : string)] },
        { "name": "string$macrocall$1", "symbols": ["string$macrocall$2"], "postprocess": id },
        { "name": "string$macrocall$1", "symbols": ["string$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "string", "symbols": ["string$macrocall$1"], "postprocess": ([[lit]]) => Expr_1.Expr.constStr(Versioned_1.str(lit.value.slice(1, -1))(Versioned_1.ν()))(Versioned_1.ν()) },
        { "name": "number$macrocall$2", "symbols": [(lexer.has("number") ? { type: "number" } : number)] },
        { "name": "number$macrocall$1", "symbols": ["number$macrocall$2"], "postprocess": id },
        { "name": "number$macrocall$1", "symbols": ["number$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "number", "symbols": ["number$macrocall$1"], "postprocess": ([[lit]]) => Expr_1.Expr.constNum(Versioned_1.num(new Number(lit.value).valueOf())(Versioned_1.ν()))(Versioned_1.ν()) },
        { "name": "parenthExpr$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "parenthExpr$macrocall$1", "symbols": ["parenthExpr$macrocall$2"], "postprocess": id },
        { "name": "parenthExpr$macrocall$1", "symbols": ["parenthExpr$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "parenthExpr$macrocall$4", "symbols": [{ "literal": ")" }] },
        { "name": "parenthExpr$macrocall$3", "symbols": ["parenthExpr$macrocall$4"], "postprocess": id },
        { "name": "parenthExpr$macrocall$3", "symbols": ["parenthExpr$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "parenthExpr", "symbols": ["parenthExpr$macrocall$1", "expr", "parenthExpr$macrocall$3"], "postprocess": ([, e,]) => e },
        { "name": "pair$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "pair$macrocall$1", "symbols": ["pair$macrocall$2"], "postprocess": id },
        { "name": "pair$macrocall$1", "symbols": ["pair$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "pair$macrocall$4", "symbols": [{ "literal": "," }] },
        { "name": "pair$macrocall$3", "symbols": ["pair$macrocall$4"], "postprocess": id },
        { "name": "pair$macrocall$3", "symbols": ["pair$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "pair$macrocall$6", "symbols": [{ "literal": ")" }] },
        { "name": "pair$macrocall$5", "symbols": ["pair$macrocall$6"], "postprocess": id },
        { "name": "pair$macrocall$5", "symbols": ["pair$macrocall$6", "_"], "postprocess": ([x,]) => x },
        { "name": "pair", "symbols": ["pair$macrocall$1", "expr", "pair$macrocall$3", "expr", "pair$macrocall$5"], "postprocess": ([, e1, , e2,]) => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Pair), e1, e2)(Versioned_1.ν()) },
        { "name": "list$macrocall$2", "symbols": [{ "literal": "[" }] },
        { "name": "list$macrocall$1", "symbols": ["list$macrocall$2"], "postprocess": id },
        { "name": "list$macrocall$1", "symbols": ["list$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "list$macrocall$4", "symbols": [{ "literal": "]" }] },
        { "name": "list$macrocall$3", "symbols": ["list$macrocall$4"], "postprocess": id },
        { "name": "list$macrocall$3", "symbols": ["list$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "list", "symbols": ["list$macrocall$1", "listOpt", "list$macrocall$3"], "postprocess": ([, e,]) => e },
        { "name": "constr", "symbols": ["ctr", "args"], "postprocess": ([c, e̅], _, reject) => {
                Core_1.assert(c instanceof Value_1.Str);
                const ctr = DataType_1.ctrFor(c.val);
                if (ctr.arity !== e̅.length) {
                    return reject;
                }
                return Versioned_1.at(DataType_1.exprClass(ctr.C), ...e̅)(Versioned_1.ν());
            } },
        { "name": "ctr$macrocall$2", "symbols": [(lexer.has("ident") ? { type: "ident" } : ident)] },
        { "name": "ctr$macrocall$1", "symbols": ["ctr$macrocall$2"], "postprocess": id },
        { "name": "ctr$macrocall$1", "symbols": ["ctr$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "ctr", "symbols": ["ctr$macrocall$1"], "postprocess": ([[x]], _, reject) => {
                if (!isCtr(x.value)) {
                    return reject;
                }
                return Versioned_1.str(x.value)(Versioned_1.ν());
            } },
        { "name": "args", "symbols": [], "postprocess": () => [] },
        { "name": "args$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "args$macrocall$1", "symbols": ["args$macrocall$2"], "postprocess": id },
        { "name": "args$macrocall$1", "symbols": ["args$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args$ebnf$1", "symbols": [] },
        { "name": "args$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "args$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "args$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args$ebnf$1$subexpression$1", "symbols": ["args$ebnf$1$subexpression$1$macrocall$1", "expr"], "postprocess": ([, e]) => e },
        { "name": "args$ebnf$1", "symbols": ["args$ebnf$1", "args$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "args$macrocall$4", "symbols": [{ "literal": ")" }] },
        { "name": "args$macrocall$3", "symbols": ["args$macrocall$4"], "postprocess": id },
        { "name": "args$macrocall$3", "symbols": ["args$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "args", "symbols": ["args$macrocall$1", "expr", "args$ebnf$1", "args$macrocall$3"], "postprocess": ([, e, es,]) => [e, ...es] },
        { "name": "typematch$macrocall$2", "symbols": [{ "literal": "typematch" }] },
        { "name": "typematch$macrocall$1$macrocall$2", "symbols": ["typematch$macrocall$2"] },
        { "name": "typematch$macrocall$1$macrocall$1", "symbols": ["typematch$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "typematch$macrocall$1$macrocall$1", "symbols": ["typematch$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typematch$macrocall$1", "symbols": ["typematch$macrocall$1$macrocall$1"] },
        { "name": "typematch$macrocall$4", "symbols": [{ "literal": "as" }] },
        { "name": "typematch$macrocall$3$macrocall$2", "symbols": ["typematch$macrocall$4"] },
        { "name": "typematch$macrocall$3$macrocall$1", "symbols": ["typematch$macrocall$3$macrocall$2"], "postprocess": id },
        { "name": "typematch$macrocall$3$macrocall$1", "symbols": ["typematch$macrocall$3$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typematch$macrocall$3", "symbols": ["typematch$macrocall$3$macrocall$1"] },
        { "name": "typematch", "symbols": ["typematch$macrocall$1", "expr", "typematch$macrocall$3", "typeMatches"], "postprocess": ([, e, , m]) => Expr_1.Expr.typematch(e, m)(Versioned_1.ν()) },
        { "name": "defList$ebnf$1", "symbols": [] },
        { "name": "defList$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "defList$ebnf$1$subexpression$1$macrocall$1", "symbols": ["defList$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "defList$ebnf$1$subexpression$1$macrocall$1", "symbols": ["defList$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "defList$ebnf$1$subexpression$1", "symbols": ["defList$ebnf$1$subexpression$1$macrocall$1", "def"], "postprocess": ([, def]) => def },
        { "name": "defList$ebnf$1", "symbols": ["defList$ebnf$1", "defList$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "defList", "symbols": ["def", "defList$ebnf$1"], "postprocess": ([def, defs]) => BaseTypes_1.List.fromArray([def, ...defs]) },
        { "name": "def", "symbols": ["let"], "postprocess": id },
        { "name": "def", "symbols": ["letrec"], "postprocess": id },
        { "name": "def", "symbols": ["prim"], "postprocess": id },
        { "name": "let$macrocall$2", "symbols": [{ "literal": "let" }] },
        { "name": "let$macrocall$1$macrocall$2", "symbols": ["let$macrocall$2"] },
        { "name": "let$macrocall$1$macrocall$1", "symbols": ["let$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "let$macrocall$1$macrocall$1", "symbols": ["let$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "let$macrocall$1", "symbols": ["let$macrocall$1$macrocall$1"] },
        { "name": "let$macrocall$4", "symbols": [{ "literal": "=" }] },
        { "name": "let$macrocall$3", "symbols": ["let$macrocall$4"], "postprocess": id },
        { "name": "let$macrocall$3", "symbols": ["let$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "let", "symbols": ["let$macrocall$1", "var", "let$macrocall$3", "expr"], "postprocess": ([, x, , e]) => Expr_1.Expr.let_(x, e)(Versioned_1.ν()) },
        { "name": "letrec$macrocall$2", "symbols": [{ "literal": "letrec" }] },
        { "name": "letrec$macrocall$1$macrocall$2", "symbols": ["letrec$macrocall$2"] },
        { "name": "letrec$macrocall$1$macrocall$1", "symbols": ["letrec$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "letrec$macrocall$1$macrocall$1", "symbols": ["letrec$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "letrec$macrocall$1", "symbols": ["letrec$macrocall$1$macrocall$1"] },
        { "name": "letrec$ebnf$1", "symbols": [] },
        { "name": "letrec$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "letrec$ebnf$1$subexpression$1$macrocall$1", "symbols": ["letrec$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "letrec$ebnf$1$subexpression$1$macrocall$1", "symbols": ["letrec$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "letrec$ebnf$1$subexpression$1", "symbols": ["letrec$ebnf$1$subexpression$1$macrocall$1", "recDef"], "postprocess": ([, recDef]) => recDef },
        { "name": "letrec$ebnf$1", "symbols": ["letrec$ebnf$1", "letrec$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "letrec", "symbols": ["letrec$macrocall$1", "recDef", "letrec$ebnf$1"], "postprocess": ([, recDef, δ]) => Expr_1.Expr.letRec(BaseTypes_1.List.fromArray([recDef, ...δ]))(Versioned_1.ν()) },
        { "name": "prim$macrocall$2", "symbols": [{ "literal": "primitive" }] },
        { "name": "prim$macrocall$1$macrocall$2", "symbols": ["prim$macrocall$2"] },
        { "name": "prim$macrocall$1$macrocall$1", "symbols": ["prim$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "prim$macrocall$1$macrocall$1", "symbols": ["prim$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "prim$macrocall$1", "symbols": ["prim$macrocall$1$macrocall$1"] },
        { "name": "prim", "symbols": ["prim$macrocall$1", "var"], "postprocess": ([, x]) => Expr_1.Expr.prim(x)(Versioned_1.ν()) },
        { "name": "recDef$macrocall$2", "symbols": [{ "literal": "fun" }] },
        { "name": "recDef$macrocall$1$macrocall$2", "symbols": ["recDef$macrocall$2"] },
        { "name": "recDef$macrocall$1$macrocall$1", "symbols": ["recDef$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "recDef$macrocall$1$macrocall$1", "symbols": ["recDef$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "recDef$macrocall$1", "symbols": ["recDef$macrocall$1$macrocall$1"] },
        { "name": "recDef", "symbols": ["recDef$macrocall$1", "var", "matches"], "postprocess": ([, f, σ]) => Expr_1.Expr.recDef(f, σ)(Versioned_1.ν()) },
        { "name": "fun$macrocall$2", "symbols": [{ "literal": "fun" }] },
        { "name": "fun$macrocall$1$macrocall$2", "symbols": ["fun$macrocall$2"] },
        { "name": "fun$macrocall$1$macrocall$1", "symbols": ["fun$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "fun$macrocall$1$macrocall$1", "symbols": ["fun$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "fun$macrocall$1", "symbols": ["fun$macrocall$1$macrocall$1"] },
        { "name": "fun", "symbols": ["fun$macrocall$1", "matches"], "postprocess": ([, σ]) => Expr_1.Expr.fun(σ)(Versioned_1.ν()) },
        { "name": "matchAs$macrocall$2", "symbols": [{ "literal": "match" }] },
        { "name": "matchAs$macrocall$1$macrocall$2", "symbols": ["matchAs$macrocall$2"] },
        { "name": "matchAs$macrocall$1$macrocall$1", "symbols": ["matchAs$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "matchAs$macrocall$1$macrocall$1", "symbols": ["matchAs$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matchAs$macrocall$1", "symbols": ["matchAs$macrocall$1$macrocall$1"] },
        { "name": "matchAs$macrocall$4", "symbols": [{ "literal": "as" }] },
        { "name": "matchAs$macrocall$3$macrocall$2", "symbols": ["matchAs$macrocall$4"] },
        { "name": "matchAs$macrocall$3$macrocall$1", "symbols": ["matchAs$macrocall$3$macrocall$2"], "postprocess": id },
        { "name": "matchAs$macrocall$3$macrocall$1", "symbols": ["matchAs$macrocall$3$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matchAs$macrocall$3", "symbols": ["matchAs$macrocall$3$macrocall$1"] },
        { "name": "matchAs", "symbols": ["matchAs$macrocall$1", "expr", "matchAs$macrocall$3", "matches"], "postprocess": ([, e, , σ]) => Expr_1.Expr.matchAs(e, σ)(Versioned_1.ν()) },
        { "name": "matches", "symbols": ["match"], "postprocess": id },
        { "name": "matches$macrocall$2", "symbols": [{ "literal": "{" }] },
        { "name": "matches$macrocall$1", "symbols": ["matches$macrocall$2"], "postprocess": id },
        { "name": "matches$macrocall$1", "symbols": ["matches$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matches$ebnf$1", "symbols": [] },
        { "name": "matches$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "matches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["matches$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "matches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["matches$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matches$ebnf$1$subexpression$1", "symbols": ["matches$ebnf$1$subexpression$1$macrocall$1", "match"], "postprocess": ([, m]) => m },
        { "name": "matches$ebnf$1", "symbols": ["matches$ebnf$1", "matches$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "matches$macrocall$4", "symbols": [{ "literal": "}" }] },
        { "name": "matches$macrocall$3", "symbols": ["matches$macrocall$4"], "postprocess": id },
        { "name": "matches$macrocall$3", "symbols": ["matches$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "matches", "symbols": ["matches$macrocall$1", "match", "matches$ebnf$1", "matches$macrocall$3"], "postprocess": ([, m, ms,]) => [m, ...ms].reduce(Match_1.DataElim.join) },
        { "name": "match$macrocall$2", "symbols": [{ "literal": "→" }] },
        { "name": "match$macrocall$1", "symbols": ["match$macrocall$2"], "postprocess": id },
        { "name": "match$macrocall$1", "symbols": ["match$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "match", "symbols": ["pattern", "match$macrocall$1", "expr"], "postprocess": ([mk_κ, , e]) => mk_κ(e) },
        { "name": "match", "symbols": ["pattern", "matches"], "postprocess": ([mk_κ1, σ]) => mk_κ1(Expr_1.Expr.fun(σ)(Versioned_1.ν())) },
        { "name": "typeMatches", "symbols": ["typeMatch"], "postprocess": id },
        { "name": "typeMatches$macrocall$2", "symbols": [{ "literal": "{" }] },
        { "name": "typeMatches$macrocall$1", "symbols": ["typeMatches$macrocall$2"], "postprocess": id },
        { "name": "typeMatches$macrocall$1", "symbols": ["typeMatches$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatches$ebnf$1", "symbols": [] },
        { "name": "typeMatches$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "typeMatches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["typeMatches$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "typeMatches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["typeMatches$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatches$ebnf$1$subexpression$1", "symbols": ["typeMatches$ebnf$1$subexpression$1$macrocall$1", "typeMatch"], "postprocess": ([, m]) => m },
        { "name": "typeMatches$ebnf$1", "symbols": ["typeMatches$ebnf$1", "typeMatches$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "typeMatches$macrocall$4", "symbols": [{ "literal": "}" }] },
        { "name": "typeMatches$macrocall$3", "symbols": ["typeMatches$macrocall$4"], "postprocess": id },
        { "name": "typeMatches$macrocall$3", "symbols": ["typeMatches$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatches", "symbols": ["typeMatches$macrocall$1", "typeMatch", "typeMatches$ebnf$1", "typeMatches$macrocall$3"], "postprocess": ([, m, ms,]) => [m, ...ms].reduce((m1, m2) => FiniteMap_1.unionWith(m1, m2, (e, eʹ) => Core_1.userError("Overlapping typecase branches."))) },
        { "name": "typeMatch$macrocall$2", "symbols": [{ "literal": "→" }] },
        { "name": "typeMatch$macrocall$1", "symbols": ["typeMatch$macrocall$2"], "postprocess": id },
        { "name": "typeMatch$macrocall$1", "symbols": ["typeMatch$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatch", "symbols": ["typename", "typeMatch$macrocall$1", "expr"], "postprocess": ([x, , e]) => {
                Core_1.assert(x instanceof Value_1.Str);
                if (!DataType_1.types.has(x.val)) {
                    Core_1.userError(`Type name ${x.val} not found.`);
                }
                return FiniteMap_1.singleton(x, e);
            } },
        { "name": "typename$macrocall$2", "symbols": [(lexer.has("ident") ? { type: "ident" } : ident)] },
        { "name": "typename$macrocall$1", "symbols": ["typename$macrocall$2"], "postprocess": id },
        { "name": "typename$macrocall$1", "symbols": ["typename$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typename", "symbols": ["typename$macrocall$1"], "postprocess": ([[x]]) => Versioned_1.str(x.value)(Versioned_1.ν()) },
        { "name": "listOpt", "symbols": [], "postprocess": () => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Nil))(Versioned_1.ν()) },
        { "name": "listOpt$ebnf$1", "symbols": [] },
        { "name": "listOpt$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "listOpt$ebnf$1$subexpression$1$macrocall$1", "symbols": ["listOpt$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "listOpt$ebnf$1$subexpression$1$macrocall$1", "symbols": ["listOpt$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "listOpt$ebnf$1$subexpression$1", "symbols": ["listOpt$ebnf$1$subexpression$1$macrocall$1", "expr"], "postprocess": ([, e]) => e },
        { "name": "listOpt$ebnf$1", "symbols": ["listOpt$ebnf$1", "listOpt$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "listOpt", "symbols": ["expr", "listOpt$ebnf$1", "listRestOpt"], "postprocess": ([e, es, eʹ]) => [e, ...es, eʹ].reverse().reduce((e̅, e) => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Cons), e, e̅)(Versioned_1.ν())) },
        { "name": "listRestOpt", "symbols": [], "postprocess": () => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Nil))(Versioned_1.ν()) },
        { "name": "listRestOpt$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "listRestOpt$macrocall$1", "symbols": ["listRestOpt$macrocall$2"], "postprocess": id },
        { "name": "listRestOpt$macrocall$1", "symbols": ["listRestOpt$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt$macrocall$4", "symbols": [{ "literal": "..." }] },
        { "name": "listRestOpt$macrocall$3", "symbols": ["listRestOpt$macrocall$4"], "postprocess": id },
        { "name": "listRestOpt$macrocall$3", "symbols": ["listRestOpt$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt", "symbols": ["listRestOpt$macrocall$1", "listRestOpt$macrocall$3", "expr"], "postprocess": ([, , e]) => e },
        { "name": "pattern", "symbols": ["variable_pattern"], "postprocess": id },
        { "name": "pattern", "symbols": ["pair_pattern"], "postprocess": id },
        { "name": "pattern", "symbols": ["list_pattern"], "postprocess": id },
        { "name": "pattern", "symbols": ["constr_pattern"], "postprocess": id },
        { "name": "variable_pattern$macrocall$2", "symbols": [{ "literal": "_" }] },
        { "name": "variable_pattern$macrocall$1$macrocall$2", "symbols": ["variable_pattern$macrocall$2"] },
        { "name": "variable_pattern$macrocall$1$macrocall$1", "symbols": ["variable_pattern$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "variable_pattern$macrocall$1$macrocall$1", "symbols": ["variable_pattern$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "variable_pattern$macrocall$1", "symbols": ["variable_pattern$macrocall$1$macrocall$1"] },
        { "name": "variable_pattern", "symbols": ["variable_pattern$macrocall$1"], "postprocess": () => (κ) => Match_1.varElim(Versioned_1.str("_")(Versioned_1.ν()), κ)(Versioned_1.ν()) },
        { "name": "variable_pattern", "symbols": ["var"], "postprocess": ([x]) => (κ) => Match_1.varElim(x, κ)(Versioned_1.ν()) },
        { "name": "pair_pattern$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "pair_pattern$macrocall$1", "symbols": ["pair_pattern$macrocall$2"], "postprocess": id },
        { "name": "pair_pattern$macrocall$1", "symbols": ["pair_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "pair_pattern$macrocall$4", "symbols": [{ "literal": "," }] },
        { "name": "pair_pattern$macrocall$3", "symbols": ["pair_pattern$macrocall$4"], "postprocess": id },
        { "name": "pair_pattern$macrocall$3", "symbols": ["pair_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "pair_pattern$macrocall$6", "symbols": [{ "literal": ")" }] },
        { "name": "pair_pattern$macrocall$5", "symbols": ["pair_pattern$macrocall$6"], "postprocess": id },
        { "name": "pair_pattern$macrocall$5", "symbols": ["pair_pattern$macrocall$6", "_"], "postprocess": ([x,]) => x },
        { "name": "pair_pattern", "symbols": ["pair_pattern$macrocall$1", "pattern", "pair_pattern$macrocall$3", "pattern", "pair_pattern$macrocall$5"], "postprocess": ([, mk_κ1, , mk_κ2, ,]) => (κ) => Match_1.dataElim([BaseTypes_1.Pair.name, compose(mk_κ1, mk_κ2)(κ)])(Versioned_1.ν()) },
        { "name": "list_pattern$macrocall$2", "symbols": [{ "literal": "[" }] },
        { "name": "list_pattern$macrocall$1", "symbols": ["list_pattern$macrocall$2"], "postprocess": id },
        { "name": "list_pattern$macrocall$1", "symbols": ["list_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "list_pattern$macrocall$4", "symbols": [{ "literal": "]" }] },
        { "name": "list_pattern$macrocall$3", "symbols": ["list_pattern$macrocall$4"], "postprocess": id },
        { "name": "list_pattern$macrocall$3", "symbols": ["list_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "list_pattern", "symbols": ["list_pattern$macrocall$1", "listOpt_pattern", "list_pattern$macrocall$3"], "postprocess": ([, mk_κ,]) => mk_κ },
        { "name": "listOpt_pattern", "symbols": [], "postprocess": () => (κ) => Match_1.dataElim([BaseTypes_1.Nil.name, κ])(Versioned_1.ν()) },
        { "name": "listOpt_pattern", "symbols": ["list1_pattern"], "postprocess": id },
        { "name": "list1_pattern", "symbols": ["pattern", "listRestOpt_pattern"], "postprocess": ([mk_κ1, mk_κ2]) => (κ) => Match_1.dataElim([BaseTypes_1.Cons.name, compose(mk_κ1, mk_κ2)(κ)])(Versioned_1.ν()) },
        { "name": "listRestOpt_pattern", "symbols": [], "postprocess": () => (κ) => Match_1.dataElim([BaseTypes_1.Nil.name, κ])(Versioned_1.ν()) },
        { "name": "listRestOpt_pattern$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "listRestOpt_pattern$macrocall$1", "symbols": ["listRestOpt_pattern$macrocall$2"], "postprocess": id },
        { "name": "listRestOpt_pattern$macrocall$1", "symbols": ["listRestOpt_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt_pattern$macrocall$4", "symbols": [{ "literal": "..." }] },
        { "name": "listRestOpt_pattern$macrocall$3", "symbols": ["listRestOpt_pattern$macrocall$4"], "postprocess": id },
        { "name": "listRestOpt_pattern$macrocall$3", "symbols": ["listRestOpt_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt_pattern", "symbols": ["listRestOpt_pattern$macrocall$1", "listRestOpt_pattern$macrocall$3", "pattern"], "postprocess": ([, , mk_κ]) => mk_κ },
        { "name": "listRestOpt_pattern$macrocall$6", "symbols": [{ "literal": "," }] },
        { "name": "listRestOpt_pattern$macrocall$5", "symbols": ["listRestOpt_pattern$macrocall$6"], "postprocess": id },
        { "name": "listRestOpt_pattern$macrocall$5", "symbols": ["listRestOpt_pattern$macrocall$6", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt_pattern", "symbols": ["listRestOpt_pattern$macrocall$5", "list1_pattern"], "postprocess": ([, mk_κ]) => mk_κ },
        { "name": "constr_pattern", "symbols": ["ctr", "args_pattern"], "postprocess": ([c, mk_κs], _, reject) => {
                Core_1.assert(c instanceof Value_1.Str);
                if (DataType_1.ctrFor(c.val).arity !== mk_κs.length) {
                    return reject;
                }
                return (κ) => Match_1.dataElim([c.val, mk_κs.reduce(compose, (κ) => κ)(κ)])(Versioned_1.ν());
            } },
        { "name": "args_pattern", "symbols": [], "postprocess": () => [] },
        { "name": "args_pattern$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "args_pattern$macrocall$1", "symbols": ["args_pattern$macrocall$2"], "postprocess": id },
        { "name": "args_pattern$macrocall$1", "symbols": ["args_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args_pattern$ebnf$1", "symbols": [] },
        { "name": "args_pattern$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "args_pattern$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args_pattern$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "args_pattern$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args_pattern$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args_pattern$ebnf$1$subexpression$1", "symbols": ["args_pattern$ebnf$1$subexpression$1$macrocall$1", "pattern"], "postprocess": ([, mk_κ]) => mk_κ },
        { "name": "args_pattern$ebnf$1", "symbols": ["args_pattern$ebnf$1", "args_pattern$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "args_pattern$macrocall$4", "symbols": [{ "literal": ")" }] },
        { "name": "args_pattern$macrocall$3", "symbols": ["args_pattern$macrocall$4"], "postprocess": id },
        { "name": "args_pattern$macrocall$3", "symbols": ["args_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "args_pattern", "symbols": ["args_pattern$macrocall$1", "pattern", "args_pattern$ebnf$1", "args_pattern$macrocall$3"], "postprocess": ([, mk_κ, mk_κs,]) => [mk_κ, ...mk_κs] },
        { "name": "compareOp$macrocall$2", "symbols": [(lexer.has("compareOp") ? { type: "compareOp" } : compareOp)] },
        { "name": "compareOp$macrocall$1", "symbols": ["compareOp$macrocall$2"], "postprocess": id },
        { "name": "compareOp$macrocall$1", "symbols": ["compareOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "compareOp", "symbols": ["compareOp$macrocall$1"], "postprocess": ([[x]]) => x.value },
        { "name": "exponentOp$macrocall$2", "symbols": [(lexer.has("exponentOp") ? { type: "exponentOp" } : exponentOp)] },
        { "name": "exponentOp$macrocall$1", "symbols": ["exponentOp$macrocall$2"], "postprocess": id },
        { "name": "exponentOp$macrocall$1", "symbols": ["exponentOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "exponentOp", "symbols": ["exponentOp$macrocall$1"], "postprocess": ([[x]]) => x.value },
        { "name": "productOp$macrocall$2", "symbols": [(lexer.has("productOp") ? { type: "productOp" } : productOp)] },
        { "name": "productOp$macrocall$1", "symbols": ["productOp$macrocall$2"], "postprocess": id },
        { "name": "productOp$macrocall$1", "symbols": ["productOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "productOp", "symbols": ["productOp$macrocall$1"], "postprocess": ([[x]]) => x.value },
        { "name": "sumOp$macrocall$2", "symbols": [(lexer.has("sumOp") ? { type: "sumOp" } : sumOp)] },
        { "name": "sumOp$macrocall$1", "symbols": ["sumOp$macrocall$2"], "postprocess": id },
        { "name": "sumOp$macrocall$1", "symbols": ["sumOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "sumOp", "symbols": ["sumOp$macrocall$1"], "postprocess": ([[x]]) => x.value }
    ],
    ParserStart: "rootExpr",
};
exports.default = grammar;


/***/ }),

/***/ "./src/Primitive.ts":
/*!**************************!*\
  !*** ./src/Primitive.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// In the following two classes, we store the operation without generic type parameters, as fields can't
// have polymorphic type. Then access the operation via a method and reinstate the polymorphism via a cast.
class PrimOp extends Value_1.Value {
    constructor() {
        super(...arguments);
        this.name = Value_1._;
    }
}
exports.PrimOp = PrimOp;
class UnaryOp extends PrimOp {
    constructor() {
        super(...arguments);
        this.op = Value_1._;
    }
}
exports.UnaryOp = UnaryOp;
class BinaryOp extends PrimOp {
    constructor() {
        super(...arguments);
        this.op = Value_1._;
    }
}
exports.BinaryOp = BinaryOp;
const ceiling = x => Versioned_1.num(Math.ceil(x.val));
// Used to take arbitrary value as additional argument, but now primitives have primitive arguments.
const debugLog = v => (k) => {
    console.log(v);
    return v;
};
const floor = x => Versioned_1.num(Math.floor(x.val));
const log = x => Versioned_1.num(Math.log(Core_1.as(x, Value_1.Num).val));
const numToStr = x => Versioned_1.str(x.val.toString());
// No longer support overloaded functions, since the pattern-matching semantics is non-trivial; might require typecase.
// If we want integer division, apparently ~~(x / y) will round in the right direction.
const div = (x, y) => (k) => {
    const n = Versioned_1.num(Core_1.as(x, Value_1.Num).val / Core_1.as(y, Value_1.Num).val)(k);
    if (!isFinite(n.val)) {
        Core_1.userError("Division by zero", x, y);
    }
    return n;
};
const concat = (x, y) => Versioned_1.str(Core_1.as(x, Value_1.Str).val + Core_1.as(y, Value_1.Str).val);
const equal = (x, y) => {
    if (x instanceof Value_1.Num && y instanceof Value_1.Num) {
        return x.val === y.val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else if (x instanceof Value_1.Str && y instanceof Value_1.Str) {
        return x.val === y.val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else {
        return Core_1.userError(`Expected ${Value_1.Num.name} or ${Value_1.Str.name}.`);
    }
};
const error = message => Core_1.assert(false, "Fluid error:\n" + message.val);
const greaterEq = (x, y) => {
    if (x instanceof Value_1.Num && y instanceof Value_1.Num) {
        return x.val >= y.val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else if (x instanceof Value_1.Str && y instanceof Value_1.Str) {
        // string comparison delegates to central implementation for consistency
        return x.geq(y) ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else {
        return Core_1.userError(`Expected ${Value_1.Num.name} or ${Value_1.Str.name}.`);
    }
};
const greater = (x, y) => Core_1.as(x, Value_1.Num).val > Core_1.as(y, Value_1.Num).val ? BaseTypes_1.true_() : BaseTypes_1.false_();
const lessEq = (x, y) => {
    if (x instanceof Value_1.Num && y instanceof Value_1.Num) {
        return Core_1.as(x, Value_1.Num).val <= Core_1.as(y, Value_1.Num).val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else if (x instanceof Value_1.Str && y instanceof Value_1.Str) {
        return x.leq(y) ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else {
        return Core_1.userError(`Expected ${Value_1.Num.name} or ${Value_1.Str.name}.`);
    }
};
const less = (x, y) => Core_1.as(x, Value_1.Num).val < Core_1.as(y, Value_1.Num).val ? BaseTypes_1.true_() : BaseTypes_1.false_();
const minus = (x, y) => Versioned_1.num(Core_1.as(x, Value_1.Num).val - Core_1.as(y, Value_1.Num).val);
const plus = (x, y) => Versioned_1.num(Core_1.as(x, Value_1.Num).val + Core_1.as(y, Value_1.Num).val);
const pow = (x, y) => Versioned_1.num(Math.pow(Core_1.as(x, Value_1.Num).val, Core_1.as(y, Value_1.Num).val));
const times = (x, y) => Versioned_1.num(Core_1.as(x, Value_1.Num).val * Core_1.as(y, Value_1.Num).val);
// Convenience methods for building the maps. Export to allow other modules to provide operations.
function unary_(op) {
    return DataValue_1.explValue(Expl_1.Expl.const_()(Versioned_1.ν()), Versioned_1.at(UnaryOp, op.name, op)(Versioned_1.ν()));
}
exports.unary_ = unary_;
function binary_(op) {
    return DataValue_1.explValue(Expl_1.Expl.const_()(Versioned_1.ν()), Versioned_1.at(BinaryOp, op.name, op)(Versioned_1.ν()));
}
exports.binary_ = binary_;
// Primitives with identifiers as names are unary and first-class.
exports.unaryOps = new Map([
    [ceiling.name, unary_(ceiling)],
    [debugLog.name, unary_(debugLog)],
    [error.name, unary_(error)],
    [floor.name, unary_(floor)],
    [log.name, unary_(log)],
    [numToStr.name, unary_(numToStr)]
]);
exports.binaryOps = new Map([
    ["-", binary_(minus)],
    ["+", binary_(plus)],
    ["*", binary_(times)],
    ["**", binary_(pow)],
    ["/", binary_(div)],
    ["==", binary_(equal)],
    [">", binary_(greater)],
    [">=", binary_(greaterEq)],
    ["<", binary_(less)],
    ["<=", binary_(lessEq)],
    ["++", binary_(concat)]
]);


/***/ }),

/***/ "./src/Value.ts":
/*!**********************!*\
  !*** ./src/Value.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
// Use to initialise fields for reflection, without requiring constructors.
exports._ = undefined;
// Value in the metalanguage.
class Value {
    __child(k) {
        return this[k];
    }
    // Probably confusingly, "children" isn't a user-level notion; specifically, wrappers
    // like Num and Str have children which are not observable through pattern-matching.
    get __children() {
        return fields(this).map(k => this.__child(k));
    }
}
exports.Value = Value;
// Address or location of persistent object.
class Id extends Value {
    tag(tag) {
        return taggedId(this, tag);
    }
}
exports.Id = Id;
class FunctionId extends Id {
    constructor() {
        super(...arguments);
        this.f = exports._;
    }
}
function functionId(f) {
    return make(FunctionId, f);
}
class ApplicationId extends Id {
    constructor() {
        super(...arguments);
        this.k = exports._;
        this.v = exports._;
    }
}
exports.ApplicationId = ApplicationId;
function applicationId(k, v) {
    return make(ApplicationId, k, v);
}
class TaggedId extends Id {
    constructor() {
        super(...arguments);
        this.k = exports._;
        this.prop = exports._;
    }
}
exports.TaggedId = TaggedId;
function taggedId(k, prop) {
    return make(TaggedId, k, prop);
}
function memoId(f, v̅) {
    const fʹ = functionId(f);
    let k = fʹ;
    for (let v of v̅) {
        k = applicationId(k, v);
    }
    return k;
}
exports.memoId = memoId;
function isPrim(v) {
    return v instanceof Num || v instanceof Str;
}
exports.isPrim = isPrim;
class Num extends Value {
    constructor() {
        super(...arguments);
        this.val = exports._;
    }
    toString() {
        return this.val.toString();
    }
}
exports.Num = Num;
class Str extends Value {
    constructor() {
        super(...arguments);
        this.val = exports._;
    }
    toString() {
        return `"${this.val}"`;
    }
    leq(str) {
        return this.val.localeCompare(str.val) <= 0;
    }
    eq(str) {
        return this.val.localeCompare(str.val) === 0;
    }
    geq(str) {
        return this.val.localeCompare(str.val) >= 0;
    }
}
exports.Str = Str;
// Mergeable state deltas are disjoint.
function mergeInto(tgt, src) {
    Object.keys(src).forEach((prop) => {
        if (!tgt.hasOwnProperty(prop)) {
            tgt[prop] = src[prop];
        }
        else {
            Core_1.absurd(`Incompatible update of field "${prop}" at revision.`, tgt[prop], src[prop]);
        }
    });
}
exports.mergeInto = mergeInto;
// Hash-consed constructors are invariant across worlds.
const __ctrMemo = new Map;
function lookupArg(f, m, v̅, n) {
    // for memoisation purposes, treat f's key as argument -1
    const k = n === -1 ? f.key : v̅[n];
    let v = m.get(k);
    if (v === undefined) {
        if (n === v̅.length - 1) {
            v = f.call(v̅);
            v = v; // TS confused; thinks v can be undefined here
        }
        else {
            v = new Map;
        }
        m.set(k, v);
    }
    return v;
}
class MemoCtr {
    constructor(C) {
        this.C = C;
    }
    get key() {
        return this.C;
    }
    call(v̅) {
        const v = new this.C;
        construct(false, v, v̅);
        Object.freeze(v);
        return v;
    }
}
function memoCall(memo, f, v̅) {
    let v = lookupArg(f, memo, v̅, -1);
    for (let n = 0; n < v̅.length; ++n) {
        // since there are more arguments, the last v was a (possibly nested) map
        v = lookupArg(f, v, v̅, n);
    }
    return v;
}
exports.memoCall = memoCall;
// Experimented with dictionary-based construction pattern; eliminates field order mismatch as a possible
// source of error, but the benefit is very small and doesn't really suit the memoisation pattern.
function make(C, ...v̅) {
    return memoCall(__ctrMemo, new MemoCtr(C), v̅);
}
exports.make = make;
// Depends heavily on (1) getOwnPropertyNames() returning fields in definition-order; and (2)
// constructor functions supplying arguments in the same order.
function construct(compare, tgt, v̅) {
    const f̅ = fields(tgt), ẟ = compare ? {} : null;
    Core_1.assert(f̅.length === v̅.length);
    let n = 0;
    f̅.forEach((prop) => {
        const src = v̅[n++];
        if (compare && tgt.__child(prop) !== src) {
            ẟ[prop] = { before: tgt.__child(prop), after: src };
        }
        tgt[prop] = src;
    });
    return ẟ;
}
exports.construct = construct;
// Exclude metadata according to our convention.
function isField(prop) {
    return !prop.startsWith("__");
}
exports.isField = isField;
function fields(v) {
    return Object.getOwnPropertyNames(v).filter(isField);
}
exports.fields = fields;
function metadataFields(v) {
    return Object.getOwnPropertyNames(v).filter(f => !isField(f) && f !== "__id");
}
exports.metadataFields = metadataFields;


/***/ }),

/***/ "./src/Versioned.ts":
/*!**************************!*\
  !*** ./src/Versioned.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Delta_1 = __webpack_require__(/*! ./Delta */ "./src/Delta.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
function versioned(v) {
    return v.__id !== undefined;
}
exports.versioned = versioned;
function asVersioned(v) {
    if (versioned(v)) {
        return v;
    }
    else {
        return Core_1.assert(false, `${v} is not versioned.`);
    }
}
exports.asVersioned = asVersioned;
const __versioned = new Map();
const __reachable = new Set(); // subset of __versioned reachable at current revision
// The (possibly already extant) versioned object uniquely identified by a memo-key. As an idempotent side-effect,
// record how the object differs from its previous version. External nodes are always created fresh.
function at(C, ...v̅) {
    return (k) => {
        let v = __versioned.get(k);
        if (v === undefined) {
            const v = create(C, ...v̅)(k);
            if (!(k instanceof Extern)) {
                __versioned.set(k, v);
                __reachable.add(v);
            }
            return v;
        }
        else {
            Core_1.assert(!(k instanceof Extern));
            __reachable.add(v);
            reset(v, C, ...v̅);
            return v;
        }
    };
}
exports.at = at;
function create(C, ...v̅) {
    return (k) => {
        const v = new C;
        Object.defineProperty(v, "__id", {
            value: k,
            enumerable: false
        });
        Object.defineProperty(v, "__ẟ", {
            // The delta map is partial; the absence of an entry is equivalent to an empty delta. This allows
            // deltas to be cleared simply by removing all entries from the map.
            get: function () {
                let ẟ = Delta_1.__deltas.ẟ̅.get(this);
                if (ẟ === undefined) {
                    ẟ = new Delta_1.Change({});
                    Delta_1.__deltas.ẟ̅.set(this, ẟ);
                    return ẟ;
                }
                else {
                    return ẟ;
                }
            },
            enumerable: false
        });
        Value_1.construct(false, v, v̅);
        Delta_1.__deltas.created(v);
        return v;
    };
}
exports.create = create;
function reset(v, C, ...v̅) {
    if (v instanceof C) {
        Delta_1.__deltas.changed(v, Value_1.construct(true, v, v̅));
    }
    else {
        reclassify(v, C);
        Value_1.construct(false, v, v̅);
        Delta_1.__deltas.reclassified(v);
    }
}
exports.reset = reset;
// Should emulate the post-state of "new C". Probably need to worry about how this works with inherited properties.
function reclassify(v, ctr) {
    const proto = Object.getPrototypeOf(new ctr);
    Core_1.assert(Object.getPrototypeOf(v) !== proto);
    for (const k of Value_1.fields(v)) {
        Core_1.assert(delete v[k]);
    }
    Object.setPrototypeOf(v, proto);
}
// A memo key which is sourced externally to the system. (The name "External" is already taken.)
class Extern extends Value_1.Id {
    constructor() {
        super(...arguments);
        this.id = Value_1._;
    }
}
exports.Extern = Extern;
function extern(id) {
    return Value_1.make(Extern, id);
}
// Fresh keys represent inputs to the system, e.g. addresses of syntax nodes provided by an external structure editor.
exports.ν = (() => {
    let count = 0;
    return () => {
        return extern(count++);
    };
})();
function num(val) {
    return at(Value_1.Num, val);
}
exports.num = num;
function str(val) {
    return at(Value_1.Str, val);
}
exports.str = str;
const __funMemo = new Map;
// Should clear memo table at each revision, but there are no memo-functions at the moment.
function newRevision() {
    Delta_1.__deltas.clear();
    __versioned.forEach((v, k) => {
        if (!__reachable.has(v)) {
            __versioned.delete(k);
        }
    });
    __reachable.clear();
}
exports.newRevision = newRevision;
class MemoFun {
    constructor(f) {
        this.f = f;
    }
    get key() {
        return this.f;
    }
    call(v̅) {
        return this.f.apply(null, v̅);
        // for an "instance" version where v̅[0] is "this", use:
        // return this.f.apply(v̅[0], v̅.slice(1))
    }
}
// Memoisation.
function memo(f, ...v̅) {
    return Value_1.memoCall(__funMemo, new MemoFun(f), v̅);
}
exports.memo = memo;


/***/ }),

/***/ "./src/app/AvenirLTStd-Book.woff":
/*!***************************************!*\
  !*** ./src/app/AvenirLTStd-Book.woff ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:font/woff;base64,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"

/***/ }),

/***/ "./src/app/Core.ts":
/*!*************************!*\
  !*** ./src/app/Core.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// First-class module.
class SVG {
    constructor() {
        this.hiddenMetricsElement = document.createElementNS(SVG.NS, "svg");
        this.hiddenMetricsElement.setAttribute("width", "0");
        this.hiddenMetricsElement.setAttribute("height", "0");
        this.hiddenMetricsElement.style.visibility = "hidden";
        document.body.appendChild(this.hiddenMetricsElement);
    }
    textWidth(text) {
        this.hiddenMetricsElement.appendChild(text);
        const width = text.getBBox().width;
        text.remove();
        return width;
    }
    textHeight(text) {
        this.hiddenMetricsElement.appendChild(text);
        const height = text.getBBox().height;
        text.remove();
        return height;
    }
}
exports.SVG = SVG;
SVG.NS = "http://www.w3.org/2000/svg";


/***/ }),

/***/ "./src/app/Cursor.ts":
/*!***************************!*\
  !*** ./src/app/Cursor.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ../../src/util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ../../src/util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ../../src/util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ../../src/Annotation */ "./src/Annotation.ts");
const BaseTypes_1 = __webpack_require__(/*! ../../src/BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ../../src/DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ../../src/DataValue */ "./src/DataValue.ts");
const Delta_1 = __webpack_require__(/*! ../../src/Delta */ "./src/Delta.ts");
const Expl_1 = __webpack_require__(/*! ../../src/Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ../../src/Expr */ "./src/Expr.ts");
const Match_1 = __webpack_require__(/*! ../../src/Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ../../src/Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ../../src/Versioned */ "./src/Versioned.ts");
var Let = Expr_1.Expr.Let;
var LetRec = Expr_1.Expr.LetRec;
var Prim = Expr_1.Expr.Prim;
class Cursor {
    notAnnotated() {
        return Core_1.userError("Not an annotated node.", this.on);
    }
    assert(C, pred) {
        return this.at(C, v => Core_1.assert(pred(v)));
    }
    αset() {
        if (Annotation_1.annotated(this.on)) {
            Core_1.assert(Annotation_1.isα(this.on) === Lattice_1.bool_.top);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    αclear() {
        if (Annotation_1.annotated(this.on)) {
            Core_1.assert(Annotation_1.isα(this.on) === Lattice_1.bool_.bot);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    setα() {
        if (Annotation_1.annotated(this.on)) {
            Annotation_1.setα(Lattice_1.bool_.top, this.on);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    clearα() {
        if (Annotation_1.annotated(this.on)) {
            Annotation_1.setα(Lattice_1.bool_.bot, this.on);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    // Helpers specific to certain datatypes.
    treeNodeValue() {
        return this.to(BaseTypes_1.NonEmpty, "t")
            .to(BaseTypes_1.Pair, "snd");
    }
    nth(n) {
        if (n === 0) {
            return this.to(BaseTypes_1.Cons, "head");
        }
        else {
            return this.to(BaseTypes_1.Cons, "tail").nth(n - 1);
        }
    }
}
exports.Cursor = Cursor;
class ExplValueCursor extends Cursor {
    constructor(ancestors, tv) {
        super();
        this.ancestors = ancestors;
        this.tv = tv;
    }
    static descendant(prev, tv) {
        return new ExplValueCursor(prev === null ? [] : [...prev.ancestors, prev.tv], tv);
    }
    static parent(child) {
        Core_1.assert(child.ancestors.length > 0);
        return new ExplValueCursor(child.ancestors.slice(0, child.ancestors.length - 1), Array_1.last(child.ancestors));
    }
    get on() {
        return this.tv;
    }
    to(C, k) {
        return ExplValueCursor.descendant(this, Expl_1.Expl.explChild(this.tv.t, Core_1.as(this.tv.v, C), k));
    }
    toChild(n) {
        if (this.tv.v instanceof DataValue_1.DataValue) {
            const tvs = Expl_1.Expl.explChildren(this.tv.t, this.tv.v);
            if (0 <= n && n < tvs.length) {
                return ExplValueCursor.descendant(this, Array_1.nth(tvs, n));
            }
            else {
                return this;
            }
        }
        else {
            return Core_1.userError("Not a data value");
        }
    }
    toChildOffset(tv, offset) {
        if (this.tv.v instanceof DataValue_1.DataValue) {
            const tvs = Expl_1.Expl.explChildren(this.tv.t, this.tv.v);
            const n = tvs.findIndex(tv_ => tv_ === tv);
            if (n === -1) {
                return Core_1.userError("Not a child");
            }
            else {
                return this.toChild(n + offset);
            }
        }
        else {
            return Core_1.userError("Not a data value");
        }
    }
    nextSibling() {
        if (this.hasParent()) {
            return this.up().toChildOffset(this.tv, 1);
        }
        else {
            return this;
        }
    }
    prevSibling() {
        if (this.hasParent()) {
            return this.up().toChildOffset(this.tv, -1);
        }
        else {
            return this;
        }
    }
    hasParent() {
        return this.ancestors.length > 0;
    }
    up() {
        return ExplValueCursor.parent(this);
    }
    toBinaryArg1(opName) {
        const t = Core_1.as(this.tv.t, Expl_1.Expl.BinaryApp);
        Core_1.assert(t.opName.val === opName);
        return ExplValueCursor.descendant(this, t.tv1);
    }
    toBinaryArg2(opName) {
        const t = Core_1.as(this.tv.t, Expl_1.Expl.BinaryApp);
        Core_1.assert(t.opName.val === opName);
        return ExplValueCursor.descendant(this, t.tv2);
    }
    at(C, f) {
        f(Core_1.as(this.tv.v, C));
        return this;
    }
    isChanged(s_ẟ) {
        Core_1.assert(Versioned_1.asVersioned(this.tv.v).__ẟ.eq(new Delta_1.Change(s_ẟ)));
        return this;
    }
    isUnchanged() {
        Core_1.assert(Versioned_1.asVersioned(this.tv.v).__ẟ.eq(new Delta_1.Change({})));
        return this;
    }
    isNew() {
        Core_1.assert(Versioned_1.asVersioned(this.tv.v).__ẟ instanceof Delta_1.New);
        return this;
    }
    toTerminal() {
        let t = this.tv.t;
        while (t instanceof Expl_1.Expl.NonTerminal) {
            t = t.t;
        }
        return ExplValueCursor.descendant(this, DataValue_1.explValue(t, this.tv.v));
    }
}
exports.ExplValueCursor = ExplValueCursor;
class ExprCursor extends Cursor {
    constructor(v) {
        super();
        this.v = v;
    }
    get on() {
        return this.v;
    }
    // No way to specify only "own" properties statically.
    to(C, prop) {
        const vʹ = Core_1.as(this.v, C)[prop]; // TypeScript nonsense
        return new ExprCursor(vʹ);
    }
    // Allow the data value class to be used to navigate the data expression form.
    constr_to(C, prop) {
        return this.to(DataType_1.exprClass(C), prop);
    }
    toCase(C) {
        const vʹ = Core_1.__nonNull(Core_1.as(this.v, Match_1.DataElim)[C.name]);
        return new ExprCursor(vʹ);
    }
    static defs(defs) {
        const defsʹ = new Map;
        for (; BaseTypes_1.Cons.is(defs); defs = defs.tail) {
            const def = defs.head;
            if (def instanceof Let || def instanceof Prim) {
                defsʹ.set(def.x.val, def);
            }
            else if (def instanceof LetRec) {
                for (let recDefs = def.δ; BaseTypes_1.Cons.is(recDefs); recDefs = recDefs.tail) {
                    const recDef = recDefs.head;
                    defsʹ.set(recDef.x.val, recDef);
                }
            }
            else {
                Core_1.absurd();
            }
        }
        return defsʹ;
    }
    toDef(x) {
        const here = this.to(Expr_1.Expr.Defs, "def̅"), defs = ExprCursor.defs(here.v);
        Core_1.assert(defs.has(x), `No definition of "${x}" found.`);
        return new ExprCursor(defs.get(x));
    }
    at(C, f) {
        f(Core_1.as(this.v, C));
        return this;
    }
    var_(x) {
        this.assert(Match_1.VarElim, σ => σ.x.val === x);
        return this.to(Match_1.VarElim, "κ");
    }
    // Editing API.
    setNum(n) {
        Versioned_1.reset(this.v, Value_1.Num, n);
        return this;
    }
    setStr(str_) {
        Versioned_1.reset(this.v, Value_1.Str, str_);
        return this;
    }
    constr_splice(C, props, makeNode) {
        return this.splice(DataType_1.exprClass(C), props, (e̅) => makeNode(e̅.map(e => Core_1.as(e, Expr_1.Expr.Expr))));
    }
    splice(C, props, makeNode) {
        const v = Core_1.as(this.v, C), v̅ = v.__children, n̅ = props.map(prop => Core_1.__check(Value_1.fields(v).indexOf(prop), n => n != -1)), v̅ʹ = makeNode(n̅.map((n) => v̅[n]));
        n̅.forEach((n, m) => {
            v̅[n] = v̅ʹ[m];
        });
        Versioned_1.reset(v, C, ...v̅);
        return this;
    }
}
exports.ExprCursor = ExprCursor;


/***/ }),

/***/ "./src/app/GraphicsRenderer.ts":
/*!*************************************!*\
  !*** ./src/app/GraphicsRenderer.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ../util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ../BaseTypes */ "./src/BaseTypes.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Primitive_1 = __webpack_require__(/*! ../Primitive */ "./src/Primitive.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Core_2 = __webpack_require__(/*! ./Core */ "./src/app/Core.ts");
const Cursor_1 = __webpack_require__(/*! ./Cursor */ "./src/app/Cursor.ts");
const Interactor_1 = __webpack_require__(/*! ./Interactor */ "./src/app/Interactor.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
const fontSize = 12;
exports.svg = new Core_2.SVG();
function scale(x_scale, y_scale) {
    return ([x, y]) => {
        return [x * x_scale, y * y_scale];
    };
}
function translate(x_inc, y_inc) {
    return ([x, y]) => {
        return [x + x_inc, y + y_inc];
    };
}
function invertScale(scale) {
    return ([x, y]) => {
        const [x_scale, y_scale] = scale([1, 1]);
        return [x / x_scale, y / y_scale];
    };
}
function transformFun(t) {
    if (t instanceof Graphics_1.Scale) {
        Core_1.assert(t.x.val >= 0 && t.y.val >= 0);
        return scale(t.x.val, t.y.val);
    }
    else if (t instanceof Graphics_1.Translate) {
        Core_1.assert(isFinite(t.x.val) && isFinite(t.y.val));
        return translate(t.x.val, t.y.val);
    }
    else {
        return Core_1.absurd();
    }
}
function postcompose(f1, f2) {
    return ([x, y]) => {
        return f1(f2([x, y]));
    };
}
class GraphicsRenderer {
    // transform attribute isn't supported on SVGElement, so it contains a group element with the inversion transform.
    constructor(editor, root, initialAncestor) {
        this.showInvisible = false;
        this.editor = editor;
        this.root = root;
        this.ancestors = [initialAncestor];
        this.translations = [Core_1.id];
        this.scalings = [Core_1.id];
    }
    get current() {
        return this.ancestors[this.ancestors.length - 1];
    }
    // scaling applies to translated coordinates
    get transform() {
        return postcompose(this.scale, Array_1.last(this.translations));
    }
    get scale() {
        return Array_1.last(this.scalings);
    }
    render(tg, [w, h]) {
        Core_1.assert(this.ancestors.length === 1);
        const root = this.current;
        while (root.firstChild !== null) {
            root.removeChild(root.firstChild);
        }
        const width = parseFloat(Core_1.__nonNull(root.getAttribute("width")));
        const height = parseFloat(Core_1.__nonNull(root.getAttribute("height")));
        this.withLocalFrame(scale(width / w, height / h), Core_1.id, () => {
            this.renderElement(Cursor_1.ExplValueCursor.descendant(null, tg));
        });
    }
    renderElement(tg /*<GraphicsElement>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.GraphicsElement);
        if (g instanceof Graphics_1.Circle) {
            return this.circle(tg);
        }
        else if (g instanceof Graphics_1.Group) {
            return this.group(tg);
        }
        else if (g instanceof Graphics_1.Line) {
            return this.line(tg);
        }
        else if (g instanceof Graphics_1.Polyline) {
            return this.polyline(tg);
        }
        else if (g instanceof Graphics_1.Polymarkers) {
            return this.polymarkers(tg);
        }
        else if (g instanceof Graphics_1.Rect) {
            return this.rect(tg);
        }
        else if (g instanceof Graphics_1.Text) {
            return this.text(tg);
        }
        else if (g instanceof Graphics_1.Viewport) {
            return this.viewport(tg);
        }
        else {
            return Core_1.absurd();
        }
    }
    // Scalings accumulate as we go down. Translations don't, because we use nested SVGs.
    withLocalFrame(scale, translate, localRender) {
        let result;
        this.scalings.push(postcompose(Array_1.last(this.scalings), scale));
        this.translations.push(translate);
        result = localRender();
        this.translations.pop();
        this.scalings.pop();
        return result;
    }
    // Scale circle by product of x, y scaling factors to maintain ratio of area to fixed rectangle as an invariant.
    circle(tg /*<Rect>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Circle);
        const [x, y] = this.transform([g.x.val, g.y.val]);
        const [x_scale, y_scale] = this.scale([1, 1]);
        const r = Renderer_1.circle(x, y, g.radius.val * x_scale * y_scale, "none", g.fill.val, this.circle);
        this.current.appendChild(r);
        return r;
    }
    group(tg /*<Group>*/) {
        const g = Renderer_1.group();
        this.current.appendChild(g);
        this.ancestors.push(g);
        for (let tg̅ = tg.to(Graphics_1.Group, "gs"); BaseTypes_1.Cons.is(Core_1.as(tg̅.tv.v, BaseTypes_1.List)); tg̅ = tg̅.to(BaseTypes_1.Cons, "tail")) {
            this.renderElement(tg̅.to(BaseTypes_1.Cons, "head"));
        }
        this.ancestors.pop();
        return g;
    }
    // For line/polyline, each point is considered a "child", and therefore subject to my local scaling.
    line(tg /*<Polyline>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Line);
        const [[x1, y1], [x2, y2]] = [
            this.transform([g.p1.x.val, g.p1.y.val]),
            this.transform([g.p2.x.val, g.p2.y.val])
        ];
        const l = Renderer_1.lineRounded(x1, y1, x2, y2, g.stroke.val, g.strokeWidth.val);
        this.current.appendChild(l);
        return l;
    }
    polyline(tg /*<Polyline>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Polyline);
        const ps = g.points.toArray().map((p) => {
            return this.transform([p.x.val, p.y.val]);
        });
        const l = Renderer_1.polyline(ps, g.stroke.val, g.strokeWidth.val);
        this.current.appendChild(l);
        return l;
    }
    // Polymarkers have coordinates relative to the points, in the *parent* scaling.
    polymarkers(tg /*<Polymarkers>*/) {
        const g = Renderer_1.group();
        this.current.appendChild(g);
        this.ancestors.push(g);
        const invScale = invertScale(this.scale);
        for (let tg̅ = tg.to(Graphics_1.Polymarkers, "markers"), tps = tg.to(Graphics_1.Polymarkers, "points"); BaseTypes_1.Cons.is(Core_1.as(tg̅.tv.v, BaseTypes_1.List)) || BaseTypes_1.Cons.is(Core_1.as(tps.tv.v, BaseTypes_1.List)); tg̅ = tg̅.to(BaseTypes_1.Cons, "tail"), tps = tps.to(BaseTypes_1.Cons, "tail")) {
            if (!BaseTypes_1.Cons.is(Core_1.as(tg̅.tv.v, BaseTypes_1.List)) || !BaseTypes_1.Cons.is(Core_1.as(tps.tv.v, BaseTypes_1.List))) {
                Core_1.userError(`${Graphics_1.Polymarkers.name}: more markers than points.`);
            }
            else {
                const tp = tps.to(BaseTypes_1.Cons, "head");
                const p = Core_1.as(tp.tv.v, Graphics_1.Point);
                const [x, y] = this.transform([p.x.val, p.y.val]);
                const markerViewport = Renderer_1.svgElement(true, x, y, 10, 10, false, this.polymarkers);
                this.current.appendChild(markerViewport);
                this.ancestors.push(markerViewport);
                this.withLocalFrame(invScale, Core_1.id, () => {
                    const marker = this.renderElement(tg̅.to(BaseTypes_1.Cons, "head"));
                    if (marker instanceof SVGCircleElement) {
                        new Interactor_1.PointInteractor(this.editor, tp, marker);
                    }
                });
                this.ancestors.pop();
            }
        }
        this.ancestors.pop();
        return g;
    }
    rect(tg /*<Rect>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Rect);
        const [x, y] = this.transform([g.x.val, g.y.val]);
        const [width, height] = this.scale([g.width.val, g.height.val]);
        Core_1.assert(width >= 0 && height >= 0);
        const r = Renderer_1.rect(x, y, width, height, "none", g.fill.val, this.rect);
        new Interactor_1.RectInteractor(this.editor, tg, r);
        this.current.appendChild(r);
        return r;
    }
    text(tg /*<Text>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Text), [x, y] = this.transform([g.x.val, g.y.val]), t = Renderer_1.textElement_graphical(x, y, fontSize, g.str.val);
        this.current.appendChild(t);
        t.setAttribute("fill", "black");
        t.setAttribute("text-anchor", `${g.anchor.val}`);
        t.setAttribute("alignment-baseline", `${g.baseline.val}`);
        return t;
    }
    viewport(tg /*<Viewport>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Viewport);
        // dimensions are relative to parent coordinate space, so not transformed by g's scaling
        const [x, y] = this.transform([g.x.val, g.y.val]);
        const [width, height] = this.scale([g.width.val, g.height.val]);
        Core_1.assert(width >= 0 && height >= 0);
        const outerSvg = Renderer_1.svgElement(false, x, y, width, height, false, this.viewport);
        if (g.fill.val !== "none") {
            outerSvg.appendChild(Renderer_1.rect(0, 0, width, height, "none", g.fill.val, this.viewport));
        }
        this.current.appendChild(outerSvg);
        if (this.showInvisible) {
            this.current.appendChild(Renderer_1.border(x, y, width, height, "gray", true));
        }
        this.ancestors.push(outerSvg);
        const margin = g.margin.val;
        const [widthʹ, heightʹ] = [Math.max(width - margin * 2), height - margin * 2];
        const innerScale = ([x, y]) => {
            return [x * widthʹ / width, y * heightʹ / height];
        };
        const innerViewport = Renderer_1.svgElement(true, margin, margin, widthʹ, heightʹ, false, this.viewport);
        this.current.appendChild(innerViewport);
        this.ancestors.push(innerViewport);
        this.withLocalFrame(postcompose(innerScale, transformFun(g.scale)), transformFun(g.translate), () => {
            this.renderElement(tg.to(Graphics_1.Viewport, "g"));
        });
        this.ancestors.pop();
        this.ancestors.pop();
        return outerSvg;
    }
    setMarkerMid(el, C, colour) {
        const markerId = Renderer_1.markerEnsureDefined(this.root, C, colour); // revisit cast
        el.setAttribute("marker-mid", `url(#${markerId})`);
    }
}
exports.GraphicsRenderer = GraphicsRenderer;
{
    // Additional primitives that rely on offline rendering to compute text metrics. Combining these would 
    // require more general primitives that can return tuples.
    const textWidth = (str) => {
        return Versioned_1.num(exports.svg.textWidth(Renderer_1.textElement_graphical(0, 0, fontSize, str.val)));
    };
    const textHeight = (str) => {
        return Versioned_1.num(exports.svg.textHeight(Renderer_1.textElement_graphical(0, 0, fontSize, str.val)));
    };
    Primitive_1.unaryOps.set(textWidth.name, Primitive_1.unary_(textWidth));
    Primitive_1.unaryOps.set(textHeight.name, Primitive_1.unary_(textHeight));
}


/***/ }),

/***/ "./src/app/Interactor.ts":
/*!*******************************!*\
  !*** ./src/app/Interactor.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tippy_js_1 = __webpack_require__(/*! tippy.js */ "./node_modules/tippy.js/dist/tippy.esm.js");
__webpack_require__(/*! tippy.js/dist/tippy.css */ "./node_modules/tippy.js/dist/tippy.css");
__webpack_require__(/*! tippy.js/themes/light-border.css */ "./node_modules/tippy.js/themes/light-border.css");
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ../util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ../Annotation */ "./src/Annotation.ts");
const Expl_1 = __webpack_require__(/*! ../Expl */ "./src/Expl.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Value_1 = __webpack_require__(/*! ../Value */ "./src/Value.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
function createTooltip(element, placement) {
    return tippy_js_1.default(element, { theme: "light-border", placement });
}
class Interactor {
    constructor(editor, C, cursor /*<Pair<Num, Num>>*/, element) {
        this.propFocus = null;
        this.editor = editor;
        this.C = C;
        this.tooltip = createTooltip(element, editor.tooltipPlacement);
        this.editor.tooltips.add(this.tooltip);
        this.cursor = cursor;
        this.element = element;
        const p = Core_1.as(cursor.tv.v, C);
        const propsFocus = this.focusedProps(cursor.tv);
        if (propsFocus.length > 0) {
            this.tooltip.setContent(this.propValues(p, propsFocus));
            this.tooltip.show();
            element.classList.add("focus");
        }
        element.addEventListener("mousemove", (e) => {
            e.stopPropagation();
            this.onMouseMove(e);
        });
        element.addEventListener("mouseout", (e) => {
            e.stopPropagation();
            this.onMouseOut(e);
        });
    }
    // Non-primitive dependencies render as a bullet.
    propValues(g, props) {
        const lines = props.map((prop) => {
            const propVal = g.__child(prop);
            const propStr = propVal instanceof Value_1.Num ?
                Renderer_1.round(propVal.val) :
                propVal instanceof Value_1.Str ?
                    propVal.val : "•";
            return `${prop}: ${propStr}`;
        });
        return lines.join("</br>");
    }
    focusedProps(tv) {
        return Value_1.fields(tv.v).filter((prop) => {
            const tv_ = Expl_1.Expl.explChild(tv.t, tv.v, prop);
            return Core_1.__nonNull(this.editor.direction) === Annotation_1.Direction.Fwd ? Lattice_1.bool_.negate(Annotation_1.isα(tv_)) : Annotation_1.isα(tv_);
        });
    }
    onMouseMove(e) {
        const v = Core_1.as(this.cursor.tv.v, this.C);
        const rect = this.element.getBoundingClientRect();
        // invert sign on y axis because of global inversion for SVG graphics
        const x_prop = Math.max(e.clientX - rect.left, 0) / rect.width;
        const y_prop = Math.min(rect.bottom - e.clientY, rect.height) / rect.height;
        const propFocus = this.propFor(x_prop, y_prop);
        if (this.propFocus !== propFocus) {
            this.propFocus = propFocus;
            this.editor.bwdSlice(() => {
                Annotation_1.setα(Lattice_1.bool_.top, this.cursor.to(this.C, propFocus).tv);
            });
            this.tooltip.setContent(this.propValues(v, [propFocus]));
            this.element.classList.add("focus");
        }
    }
    onMouseOut(e) {
        this.propFocus = null;
        this.editor.bwdSlice(() => { });
        this.element.classList.remove("focus");
    }
}
class PointInteractor extends Interactor {
    constructor(editor, tp /*<Point>*/, marker) {
        super(editor, Graphics_1.Point, tp, marker);
    }
    propFor(x_prop, y_prop) {
        return "y";
    }
}
exports.PointInteractor = PointInteractor;
class RectInteractor extends Interactor {
    constructor(editor, tg /*<Rect>*/, r) {
        super(editor, Graphics_1.Rect, tg, r);
    }
    // Determine which "diagonal quadrant" of the unit square [1, 1] contains [x, y], and
    // then map to the corresponding attribute of the rectangle.
    propFor(x, y) {
        const corner = y > x ? ["x", "height"] : ["y", "width"];
        return y < 1 - x ? corner[0] : corner[1];
    }
}
exports.RectInteractor = RectInteractor;


/***/ }),

/***/ "./src/app/Pane.ts":
/*!*************************!*\
  !*** ./src/app/Pane.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Annotation_1 = __webpack_require__(/*! ../Annotation */ "./src/Annotation.ts");
const DataValue_1 = __webpack_require__(/*! ../DataValue */ "./src/DataValue.ts");
const Eval_1 = __webpack_require__(/*! ../Eval */ "./src/Eval.ts");
const Expl_1 = __webpack_require__(/*! ../Expl */ "./src/Expl.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Cursor_1 = __webpack_require__(/*! ./Cursor */ "./src/app/Cursor.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
const View_1 = __webpack_require__(/*! ./View */ "./src/app/View.ts");
__webpack_require__(/*! ./styles.css */ "./src/app/styles.css");
// Previously Editor, but clashes a bit with the Wrattler class of the same name.
var Pane;
(function (Pane_1) {
    function initialise() {
        View_1.View.initialise();
    }
    Pane_1.initialise = initialise;
    class Pane {
        constructor(listener, [width, height], tooltipPlacement, ρ_external, ρ_imports, e) {
            this.slice = new Set();
            this.listener = listener;
            this.rootPane = Renderer_1.svgRootElement(width, height);
            this.tooltips = new Set();
            this.tooltipPlacement = tooltipPlacement;
            Renderer_1.markerEnsureDefined(this.rootPane, Graphics_1.Arrowhead, "blue");
            document.body.appendChild(this.rootPane);
            this.ρ_external = ρ_external;
            this.ρ_imports = ρ_imports;
            this.e = e;
            // evaluate twice so we can start with an empty delta
            this.tv = Eval_1.Eval.eval_(this.ρ, this.e);
            this.here = Cursor_1.ExplValueCursor.descendant(null, this.tv);
            this.direction = Annotation_1.Direction.Fwd;
            Versioned_1.newRevision();
            Eval_1.Eval.eval_(this.ρ, this.e); // reestablish reachable nodes
        }
        get ρ() {
            return this.ρ_external.concat(this.ρ_imports);
        }
        visibleTooltips() {
            return [...this.tooltips].filter(tooltip => tooltip.state.isVisible);
        }
        initialise() {
            this.render();
            const this_ = this;
            // https://stackoverflow.com/questions/5597060
            document.onkeydown = function (ev) {
                if (ev.shiftKey) {
                    if (ev.keyCode == 37) { // left
                        this_.here = this_.here.prevSibling();
                        this_.render();
                    }
                    else if (ev.keyCode == 38) { // up
                        if (this_.here.hasParent()) {
                            this_.here = this_.here.up();
                            this_.render();
                        }
                    }
                    else if (ev.keyCode == 39) { // right
                        this_.here = this_.here.nextSibling();
                        this_.render();
                    }
                    else if (ev.keyCode == 40) { // down
                        if (this_.here.tv.v instanceof DataValue_1.DataValue) {
                            this_.here = this_.here.toChild(0);
                            this_.render();
                        }
                    }
                }
            };
            document.onkeypress = function (ev) {
                if (ev.shiftKey) {
                    if (ev.key === "V") {
                        View_1.View.existingView(this_.here.tv).toggleValue();
                        this_.render();
                    }
                    else if (ev.key === "E") {
                        View_1.View.existingView(this_.here.tv).toggleExpl();
                        this_.render();
                    }
                }
            };
        }
        bwdSlice(setNeeded) {
            Annotation_1.__slice.reset(Annotation_1.Direction.Bwd);
            setNeeded();
            Eval_1.Eval.eval_bwd(this.e, this.tv);
            Annotation_1.__slice.ann = Annotation_1.__slice.restrictTo(this.ρ_external.values());
            this.listener.onBwdSlice(this, Annotation_1.__slice.ann);
            this.direction = Annotation_1.Direction.Bwd;
            this.slice = Annotation_1.__slice.ann;
        }
        // Forward-slice with respect to supplied slice of ρ_external.
        fwdSlice(externDeps) {
            Annotation_1.__slice.direction = Annotation_1.Direction.Fwd;
            Annotation_1.__slice.ann = externDeps;
            Eval_1.Eval.eval_fwd(this.e, this.tv);
            Annotation_1.__slice.ann = Annotation_1.__slice.restrictTo([this.tv]);
            this.direction = Annotation_1.Direction.Fwd;
            this.slice = Annotation_1.__slice.ann;
        }
        render() {
            // https://stackoverflow.com/questions/48310643
            const children = Array.from(this.rootPane.childNodes);
            children.forEach((child) => {
                if (!(child instanceof SVGDefsElement)) {
                    this.rootPane.removeChild(child);
                }
            });
            this.tooltips.forEach(tooltip => tooltip.destroy());
            this.tooltips.clear();
            View_1.View.render(this);
        }
        onEdit() {
            this.tv = Eval_1.Eval.eval_(this.ρ, this.e);
            this.here = Cursor_1.ExplValueCursor.descendant(null, DataValue_1.explValue(Core_1.as(this.tv.t, Expl_1.Expl.Defs).t, this.tv.v));
            // cursor may no longer be valid, how to deal with that?
            this.render();
        }
        onViewChange() {
            this.render();
        }
    }
    Pane_1.Pane = Pane;
})(Pane = exports.Pane || (exports.Pane = {}));


/***/ }),

/***/ "./src/app/PaneCoordinator.ts":
/*!************************************!*\
  !*** ./src/app/PaneCoordinator.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Annotation_1 = __webpack_require__(/*! ../Annotation */ "./src/Annotation.ts");
const Pane_1 = __webpack_require__(/*! ./Pane */ "./src/app/Pane.ts");
const View_1 = __webpack_require__(/*! ./View */ "./src/app/View.ts");
class PaneCoordinator {
    constructor(ρ_external) {
        this.panes = new Set();
        this.ρ_external = ρ_external;
    }
    addPane(ρ, e, tooltipPlacement = "top") {
        const pane = new Pane_1.Pane.Pane(this, View_1.View.defaultDims, tooltipPlacement, this.ρ_external, ρ, e);
        pane.initialise();
        this.panes.add(pane);
        return pane;
    }
    removePane(pane) {
        Core_1.assert(this.panes.has(pane));
        this.panes.delete(pane);
    }
    onBwdSlice(editor, externDeps) {
        // consider availability of ρ_external only; treat ρ and e as unlimited resources
        [...this.panes]
            .filter(editor_ => editor_ !== editor)
            .forEach((editor_) => {
            editor_.fwdSlice(externDeps);
            editor_.render(); // TODO: just redo selection rendering
        });
        Annotation_1.__slice.reset(Annotation_1.Direction.Fwd);
    }
}
exports.PaneCoordinator = PaneCoordinator;


/***/ }),

/***/ "./src/app/Renderer.ts":
/*!*****************************!*\
  !*** ./src/app/Renderer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Delta_1 = __webpack_require__(/*! ../Delta */ "./src/Delta.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "./src/Expr.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Value_1 = __webpack_require__(/*! ../Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Core_2 = __webpack_require__(/*! ./Core */ "./src/app/Core.ts");
__webpack_require__(/*! ./styles.css */ "./src/app/styles.css");
exports.svg = new Core_2.SVG();
const fontSize = 18;
const classes = "code";
// bizarrely, if I do this later, font metrics are borked:
const lineHeight = exports.svg.textHeight(textElement(fontSize, classes, "m")); // representative character 
// ASCII spaces seem to be trimmed; only Unicode space that seems to render monospaced is this: 
const space_char = "\u00a0";
const shapeRendering = "geometricPrecision";
exports.__dimensions = new Map();
function arrow(ẟ_style) {
    return keyword("arrow", ẟ_style);
}
exports.arrow = arrow;
function border(x, y, width, height, stroke, dashed) {
    const b = rect(x, y, width, height, stroke, "none", border);
    b.setAttribute("stroke-width", "0.5");
    if (dashed) {
        b.setAttribute("stroke-dasharray", "1,1");
    }
    return b;
}
exports.border = border;
function addBorder_changed(g) {
    const { width, height } = Core_1.__nonNull(exports.__dimensions.get(g));
    const b = border(g.x.baseVal.value, g.y.baseVal.value, width, height, "blue", true);
    g.appendChild(b);
    return g;
}
exports.addBorder_changed = addBorder_changed;
function addBorder_focus(g) {
    const { width, height } = Core_1.__nonNull(exports.__dimensions.get(g));
    const b = border(g.x.baseVal.value, g.y.baseVal.value, width, height, "gray", false);
    g.appendChild(b);
    return g;
}
exports.addBorder_focus = addBorder_focus;
function bracket(gs, ẟ_style) {
    return horiz(keyword("bracketL", ẟ_style), ...gs, keyword("bracketR", ẟ_style));
}
exports.bracket = bracket;
function centreDot(ẟ_style) {
    return text("•", ẟ_style);
}
exports.centreDot = centreDot;
function comma(ẟ_style) {
    return keyword("comma", ẟ_style);
}
exports.comma = comma;
// Whether the centre of r1 is to the left of the centre of r2.
function leftOf(r1, r2) {
    return r1.x + r1.width / 2 <= r2.x + r2.width;
}
// TODO: remember what this is for.
function blah(x, length, proportion) {
    return x + proportion * length;
}
// Offset might be better computed as a function of distance between p1 and p2.
function curvedLine(p1, p2, offset) {
    const mp = { x: (p2.x + p1.x) * 0.5, y: (p2.y + p1.y) * 0.5 };
    // angle of perpendicular to line
    const theta = Math.atan2(p2.y - p1.y, p2.x - p1.x) - Math.PI / 2;
    const control = { x: mp.x + offset * Math.cos(theta), y: mp.y + offset * Math.sin(theta) };
    return `M ${p1.x} ${p1.y} Q ${control.x} ${control.y} ${p2.x} ${p2.y}`;
}
// Factor all element creation through this so we can tag with extra metadata.
function createElement(name, createdBy) {
    const e = document.createElementNS(Core_2.SVG.NS, name);
    e.setAttribute("data-created-by", createdBy.name);
    return e;
}
function connector(g1, g2) {
    const g1_ = dims(g1);
    const g2_ = dims(g2);
    const [fromBottom, fromTop] = [0.1, 0.9];
    const connector_ = createElement("path", connector);
    const curveOffset = 5; // somewhat arbitrary
    if (leftOf(g1_, g2_)) {
        connector_.setAttribute("d", curvedLine({ x: g1_.x + g1_.width, y: blah(g1_.y, g1_.height, fromBottom) }, { x: g2_.x, y: blah(g2_.y, g2_.height, fromBottom) }, curveOffset));
    }
    else {
        connector_.setAttribute("d", curvedLine({ x: g1_.x, y: blah(g1_.y, g1_.height, fromTop) }, { x: g2_.x + g2_.width, y: blah(g2_.y, g2_.height, fromTop) }, curveOffset));
    }
    connector_.setAttribute("shape-rendering", shapeRendering);
    connector_.setAttribute("fill", "none");
    connector_.setAttribute("stroke", "blue"); // hardcoded
    connector_.setAttribute("stroke-width", "1");
    connector_.setAttribute("stroke-dasharray", "1,1");
    connector_.setAttribute("marker-end", "url(#Arrowhead-blue)"); // extract to helper function
    return connector_;
}
exports.connector = connector;
// Couldn't get getScreenCTM or getBoundingClientRect to work properly (perhaps because of nested SVGs?) so just use this to compute 
// coordinates of g relative to root SVG.
function coordinates(g) {
    if (g instanceof SVGSVGElement) {
        const { x, y } = g.parentElement instanceof SVGSVGElement ? coordinates(g.parentElement) : { x: 0, y: 0 };
        return { x: x + g.x.baseVal.value, y: y + g.y.baseVal.value };
    }
    else {
        return { x: 0, y: 0 };
    }
}
function delimit(delimiter, ...gs) {
    const gsʹ = [];
    gs.forEach((g, n) => {
        gsʹ.push(g);
        if (n < gs.length - 1) {
            gsʹ.push(delimiter());
        }
    });
    return gsʹ;
}
exports.delimit = delimit;
function dims(g) {
    const { width, height } = Core_1.__nonNull(exports.__dimensions.get(g));
    const { x, y } = coordinates(g);
    return { x, y, width, height };
}
function edge_left(g) {
    const { height } = exports.__dimensions.get(g);
    const edge = line(g.x.baseVal.value, g.y.baseVal.value, g.x.baseVal.value, g.y.baseVal.value + height, "gray", 1);
    edge.setAttribute("stroke-width", "4");
    //   edge.setAttribute("stroke-dasharray", "2,2")
    g.appendChild(edge);
    return g;
}
exports.edge_left = edge_left;
function edge_bottom(g) {
    const { width, height } = exports.__dimensions.get(g);
    const edge = line(g.x.baseVal.value, g.y.baseVal.value + height, g.y.baseVal.value + width, g.y.baseVal.value + height, "gray", 1);
    edge.setAttribute("stroke-width", "2");
    //   edge.setAttribute("stroke-dasharray", "2,2")
    g.appendChild(edge);
    return g;
}
exports.edge_bottom = edge_bottom;
function ellipsis(ẟ_style) {
    return text("…", ẟ_style);
}
exports.ellipsis = ellipsis;
function group() {
    return createElement("g", group);
}
exports.group = group;
function horiz(...gs) {
    const g = createElement("svg", horiz);
    let width_sum = 0, height_max = 0;
    gs.forEach((gʹ) => {
        gʹ.setAttribute("x", `${width_sum}`);
        gʹ.setAttribute("y", `0`);
        const { width, height } = exports.__dimensions.get(gʹ);
        width_sum += width;
        height_max = Math.max(height_max, height);
        g.appendChild(gʹ);
    });
    exports.__dimensions.set(g, { width: width_sum, height: height_max });
    return g;
}
exports.horiz = horiz;
function horizSpace(...gs) {
    return horiz(...delimit(space, ...gs));
}
exports.horizSpace = horizSpace;
function keyword(str, ẟ_style) {
    return text(Expr_1.strings[str], ẟ_style);
}
exports.keyword = keyword;
function line(x1, y1, x2, y2, stroke, strokeWidth) {
    const l = createElement("line", line);
    l.setAttribute("shape-rendering", shapeRendering);
    l.setAttribute("x1", `${round(x1)}`);
    l.setAttribute("y1", `${round(y1)}`);
    l.setAttribute("x2", `${round(x2)}`);
    l.setAttribute("y2", `${round(y2)}`);
    l.setAttribute("stroke", stroke);
    l.setAttribute("stroke-width", `${round(strokeWidth)}`);
    return l;
}
exports.line = line;
function lineRounded(x1, y1, x2, y2, stroke, strokeWidth) {
    const l = line(x1, y1, x2, y2, stroke, strokeWidth);
    l.setAttribute("stroke-linecap", "round");
    return l;
}
exports.lineRounded = lineRounded;
function marker(C, colour) {
    const m = createElement("marker", marker);
    m.setAttribute("id", markerId(C, colour));
    m.setAttribute("orient", "auto");
    m.setAttribute("fill", colour);
    m.setAttribute("stroke", colour);
    return m;
}
exports.marker = marker;
function markerId(C, colour) {
    return `${C.name}-${colour}`;
}
let markerFactory;
{
    markerFactory = new Map();
    markerFactory.set(Graphics_1.Arrowhead.name, marker_arrowhead);
}
// Assume root has a unique defs element called "defs". Return composite marker id.
function markerEnsureDefined(root, C, colour) {
    const id = markerId(C, colour);
    let marker = root.getElementById(id);
    if (marker === null) {
        marker = Core_1.__nonNull(markerFactory.get(C.name))(colour);
        const defs = Core_1.as(root.getElementById("defs"), SVGDefsElement);
        defs.appendChild(marker);
        Core_1.assert(root.getElementById(id) === marker);
    }
    else {
        Core_1.assert(marker instanceof SVGMarkerElement);
    }
    return id;
}
exports.markerEnsureDefined = markerEnsureDefined;
function marker_arrowhead(colour) {
    const m = marker(Graphics_1.Arrowhead, colour);
    const length = 6, width = 4;
    m.setAttribute("refX", `${length}`);
    m.setAttribute("refY", `${width / 2}`);
    m.setAttribute("markerWidth", "16");
    m.setAttribute("markerHeight", "16");
    const path = createElement("path", marker_arrowhead);
    m.appendChild(path);
    path.setAttribute("shape-rendering", shapeRendering);
    path.setAttribute("d", `M ${length} ${width / 2} L 0 ${width} L 0 0 Z`);
    return m;
}
exports.marker_arrowhead = marker_arrowhead;
function circle(x, y, radius, stroke, fill, createdBy) {
    const r = createElement("circle", createdBy);
    r.setAttribute("shape-rendering", shapeRendering);
    r.setAttribute("cx", `${round(x)}`);
    r.setAttribute("cy", `${round(y)}`);
    r.setAttribute("r", `${round(radius)}`);
    r.setAttribute("stroke", stroke);
    r.setAttribute("fill", fill);
    return r;
}
exports.circle = circle;
function parenthesise(g, ẟ_style) {
    return horiz(keyword("parenL", ẟ_style), g, keyword("parenR", ẟ_style));
}
exports.parenthesise = parenthesise;
function parenthesiseIf(parens, g, ẟ_style) {
    return parens ? parenthesise(g, ẟ_style) : g;
}
exports.parenthesiseIf = parenthesiseIf;
// TODO: use Point consistently everywhere?
function pointsToString(p̅) {
    return p̅.map(([x, y]) => `${round(x)},${round(y)}`).join(" ");
}
function polyline(p̅, stroke, strokeWidth) {
    const l = createElement("polyline", polyline);
    l.setAttribute("shape-rendering", shapeRendering);
    l.setAttribute("points", pointsToString(p̅));
    l.setAttribute("stroke", stroke);
    l.setAttribute("stroke-width", `${round(strokeWidth)}`);
    l.setAttribute("stroke-linecap", "round");
    l.setAttribute("fill", "none");
    return l;
}
exports.polyline = polyline;
function rect(x, y, width, height, stroke, fill, createdBy) {
    const r = createElement("rect", createdBy);
    r.setAttribute("shape-rendering", shapeRendering);
    r.setAttribute("x", `${round(x)}`);
    r.setAttribute("y", `${round(y)}`);
    r.setAttribute("width", `${round(width)}`);
    r.setAttribute("height", `${round(height)}`);
    r.setAttribute("stroke", stroke);
    r.setAttribute("fill", fill);
    return r;
}
exports.rect = rect;
// Rounding to pixel boundaries (although often desirable for SVG, e.g. to get sharp lines) doesn't work well 
// for small shapes, but we don't need to maintain the full monstrosity that are floating-point numbers. Round 
// to an appropriate number of decimal places, cast to number to strip trailing zeros, and then cast back to string.
// This seems to be sufficient precision for SVG but is also human-friendly.
function round(n) {
    return (+n.toFixed(3)).toString();
}
exports.round = round;
// Needs to be at the bottom in the z-order, and opaque.
function shading(g, fill) {
    const svg = createElement("svg", shading);
    const { width, height } = exports.__dimensions.get(g);
    const background = rect(g.x.baseVal.value, g.y.baseVal.value, width, height, "none", fill, shading);
    background.setAttribute("pointer-events", "none");
    svg.appendChild(background);
    svg.appendChild(g);
    exports.__dimensions.set(svg, { width, height });
    return svg;
}
exports.shading = shading;
function space() {
    return text(`${space_char}`, DeltaStyle.Unchanged);
}
exports.space = space;
// Content below or to the left is clipped automatically; content to above or to the right is clipped 
// if we set width and height.
function svgElement(overflow, x, y, width, height, defs, createdBy) {
    const svg = createElement("svg", createdBy);
    svg.setAttribute("x", `${round(x)}`);
    svg.setAttribute("y", `${round(y)}`);
    svg.setAttribute("width", `${round(width)}`);
    svg.setAttribute("height", `${round(height)}`);
    // use inline style rather than an attribute, otherwise any active styling will override
    svg.setAttribute("style", `overflow: ${overflow ? "visible" : "hidden"}`);
    if (defs) {
        const d = createElement("defs", createdBy);
        d.setAttribute("id", "defs");
        svg.appendChild(d);
    }
    return svg;
}
exports.svgElement = svgElement;
// Chrome doesn't appear to fully support SVG 2.0 yet; in particular, transform attributes on svg elements are 
// ignored (except at the root). To invert the y-axis, we have to add a nested g element containing the transform.
function svgElement_inverted(w, h) {
    const svg = svgElement(false, 0, 0, w, h, true, svgElement_inverted);
    const g = createElement("g", svgElement_inverted);
    g.setAttribute("transform", `scale(1,-1) translate(0,${-h})`);
    g.setAttribute("width", `${w}`);
    g.setAttribute("height", `${h}`);
    svg.appendChild(g);
    return [svg, g];
}
exports.svgElement_inverted = svgElement_inverted;
// Top-level SVG node with a "defs" element with id "defs".
function svgRootElement(w, h) {
    const svg = svgElement(false, 0, 0, w, h, true, svgRootElement);
    // See https://vecta.io/blog/guide-to-getting-sharp-and-crisp-svg-images
    svg.setAttribute("viewBox", `-0.5 -0.5 ${w.toString()} ${h.toString()}`);
    svg.style.verticalAlign = "top";
    svg.style.display = "inline-block";
    return svg;
}
exports.svgRootElement = svgRootElement;
function text(str, ẟ_style) {
    const text = textElement(fontSize, [classes, ẟ_style].join(" "), str);
    text.setAttribute("transform", `translate(${0},${lineHeight / 2})`);
    text.setAttribute("alignment-baseline", "central");
    const width = exports.svg.textWidth(text);
    exports.__dimensions.set(text, { width, height: lineHeight });
    text.remove();
    return text;
}
exports.text = text;
function textElement(fontSize, class_, str) {
    const text = createElement("text", textElement);
    text.setAttribute("stroke", "none");
    text.setAttribute("font-size", fontSize.toString()); // wasn't able to set this through CSS for some reason
    text.setAttribute("class", class_); // set styling before creating text node, for font metrics to be correct
    text.setAttribute("pointer-events", "none");
    text.appendChild(document.createTextNode(str));
    return text;
}
// Flip text vertically to cancel out the global vertical flip. Don't set x and y but express
// position through a translation so that the scaling doesn't affect the position.
function textElement_graphical(x, y, fontSize, str) {
    const text = textElement(fontSize, "label", str);
    let transform = `translate(${round(x)},${round(y)})`;
    text.setAttribute("transform", transform + " scale(1,-1)");
    return text;
}
exports.textElement_graphical = textElement_graphical;
function unimplemented(v) {
    return horiz(text(`TODO: ${Core_1.className(v)}`, DeltaStyle.Unchanged));
}
exports.unimplemented = unimplemented;
function vert(...gs) {
    const g = createElement("svg", vert);
    let height_sum = 0, width_max = 0;
    gs.forEach((gʹ) => {
        gʹ.setAttribute("y", `${height_sum}`);
        gʹ.setAttribute("x", `0`);
        const { width, height } = exports.__dimensions.get(gʹ);
        height_sum += height;
        width_max = Math.max(width_max, width);
        g.appendChild(gʹ);
    });
    exports.__dimensions.set(g, { width: width_max, height: height_sum });
    return g;
}
exports.vert = vert;
var DeltaStyle;
(function (DeltaStyle) {
    DeltaStyle["New"] = "new";
    DeltaStyle["Changed"] = "changed";
    DeltaStyle["Unchanged"] = "unchanged";
})(DeltaStyle = exports.DeltaStyle || (exports.DeltaStyle = {}));
// Delta-styling for the constructor component of a value (not its child pointers). In particular, primitives appear changed
// iff their value has changed, whereas non-primitives appear changed iff reclassified. Changes to child pointers must be
// visualised separately.
function deltaStyle(v) {
    if (Versioned_1.versioned(v)) {
        if (v.__ẟ instanceof Delta_1.New) {
            return DeltaStyle.New;
        }
        else if (v.__ẟ instanceof Delta_1.Change) {
            if (Object.keys(v.__ẟ.changed).length > 0 && Value_1.isPrim(v)) {
                return DeltaStyle.Changed;
            }
            else {
                return DeltaStyle.Unchanged;
            }
        }
        else if (v.__ẟ instanceof Delta_1.Reclassify) {
            return DeltaStyle.Changed;
        }
        else {
            return Core_1.absurd();
        }
    }
    else {
        return Core_1.absurd();
    }
}
exports.deltaStyle = deltaStyle;


/***/ }),

/***/ "./src/app/Slabo13px-Regular.woff":
/*!****************************************!*\
  !*** ./src/app/Slabo13px-Regular.woff ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:font/woff;base64,d09GRgABAAAAAF3YABIAAAAAw8AAAQACAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAABdvAAAABwAAAAccq/j0kdERUYAAFhkAAAAHQAAAB4AJgGzR1BPUwAAWvwAAAK+AAAFykUUsQpHU1VCAABYhAAAAnUAAAQQipmvtk9TLzIAAAIQAAAAWQAAAGBq+GQrY21hcAAABLAAAAJOAAADTlMmbV1jdnQgAAAIQAAAACIAAAAiAJgIKmZwZ20AAAcAAAAA9wAAAWGSQdr6Z2FzcAAAWFQAAAAQAAAAEAAbAAlnbHlmAAALuAAAQ/QAAJdIhK+t+mhlYWQAAAGUAAAANgAAADYBExUhaGhlYQAAAcwAAAAhAAAAJAYbBRNobXR4AAACbAAAAkIAAAayu6rgUmxvY2EAAAhkAAADUQAAA1zJRO7ibWF4cAAAAfAAAAAgAAAAIAPHAfluYW1lAABPrAAAAvIAAAaoVnILNHBvc3QAAFKgAAAFsgAACmlnvpTDcHJlcAAAB/gAAABHAAAATNKmThoAAQAAAAEFHnWZlbxfDzz1AB8DDAAAAADO6WmHAAAAAM+uZDn+rP9MBJwC7gAAAAgAAgAAAAAAAHicY2BkYGC68F+AgYHlzb81/7NY5jAARZAB4xoAo2AHNAAAAAABAAABrQBNAAQAVgAHAAEAAAAAAAoAAAIAAVQABAABeJxjYGbcwziBgZWBgamfyZOBgWEalN7CYMRwCSjKxsrMzMrKxMKygIEh34GBwZsBCkI8g/wZHBh4f7MwXfgvAFR5geGDAgPDZJAc4xImGSClwMACAMEUDuUAAAB4nI1VsYobQQzVrK9yDnLFEs5wmDRHXAxpk8J1SJEPyCfMh+QT/AlbXpHiOEKqK9xdY0gIWxoTUoQtUi0BB0/eSJo5ee2YGB7akUYjzZNGdg3J79bIXzRzni7dmsg1cTv6QHX1nmrYLqF/BZAL8XeyY28NZB+CjteuoTFAijrp+TvJB97zhn3WbCMG/KtV0sVlWldXNAEo25HDBCCJF9tsg0+ysb3su5LcdU3pzNF5XIqPnI94c+djq/fpcOZHnD3OfiZvuZPmqvG7/J3ia451kZ79p8JJ7HFmWy0QSzhtXZD7wn+uezP3LzTuTM6KPe9J3PnYj85xx4D8hEuOzzqPvL3mEQSwTbGe674Z8Exrw7WoFpI7/NPZW+HlENWKeZuUOq1z7MSZ1ALYJG5zHYaw9bMotViTY96PALxtNec9mPiblMMe/4dQPWph0ZiapFwa5cFIvjvinZCpV2vtx9r0zkmpvJySue8z3xtFp/gO/ND3V2Dq09IXqcujbl+WnvHFpx/GPSKP5jt6i/qulAfPnOxJqSd68l/S5hPMTJA+6f9X8jtflHq2pcfC4OygdR/EB2cd5yE4w7t8CvmcvhXdlGh3TxQvIO8UWO8+Q+cgbwDs3n0VW3xC87jE9x/gJ9avc45DWXJu5F3yTLjVt5xzCpxrrXPmGveenXVlDhNiveQ+C8z9GPNbapv05v3y3Fwd9gXPhHtB/rYy+2ZpuLhRWE4+AfGRj/iOZ1yaN/m/xOsM9GUmks4p4cCsif4CT7vjxgAAeJytk1dPlEEUhp+zH66IiEpRBFyHVRGsoCKCDZHeFRV7F5HejKBCjIq9EmussRfEEnuNmOiNP8AbhY/4CyxXJvs57npBvPDKk8yZM5OZd2aecwYw8LQwRHskWY/EPfaSSN2nkkgP7DrqQ5PESbo0SYst1BZne2/7ZHgZ3oav4W8EGZGOZsc3FahClEM5VYSKVgkqWVWpOtUa7nT6O4N+elnW7xO0juKCxEum1gnWOu9sHw0Mu+Hj1olwbHV8VQEqWIUp5daJ/0sHrWNYP6wv1lur3XpjtVlRlp9rq6vKlevKcWW70lwprtiuz101ZoGZb+aZuWaWmWQmmDGm3TQ6P3QWdhR3FNm3eN77H8xu83GT83DsboLtT2Tj3+a5i5ebdE+86YUPvfHVrPzoSz/6408AgQQxgIEEM4gQQnWOBuNgiOYZjpOhDGM4EYwgkihGMorRjGEs44gmhvFMYCKxTCKOycSTwBSmMo3pzNAZnkkSs0gmRec7jXQyyCSLbHLIJY98ZjOHAuYyj/kUsoCFLGIxS1jKMpazgpWs0vffxW72sp+jnOI8l7nEFa5xlevcpJVb3KaNu9zhHvd5wCMe8pinPOElL3jFa6mglrUUUSJVNHCRasqkgY2Uau09nNa+zs2pmPpu7Mpp1P4Gz9nGGio1zET3fIWu12pWs52dnJQACZQiWSelUibFsp5nekW7rsINUi+1UieNuq4r2SQlUi41NHOAHRxkH4c5QguHOM4JveMYZznHGb5LqmRTo39DhmSyWXIkS9J+AX22lsEAAHicXZA9TsQwEIVjEhZyAyQLySNrKVa26KlSOJFQmrCh8DT8SLsS2TsgpaFxwVnedilzMQTeBFZA4/F7o/n0ZpCYGnnj90K88yA+3+Au93n6+GAhjFJl5yCeLE4MxIosUqMqpMtq7TWroMLtJqhKvTxvkC2nGhvbwNcKSeu7+N57QsHy+N0y31hkB0w2YQJHwO4bsJsAcf7D4tTUCulV4+88eidROJZEqsTYeIxOErPF4pgx1tfuYk57ZrBYWZzPhNajkEg4hFlpQh+CDHGDHz3+1YNI/hvFbyNeoBxE30ydXpM8GJo0xYTsLHJTt76MEYntF+Vga1wAeJzbwKDNsImRkUmbcRMTiNzO5GFnoCzKwKHNsJ3RD8bcxMzOrr2BQcG1NlPCZZMBO2PxpgJOIMHPCyQS+IGEPpAAAEQgENYAABAANwA8AAAACv9MAAoAtAAKAZ8ADwHgAAoCHAAKAlgACgAAeJw9wm9IGgsAAHBTMzNzauZMLe3uvDvP887uv6dzzlemdzFkSMQYIUPiEfGQR4QMPzxEIvZBYkgMiZDHiIh4jIiQETEiHiP2QcYj/BAR8RgSj5CQiBjx3qfH76dQKCr/+0tx0TXd9aWrqSwpq8oD5bnKqmJUcdW0akW1obpVW9Wz6gN1qxvurnR/0kQ1Vc19j9CT7lnsWdXqtFvam95078feax2jy+vO+8b7Fvu29Fq9qP9df9M/1b/a/92QMnwxPDyaflQxKo0LxrqxZTKYIFPClDUVTMumtvmleX8AGlgZuLcULf8M4oOlwaZVbS1brx7HHu/bUFvO1hoaH3o/1LRH7R8ceofoKDlqjisn+p/XzvowMDw3fDGiHimPvHfpXIuu31zvXFU34464i+5td2d0bjQ32hi9A8yAE+CAN8AysAZsAvugBXSDOCiA42AKfAX+CX4Dz8Er8BZSQgbIDsEQBYlQHHoBzULz0BJUhGoeyBPwhD0JT9qT8dThNJyBF+A8XIJX4XUkjrxAZpF5ZAkpImWkimwiuyiDRtEpdAbNojm0gO56GW/UO+Wd8Wa9OW/b+wPTYhbMjeFYDdvB6tgx1sDOsBbW8Sl8ep/NB/nyvltciRtwOw7jFB7BJfwSv8bv/Rq/2T/ix/ycP+Z/7n/pn/P/SuiIIlEmqsQmsUscEifEKXFJXJN2EiYpMkJK5DT5mvyFfEMuk+/IDXKbvAlQgULgJHAauAxcB+7HNGPmsaWxB0pHWSmAIiiRilN79BQ9Q2fpHF2gV+gKXaN36Dp9TDfoM7pFdxgFo2dsTIlpsAk2zWbYBTbPlthVdp3dYvfYz9wMl+VyXIFb4Spcjdvh6twx1+DOuBYv8ON8in/F/8z/wdf5I/4rf8pf8Fd8h38QnIIozAprwkfhe1AZFIJzwbXgcfA82BGNYkpcF7fEPfGz+FVsin+LbfFHyBByh4TQ81AmtBDKh0qhg7A2TIXXwtvhw/C3cPuJ9GQpoo6sR3Yie08zTy+j88/wZ52YNmaMQbHyT4Fx84RzAp1g4ob4w+Tu5OHkSSKbtCSJZCI5n3ybPEreSQaJkdLShnQkNaULqSW1pTtZIWtlo2yTYZmRY3JKzsg5+a384V8BfBT8AAAAeJzFvQt4G9d1IDx3ABAESRCD95MASJAA+CYBAgOS4FMUSYl6UC+TlkxJlmSLcmzLlmULduLEUW2LceVHYsWiE2+qbZSHHDcGIUQN8zeP3WZbN1/+Fk3dNH9X2yrdJN22SavdOP3aJAb33DMPzECgzORvd22R4L24M3Pvueee9znDaBj4jyyyPqaW6WWGmA8wWWbzfLax27vSaBi+ExvV0Kg2ig0WGqxm+M6rXWRQ256t5lZs5J38FduqjV0YtVfbXLaoLWWbts3bFm0Z25Jt2VazkGW5lQR5Z9SuTzgTkQSfmErMJY4nziTOJS4mahbyn01cS7ALPb0ttlBjU8LcF2+M2TXDJNHXxYaaqvRVdpsjHuOHSTzmsNuq9PWkgdCeZEIvfPSFYRhZ9Bb/xOcjvd5834Q52N3YmtbX1tfo9FUtDV1NXSGbtZ6r56acFovLZbE4vV4v+ZHXW/yfVRMxR7vfatMbjLUWlq0PuYJBDWusHzfV1ZkeMLtcZriAYZkoAOp5gJOGMTGTApQYgAUjAcYIDSMAZkVP3rl2Rn9Of1GvWbi2U39IfxL+GDXo9U59RM/rtbBe/TU9Xa81rgnp+5LCskJN4disKeb2upxen8vpYX3FFx53+bxOl9fLrK0xLnKK+R4b5sKwUwxXxdRm6NaxuH9vkhuMlwkwHxHmZYep2GvFebmh4ZYaemjoNWKjFhq1dCu1RAdb6eay5PoKQ97J6rms5npWx2UNBfrbWMhquKypkOUKWcJlzYWspZBluKwVfzuhn8v6CtkG6Oey/kI2UOjpJfqQPg4/IR5/+Dj+xPXwYyLQIG/qDtTt1+03Jo0Z+KF/wU99oj5Tn6z/eqYuQw7GMrGz8J/48XqG0az9Yu2z5AH2MaaRCTPtzCFhtSZYhknaBQs0LFKDQINIqw1CI0gbhFuphkVauBU3eSfXTExmSz/gcbalkGsVGgCJNliDMxGOJOJ2hzPRBbiY5PFvewh67X5CEdHO90XsSY3Nmaj66NapdKRr67at2/iZsXRzx9yOO3YeO3bs5r59+/ezDQ9MGcnXHZODA9sM+/drGu6fqmP/H/cUPzGt3/+jcc9KDdk16n6jBnYS9tnGMJo+1seFyWOwzxHyKLkMn3ryGLmxth2wD75nfYCHUTivaeZ1xXmVlm2GhllatgMaDmGTNbDJsJFVhayZW6nD81jnrIvU8XVTdXN1x+vO1J2ru1hHz2PdtTp2IVtfyNZ3Zxvx7OavJFYTeMITrkQ0kUpMJ+YTi4lMYimxDEc41+pIUMjVc9muQm6wqxEaOW/rIP2I4Aec7iQfAhCGqvR+OMm8nWJ8hP5K9PEIYPF4OyLigQ/zeLCh4UySTDObvBTX9QLwjfVmWygWnTix+/ip9sDseHrrQHrvR/ZO8jP8LntHKNTlbd//UrKf53dsCtnYeFWweWLn+Fy6PRFITAwk2sebdiXbRroS3Zt/4W8MBhxt0R44Qni+DrNhgLC17HSz1+lR1Ydc01yUDedhLL+2jbnJzjMGpoEpnSuTkkTqhu/s6eVtzhBdXrwqk0k/+WQ68/YPLue+82dfugz3YOAeq8p74GUm5UEV7tEXiQNc9KGkdI8bl7/0Z9/JwT3W/oX5VxKHOdczfWVzrrqeI1UMBb9e+KjRE7pBNVxWi6fYCAhu1fNOpEoRPsI7I1+uf9T2oTtTI2PJuQ/az3Bs+KnEuONI9JFHokdco4mn6JwZG7lMrgIFsjNXCWEAoeBWOqQDerjhEInDDsMewynJp/P59Ft8Pg//KHxta59lnmeOAXyrmRzRaNrhgAFBsEV3je3/2teQjMHPKpNnbsIYA70/q4VBFGXy+Zs8/R5pMHMPPL9fWK8B1mugRFdDia7mnOaihhJdzSHNSQ0SXY1TE9HwGkp0Ndc0lOjyCoIblYhtr0Ro6b58lrhgXzQMp4CpiW4FpdfX09fT7Py7O5D2wlkkLwHtrWWczL3CaA2M1kjkVp6eCU+byWmKmHjTlGnOdNx0xnTOdNFET5vpmglOm4ZbsdNzZl+14zmzu+xRe8o+bZ+3L9oz9iX7sr2mbPq8gv3Z7rtzz70n5u64d2x8MD02NJIev/ng2Q/ef/Lc0yfnj907t/fugwhfhsnAfHVMc4XZ4kIp3YCpEPJOT2/cDAfWnE5nyBW+GITrgUSRvXC9g9mqoL23XG9CCpu/Ur1ajUupdlVHq1PV09Xz1YvVmeql6uVqEAoYXHBPbytJUF4Pi9AD2khUIE72Fq89mWmPd7UMTO3YvPuxe292H355oLHD0j/XPtY//tou3KslnE+Y2SXMxwVTcMF8rrKkGZDTxa2Y6UTMq2aciNlljppT5mnzvHnRnDEvmZfNQLuqm80CCwBC/E7OX12D5MouwradJCQgl+anFzhAqCkyOj4+vWk85Ogf6unqjgxs3rFl7u6hTWcOjg+1O0YG+1OJFN/ZZU3NtW8bvauNmGZSs0dtAt9e+yb5AMy9BuSJJvVuXK3Do1WnPFpAO61xMx6tSDwR0t+8+Yve2dn07/wO+4WxHnKyuMw/mX/3F3jOBJi4mU6mxOYFmDi17VfNpFrbnuOqyUK2llsxwoo5MwHEcsq4pDc3wmNkNIvYUj2bZ2a2h1qJ63tm6+HFx+/ui3VZt01t3lxFavhX2cN3HXzIVDoPcHYcwKEfFp5ug6fbTEpmJDXqoVFPOVM1CcJqHRzKHmwhV1VvoxTrEJ1iPbfiwbPjcXoiHt4z5ZnzHPec8ZzzXPTQs+O55mEXcoeCdAWEngO9s3Q+kKc4CWU3wsrIYrPn+H06TXrv9N1H9x04ceE3fI3Ff9SNp+ObhpMzbIP2g4+TkcPTO049f/bVrK74W7tPTAwmN4u0CeC6CHDlYJWlww1wXdFRLHYOa3hK9hrt9Rr9/WxLcjTwT/1kMTgaaySZ6QsvnE3MnO3in3phWeThCCcn7Hwn8wxTEl0k4FRBo4qeJRBTwhSFw6thROGwKxwNp8LT4fnwYjgTXgovhwGFG6vCFIWruBUvQsvr9Ea8vHfKO+c97j3jPee96KXQ8l7zArQ6vHRwjmnsoB+1+AHQEzGa8qtEiR+biERkIlVKfmwZHX7wjr3HHk/xJ3ZvP3z6qyOD6Ynx3ff+dCzRNz49foSkAjO9E3fuG7tnkG2Y7BjZvW1o/+ClrkQy0j4Y7v2v0e7OUOtgoJviDMD1JaQpjcwMU8IMAWNtgLFBirGgQ2QZOA3dIkrkr3hWPQgRj8sT9aQ80555z6In41nyLHtqJHzmIzIeiMhMuoiwhngs3eS/d1GnGdi79fDRvQuLL3/Y30Qs2k1DyZF0alta98T7ydDdMzsf+MjZT71ZRQ7NH9ucTE0JMvck/P4CyGWU7j+ioISGcrq/UbZESSal/pTKswsSEzBITEALf4/aZ+2H7Q/B32omYFb8PSnxs3K+RvZJDA7nHwVeLMzfxIwraA/MP2c0aaiYuGIARDIsGjKGJcOyASZ6xbBqwDkZXIaoIUW7Rg2zBtRjFFPQAE+Xp+EH5k4eEh9d3AZsHugT4wcZ4gqjl/irDp6sM6Coo7O3JFrsulmg/Q+Rl4pvfP9c+vXkF9JLgp7zJFy3FU6PHmjbVR3RAmqgDJIbZchCbpRQGmCGA6iDH3K5eBcMt/L8KzwvyhZ+wDPFc1Hewud2koQOrmqBx74Bj32I7P3hUvoLydfT5wT9ivkZyNteJsI8KVzJwZWcJG23QKOFnlSOW6mleFm7Wot4Weuqjdamaqdr52sXazO1S7XLtXBSjS0cysb4kW3hVgIURQLnAhcDFEUChwInA4giAWcgEuADFEUC1wIouVBE5iVeKXPKeji3TqUaOVYT8vobuzs6OmM9Y7ubQw0h3Yy0I6873A1dDldHQyhiSVrHBlr7PY5Ob5358TL8WGLvhzPZxQwwrzIlI0BtGenGhhUaVkrHO6jAdtVNemFLzPXVdJmcW6DhQaRKQWcwEuSDU8G54PHgmeC54MUgpUrBa0E4AdUbInRcL9wwyGV5YIm68rMdKhF9ajSQZSNBndDIfyZ58s6+3R957TMfef8n79g0o9dEN3XGDmzvGDDowqH4maMPPPPEYzt2399g7eWdztCA/pD75bPPfvXV0/PvP3Bgy9iBU5ZTgw0TuyaPnbnwyIkn3GSiatdEW8eJCYTd2jcB2W4AvphAj5hVYHhFpVQiFFetxIjCNPJATYEK6fpCtrqQrS1k66gWvsJRLsMDh4lb4X/6GQnpraBlZ/L8lzflk/nhnre7P6nd+wbP8+SHRS/Pnz1LfutHMCfBxvMSzMnK+JgWZq8wqzp4dp2xjN9cbSAe2L5uD5yo7gb4xXgaRM5CleY6lJGotmwrUJ0f1IlQIdtckNgHFZao0Ig7YiKiAGW3Sn+Q0ED8vgdW0+nfPXFXtPfeLVtGpmcnRkYHdgySgGlzbGYHT77ID0+2D3L/0B3vSb7FrLX3dLe8Sc+vG359G9bgZB5SYGS5WYqikYmikWnVhGhkcpmippRp2jRvWjRlTEumZZNgkLIjStqd9oidt0/Z5+zH7Wfs5+wX7RQl7deA/uacbLWguZbwiqr/MkaRb8/vP/38i4/OzacTmxbuXlyYXYjHP/b+D7/Q9twx98lj9z7aJ9pn/hDmXQc604Awcy1MVmsss8Lgzmu5FRY+GDS6gP7NIqDtBaoGyXBtJ7wkmqbTX3n6I698OJsZPnb/0ftHKPQ+/MEXX+BPPrR4XJD3cd+dzBRTQj5j+cGtViIfiJxVhVx3NUUAIxw2KwIU5pB1FAT6GkqE7FTPkz4bYW7kpfT1Y+n0sevp4kNp8kP+0ok30/mxt05cgilJup0wF7ukOyDKGct0h6tGYMHtVDegcACs08JHDT0GOJtct4UsKKASDyFcyuYEimdamlCawkScDSPiEdpPGphHb4NHVz3ELZg3/62wiVqVfIX1kSmBxhFy48DBJy688sSBu9Kp6aPHTx5LjaTz6fZ2JVbZn0WWJsAU1+JlPlThTKPoXX7AseGBhoeu0kxJNgUz3XkCMGYBvEB7dEh7DAXpwAMqmuBbUBSo7c9KcYEa/gxc1lXIuumq4rAJSJXMuA5ACvykGgtZTBffhlXAP9KBn/xbb/F0X/g33+T54m5eXAuTRzs0X+GU1ECjpuyUVCGNhLOCU5WOiPDMtPAc+gzh/mvfW1vC+5uZDvW+g5RpUsqXsOdVEtL19OpR+hVvjFwmauQiQbg9P2U1jZL2XvIteMbgtm2akj2W0n8jYNqpChi2voUSlVfRQlliA8rpwMqFrQDVjVpjzQXhIID4KOwIbARyBsHSpnc2KkBCbuTb//yv+vLJ/+8vi/tE+PD8977L83/630pwwvlfxvlX2gdEsA3vAyUO9Ek308W7xL04cUnE2wuIt++vQJfQYi01VBZrycauIl8UXBq0WlNNjCJtTSFXh+auHCdYvQSTNZIwagEFzHVRUFlFyNAJa+B/s4zAVrLz2ot05trV9i9rKawu5u8hv0thxJOl4hj5ejGDGFzcojyHdma/QrasuOOqcyhBk1IQBCiePOWZo/Z33GjgsAJQQ0QxTxInl+nsit/DSWZIVAvEly96yZvFJWGCuwEnKc3T4NlS26mM5frKv52dyrqOncq9dOrkh5dOPvjM2OG9+w4dmJ87SEyPX3gh89QrLz91LJM5duiRk6VzdAXmzMHshxQatzRnXAClYW40lgg2K4F7AV2iXhhpn/kSYRJmxEviSIYC7ebd88cPaUY2pcceubmKMJue3DHLd8d6O75GYQeycA/ubaOkKyExMqLUJki8HEygBkX5/JXAagDhEnAFooFUYDowH1gMZAJLgeUAhQsVWiNKc7cdJQkFhNie1o5PLtz1IAXUyYXh97WFi20SrN5nfML04snMx18888hHjbp0LZm4BWaU9gSZVmbhNjBTewZa1wNgjmNaBeFPJDN6LhspZKO3wpTawwIEurpIN+nSlEP4yNyL5qBjdOQ+o7O2yeL1+Kz8yKbBcRne0x9waQzB8Ene1WpNN4ZtOr4rTqFP6fYv4NcDsKZO5rSwIifM21kuN9DpAuaKPrYp/Zz+uF5wwtVI/rask1vx0x3yr/pxh/wuf9Sf8k/75/2L/ox/yb/sBw3DxPgp5QjrnSj7xZvQB4S708VGujRlrNvPOv0a2MdP7dyZ7hoe2WwKxkL+oXjgfXfu3pQOD6ZHzE2xJv9Qr//Bxg/tN/U023wOW22NqynePDbb9ME7ud4mR4PTCj2NvaHJ7Qr6a5Lor0pOkjQvJBdVAv0VWAPQX1AUqFmfh22xi0IRJRWZdCYNZCKD/PDEpUsnkNIr6ZZbogoqbEEEkRqo84omDQC0aMCY0sxpjmsEC0eNbMwQj5+gugiYI4oJIiVQsNOw2MjMTkztAmR5+Oihh+Hj/90yu2eaOICU/fjgI/cfIh4QeYhCt5pajzdJDeS5FRmVAC6krhRWVnw8Jf/08zvai2P5/mubcqn88CT5LSSlP5SeramDZ/skWUul1eG+VAScisVLghdV6JBnoZxF0NpCtSrcQZGzg3AlyFpmTg1EIk0WFMFIiBf+kFZBjj226U2Y/Me1mdAAmx9+TfsyLCi36TEyVPx95A13k7GD+CGsbkjEuRvIj5+pwL9USCHhQekolvOvXBXHUqqh0F9zNuzKGW1V9BuOW6mnHlhcncCV3YWsp5Dz4vfAPHA1TkmKEbRdPX7w/f35xOlH0/n+j38c/nr0NPx1ga7r9dd5/i/+guevXOH57ypwxc7sqcDx0EdaLlyqaWCNqPLillRJDnArxWiYoTA3jUAGE8J+OL/7Yn8+Lf7f9Rxx/jFA+Jcwr8+TKp7/Y7UeZGTaK+CRLBHohKnU4SRApiKNeKRJI5WpyHTxHdBwil8mdaBv9ZL8iUu9xW0gWsH906JvUi/dX/JflYiJjjaUGhZ1bYlycz6TybPz/LtHeJSZP4v30qhsZugLc4Y08Zvp6+n9bE6yj28D+Zo+N6qgWyYlnYbnqh7qFDlInj40z7Ofos/8MXOTjAJ8ZDuddMYpWugR1S+yJ0bPp8+PksIN0lF8G5+/ll17jWjX/hjm6hR9h3mGcIRdyDMsx1L7mb7R3khNi2/EYmtrTA25wbzCzoOEuINsZQTbDeU1p8hloIdNkv9CshKqiIpKGL1qoSYTUU7P1VYj8sOBcFJe41x1Iq9xupxRZ8o57Zx3LjozziXnshN4jVsYDMhFYyasVCRooFxUsmQNirY+Z5OoI9pmdkxsTp/WapJb06N/3tbaOb4j91xLaDRJPhwa3vz3/NDQUPLZtuZwaGkmGBzaIckE1NdQw3iYDzMlAVvlhpEWiCqjRtgmoPKsk42wPDvFzrHH2TPsOfYiS6k8e41l0az33l6+XB0aAkH5pfAAelvyMiXiJcsdxYJMc/OWyaFksoskx7bMnTg6NJPODFXP7pja09rXceqOu99vZetFvkX9J4uwT2pbkLSI/zu2oMWRLQcePrOwaSjd0L5569bpsdFg8P67733YczBVs316djYk+scuw17YmIDERZA9mJTEVVoG0gVNOYmSrDTIP3LVOo1IUDeAbVaOijRUAWqg2JZAd6LSaBpP2EsLupkBPGN7hrccOrGnq4Nt7R4ZHUoNRthG/t2/5uPxU/NHz1hf+gPL9u3bZrsl3x/dEwvjYh5TeB7LlwNCM1W3dbgOgDpsYgREnSlmjjnOnGHOMRcZCnXmGgNQZ3W1dMq1G/SNi1ElgnDdQBr9hEef4F+NjYxN7V88vnfLbPEnmrGXdYdivJ5vHWx5+MC9p47OBzbv+Nb9/fESfe6APfIyL1c4LSpEw9NiGFZLZrkAIdTYQ0lc/op2VYsz1rq0UW1KO62d1y5qM9ol7bKWypp6amGlfs5qUefDwBxRAKgRBYAcY4NhJgf6OAWcQypRUgNFR2cHb3O2R44dozJ3emY83kNuDFb1dAb54rdAzk7yjtkddsFPu7ZNPD9NzOcUOo1BiYc6sYH0l9KE9zbi51htkPJ5K1cjouUG7GI1G/PntSQUmCpYYhKUmJgVZ7AD8XXx8PCOOw6lB/nRcb61Y3x0OJVqNTd0nZo7mnEWnz5xl3nA1k8+V7N9x/Yd7aU9/yLsuQ/Qr7Rmk1L+kUCDfj7pVHqh4VULmTm9SUvXLptwBdsDiMQOukjHqgMX6XA5oo6UY9ox71h0ZBxLjmUHkCILJwhCsg0lLrMEuskYgoDGrQzpn0n3wz5HGzfFqFz/w/RP+ifSP+H5H3WGhv+FF/1WeXaYMZTZnct52VUjsQrsS22ARmFZmghFNaVGn6baRNRts7npD8Wt4ss8a3R6PDaHx4O89McgD5yF55vgJC0wt7IaFMd0SuKgQ+LgFnTRakScamd1pJqvnqqeqz5efab6XPXFaoo41deqBQZUh2JECRlQmYgoJprhk5ypuq7Zlc7MStP17dmsSZDOHvI8f0KaMSvqXfNMHeNg7mZKQqJJOUWDUpyRsADDLW8R6hnhRItIIBjR6zlJfmyMiAZfKt22yDAm039wYSDf99Jr6eJdCOPvP8fy/LNZOL5/T+mubCelcWO9FXC1ktpTaTPTgjoo3FTWBT8FNKGT+Q8VsEV1BiqKDNiQgyxpowMaHeWnw0ZPR67OJh0SpTmZ5bJe+EMMIs02FahzyYs2hxANycy2y2twxpFhVTwe6qMCTCyxdadPk9rZPwgHJhwa6ZU/KOL294+Pjw78lOf/e0dk9J+lDwVdAJj4gDW9B0x+TbrAouG2/Nyvs7B0+lFN+cFP8oOD0sEX5y3FpV2+xd53S3zC/4G4tAf37b3nfXfsPT42Pjw4MjLaP144cup9h489+tCJ2d1AgbdPYSzUNpwvjQF5RhFRKc0XtSKpgRKTRDjQtnqLzVwwBedq9DoKciHSF9bpdrojbt495Z5zH3efcZ9zX3TTdbqvuYF12S1uOlgnyOJOibU6FVKq3p4oia/UyXRaq+0bnt5/Ynd3B9vSMzwxlEx0P4lntafn4TvvftxKXvwv5i2zM7vjjMx3L8M6zYBRz1WgiaqlycpGuTtgAwFRVdUeIRx3A9H5Pb06RDMle9UomOrlfFpmq2mJn8IqvyBw1Hf/mdwo56VaWKON2cmU9CSDcr8qyk+Sob9kxM8aMaIix+mNQoRS6YCXSADR2m0TgTRuBhuZMHHkkHbkJyjuDA1pYD5+jFm8DNrwmQonQTbIaJBc56/UrNYgqGpcNdGaVM10zXzNYk2mZqlmuQYYtIdbaUToNzobI41841TjXOPxxjON5xovNlLoN15rBOhbGjUY+OwRIgmtlS2GIYVlMRzp0vgPbBnenA61RpNGEIDcsaj74PbNY+mWtrbBRI873uYhvXzacaTf4PFydlN9dbXFE2lIjXgX+g3ehoCvXm/xRkX+8HO0ezxWwaaHSrm0eJXMJ7M0QTvPzRpALBWMHwyGUcKqzU5zxMybp8xz5uPmM+Zz5otmumrzNTOs2soYRIupYNNLoI3YjEhkr/qd3lEQSs+ebfY0hlp6YqSWf6A2wxfXfG5LgpKrtX+m/Bf2ycUcqKB5Iys2KBdRnsUg2aDE6RuqWJHcCnYbLYf+axJSqj1D2BRlx7Sg8MwMjaYzHaGJdvIAFWoGBoYHfsYX/6Y7mBLsDN+DXx+AeZokP7aKJ6golQxSpf0xZ2CQEajMkPGSRQ8/vzVytvdSzz2a+zvOR2EefPH7JCDEMdHns/cjTzqjjp+6lZygHVJFW25rh8zVEKSXCiNkzip0qeyPLXp5tnxENW1NKELajwwLcz9qil3qvQuX8NzQ7M9/Lqzjf3VKqym+/HPZ3wjraZAi6VTnE5UvFb5qyin/uka7nKlG0I4VjtIq0ftHBQ3qjR8hKhtjSDQyCsty/sWBrkvJD2QG8h272f2xS90ffIzP9+z619M8/4nXeP6xx3j+k5/k+dPCvgBtp3jhV0W+SlP3QcNXcStUBlXZPOeTkdkgWNLVolLOXUVjZEFkgIVQi3C9RhSBh1lejUtk729ywXBfk8vtclm9Xp9ZL6MWeaD4UvumDmdVUqd393YoEU3Ug2E9ajulCs8r2SmtgutBg77fv/rtNOmAX8W3O8nozNnO4jdmzkq2QmpXDEkyrErHRoKlQ8OaGZQB0ZvgxthWEDT8mP41SOx4gIEXJ2JJ+ExiD2jGtir9SDjid3bHkqn2lpb2gWRPj8sXCRcMiZ7X/U4+2f96R6Qv0nmlHzTiwJXevhpGsptm0NbZUMFuWsrpsALzAUrGzv/yHabiWnD6JiX+6jDSwlJhLV2ErgBDzB2Y1GYXViAEndNV8SuV1vL27dfCMK+Afl/PuJkIc9VA3ZNXNcShbc+ZNKIlIVfnQB7l5gSincDsOieGSvP2ekJzczBSVu+JuxvazOZGmy9h9fR6Glrhb4c3af1vHqfdaLS2eDZ7HDb8Q5BxImtLzHnAG5onN6CWAOja80v6ZT0NcdWv6jGcVO/SR/UpPYa46mf1h/UP6WmIq5NSl1IUt+OsMjcuQ04pAhapXPVZWG8R5Ecvs7sCtqqsNqrTJ+tu1WKYEwba5Sx2tFoCkfB2YyIYDYqW07/MAKIqvV0DzNy5+pnP8MMDaU/T4NDAMH/s2P4D9q9caziwn3UdTFWzxT9iQ+kGzX7yB+annzczYg4L2v9bmAcq+Pf80PALVjIb7FePFSOwskwhR/xVYiCekcopxlUjyilGlzFqTBmnjfPGRWPGuGRcNtYs5HpscJ0fRcWsjcMAPWu83GxJaR76boUgLhBDIqHoEHd0Zuum/raeWML80rOasR/0F5dnNNOkaSgyvcP/4KSpq8M/E7PY9vPsvvOxxILbirqzBWj4lxgPE4Zdv+ontYBxLpqCAbTJqacPceojKEJH+HAfzTbCIE1l+uYTbds8nm1t2yKJZHib/Hci8o1Ed1cy2dWdIF8SOmbaZjwe+BW5L4Ljnu0eHOzuTaUkGQJg28R8skLkjSpRsAEaDRTQLmpxuKpDh4HJFXCByuOiAAflJ8B2s5qFayZdQNet0yyoQnFydQ2IIkplTofqPah09kLe5A6AVpFtwJNOtdlggUaANaLPMYG8RunjoiFT4g8VxaPnz598MP5634l7kpe6Tzx0/vz50d8bPZ9Px36f57/+dZ7//Vg6NsPzMwD7NEA/g3mpeoD+rR6lErpjSqf2OkaRDrFxeyadvn79+rHr14XYgbUlcifcp5fZxMwL9+mCS7tonIOP2IF4daGskL+iWdUg6mlcmqgmpZnWzGsWNRnNkmZZA6hn8HVRwtJkR/rSL7TGsQXIIFnMUQTWOyqIwXDSJETVC9Kywyn43sPEEIl0DIwkXX2tnrHOA7MgHWNHwhOXOv4qbPG3Opsb8KONvDRT4w81NdsMDn+7f1OoKTkw4Xx0ezXts9bQvvGWID8w4Tp9yNdu89rMhvq6hjarD/7gmLW1NVBtQJbu5/Rkn+gj0jDutW+yvwf0nurW3cxdCpkFaP5VEzEANnVSj9DVIIkItqz31p8xgyXH0F+HIvSvCLlNDA1Zxwfh/uqFj3/1qx+/8FV++TfOLi+f/Y1lcnlw2+EHHj08OsI3R6Z2zk5ODJP6l77ylZde+L3fe+GJT33qiSc/8YnijZb77zz8Ps+pnbUz09O7ougHy6MPrtwPpnKu65V+MP2tfrCqf08/2PBQP2p8bX296Tca/eH40PP3NLmjraToH+S/GYtE+rofDgcagqeGvJ7AHppXyzBp4BGLXJg8gvm0jzB5kVfagFutMToh55ChNGsIva3kcvot/h/yeC3mJVqqGErDtSocSDIjkl+tDAvcIhYE4DdPEhvFBSFQNHcoQJRowfDwK5rgxfzkjgLootmuQjbAZYcK66OKVR36JMfphLtJF2kncpxOOeo888r16Plo9PKeLZ0DtTZjvG2fyRg1e1xNfam+rsTQrUj0k1iMdMSSychQHau1OPfEgo4Jv6W7qSnkfwbzmqm/9UesBSC/W/K3UgkTZCchLi2t9tILMNyo9cm8zvI3JRKb6A8f8vtD9Idcph19ExN9gUgkEAyHxbgpv5jXSq3VV42kTsotUee3mhOl/FY9SLmY45qHS7V8JgP/fiTnmuSJC9alzpNUxSzR0/Or5Um2NFbOk3QV/8fdD4ejbf7YwFR66tgd38x3jix2eL3G/vlgX3viRD+jmlOLlMWC4abSnELQCNFDXIvpgUzIRREtxG3EEbyxLEt/da0gad4+r1JkCbGRnsG+Ab890dUUjvpi/ERqanTvwS1jPb+w+/xuT6ff53Qb27YEe9r6XSw33j1gozjmBxx7HX36O0H6ZSS5HvVLuyrWtKJkKAUpqDUc2fwgGqcAHDqnLqLjdVO6Od1x3RndOd1FHQWH7pqO+rNQPDAxGIBqww8QIc1xM6Vc5pL1IRKyp9OuoaEmSsg0zXy/l82z88W3x4ZJd/FlfmiI/wcp71CIB/MoLKOwb6gZovhBb48hhVQFMtP/83ML+w/+OE0dRYvsjq0TO/h3P80uvPtpgFGUucQ8T3RWPWMB+FxigkxOY9C057s1I8DWcydBQ8h3G0YM9G8D5UJwjQN0nEtMDcD1LjixMj6h3KGT8iGlkyvkDvNS7nCeJGPFZcku/RrZ+29x3tcjd7aDk5N37J+emhuLd3X29PS0x8n+/YtH5g+8797DW2amJ6emxtS84DTygtOUF2A/w87T2gvMB8TaC/X4/RnSsbZd/P4p1fda+j3zKFmUvy/g91LthmfF6y+vbad8FXSjm4CLNJdsWlg/po8Z8OCBmpY71AKCu5AVlqcho1RTEiJKDVJEKWpKgdnA4cBDAUwGlLPAHPGSAxzzxCJKDerN26SF/fw90sJAFhLiqQqWMFAQuqaP0roUFfo/tk7/y6r+Vbn/46r+Fbn/lXXu8wnaL+RZ0b0Abb1RyuRYP89KClS72ki8QNrr0LCgsqvr0NKS664D+HvRaGjqFhIetKLTTnDR0LA8scaJkIxVMR8mIadm/UyVGXN17J2GJy5ihlYpQ+bsWfLFnyH+uYFWfZv1wVojuNa7gJ6JeAk6I4VBqxL2t/R/bJ3+l1X9K3K/BOMfo0+Rju8U798hjWfeUvR/TOinNkjmuqL/ZbH/b6D/O3j/TvH+8n3ID2FdVcyfyefMhzgQE3FAWKcQp07vGxfnUbn/Y+v0v6zqX5X71fdfkftfof1IywT9tZbWpmC0GkFtlStjgG76+c9L/0AN/fzn2j4H/6CB+sB1uOcoY4VTHWI+qqbRKhKn4iQl0ZnGjDjMeiE0h3qq8lfcq26kfm6XO+pOuafd8+5Fd8a95F52g0Bg5FZ8yIZ8Tl/Ex/umfHO+474zvnO+iz7KhnzXfEC8G/GWkveBd0rKFtXAeZvTitIhpZsRjcO9dGor39Xau2Xp5AzfE41vG+v+u+jg3MH8vkMd/9BKA/QbN3u2TH/oqVdCU+6ZrR+5Z4DMeU4W/1Pm2KFU8YpPsad0L/pVe1fe/7F1+l9W9a/I/a8I/Qo6MFTCddFv/3GgAzagBAcrRAWrOLyc8mbHICQrd0t4cC5gIlTmElT6XMAuBOeguU5ObpLy8KgoKIvQNF3kGM0lmEvnv0PTCQ5hysvY9OSOmUk+3xbr7VgFXCNinME4s6SwjqniM9cXTjRKcU1TCuOsFhLldIVcmDEKelc2ig60EYpPI6sjiE8jrpHoSGpkemR+ZHEkM7I0sjxCuWlcDiMaZnFp9azAT0qOKqV+Pszyw/BB1c7MmcHBQVfrQGhqyujwGG2eSMTS7LfsnW5ra+/qCbeGzSGvudbsqKuzc4Y9QDJJktf2bGqzjvW7WjxWg9Fr83itBqu3yZUcNfab/C5/g7na4m5yWRvs5upqzuqxbEkM0v3H2Ex2HvZ/M+7/DnKKqdS/c53+WVX/mNy/S9XfL/fvU/U/LPffQftpLSoqKwAOtjDdTIL5qsKObVDa8m4bzXe1hzT9CrFw1EGdq8aPbA/yKPdGHLw5h3ClT7iyicuGUaNpL1DbYIx6dAS5oVzdTihiLBr9JCJq3+FEC0bVkT+aGBufPh1np+9Kj/55d3vP+I6ZHfe42L6DW3YVf6Cd+NpzLaEtQ7XEqj3c219Fw+3m5sTwVD40Pn50PjK8/TdngsGZJj9/emCA1r4S4tIA1lMi/7ss1cQCOZbu5RZx7yv371ynf1bV3y/371PxPzr+HfH+Sv5X6t+p4nOl/lkVX+yX+/ehtFyqi+KB7V2qEI2uMgGr4nlUhaXkiik2KsXkSD3G0mB0IOOFX06vTfT6v7eTmoawh+FclziDaFGCXr1TSpQH7hD+yOTg/JltU4GR+47etW/xwf3xbtbat6tnfGxyYGhIy5NvJYIsr4knw91H3jj1Gw/smrvHQXZ2DB0cGx+d2XVPYwP1C4gywBfx3O0Wz11pT15CWO65ZW+V/TvX6Z9V9Y/J/er798v9uOeYE29T6Px25qoGjTYYgCZYANRBLRHQ91sU7d/2OB0er9Ph/m1yuViUGuMur8fh9Hg+wfNfFv+k9V7W/oa8RP5zBRlBFQ1n+L8lI/CVZQQMnnUiFugdtgf3paLh5kjyfXekWiPNUX7M8/mGtv7xpwZH3J9vKBw55eZd/ckjxx71pFyD/APT0Z+ap/5px/bN4XcseDYE2zzdtzvFff5Exf6d6/TPqvr75f59Yj/6X3H8gnifZ0W79ja5JtGnKnj2VO57VeCr7G7WYgGL/JXgahBBHnQFo8FUcDo4H1wMZoJLweVgjRT7qk5uYZA+iyGu7xG0AyfSrgo2kkx3Vrus4GaE2Hgab4T5nkLQUZKdv9Fxau4IjTfiaRpF8ce/NG/ZtWVPCS79Mlz2UbjI8tRzsl51UaSFAr+zyPxut8gHy/WwZdX4Ep/dg/wR9DN47g3MlwoyT1fQz9A9rqukrMlFMYJoUK5QFMPGbSByLWe26YSIrpWGstoZVSpdmVcX0jgybOfsDk+gqfe+PnVFjdZOm7U2bopGZza9KNTWoOuHdZ5CniWsf4EWPBB0DdDlCrIuJ8m9Jd40paJr5eNfXmf8rGr8NXn8q6rxw/L4vevc/8I6959X6Ip/iOOj4vgSPf1Xdp4LM9PYvx91KFbS8RgO5PA7Kng25XQZDdbs6aY1e7o1IF2LRR6MggNW8KRpxcICNFnBg8KKT6iBhq4zUfpODLKS7I3Bken0N176+Kef/1I6vflk5sHMZCbzM361VA9jlZd58WXkxS0SJVbRA1WEmir7vGQRpPVRUe6+JdCwgdKJhtUGpBMNroZoQ6phumG+YbEh07DUsNxQQwMNG8Q0DDnq1YW+wxCN5LCLgf3qvAy6cGWg+2I6rcrOyGTk/Iz5yVhxjo/HH567+zHr3thksWjZtm3rzu6S/v+crP9fVMlFFlku2r2OHWF5Hflqj2r8NXn8q6rxw/J4CScF2uyTxy+QbzPK/IQmwL3fVVirVYFA5SGgV0PEJ+Rhv7eRNqevcYk7toGsBs6CWQ1NwjUubqWF7nLLagvucourJdqSaplumW9ZbMm0LLUst2C+QjmRKctMga8ighh9cFYiOEPEE7hTTlPZPDYSw0yVltFBgfA09yfYajlnpfU/YtJKhX26sM4+zZdogah7t4u05h1hPIU7jp8ppzWq8cvrjN+jGn9NHv+qavywPF6mTWvbaB6yPP6AavwRefydJTwT59NRbjsAGfMH0L9N7P8MwIAVx/tA9oowf8iUYuNUURfGSgQAA+WkRhM0mgxKuaGcNFxtxlp1TbfaFfJMNVcNuNRDs30UsX+UmAgBag5BVhDonlBPOVjINhZyPc1kIc80c83sAs0FbimA/kYjGYX8H2XdlYSq9oo9Tn1UrI8aJoQCLKUSLJni2+QBmha0uoqxsmM8P0Z/npycVOTDNDGvVMgxUAX0ylU4aCMAjYAgMWWZ6xhZWFWqDJKrtWLkoxX9RWLir3Ej2T8AGwoOPwVHtqkgJAiLnrj1cgDoajNleTJpciM2ORl7on8i/T94/vudoeGf8ryoz/0p2gs7RXthSc/7U9Qp3hF1ig5ZX3wL6WinSEeV/RZ5/G6x/wfQX1DYS5fFflqd648VeuQeSe/EXFqfPH6Buanop+dnu7of9ddr8vhXSScj19SBM6POFSnPANpgrgjm+Ii6nOCT4sTnMV2l+YEsOMyJ82N2CP1Ye0ewF3ep7cWwHtSjiWSjkddPZUcY3y3Sg/8s9ws6wU6xv8R3LuP9e5R2alF//0fon5X7/fJ9fPL4AyV+JNoBZsX+DsX9S+NfU9AbA8pCwvj9dL1yLhH1c7mZ0Qo1A6VKP4LOSTkKZv0pNYc6ucYVUSidOlVpHeL2OpxeH6iexb+VyuyQPpfPZ3f6fH8n19sR5tOAOUPqXLDyrKFfPxfs90u5YJhTRDpKuWClmhZyLr4qLktOOoaH5lgbFg7U4EdZxJXwlVH4ipEL48C51yfEdCo7bxfj2QRqd/481h76I66PW+H5T4f7wn9B0+SFWDHmawATM3Mk56klCxVSVnGWqtxceZacUN6QBSFWI/6tIVKEWK6Gk6YoxncD1KQpwgTxUE1OpjPwAwer1hP3vMH/iTfuLX6fL+NvsXKbOaXLsg1lZwlvRf4ZE/H2hnxevoi6ye7y86K6/4V17o/yguCDRv4ZZI4pMuOk/VMVZKkYmw947ge8quVKPmsxJS5nq8Liy4oqED29OkcMizSqCh0pS3CRUX19dbBZoyh7BJ+pSVqQq6FZUfuInIEz0DUi1OYiAn1CufJ3KlRtVQVsYwqXJGJisKCuTD2lWuh75/iqi6FoxeyvnMWLbxrwbkT+BICYFYxNkZWkSIMlSZHFSTliUuJjkAxhZpiUKlb8hpD+WPKHPSf7wy4qdMKXkI/tUekD5f62ZdX4kk1uzzrjP7nO+DnRl0PH/wvgmR/k2MUK79jAKHpjmdxfEucopump5Y7aXWgSSDfNr0aXrkOgraZCzuaop5AP4GZg5cpKHtyS8qWJ8ZLmRS6TvbIz943x3Y88vXRm+8jH7kin99518BDrk126vb0X3v/+j7UXJ9NkIHXy6NHHxfc2XMD8gFbgapcrRCmr0nHk0iryuunq2kg96M7VTlQ3ndyKBZHH4rRELLxlyjJnOW45YzlnuWihyGO5ZgGB04aDcx7hmib0dEco2kZWI4i2EVckGklFpiPzkcVIJrIUWY4A2nZQfRv9QQoPQFzpJ5DiLgA2OlRkbL7Y5rajvWz86PTO4k3N6ObR4dGp+/vY5JE9R8aG06nBx/khVqNbAHJd6N3B+3fuFNSYwZY9e07et2vX9h2fnAwLefgiLRLsTclbfNtaxJ07RBq4tUxmSJbzdJqPJo9X8nTl/S+sc/954f5iHSo6nhfng3Y0Ib8Mx8+V7I4Vxr+8zvhZaTzM8wGcPy/6Pj4gjIf+vTj/OWX/Lfe/sM7958X+ksyTUvlWqMzzc+yfF/sXy2SqVAk+oiyxGXm5W8phXL9q1L97uhlV9134roKKWWf0tR2YeTZy9zHMPOseC8XKs8/g4CpkFKdkvZKqvKnpCwaKi8Xqcz2U//foCBYxqCqr2cdy4ntyRDlOCPtOyKW5pHjvDKgpQoGuDJWzv8av0hpdq/CHLMPfxDiXSwp/sbESTFXJX3JFVT2tlJ0/qf0QcKncTi3MeCeQxfxJ/Yf0QvWFagp+WupV0EP1nGiBs+FWbCB11ssYpcw/zKhLyPuAP+JefK5rKC0oZZlMoysQDPXE3sefwI04wd8t5AGqYkP6lbEbot1/TLb77xLs/uL45+TxF1XjLfL43arxpbiDZdX4kr9hzzrjP6Ea/7A8/o51xn9ynfvP0fGCTIKyVbtk6VKdpig0olIDjRGSGCLr2rJl4tepzubZWPEbDz1ruWAT5tPVoQM5UpAy8suLuukrWr7UZd6mkjOS0WuMVFeX13zbetyc6BFtXoMdLBErwCEchXhOGY4LpfgQTR3CfVCgt2xY8smy9yPcD4j09p0yf8aQSJ8vV/Qjzar8JSvy+FdusZEOi3xBxgNaRwb6D4p8YVEx/po8/lXV+GF5/F7V+NL9L6xz/3k6XqhzizGWAWakgqdZcsFcdVFND/S9eiH+gBKv6gItUOGjNpmsnxpZaE6YE0sCmah9RU/TwgRpE9MmP6Sf3eG1u82pmE732OPG6h3TPhvniXXp6/vTZHFuQctrU1tSsU/dc1KX1G7b/R9iFfncgXX4nNRfzrcOrMO3Dojrp3VHMpifO7fRqiP/P+uNKGqMKEqL4BwBN29iPPKsEPOu6puX+7TQ92Ps2yP3maDvBDuMmFAv9gWhr8A+jNRGvh+s9zzG5i4wbyme8U/sGFJJaZyf3CBN+Iw5Mf6eFL9BbgD1oTmPTer6brlZWgiauZ5jqJuGwVcraEKReD62f5LcyFA4c3Dta8prJS9KbpahNbrhWsodGQ1eC3z49cn9MXaeXlu8Btd+FmvFhdSZE7lZqkWT6/hIIaUXLtaH+LgzFHl7IL3Qd2hokO3emcnslO7zGXaMsYJEfbWKSv652Sp0KVFexnULsVEFUORzs1QLqEPWZukGoZ+K9pRIxVGgpdpVqHjN19bodAMNM8EfLpe9mTOxvhanq3OA/hLh9RprgTW7xBpzuVlCMyrpSinI4MZwUIrfuH6dtcQEGH8FrvltWKtcT/nWenwm1JBr6N0ouCkMcB252Rq8pZCVGReyMot/p2vyBxp13bp0PD4EkmpTc0tjanSU5r8ReNYBdpippbksaFsC6ClMNWuSlUZZqodhi2/AdVm2H+OyA+KV4jSoWCa8/c/A3WKOUsZHFN9w2W0ut93q+oLLbnW77TYnW2dzu+gTreInfdZ34VnPsg/js0yMmCqjoQlmZfdWhHUXvxtrjXT1tkU7YzaLzWKxWuxsFHYt2NjWGjTbHZzZZqH3fhvu/T3EST1wgXV8/TKKgmgmYmlWU8jNainiCIYuiq4R+LlvfH8sNraPom0mo8LbZIXqbUhO8O4UeQl1EiL6o6g4q8NzwOOdnQUJlQ0CKsPe1cK9D7NHELcqnkV6Avl4HgRYcuMs4hZ9gxTjxty/Su+so6uIwnCUb4u/XNu2tgu4oQZ2uHR/oH5oxcrPsodpLgd9DH1x4024Lnqe4u/fw3WnmRp4Qlph+6EpzQb0dZg3kiNCbTribgIEpHdnFf/earPY/R5fL+fzplod1vfrjfUWy/auqhZXc2u1sMYUPP+b8Hwzc1ghl+vK1QjZmkMbG/UB0jfj0drp3HU0JJbHBSTiadk1N5vubBUFknRbXQV546PryBs7SvKGavzH1hm/UzV+RR7/imp8vzx+3zryzEfXkWd2YFwMvmsPOGbZu/Ya7Y1ksbh8U65/tMoWKoxhC+/2yGPIKeZkxfcmEvreRKDdJ6NTY2yYvgWw4vhS7XcYbwb0gOHkVJ6+Z9G/lq30zkA/jJjF+yGvO8X8LX0vKuX/XBVZzJT3n8D+E2I/3JPomGPQfx/235cR5oXvocKcvkkFnqnql5bH5eYOCWREGT1M35tB31wmllQNoU4av3npUhr+kctCPeG84nlWCa9V1uaKirMYOhGooc+oEbROMez3EGUXgSpZh9ag6Rlt5KW4CcljRvPX8pcu4ZzgV5r/OX1NI/yicGhhvsZ8G2BZy4SFzKDcISwaQH/10F8PYdNA52Aoz1Jt6Yy2dHZGwx2Ea+3uamnt6mJorB3Nef9nfG+jEzj+XQo955Y8fNrAt5nShgEzjpXvy5JfoiW/Vkt+g5ZQCoNfhz1VfO1j3udy+OAP75eEHodXemGWo+yTkeyW2tdueTdrRHg3K5ytxzTTa0IN7zSTBxjqKN6ymE+QALx1hh6cfPDBye+88sor0vlSjNMydBwf4oE/TNJxD6aFgWSNQvE7SOcbKlhFpeAp2AoSIt8pXhwk97G+d38AF2C8S17OuVq39r/+/0jtf9v+rVv20OysdF9PdyJGqxof33f48M47jh7dk56eTg9u3sSINqY86Da+W96NaKz8bkRrCKBrl96NGNHn81+LpdPpxx5jHyX1nd+/Htt//jz5TfH9lfQdQq3M5xXunvI3eV31kQaQSarxrcg+LL7QraM4j7/wxTji2xMtFBiWVQsCw+KyRC0py7Rl3rJoyViWLMuWmgXxVUk6DPZp2VC0SVML1jxt4IRC+7RsA315sqCMYbo3ZdBYv0EfktkVzSYkZHPtmCVzbPNYf6j9Rf//rP0xCIQ1f9J0fnhq08Q9j3PbbxpNHBfbd8JzMFl7LmY0WrjYOU/Kfd9eAeaaYcwzbGeuVojfQh+IUXlCVbXPpWxwlA6kBhqxpUYEGhHaqOfWr16fs9VXlfmD6LtOsFpPLih8h2+counPGAmRbS3g25rLq95jlXShnI9VDvwTX5yVTo/xpIMfS+fZ58+0PqSpjl0aqBlYepA9/cFYTeyVjuofEe1kJjNZ/GWMOIt/R8x/HYsRbaz4U2KMQV/sh3h238K8cU1Z3ji5/BbGFIhn1lJFHpXseKwP6H2c+TOmBEOJ3vdCo7dikVlV5SAsqVhecVZloMz2bqjy7HsWnS2rOk+LkGCxoRzjE3LiooWcqZ0qeB3r1aUtr09rl8cIbdZXqlebx/CULeOtUd5Q296Wv7V6bamGbf19I2xbPIjVbCW77TzTKJ1pVdVOVT0uFShVjkq5bqXwKiRhkT7Z/618IxLLie5ohmqUZjQ/56+4Vl0IbZfLFXWlXNOuedeiK+Naci27aJ1fL1lQJg7eFjj0m5siQPbesXko7W8b6r6JERglGFjvQdhgRIYSBjmmxE4lGGC0wfrhzhWra0keJ1oQh6ELZFYZXCBoJ1EmxUwz88wik2GWmGWmRpQOGC1ihuCxLyueL7xAiuEIDU0XMEmChnWdcsZ8XOwJ/2W8WyxqvHdLW2usBv5sYRvVhY0Nhnf/Gv7+vkE6axcAHv3MP1WoL9UKjVapoXL6NkOjWWr0QaOvIraoDl4KGikl6vTBGvtuizoUFZRveqhVFnqmOT0biDY3hSjEm2F8D57VZAHfidiiQK33On9qlCM3pDcXqA5iRQysdBaVGKneg19W0MTD0AhLjSQ0khWjy5BGGpQ0UmXIu+VVULLn/pbCcEmMPZDeYmqX3mI6bZiXX3JKyaIRERQjkas41XujTFLlOIdYrFWMSHNxQnWfHNMoHPJOIIw9dHN6kTBKSPyrUkeenad43ini/i37Qk8COy8i/e3JpMEgxmx9mS2IMVsRIWYLZFeMlUJ9VM7jxBizKhrDJdpfv4wxTu/g+M3idTvF63bS66S6n1g3/elfq276Bkumb6xa+nsUStfyVTXNjSJNGU83h8mNUQKwUtCTOtHXyT4Fa4owMaB/t2IxSowVC0SrlojcRWrI9Spljw5ttGDdsfwVbpXDxXMuLsqluGlunlvkMtwSt8zRQ2+leEWJhA3riVP3DbAfMVrUITIYLBhD5cc2kIy60SSpfNXCumCxlorbkoM18lsYZBQUyG9aek0DJp3gaxl0hjJa/O4/Cu9tEGGoeQhgOMJsJRpFLLcENvRwSY12aLRX1LnxiEsNTH+VGj3Q6KmYZql6XRwSGZpHxYhKO5FfoyBmlRiQPIPALrjGhLqhNVImMENLsbk28pKvnKmJbhMQ6Owg3IPLjhey4920yPM0RvhvnARU2jjlLn17Xcqg3r6b8qs1Lt+WTKg2tPiquIl4tjUvwB5uI3srnIJ+aPRLjS3Q2FJR2FCdAhVznYDGREUxRJZqZZ4hNbA2Gd1OVrDiqQQO7UYq0lBBRCnhbsGUufwV36oPL/K5fFFfyjftm/ct+jK+Jd+yr0YoxkT5rVCc3E1DiKgeEkU9RKpSnm3FCk2dBcqce6GHptlm4wVBOACVchR4xCaKJBNIq9YNYv612EZZzPN7sRDViwM2wkxkvxPl75Yw+ZDgh2ULUr9mN+UXQj+zg/aLfu55SgeI+F4fPMQSpsShEZcaqsRp3GipMQyN4dv78mS5VsIU+bWaG/Ly5Zhh2KLh20TkUlVIyNwRxFg7J9DfHOOHK0PcShvForbVNsSiNldbtC3VNt0237bYlmlbaltuoxSik25+F4wfoPGOKofiry6+sfOSB/L2ElzJO/meYpxkh2E0T+M7ESZJe4VqBapd2wSNTRWZoSqJYv39VNnyVVuoeq0AMoz1XrcgBOAIG7ZpI+/cyDEeFChEHmpVv3ygQTrfIVXMA7Br4XwLewiMdwAO9BARsKfs7Q6/vgSoicpvg3j7PQ+y9KaIDcuE0jsfYH/7mL/+9fVGNAxVpN6lKhXQ6IZG97+LRpnz1tixFCcnpIeIdiGgvl1IfWO3VTJvQ3vL9c5ywnqrDnoLLWUUMQyUVj6pjFlBmngEaeWTAq2U6tEIeVUgd/4RU9JpTEqmaFAyxV+BIm6QCIYB8OHbEMEc48BCSStNdCubVptwK5tcTdGmVNN003zTYlOmaalpuYluZQs9E5WJ3K24TxaVxExpAiknXwo7iCirX0AbSJeEzSopBZlKRSVTVbQDrZTvrWRKAVdqJdO/ISXTVEc2pGnmGDeMiXArYRjThvI9Ep3bKJUyWltVFGhRST1EbP5LibZUIBiiQeXzEk3BWBF2HrC1UPJPy75vzXU8raUIEYzywBgRuOY15TWST5uGlpgYVWRIQbim+AZck4Vr9Iy/8nOEkoyKsJDx4cXYfaPj7KdnMpmZsnt41fElNLTEJISWKJzx0g2eEW5Aitfg+s+wq4wVdOWSGRGuR0pUFlry60SVXChFldC4Bfq8z7Ir6vgLk+Rn22D8xTUp/uKiHH/x9C3xF8I+vsY+h/5XMYbFJMWwKMJXnovBWND71y4DHI1SjT/JJ0oZ7y2BKX+ra/YHQrpu3XA8PqJlC3JgCu7JGtzrAHsN1mi9ZYXqVRXXPDabh/6wz8jvZyp+lx1ZexbmQmE0pcjeEIJn7DSlnCKHSXUETerDp1/I0zMJBK7bXv7U94o3OVcp3gTW9D3Ebz3QnYoYTg2ALCfEMYlRJSfGxKiSAo0qoedkG/nA2n+8bRzHJSGOA3hGBK44j7XUjjEZIQ6cxgdD+yxtMzytMchegHYdkxbsPswqto3YTsvfj8jf57E9JreF7w+Vte8W2swakydJK62FO0n9locQcUTb0W2/I4v0O3Jvpe/YAn53vMJ3GZrDCN89wqRhDTlOJwZdwwDV96fF72kMVQ+j+J7mkmPd37RZqPubBhzKcTQUuof+4mrpX7XCI9XXnMZrTsvXSPfOcdTh3lMlXvO/AbgtI/p4nKWUy27TQBSGfye93yRoBRJiMUKialE7uZSClF1bKWqriFISVWxN7CRWXdvYk5q+BU+AxIIXYIfYs+ABuoNX4A0Q/0yGNi0FRSKW5W/G5zb/OQ6A+84RHAx+TxBZdjCDz5YLmMS55SIeOo8sj2HG6Vgex13nveUJ3HK+WZ7EWmHP8hQWC+8sT2O28NXyLPd/Wp7DYrFmeR5vxxLLC7g3/pTZnbFprkJTiWYHS/hguUCrL5aL2Md3y2NYcp5bHod0XluewAPnk+VJvHR+WJ7CcuHU8jTuFD5anuX+ueU5LBdvW553RPGZ5QU8HnewgxgJzpAiQBc9KAisoI1VPqsoo4INrJFbfJ/SVtMZPXzkXKU4Rsa9Bv0845mbS3I9sJeMFeOE8SSwEydnadDtKbHSXhXVcmVjTbSCNBats8TP4/Q4Ew3liZU8z6XivmzHJ6v0a1JGF69Mel1QgjfcDN1XsahsJOQXrKeLvjFLufS7/dAljFK1RI18U4rakAb4s05ZE5c11MxxRij1iEWkTB/QJDJGkimqpG0eIKC7FrLMa5OBcOSnWRBHoiLLVbHdD0JPlMub7nCi32nWr8tg0uqs6xeCDJcXGBFc3orWLvP6bJRr5BG06IzYdqlbOzhikAlXqNT1/BM3PRZx54b2SjlqX27SHPxaYs6plm6XR/XooYXEftyLxG7fy2Iu9Bwrxq2hxOtvM4meUkmtVBoet//zbdF7IGvdVKXMZGkpFaNoaf0L4UM+21xHXPmm6X2yZ8ZDt6RnbJvYox4CB0al6ErkxpUI+iu9abj0LYYqu5r3cgxOeQd2PELzJuda1zEYkjq2cGhYmS/jqk4ZY+r/kIR7GTNmJpY0Xe3y/QH9GxSoxxGpx5ESzbijcjf19cyEQduPMt8T/cjzU6F6vmjuNcRB4kcD48bAYE1cfg4VKUww62tG79QNOIahL/JA9TiJ9a1D4aqasL3K2mmQqExmQSjjtFs6qDeut3vEY/wj4C+7oUYNAAB4nG2VB3RTVRjH//82TWjTssUtwwGI1CSduKAjlA5bLA0VFPE1eU1e+/JSkvcoxQHKUtx7K8OtLHED7r097r33nkc9ruTda/I4x3fOu7//d9837nfvewnyYF//XIkA/ufihsyAPOYhHy4UwA0PBqEQRfCiGCUYjCEYimEYjhEYiV0wCrtiN+yOPbAn9sLe2AejMQZjMQ77Yj/sjwMwHhMwEQdiEg7CZJTiYPjgT1cvQzkqUIkqVGMKDsGhOAyH4whMxTTUoBZ1qEcQ09GAGWhEE5rRgiPRijbMxFFoxyx0IITZ6MTRmIO5OAbHYh6Ow3wcD4X5WI/lWIEduBifYyXOxhm4CjfhWrqwGm9iGS7Aj/gJZ7EAp+FhvIsfcDVuxi/4Gb9iHTbgSTyOjehCGOcigqeh4gk8hefxDJ7Fc/gC3XgJL+BFbEIU3+M8vIqX8Qpi+Arf4HT0QEMv4tBhYA0SWIA+JJGCBRML0Y8vsQiLMYATcBJOxN1YiyU4GUtxCr7Gt7iXbno4iIUsohd/4W8Ws4SDOQT/EBzKYRxOcgRHcheO4q7cjbtzD+7Jvbg398Fv+J2jOYZjOY77cj/uzwM4nhM4kQdyEg/iZJbiD7zGg+mjnwGWsZwVrGQVqzmFh/BQHoYP8REP5xGcymmsYS3rWM8gp7OBM9jIJmzGFjazhUeylW2cyaPYzlnsYAh/4mN8wtns5NGcw7k8hsdyHo/jfB5PhV0MM0KV3YwyRo097MU26ozTYAKf4jP2cQGTTNGkhdfxAd7C23gH7+MNvMeF7OciDnAxT+CJPIkncwmX8hSeymVczhVcyVU8jadzNc/gmTwLt2Er7sRdeAS34w48ilPxEFbhFjyG+3A/tvNsnsNzcSa+43k8nxfwQl7Ei3kJL+VlvJxX8Epexat5DddwLddxPa/ldbyeN/BG3sSbeQtv5QZu5CZu5hbexq28nXfwTt7Fu3kP7+U2bucO3sf7+QAf5EOu1lBLi8cyNJ+vxidZL1hb4amJK+FkwvAogu6arqS6UHUrNjw1iWjCUHs9iqC3Lqwlw1a8W1cXecM5XVQXSZhKOKwaZlE4K931YSWTMiJQn86vmJ6gLKjKgkFRULVRFMwlUrPSE5TLUAXdQZFRteFtcCwq6lhUQy5XNCuLG8KJeFyRRtRheGc48sRy2jWjS0m6YunB3WhqekR1azY8jbITTXbSKDrRxNY1yjVrgnmNTXlaj7fJUaMnp4ubnavqdRjuFiVsmapbt1Hc4vTTd/ITe6LbcLWkG3bp6cHdKuINEd/qjDec8a0i3rCRHzSi+aoR9bTJHhOyxzbRY8JGSVvMMqJK0orrimWWJJyWu13UTYq67c66SWfddlE3KTBLRKVseGc5diuV0/bL668IClYGBplhNaLpuuLuEFlMsQkdmYMzMwcXEgdniYMLyaYs2VRINGXZKAglNSNaYGXGktBODVpOyxOSB2zJb6PTsdh+h57j0AM57Z4rWl1so2hu7mVdnHvx7QanBGwG/NXFKec2djgN02EI97Iqm2U+n6RfMiBZJlkuWSn5X1y1ZI1krWSdoF/m8VcIBmR8QMYHqt2d0aSS3th+gU7RcL+Nws6IpibVlJYq7P9PuecIxwEbmSwBX5VPstwVtJIJ2wj4K/K753enby196wVpPV+zR91r71hZINNugVba0d4sZ8oyG1HQXaroZjqmy/YWY8xrx8ufFlv32A/E2Jt2jxVmHVyZx+mpzN3rlRtcGlb6pPY7dMCh6xy6zKGrHbrcoSsdusqhaxy6Nqf9FRk9RF0U1pV4JNFvpM2UOmyBpaZMLWFkZwb3KUnV0NVu0zaH2GZSi8aEPbQr/b32qmbWYZicyLkMzsyouQy2mXvsjQ30xVRRrFj+2YgHqhFRUjGp41k9PGppeir9senZnCOyU7m8tpuuxhPmzm72VM7tX5ngICkAAAAAAAMACAACABQAAf//AAN4nGNgZGBg4AFiMSBmYgDyGNcASRYwjwEACwEA2wAAAHicVVLZS9RRGD3nNy5ji6ht0oMNKT3VPERFiGjmIDHNhkiERDWMudRo4ha4jaPlVpkP0lub7Qu0/Ae99Vf00FNERAgNEZGd3zc/Sh/uOd9y73fP/e4HAtiEEXwE08nBXvixF4VNja0BBKPxSAB1sUgogHBLPCq7teVkAG3A2hp8OudDgdlCcIPn2oXmCeGYX7QhWwx/KjlwAQdTqZ4+HDWs7+hPphBKd3cmEU5fTqXRYnja8KzdUuzd5WL+Xr/dUOjWl0dDGDp62U5UYR+COIJ6NCOGU6qTP5fw9vZ6POnFr3q87HFOlf0gb+f3OVX5uHPe7qbzQVxld203TT9kB83KyYqZjgOICktRwEYeZxNDbp57GGA1a2QX8bBpj2pV5Osq7+jMiMVdrW3SUQH9C2r1koTtyGrFEdRyvWnzYp6XVZf+Z3zr4s6/aN4qMn1LeCPtOfkrpqAcNdiPQ6hDCBG04gzacRF9GMYYpjCHRSxzUnXDSPC6cZwLxjHOG+c4Z7zKjHGUs8YRzhg3c0kvjPOW2ycuCnO8KVzluDDKG8IIJ4QJjgnDvCZsto6EvRlwu1VpP1Pixan+uNNQgs3Yqp5X4xgakUQPhkz7ODL666xe+Vovfot3eK/p/4TP+IKv+Ibv6sFP/MJv/FFBhwXczQZ2sZuXmGY/h3mFGU5yitOc4SznOM8FdcDRnJXxHu/zMR9whQ/5iHf4kk/4inf5lM/4nC+krgxbpKscDVJ1TrraNYF9mMAUO9jJAQ5qT5fN0wm9onTdBLvd3iZfzCGPR8UZi1e6rHieR8U+/WKZOOvls14+6+XdydyBXTZ/tfnu/QVAfZEAAAAAeJy11MtLVGEYx/Hf884o4sAwDbYTEcVNRLVIvLdQxNR2IkIXMTFQHAIjdRazCLxv+wNC0CytjPJS4tLxgoiIiIiIiIiriFbRbvrOGY2gcBE0Pz6PZ97znnPe85w5yiRlKkdXZZGHTx8rQ35GlEgoucc6Hz1Jjin1jX2Ob06ZvnGZL+LNvaybpNWe2XPbIN/drDt2s7bB31lvJLl17PP7bimg9MSwAuhOxNWDWCJu7Ylh60AnImDceplTo0xmhNgKo4DtatTgNmpRjwY0ogn30Yd+DGAQQxjGCMYwjpeYwCu8xiSm8AZv8Q7TmMEc5vEJn7GARSwhjmWsYBVrWMcGNrGFbexgF3vYxwEOcYRjnOCUuw4ihDCykI0c5CIPleiiQ8m1+1VMLUUZKhCkV3F6Ffd6dVEfls7WveqdL84vIF/l6kYPYviAj/iCr/iGH7h+Yf/v4h4e/EM//3ffkj0L/HGf7y+41wylUYOKclSUo6IcFeWoqHG09Xr7kjPSEfC+lZ/N/HV+a0cHOhHB+ZEBFVD70I8BDGIIwxjBEpaxCuMtCymsK7rBu1aqMsYqVKdRK7QiK7Fma7FWa7OY9dsLOdv03sw7mmd96fr7J+q95/GU809qOxFPhU2nSyomzruqj6tWcO46Yholfsu3fK5YYAXUQiuUjxUVMV5iJdQqq2K82ZoZb7EWaqu1Utusjb0xi8lYcz9nc7rGWtNZcYCkcb8hrhQmflUT4/9BLbPqiVMDcWokTk3EpzFNMmdK04zMEKc5LVAXiRPvKntXiGmNmNaJ0wZx2iROW8RpmzjtEKdd4rRHnPaJ0wFxOiROR8TpmDidEKdT4ixoQWrIQtSwhalZlkXNtmzuPMdyqLmWS82zPGqlVVLb+Z2kWSe/kjTrsi66M2ETnNPoQLHX/dQTz6fXqade9ftz/wn25uDOAAAAAAABAAAAANQYFhEAAAAAzulphwAAAADPrmQ5"

/***/ }),

/***/ "./src/app/View.ts":
/*!*************************!*\
  !*** ./src/app/View.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Array_1 = __webpack_require__(/*! ../util/Array */ "./src/util/Array.ts");
const BaseTypes_1 = __webpack_require__(/*! ../BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ../DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ../DataValue */ "./src/DataValue.ts");
const Delta_1 = __webpack_require__(/*! ../Delta */ "./src/Delta.ts");
const Env_1 = __webpack_require__(/*! ../Env */ "./src/Env.ts");
const Eval_1 = __webpack_require__(/*! ../Eval */ "./src/Eval.ts");
const Expl_1 = __webpack_require__(/*! ../Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "./src/Expr.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Match_1 = __webpack_require__(/*! ../Match */ "./src/Match.ts");
const Module_1 = __webpack_require__(/*! ../Module */ "./src/Module.ts");
const Value_1 = __webpack_require__(/*! ../Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Cursor_1 = __webpack_require__(/*! ./Cursor */ "./src/app/Cursor.ts");
const GraphicsRenderer_1 = __webpack_require__(/*! ./GraphicsRenderer */ "./src/app/GraphicsRenderer.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
var Closure = Eval_1.Eval.Closure;
var View;
(function (View_1) {
    View_1.defaultDims = [320, 360];
    function initialise() {
        Module_1.Module.initialise();
        // Shenanigans to call an internal function. Will extract this into a (reverse) FFI.
        const x = "g";
        const [ρ, dimsExpr] = Module_1.parseWithImports(`dimensions ${x}`);
        View_1.dimensions = function (tg) {
            const tv = Eval_1.Eval.eval_(ρ.concat(Env_1.Env.singleton(Versioned_1.str(x)(Versioned_1.ν()), tg)), dimsExpr);
            if (tv.v instanceof Graphics_1.Point) {
                return [tv.v.x.val, tv.v.y.val];
            }
            else {
                return Core_1.absurd();
            }
        };
    }
    View_1.initialise = initialise;
    // Prefer globals to threading parameters everywhere.
    let __currentEditor = null;
    const __links = new Set();
    const __svgs = new Map(); // memoised render within a single update 
    function render(editor) {
        __svgs.clear();
        __links.clear();
        Core_1.assert(__currentEditor === null);
        __currentEditor = editor;
        const g = view(editor.tv, true, false).render();
        editor.rootPane.appendChild(g); // need to render main view so links can make use of getBoundingClientRect
        renderLinks(__links).forEach((link) => {
            editor.rootPane.appendChild(link);
        });
        __currentEditor = null;
    }
    View_1.render = render;
    const views = new Map(); // persists across edits
    function existingView(tv) {
        return Core_1.__nonNull(views.get(tv));
    }
    View_1.existingView = existingView;
    function isExprFor(e, C) {
        return Core_1.classOf(e) === DataType_1.exprClass(C);
    }
    // Unpack evaluation memo-key to recover original expression. TODO: make generic
    // and move near to memo code.
    function exprFor(t) {
        if (Versioned_1.versioned(t)) {
            return Core_1.as(Core_1.as(Core_1.as(t.__id, Value_1.TaggedId).k, Value_1.ApplicationId).v, Expr_1.Expr.Expr);
        }
        else {
            return Core_1.absurd();
        }
    }
    function renderLinks(links) {
        return [...links].map(((link) => {
            return Renderer_1.connector(Core_1.__nonNull(__svgs.get(link.from)), Core_1.__nonNull(__svgs.get(link.to)));
        }));
    }
    class View {
        render() {
            const g = this.render_();
            __svgs.set(this, g);
            return g;
        }
    }
    class ExprView extends View {
        constructor(parens, e) {
            super();
            this.parens = parens;
            this.e = e;
        }
        render_() {
            const parens = this.parens;
            const e = this.e;
            if (e instanceof Expr_1.Expr.ConstNum) {
                // ouch: disregard delta-info on expression itself
                return Renderer_1.horiz(num_(e.val, e.val));
            }
            else if (e instanceof Expr_1.Expr.ConstStr) {
                // ouch: disregard delta-info on expression itself
                return Renderer_1.horiz(str_(e.val));
            }
            else if (e instanceof Expr_1.Expr.Fun) {
                const g = Renderer_1.horizSpace(Renderer_1.keyword("fun", Renderer_1.deltaStyle(e)), elim(e.σ));
                return Renderer_1.parenthesiseIf(parens, g, Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.DataExpr) {
                if (isExprFor(e, BaseTypes_1.Pair)) {
                    return pair_expr(e);
                }
                else if (isExprFor(e, BaseTypes_1.Nil) || isExprFor(e, BaseTypes_1.Cons)) {
                    return list_expr(parens, e);
                }
                else {
                    return dataConstr_expr(parens, e);
                }
            }
            else if (e instanceof Expr_1.Expr.Quote) {
                return Renderer_1.unimplemented(e);
            }
            else if (e instanceof Expr_1.Expr.Var) {
                // ouch: disregard delta-info on Var.x
                return Renderer_1.horiz(Renderer_1.text(e.x.val, Renderer_1.deltaStyle(e)));
            }
            else if (e instanceof Expr_1.Expr.App) {
                return Renderer_1.parenthesiseIf(parens, Renderer_1.horizSpace(expr(!(e.f instanceof Expr_1.Expr.App), e.f), expr(true, e.e)), Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.BinaryApp) {
                // ignore operator precedence, but allow function application to take priority over any binary operation
                return Renderer_1.parenthesiseIf(parens, Renderer_1.horizSpace(expr(!(e.e1 instanceof Expr_1.Expr.App), e.e1), Renderer_1.text(e.opName.val, Renderer_1.deltaStyle(e)), // what about changes associated with e.opName 
                expr(!(e.e2 instanceof Expr_1.Expr.App), e.e2)), Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.Defs) {
                return Renderer_1.parenthesiseIf(parens, Renderer_1.vert(Renderer_1.vert(...e.def̅.toArray().map(def_ => def(def_))), expr(false, e.e)), Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.MatchAs) {
                return Renderer_1.vert(Renderer_1.horizSpace(Renderer_1.keyword("match", Renderer_1.deltaStyle(e)), expr(false, e.e), Renderer_1.keyword("as", Renderer_1.deltaStyle(e))), elim(e.σ));
            }
            else if (e instanceof Expr_1.Expr.Typematch) {
                return Renderer_1.vert(Renderer_1.horizSpace(Renderer_1.keyword("typematch", Renderer_1.deltaStyle(e)), expr(false, e.e), Renderer_1.keyword("as", Renderer_1.deltaStyle(e))), ...e.cases.toArray().map(({ fst: x, snd: e }) => Renderer_1.horizSpace(Renderer_1.text(x.val, Renderer_1.deltaStyle(x)), Renderer_1.arrow(Renderer_1.deltaStyle(e)), expr(false, e))));
            }
            else {
                return Core_1.absurd(`Unimplemented expression form: ${Core_1.className(e)}.`);
            }
        }
    }
    class ExplValueView extends View {
        constructor(tv, show_v, show_ts) {
            super();
            this.tv = tv;
            this.show_v = show_v;
            this.show_ts = show_ts;
            this.initialise();
        }
        assertValid() {
            Core_1.assert(this.show_v || this.show_ts);
        }
        initialise() {
            const ts = splitExpls(this.tv.t);
            if (ts.length === 0 || !this.show_ts) {
                this.t_visible = false;
                this.v_visible = true;
            }
            else {
                this.t_visible = true;
                this.v_visible = this.show_v;
            }
            return [ts, splitValue(this.tv)];
        }
        render_() {
            this.assertValid();
            const [ts, tv] = this.initialise();
            let g;
            if (!this.v_visible) {
                g = expls(ts);
            }
            else if (!this.t_visible) {
                g = valueView(tv).render();
            }
            else {
                g = Renderer_1.vert(expls(ts), Renderer_1.horizSpace(Renderer_1.text("▸", Renderer_1.deltaStyle(Array_1.nth(ts, ts.length - 1))), valueView(tv).render()));
            }
            if (this.tv === __currentEditor.here.tv) {
                return Renderer_1.addBorder_focus(!this.t_visible && ts.length > 0 ? Renderer_1.edge_left(g) : g);
            }
            else {
                return g;
            }
        }
        toggleValue() {
            if (!this.show_v) {
                this.show_v = true;
            }
            else if (this.show_ts) {
                this.show_v = false;
            }
        }
        toggleExpl() {
            if (!this.show_ts) {
                this.show_ts = true;
            }
            else if (this.show_v) {
                this.show_ts = false;
            }
        }
    }
    class ExplView extends View {
        constructor(t) {
            super();
            this.t = t;
            this.bodyVisible = false;
        }
        render_() {
            let g;
            if (this.t instanceof Expl_1.Expl.Var) {
                g = Renderer_1.horiz(Renderer_1.text(this.t.x.val, Renderer_1.deltaStyle(this.t)));
            }
            else if (this.t instanceof Expl_1.Expl.UnaryApp) {
                g = view(this.t.tf, false, true).render();
            }
            else if (this.t instanceof Expl_1.Expl.BinaryApp) {
                g = Renderer_1.horizSpace(view(this.t.tv1, false, true).render(), Renderer_1.text(this.t.opName.val, Renderer_1.deltaStyle(this.t)), // what about changes associated with t.opName? 
                view(this.t.tv2, false, true).render());
            }
            else if (this.t instanceof Expl_1.Expl.App) {
                g = Renderer_1.vert(Renderer_1.horizSpace(view(this.t.tf, false, true).render(), view(this.t.tu, false, true).render()), this.appBody());
            }
            else if (this.t instanceof Expl_1.Expl.Defs) {
                g = Renderer_1.vert(...this.t.def̅.toArray().map(defₜ));
            }
            else if (this.t instanceof Expl_1.Expl.MatchAs) {
                g = Renderer_1.vert(Renderer_1.horizSpace(Renderer_1.keyword("match", Renderer_1.deltaStyle(this.t)), view(this.t.tu, false, true).render(), Renderer_1.keyword("as", Renderer_1.deltaStyle(this.t))), elimMatch(this.t.ξ));
            }
            else if (this.t instanceof Expl_1.Expl.Typematch) {
                return Renderer_1.unimplemented(this.t);
            }
            else {
                return Core_1.absurd("Unknown explanation form", this.t);
            }
            return Renderer_1.shading(g, "white");
        }
        appBody() {
            const app = Core_1.as(this.t, Expl_1.Expl.App);
            const ts = splitExpls(app.t);
            if (ts.length === 0 || this.bodyVisible) {
                return expls(ts);
            }
            else {
                const g = Renderer_1.ellipsis(Renderer_1.deltaStyle(app.t));
                g.addEventListener("click", (ev) => {
                    ev.stopPropagation();
                    this.bodyVisible = true;
                    __currentEditor.onViewChange();
                });
                return g;
            }
        }
    }
    View_1.ExplView = ExplView;
    class ValueView extends View {
        constructor(tv) {
            super();
            this.tv = tv;
        }
        render_() {
            let g;
            if (this.tv.v instanceof Value_1.Num) {
                const e = exprFor(this.tv.t);
                g = Renderer_1.horiz(num_(this.tv.v, e instanceof Expr_1.Expr.ConstNum ? e.val : undefined));
            }
            else if (this.tv.v instanceof Value_1.Str) {
                g = Renderer_1.horiz(str_(this.tv.v));
            }
            else if (this.tv.v instanceof Closure) {
                // treat closures as their function literals, for now
                g = Renderer_1.horizSpace(Renderer_1.keyword("fun", Renderer_1.deltaStyle(this.tv.v)), elim(this.tv.v.f));
            }
            else if (this.tv.v instanceof DataValue_1.DataValue) {
                if (this.tv.v instanceof Graphics_1.GraphicsElement) {
                    const tg = this.tv;
                    const dim = { width: View_1.defaultDims[0], height: View_1.defaultDims[1] };
                    let g1;
                    [g, g1] = Renderer_1.svgElement_inverted(dim.width, dim.height);
                    new GraphicsRenderer_1.GraphicsRenderer(__currentEditor, g, g1).render(tg, Core_1.__nonNull(View_1.dimensions)(tg));
                    Renderer_1.__dimensions.set(g, dim);
                }
                else if (this.tv.v instanceof BaseTypes_1.Pair) {
                    g = pair(this.tv);
                }
                else if (this.tv.v instanceof BaseTypes_1.List) {
                    g = list(this.tv);
                }
                else {
                    g = dataConstr(false, this.tv);
                }
            }
            else {
                g = Renderer_1.unimplemented(this.tv.v);
            }
            return Renderer_1.shading(g, "lavender");
        }
    }
    View_1.ValueView = ValueView;
    // Values are treated slightly differently because the "key" of a value view is the value (to distinguish
    // it from the view of the ExplValue), but the Expl is also required to render the value.
    function valueView(tv) {
        let w = views.get(Core_1.__nonNull(tv).v);
        if (w === undefined) {
            w = new ValueView(tv);
            views.set(tv.v, w);
            return w;
        }
        else {
            return w;
        }
    }
    View_1.valueView = valueView;
    function view(tv, show_v, show_ts) {
        let w = views.get(tv);
        if (w === undefined) {
            w = new ExplValueView(tv, show_v, show_ts);
            views.set(tv, w);
            return w;
        }
        else {
            return w;
        }
    }
    View_1.view = view;
    function view_child(C, tv, prop_, show_v, show_ts) {
        if (Versioned_1.versioned(tv.v) && Versioned_1.versioned(tv.t)) {
            const prop = prop_;
            const w = view(Expl_1.Expl.explChild(tv.t, tv.v, prop_), show_v, show_ts);
            const g = w.render();
            if (tv.v.__ẟ instanceof Delta_1.Change && tv.v.__ẟ.hasChanged(prop)) {
                // All a bit hacky, need to rethink:
                const t_prev = tv.t.__ẟ instanceof Delta_1.Change && tv.t.__ẟ.hasChanged(prop) ?
                    Core_1.as(tv.t.__ẟ.changed[prop].before, Expl_1.Expl.Expl) :
                    tv.t;
                const w_existing = views.get(DataValue_1.explValue(t_prev, Core_1.as(tv.v.__ẟ.changed[prop].before, Value_1.Value)));
                if (w_existing) {
                    __links.add({ from: w, to: w_existing });
                }
                return Renderer_1.addBorder_changed(g);
            }
            else {
                return g;
            }
        }
        else {
            return Core_1.absurd();
        }
    }
    function explView(t) {
        let w = views.get(t);
        if (w === undefined) {
            w = new ExplView(t);
            views.set(t, w);
            return w;
        }
        else {
            return w;
        }
    }
    View_1.explView = explView;
    function splitExpls(t) {
        if (t instanceof Expl_1.Expl.Const) {
            return [];
        }
        else if (t instanceof Expl_1.Expl.Fun) {
            return [];
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            return [];
        }
        else if (t instanceof Expl_1.Expl.Var) {
            // values of variables themselves have explanations, but ignore those for now
            return [t];
        }
        else 
        // don't recurse into App as it has its own expansion state
        if (t instanceof Expl_1.Expl.UnaryApp || t instanceof Expl_1.Expl.BinaryApp) {
            return [t];
        }
        else if (t instanceof Expl_1.Expl.App) {
            return [t];
        }
        else if (t instanceof Expl_1.Expl.NonTerminal) {
            return [t, ...splitExpls(t.t)];
        }
        else {
            return Core_1.absurd("Unknown explanation form", t);
        }
    }
    View_1.splitExpls = splitExpls;
    // The value part must be an ExplValue, because in the data value case we need the explanation as well to
    // render the value.
    function splitValue(tv) {
        const { t, v } = tv;
        if (t instanceof Expl_1.Expl.Const) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.Fun) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.Var) {
            // values of variables themselves have explanations, but ignore those for now
            return splitValue(DataValue_1.explValue(t.t, v));
        }
        else 
        // don't recurse into App as it has its own expansion state
        if (t instanceof Expl_1.Expl.UnaryApp || t instanceof Expl_1.Expl.BinaryApp) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.App) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.NonTerminal) {
            return splitValue(DataValue_1.explValue(t.t, v));
        }
        else {
            return Core_1.absurd();
        }
    }
    View_1.splitValue = splitValue;
    function expls(ts) {
        return Renderer_1.vert(...ts.map(t => explView(t).render()));
    }
    function compareCtr(c1, c2) {
        const n = DataType_1.ctrFor(c1).arity - DataType_1.ctrFor(c2).arity;
        return n === 0 ? c1.localeCompare(c2) : n;
    }
    function cont(κ) {
        if (κ instanceof Expr_1.Expr.Expr) {
            return [[[], κ]];
        }
        else if (κ instanceof Match_1.Elim) {
            return clauses(κ);
        }
        else {
            return Core_1.absurd();
        }
    }
    function clauses(σ) {
        if (Match_1.VarElim.is(σ)) {
            const cs = cont(σ.κ);
            // disregard any delta information on x :-/
            return cs.map(([cxs, e]) => [[[σ.x, Renderer_1.deltaStyle(σ)], ...cxs], e]);
        }
        else if (Match_1.DataElim.is(σ)) {
            const cκs = Array_1.zip(Value_1.fields(σ), σ.__children).sort(([c1,], [c2,]) => compareCtr(c1, c2));
            return Array_1.flatten(cκs.filter(([c, κ]) => κ !== undefined).map(([c, κ]) => cont(Core_1.__nonNull(κ)).map(([cxs, e]) => [[[DataType_1.ctrFor(c), Renderer_1.deltaStyle(σ)], ...cxs], e])));
        }
        else {
            return Core_1.absurd();
        }
    }
    function consComma(ẟ_style, src) {
        const g = Renderer_1.comma(ẟ_style);
        g.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (src !== undefined) {
                Versioned_1.newRevision();
                if (ev.metaKey) {
                    if (ev.altKey) {
                        // if my tail is another cons, swap the two head elements
                        const e = Core_1.as(new Cursor_1.ExprCursor(src).constr_to(BaseTypes_1.Cons, "tail").v, Expr_1.Expr.Expr);
                        if (isExprFor(e, BaseTypes_1.Cons)) {
                            const e1 = Core_1.as(new Cursor_1.ExprCursor(src).constr_to(BaseTypes_1.Cons, "head").v, Expr_1.Expr.Expr);
                            const e2 = Core_1.as(new Cursor_1.ExprCursor(e).constr_to(BaseTypes_1.Cons, "head").v, Expr_1.Expr.Expr);
                            // constr_splice on src, replacing head with head of src.tail
                            // constr_splice on src.tail, replacing head with head of src
                            new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Cons, ["head"], ([e]) => {
                                return [e2];
                            });
                            new Cursor_1.ExprCursor(e).constr_splice(BaseTypes_1.Cons, ["head"], ([e]) => {
                                return [e1];
                            });
                        }
                    }
                    else {
                        new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Cons, ["head"], ([e]) => {
                            const eʹ = Expr_1.Expr.app(Expr_1.Expr.var_(Versioned_1.str("sq")(Versioned_1.ν()))(Versioned_1.ν()), Expr_1.Expr.var_(Versioned_1.str("x")(Versioned_1.ν()))(Versioned_1.ν()))(Versioned_1.ν());
                            return [Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Pair), e, eʹ)(Versioned_1.ν())];
                        });
                    }
                }
                else {
                    new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Cons, ["tail"], ([e]) => {
                        const eʹ = Expr_1.Expr.constNum(Versioned_1.num(0)(Versioned_1.ν()))(Versioned_1.ν());
                        return [Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Cons), eʹ, e)(Versioned_1.ν())];
                    });
                }
                __currentEditor.onEdit();
            }
        });
        return g;
    }
    function dataConstr(parens, { t, v }) {
        const tvs = Expl_1.Expl.explChildren(t, v);
        // a constructor expression makes its value, so their root delta highlighting must agree
        const gs = tvs.map(tvʹ => view(tvʹ, true, false).render());
        const g = Renderer_1.horizSpace(Renderer_1.text(v.ctr, Renderer_1.deltaStyle(v)), ...(tvs.length > 2 ? [Renderer_1.vert(...gs)] : gs));
        return Renderer_1.parenthesiseIf(tvs.length > 0 && parens, g, Renderer_1.deltaStyle(t));
    }
    function dataConstr_expr(parens, e) {
        const es = e.__children;
        const gs = es.map(eʹ => expr(true, eʹ));
        const g = Renderer_1.horizSpace(Renderer_1.text(e.ctr, Renderer_1.deltaStyle(e)), ...(es.length > 2 ? [Renderer_1.vert(...gs)] : gs));
        return Renderer_1.parenthesiseIf(es.length > 0 && parens, g, Renderer_1.deltaStyle(e));
    }
    function def(def) {
        if (def instanceof Expr_1.Expr.Prim) {
            return Renderer_1.horizSpace(Renderer_1.keyword("primitive", Renderer_1.deltaStyle(def)), patternVar(def.x));
        }
        else if (def instanceof Expr_1.Expr.Let) {
            if (def.e instanceof Expr_1.Expr.Fun) {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), elim(def.e.σ));
            }
            else {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), Renderer_1.keyword("equals", Renderer_1.deltaStyle(def)), expr(false, def.e));
            }
        }
        else if (def instanceof Expr_1.Expr.LetRec) {
            return Renderer_1.horizSpace(Renderer_1.keyword("letRec", Renderer_1.deltaStyle(def)), Renderer_1.vert(...def.δ.toArray().map(def => recDef(def))));
        }
        else {
            return Core_1.absurd();
        }
    }
    function defₜ(def) {
        if (def instanceof Expl_1.Expl.Prim) {
            return Renderer_1.horizSpace(Renderer_1.keyword("primitive", Renderer_1.deltaStyle(def)), patternVar(def.x));
        }
        else if (def instanceof Expl_1.Expl.Let) {
            if (def.tv.t instanceof Expl_1.Expl.Fun && def.tv.v instanceof Closure) {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), elim(def.tv.v.f));
            }
            else {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), Renderer_1.keyword("equals", Renderer_1.deltaStyle(def)), view(def.tv, false, true).render());
            }
        }
        else if (def instanceof Expl_1.Expl.LetRec) {
            return Renderer_1.horizSpace(Renderer_1.keyword("letRec", Renderer_1.deltaStyle(def)), Renderer_1.vert(...def.δ.toArray().map(def => recDefₜ(def))));
        }
        else {
            return Core_1.absurd();
        }
    }
    function elim(σ) {
        return Renderer_1.vert(...clauses(σ).map(([cxs, e]) => {
            const [[g], cxsʹ] = patterns(false, 1, cxs);
            Core_1.assert(cxsʹ.length === 0);
            const gʹ = e instanceof Expr_1.Expr.Fun ?
                elim(e.σ) : // curried function resugaring
                Renderer_1.horizSpace(Renderer_1.arrow(Renderer_1.deltaStyle(e)), expr(false, e));
            return Renderer_1.horizSpace(g, gʹ);
        }));
    }
    // Hack just to support Bool, Ordering, etc.
    function elimMatch(ξ) {
        const tv = Array_1.nth(ξ.tv̅.toArray(), 0);
        // don't think the contination is needed; already stored in the trace
        return Renderer_1.horizSpace(Renderer_1.text(tv.v.ctr, Renderer_1.deltaStyle(tv.v)), Renderer_1.arrow(Renderer_1.deltaStyle(tv.v)));
    }
    function expr_(parens, e) {
        let w = views.get(e);
        if (w === undefined) {
            w = new ExprView(parens, e);
            views.set(e, w);
            return w;
        }
        else {
            return w;
        }
    }
    function expr(parens, e) {
        return expr_(parens, e).render();
    }
    // Really want some kind of view typeclass, so this isn't specific to expression. Also: consolidate with ExprCursor.
    function expr_child(C, parens, e, prop) {
        if (Versioned_1.versioned(e)) {
            const w = expr_(parens, e.__child(prop));
            const g = w.render();
            if (e.__ẟ instanceof Delta_1.Change && e.__ẟ.hasChanged(prop)) {
                const w_existing = views.get(Core_1.as(e.__ẟ.changed[prop].before, Expr_1.Expr.Expr));
                if (w_existing) {
                    __links.add({ from: w, to: w_existing });
                }
                return Renderer_1.addBorder_changed(g);
            }
            else {
                return g;
            }
        }
        else {
            return Core_1.absurd();
        }
    }
    function list({ t, v }) {
        if (BaseTypes_1.Cons.is(v)) {
            const vʹ = v;
            const e = exprFor(t);
            return Renderer_1.horiz(view_child(BaseTypes_1.Cons, DataValue_1.explValue(t, vʹ), "head", true, false), consComma(Renderer_1.deltaStyle(v), isExprFor(e, BaseTypes_1.Cons) ? e : undefined), Renderer_1.space(), view(Expl_1.Expl.explChild(t, vʹ, "tail"), true, false).render());
        }
        else if (BaseTypes_1.Nil.is(v)) {
            return Renderer_1.horiz(Renderer_1.centreDot(Renderer_1.deltaStyle(v)));
        }
        else {
            return Core_1.absurd();
        }
    }
    function list_expr(parens, e) {
        if (isExprFor(e, BaseTypes_1.Cons)) {
            return Renderer_1.parenthesiseIf(parens, Renderer_1.horiz(expr_child(BaseTypes_1.Cons, false, e, "head"), consComma(Renderer_1.deltaStyle(e), e), Renderer_1.space(), list_expr(false, e.__child("tail"))), Renderer_1.deltaStyle(e));
        }
        else if (isExprFor(e, BaseTypes_1.Nil)) {
            return Renderer_1.horiz(Renderer_1.centreDot(Renderer_1.deltaStyle(e)));
        }
        else {
            return Renderer_1.horiz(expr(false, e)); // promote to nested SVG; need to rethink
        }
    }
    function num_(n, src) {
        const g = Renderer_1.text(n.toString(), Renderer_1.deltaStyle(n));
        if (src && Number.isInteger(src.val)) {
            g.addEventListener("click", (ev) => {
                Versioned_1.newRevision();
                new Cursor_1.ExprCursor(src).setNum(ev.metaKey ? src.val - 1 : src.val + 1);
                ev.stopPropagation();
                __currentEditor.onEdit();
            });
        }
        return g;
    }
    function pair(tv) {
        return Renderer_1.parenthesise(Renderer_1.horiz(view_child(BaseTypes_1.Pair, tv, "fst", true, false), pairComma(Renderer_1.deltaStyle(tv.t), exprFor(tv.t)), Renderer_1.space(), view_child(BaseTypes_1.Pair, tv, "snd", true, false)), Renderer_1.deltaStyle(tv.t));
    }
    function pairComma(ẟ_style, src) {
        const g = Renderer_1.comma(ẟ_style);
        g.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (src !== undefined) {
                Versioned_1.newRevision();
                if (ev.metaKey) {
                    new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Pair, ["fst", "snd"], ([e1, e2]) => {
                        return [e2, e1];
                    });
                }
                __currentEditor.onEdit();
            }
        });
        return g;
    }
    function pair_expr(e) {
        return Renderer_1.parenthesise(Renderer_1.horiz(expr_child(BaseTypes_1.Pair, false, e, "fst"), pairComma(Renderer_1.deltaStyle(e), e), Renderer_1.space(), expr_child(BaseTypes_1.Pair, false, e, "snd")), Renderer_1.deltaStyle(e));
    }
    function patterns(parens, n, cxs) {
        if (n === 0) {
            return [[], cxs];
        }
        else {
            const [ctr_x, ẟ_style] = cxs[0];
            if (ctr_x instanceof DataType_1.Ctr) {
                if (ctr_x.C === BaseTypes_1.Pair) {
                    const [[g1, g2], cxsʹ] = patterns(false, 2, cxs.slice(1));
                    const [gsʹ, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[Renderer_1.parenthesise(Renderer_1.horiz(g1, Renderer_1.comma(ẟ_style), Renderer_1.space(), g2), ẟ_style), ...gsʹ], cxsʹʹ];
                }
                else if (ctr_x.C === BaseTypes_1.Nil) {
                    const [g, cxsʹ] = [Renderer_1.centreDot(ẟ_style), cxs.slice(1)];
                    const [gs, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[g, ...gs], cxsʹʹ];
                }
                else if (ctr_x.C === BaseTypes_1.Cons) {
                    const [[g_head, g_tail], cxsʹ] = patterns(false, ctr_x.arity, cxs.slice(1));
                    const g = Renderer_1.horiz(g_head, Renderer_1.comma(ẟ_style), Renderer_1.space(), g_tail);
                    const [gsʹ, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[Renderer_1.parenthesiseIf(ctr_x.arity > 0 && parens, g, ẟ_style), ...gsʹ], cxsʹʹ];
                }
                else {
                    const [gs, cxsʹ] = patterns(true, ctr_x.arity, cxs.slice(1));
                    const g = Renderer_1.horizSpace(Renderer_1.text(ctr_x.c, ẟ_style), ...gs);
                    const [gsʹ, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[Renderer_1.parenthesiseIf(ctr_x.arity > 0 && parens, g, ẟ_style), ...gsʹ], cxsʹʹ];
                }
            }
            else if (ctr_x instanceof Value_1.Str) {
                const [gs, cxsʹ] = patterns(parens, n - 1, cxs.slice(1));
                // ouch, ignore ẟ_style coming from trie and use variable instead :-/
                return [[patternVar(ctr_x), ...gs], cxsʹ];
            }
            else {
                return Core_1.absurd();
            }
        }
    }
    function patternVar(x) {
        return Renderer_1.text(x.val, Renderer_1.deltaStyle(x));
    }
    function recDef(def) {
        return Renderer_1.horizSpace(patternVar(def.x), elim(def.σ));
    }
    function recDefₜ(def) {
        return Renderer_1.horizSpace(patternVar(def.x), elim(def.tf.v.f));
    }
    function str_(str) {
        return Renderer_1.text(str.toString(), Renderer_1.deltaStyle(str));
    }
})(View = exports.View || (exports.View = {}));


/***/ }),

/***/ "./src/app/inconsolata-webfont.woff":
/*!******************************************!*\
  !*** ./src/app/inconsolata-webfont.woff ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:font/woff;base64,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"

/***/ }),

/***/ "./src/app/styles.css":
/*!****************************!*\
  !*** ./src/app/styles.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./styles.css */ "./node_modules/css-loader/dist/cjs.js!./src/app/styles.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./src/util/Array.ts":
/*!***************************!*\
  !*** ./src/util/Array.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./Core */ "./src/util/Core.ts");
function flatten(x̅̅) {
    const x̅ = []; // otherwise TS is confused
    return x̅.concat.apply([], x̅̅);
}
exports.flatten = flatten;
function counts(x̅) {
    const counts = new Map;
    x̅.forEach(x => {
        if (counts.has(x)) {
            counts.set(x, Core_1.__nonNull(counts.get(x)) + 1);
        }
        else {
            counts.set(x, 1);
        }
    });
    return counts;
}
exports.counts = counts;
function zip(x̅, y̅) {
    return zipWith((t, u) => [t, u])(x̅, y̅);
}
exports.zip = zip;
function zipWith(f) {
    return (x̅, y̅) => x̅.map((x, n) => f(x, y̅[n]));
}
exports.zipWith = zipWith;
function includes(x̅, y̅) {
    return y̅.every(y => x̅.includes(y));
}
exports.includes = includes;
function eq(x̅, y̅) {
    let n = x̅.length;
    if (n != y̅.length) {
        return false;
    }
    else {
        while (n--) {
            if (x̅[n] !== y̅[n])
                return false;
        }
        return true;
    }
}
exports.eq = eq;
function nth(x̅, n) {
    Core_1.assert(0 <= n && n < x̅.length);
    return x̅[n];
}
exports.nth = nth;
function last(x̅) {
    Core_1.assert(x̅.length > 0);
    return x̅.slice(-1)[0];
}
exports.last = last;


/***/ }),

/***/ "./src/util/Core.ts":
/*!**************************!*\
  !*** ./src/util/Core.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function classOf(x) {
    return __nonNull(x).constructor; // weirdly failing on CircleCI without cast
}
exports.classOf = classOf;
function className(o) {
    return classOf(o).name;
}
exports.className = className;
function as(x, C) {
    if (__nonNull(x) instanceof C) {
        return x;
    }
    else {
        return assert(false, "[as] Expected " + C.name + ", got " + className(x));
    }
}
exports.as = as;
function asOpt(x, cls) {
    if (x === null || x === undefined) {
        return x;
    }
    else {
        return as(x, cls);
    }
}
exports.asOpt = asOpt;
function assert(b, msg, ...x̅) {
    if (!b) {
        if (x̅.length > 0) {
            console.warn("Assertion data:\n");
            x̅.forEach(x => console.warn(x));
        }
        throw new Error(msg || "Assertion failure");
    }
}
exports.assert = assert;
function absurd(msg, ...x̅) {
    assert(false, msg, ...x̅);
}
exports.absurd = absurd;
function id(x) {
    return x;
}
exports.id = id;
// User-level error.
function userError(msg, ...x̅) {
    if (x̅.length > 0) {
        console.warn("Error data:\n");
        x̅.forEach(x => console.warn(x));
    }
    throw new Error("User error: " + msg);
}
exports.userError = userError;
function notYetImplemented() {
    throw new Error("Not yet implemented");
}
exports.notYetImplemented = notYetImplemented;
// Useful when a notionally abstract class needs to be concrete.
function abstractMethodError(this_) {
    return assert(false, "Abstract method in " + this_);
}
exports.abstractMethodError = abstractMethodError;
function __nonNull(x, msg) {
    if (x !== null && x !== undefined) {
        return x;
    }
    else {
        return assert(false, `Unexpected null | undefined.${msg === undefined ? "" : `\n${msg}`}`);
    }
}
exports.__nonNull = __nonNull;
function __log(x, msg, transform = (it) => it) {
    const x_ = transform(x);
    if (msg) {
        console.log(msg(x_));
    }
    console.log(x_);
    return x;
}
exports.__log = __log;
function __check(x, predicate) {
    assert(predicate(x));
    return x;
}
exports.__check = __check;


/***/ }),

/***/ "./src/util/Lattice.ts":
/*!*****************************!*\
  !*** ./src/util/Lattice.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./Core */ "./src/util/Core.ts");
// Actually a boolean lattice...
class LatticeImpl {
    join(...t̅) {
        return t̅.reduce((t1, t2) => this.join2(t1, t2));
    }
    meet(...t̅) {
        return t̅.reduce((t1, t2) => this.meet2(t1, t2));
    }
}
class BoolLattice extends LatticeImpl {
    constructor() {
        super(...arguments);
        this.bot = false;
        this.top = true;
    }
    // Important to assert that arguments are defined since undefined propagates in an unhelpful way.
    join2(b1, b2) {
        return Core_1.__nonNull(b1) || Core_1.__nonNull(b2);
    }
    meet2(b1, b2) {
        return Core_1.__nonNull(b1) && Core_1.__nonNull(b2);
    }
    negate(b) {
        return !b;
    }
}
exports.BoolLattice = BoolLattice;
exports.bool_ = new BoolLattice();


/***/ }),

/***/ "./src/util/Ord.ts":
/*!*************************!*\
  !*** ./src/util/Ord.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function eq(a, b) {
    return a.leq(b) && b.leq(a);
}
exports.eq = eq;


/***/ }),

/***/ "./src/util/Set.ts":
/*!*************************!*\
  !*** ./src/util/Set.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function diff(x̅, y̅) {
    return filter(x̅, x => !(y̅.has(x)));
}
exports.diff = diff;
function every(x̅, pred) {
    return Array.from(x̅).every(pred);
}
exports.every = every;
function filter(x̅, pred) {
    return new Set([...x̅].filter(pred));
}
exports.filter = filter;
function map(x̅, f) {
    return new Set([...x̅].map(f));
}
exports.map = map;
function some(x̅, pred) {
    return Array.from(x̅).some(pred);
}
exports.some = some;
function union(...x̅̅) {
    const y̅ = new Set();
    x̅̅.forEach(x̅ => {
        x̅.forEach(x => {
            y̅.add(x);
        });
    });
    return y̅;
}
exports.union = union;
function intersection(x̅̅, y̅) {
    const zs = new Set();
    x̅̅.forEach(x => {
        if (y̅.has(x)) {
            zs.add(x);
        }
    });
    return zs;
}
exports.intersection = intersection;


/***/ })

/******/ })));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZmx1aWQvbGliL2dyYXBoaWNzLmZsZCIsIndlYnBhY2s6Ly8vLi9mbHVpZC9saWIvcHJlbHVkZS5mbGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aXBweS5qcy90aGVtZXMvbGlnaHQtYm9yZGVyLmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb28vbW9vLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWFybGV5L2xpYi9uZWFybGV5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5jaHVuay5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzP2NiY2MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aXBweS5qcy90aGVtZXMvbGlnaHQtYm9yZGVyLmNzcz8yZDdkIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Fubm90YXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Jhc2VUeXBlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRGF0YVR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0RhdGFWYWx1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRGVsdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Vudi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRXZhbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRXhwbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRXhwci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRmluaXRlTWFwLnRzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaGljcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvTGliLnRzIiwid2VicGFjazovLy8uL3NyYy9NYXRjaC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvTW9kdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9QYXJzZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvUHJpbWl0aXZlLnRzIiwid2VicGFjazovLy8uL3NyYy9WYWx1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvVmVyc2lvbmVkLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvQXZlbmlyTFRTdGQtQm9vay53b2ZmIiwid2VicGFjazovLy8uL3NyYy9hcHAvQ29yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL0N1cnNvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL0dyYXBoaWNzUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9JbnRlcmFjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvUGFuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL1BhbmVDb29yZGluYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL1JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvU2xhYm8xM3B4LVJlZ3VsYXIud29mZiIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL1ZpZXcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9pbmNvbnNvbGF0YS13ZWJmb250LndvZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zdHlsZXMuY3NzPzNhMzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvQXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvQ29yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9MYXR0aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy91dGlsL09yZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9TZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFlLDhXQUErUyx1Q0FBdUMsZ0pBQWdKLDZCQUE2Qix1Q0FBdUMsdUNBQXVDLDBEQUEwRCxvRkFBb0Ysb0ZBQW9GLDhJQUE4SSwyREFBMkQscURBQXFELDJFQUEyRSxrSUFBa0ksOEhBQThILGdVQUFnVSx1RUFB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Q3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEdBQUc7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQixtQkFBbUI7QUFDdkQ7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLEdBQUcsNkJBQTZCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0g7O0FBRXhIO0FBQ0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaU9BQWlPLFdBQVcsaUJBQWlCLDZCQUE2QixXQUFXLFNBQVMsd0NBQXdDLGdDQUFnQyxjQUFjLGtCQUFrQjtBQUN0Wiw2SUFBNkksZ0JBQWdCLGNBQWMsY0FBYztBQUN6TDtBQUNBO0FBQ0EsaUxBQWlMLGdCQUFnQixxQkFBcUIsY0FBYyxvQkFBb0I7QUFDeFA7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Qsa0JBQWtCLHdDQUF3Qzs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FB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QUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFDLEVBQUUsQ0FBQyxFQUFDO1FBQy9ILEVBQUMsTUFBTSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsQ0FBQyxhQUFhLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsV0FBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsZUFBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGFBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBQyxFQUFFLENBQUMsRUFBQztRQUN2SixFQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUUsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUNsRSxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxhQUFhLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFdBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLGVBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLGFBQUMsRUFBRSxDQUFDLEVBQUM7UUFDL0ksRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUM7UUFDbEUsRUFBQyxNQUFNLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxDQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsY0FBYyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxlQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsYUFBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxhQUFDLEVBQUUsQ0FBQyxFQUFDO1FBQzVKLEVBQUMsTUFBTSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFDO1FBQ3ZFLEVBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxjQUFjLEVBQUUsWUFBWSxFQUFFLFVBQVUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsV0FBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsZUFBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGFBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBQyxFQUFFLENBQUMsRUFBQztRQUMzSixFQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUNwRSxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUNsRSxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxhQUFDLEVBQUUsQ0FBQyxFQUFDO1FBQy9HLEVBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFDO1FBQ2xF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QUMsRUFBQztRQUNwRixFQUFDLE1BQU0sRUFBRSw0Q0FBNEMsRUFBRSxTQUFTLEVBQUUsQ0FBQyw0Q0FBNEMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUM7UUFDcEksRUFBQyxNQUFNLEVBQUUsNENBQTRDLEVBQUUsU0FBUyxFQUFFLENBQUMsNENBQTRDLEVBQUUsR0FBRyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFDO1FBQ25KLEVBQUMsTUFBTSxFQUFFLGdDQUFnQyxFQUFFLFNBQVMsRUFBRSxDQUFDLDRDQUE0QyxFQUFFLEtBQUssQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFDO1FBQzdJLEVBQUMsTUFBTSxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLGdDQUFnQyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQztRQUN0SSxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsS0FBSyxFQUFFLGdCQUFnQixDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGdCQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBQztRQUN6SCxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUN0RCxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUN6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WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9MaWIudHNcIik7XG4iLCJleHBvcnQgZGVmYXVsdCBcIi8vIHR5cGVkZWYgQ29sb3VyID0gU3RyXFxuLy8gdHlwZWRlZiBDb2xvdXJzID0gTGlzdCBDb2xvdXJcXG4vLyB0eXBlZGVmIENhdCA9IFN0clxcblxcbi8vIFNpbXBsaXN0aWMgYnV0IHNvbWV0aGluZyBtb3JlIGdlbmVyYWwgbWF5IHJlcXVpcmUgcHJpbWl0aXZlcyB3aGljaCB0YWtlIGRhdGEgdmFsdWVzIGZvciBpbnB1dC5cXG4vLyBBcHBsaWNhdGlvbiBtb2R1bGUgR3JhcGhpY3NSZW5kZXJlciBtdXN0IGJlIGxvYWRlZCBmb3IgdGhlc2UgZGVmaW5pdGlvbnMgdG8gd29yay5cXG4vLyBTdHIg4oaSIE51bVxcbnByaW1pdGl2ZSB0ZXh0V2lkdGg7XFxuXFxuLy8gU3RyIOKGkiBOdW1cXG5wcmltaXRpdmUgdGV4dEhlaWdodDtcXG5cXG4vLyBHcm91cCBoYXMgbG9jYXRpb24gKDAsIDApIGJlY2F1c2UgaXQgZG9lc24ndCBpbnRlcmZlcmUgd2l0aCBwb3NpdGlvbmluZyBvZiBpdHMgY2hpbGRyZW4uXFxuLy8gR3JhcGhpY3NFbGVtZW50IOKGkiBQb2ludFxcbmxldHJlYyBmdW4gY29vcmRzIHtcXG4gICBHcm91cChncykg4oaSIFBvaW50KDAsIDApO1xcbiAgIFJlY3QoeCwgeSwgXywgXywgXykg4oaSIFBvaW50KHgsIHkpO1xcbiAgIFRleHQoeCwgeSwgXywgXywgXykg4oaSIFBvaW50KHgsIHkpO1xcbiAgIFZpZXdwb3J0KHgsIHksIF8sIF8sIF8sIF8sIF8sIF8sIF8pIOKGkiBQb2ludCh4LCB5KVxcbn07XFxuXFxuLy8gR3JhcGhpY3NFbGVtZW50IOKGkiBOdW1cXG5sZXQgZ2V0X3ggPSBmdW4gZyDihpIgbWF0Y2ggY29vcmRzIGcgYXMgUG9pbnQoeCwgXykg4oaSIHg7XFxuXFxuLy8gR3JhcGhpY3NFbGVtZW50IOKGkiBOdW1cXG5sZXQgZ2V0X3kgPSBmdW4gZyDihpIgbWF0Y2ggY29vcmRzIGcgYXMgUG9pbnQoXywgeSkg4oaSIHg7XFxuXFxuLy8gV2FudCBzb21lIGtpbmQgb2YgdHlwZWNsYXNzIG1lY2hhbmlzbSBwbHVzIHJlY29yZCBhY2Nlc3NvcnMvdXBkYXRlcnMuXFxuLy8gTnVtIOKGkiBHcmFwaGljc0VsZW1lbnQg4oaSIEdyYXBoaWNzRWxlbWVudFxcbmxldHJlYyBmdW4gc2V0X3ggeCB7XFxuICAgR3JvdXAoZ3MpIOKGkiBlcnJvciBcXFwiR3JvdXAgaGFzIGltbXV0YWJsZSBjb29yZGluYXRlc1xcXCI7XFxuICAgUmVjdChfLCB5LCB3LCBoLCBmaWxsKSDihpIgUmVjdCh4LCB5LCB3LCBoLCBmaWxsKTtcXG4gICBUZXh0KF8sIHksIHN0ciwgYW5jaG9yLCBiYXNlbGluZSkg4oaSIFRleHQoeCwgeSwgc3RyLCBhbmNob3IsIGJhc2VsaW5lKTtcXG4gICBWaWV3cG9ydChfLCB5LCB3LCBoLCBmaWxsLCBtYXJnaW4sIHNjYWxlLCB0cmFuc2xhdGUsIGcpIOKGkiBcXG4gICAgICBWaWV3cG9ydCh4LCB5LCB3LCBoLCBmaWxsLCBtYXJnaW4sIHNjYWxlLCB0cmFuc2xhdGUsIGcpXFxufTtcXG5cXG4vLyAoUG9pbnQsIFBvaW50KSDihpIgUG9pbnRcXG5sZXQgZGltZW5zaW9uczIgPSBmdW4gKFBvaW50KHgxLCB5MSksIFBvaW50KHgyLCB5MikpIOKGklxcbiAgIFBvaW50KG1heDIgKHgxLCB4MiksIG1heDIgKHkxLCB5MikpO1xcblxcbi8vIEZvciBHcm91cCwgZGltZW5zaW9ucyBhcmUgcmVsYXRpdmUgdG8gaW1wbGljaXQgY29vcmRzIG9mICgwLCAwKSwgc2luY2UgYSBHcm91cCdzIGNoaWxkcmVuIGFyZSBlZmZlY3RpdmVseVxcbi8vIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gcGFyZW50IG9mIEdyb3VwLiBGb3IgUG9seW1hcmtlciwgd2lsbCBwcm9iYWJseSBoYXZlIHRvIGlnbm9yZSB0aGUgbWFya2VycyB0aGVtc2VsdmVzLCBcXG4vLyBzaW5jZSB0aGV5IGFyZSBzY2FsZS1pbnZhcmlhbnQuXFxuLy8gR3JhcGhpY3NFbGVtZW50IOKGkiBQb2ludFxcbmxldHJlYyBcXG4gICBmdW4gZGltZW5zaW9ucyB7XFxuICAgICAgR3JvdXAoZ3MpIOKGkiBmb2xkbCBkaW1lbnNpb25zMiBQb2ludCgwLCAwKSAobWFwIChjb29yZHNfb3ApIGdzKTtcXG4gICAgICBQb2x5bGluZShwcywgXywgXykg4oaSIGZvbGRsIGRpbWVuc2lvbnMyIFBvaW50KDAsIDApIHBzO1xcbiAgICAgIFJlY3QoXywgXywgdywgaCwgXykg4oaSIFBvaW50KHcsIGgpO1xcbiAgICAgIFRleHQoXywgXywgXywgXywgXykg4oaSIFBvaW50KDAsIDApOyAvLyB0cmVhdCB0ZXh0IGxpa2UgbWFya2Vyczsgc2NhbGUtaW52YXJpYW50XFxuICAgICAgVmlld3BvcnQoXywgXywgdywgaCwgXywgXywgXywgXywgXykg4oaSIFBvaW50KHcsIGgpXFxuICAgfTtcXG5cXG4gICBmdW4gY29vcmRzX29wIGcg4oaSIFxcbiAgICAgIG1hdGNoIHByb2QgY29vcmRzIGRpbWVuc2lvbnMgZyBhcyBcXG4gICAgICAoUG9pbnQoeCwgeSksIFBvaW50KHcsIGgpKSDihpIgUG9pbnQoeCArIHcsIHkgKyBoKTtcXG5cXG4vLyBHcmFwaGljc0VsZW1lbnQg4oaSIE51bVxcbmxldCB3aWR0aCA9IGZ1biBnIOKGkiBtYXRjaCBkaW1lbnNpb25zIGcgYXMgUG9pbnQodywgXykg4oaSIHc7XFxuXFxuLy8gR3JhcGhpY3NFbGVtZW50IOKGkiBOdW1cXG5sZXQgaGVpZ2h0ID0gZnVuIGcg4oaSIG1hdGNoIGRpbWVuc2lvbnMgZyBhcyBQb2ludChfLCBoKSDihpIgaDtcXG5cXG4vLyBOdW0g4oaSIE51bSDihpIgTGlzdCBHcmFwaGljc0VsZW1lbnQg4oaSIExpc3QgR3JhcGhpY3NFbGVtZW50XFxubGV0IHNwYWNlUmlnaHQgPSBmdW4geiBzZXAgZ3Mg4oaSXFxuICAgemlwV2l0aCAodW5jdXJyeSBzZXRfeCkgKGl0ZXJhdGUgKGxlbmd0aCBncykgKGZ1biB4IOKGkiB4ICsgc2VwKSB6KSBncztcXG5cXG4vLyBCYWtlIGNvbG91ciBkZWNpc2lvbnMgaW50byB0aGUgbGlicmFyeSBmb3IgdGhlIHRpbWUgYmVpbmcuIFByb3ZpZGUgdHdvIHBhbGV0dGVzLCBzbyB3ZSBjYW4gaGF2ZSB0d29cXG4vLyBkaWZmZXJlbnQgc2V0cyBvZiBjYXRlZ29yaWNhbCB2YWx1ZXMgKGUuZy4gY291bnRyaWVzIGFuZCBlbmVyZ3kgdHlwZXMpLiBQYWxldHRlcyBmcm9tIGNvbG9yYnJld2VyMi5vcmcuXFxubGV0IGNvbG91cnMxID0gW1xcXCIjNjZjMmE1XFxcIiwgXFxcIiNhNmQ4NTRcXFwiLCBcXFwiI2ZmZDkyZlxcXCIsIFxcXCIjZTVjNDk0XFxcIiwgXFxcIiNmYzhkNjJcXFwiLCBcXFwiI2IzYjNiM1xcXCIsIFxcXCIjOGRhMGNiXFxcIiwgXFxcIiNlNzhhYzNcXFwiXTtcXG5sZXQgY29sb3VyczIgPSBbXFxcIiNlNDFhMWNcXFwiLCBcXFwiIzM3N2ViOFxcXCIsIFxcXCIjNGRhZjRhXFxcIiwgXFxcIiM5ODRlYTNcXFwiLCBcXFwiI2ZmN2YwMFxcXCIsIFxcXCIjZmZmZjMzXFxcIiwgXFxcIiNhNjU2MjhcXFwiLCBcXFwiI2Y3ODFiZlxcXCJdO1xcblxcbi8vIENvbXBvc2l0aW9uYWxpdHkgcHJpbmNpcGxlOiBjaGlsZCBjb29yZHMvZGltZW5zaW9ucyBhcmUgYWx3YXlzIGV4cHJlc3NlZCBkaXJlY3RseSB1c2luZyBwYXJlbnQgcmVmZXJlbmNlIFxcbi8vIGZyYW1lLCB0byBhdm9pZCBkZXBlbmRpbmcgb24gY29udGVudCBvZiBjaGlsZCwgYW5kIHNvIGFyZSBub3QgdGhlbXNlbHZlcyBzY2FsZWQuIFBvbHlsaW5lIGNhbid0IGJlIHNjYWxlZFxcbi8vIGRpcmVjdGx5IGJlY2F1c2UgaXQgaW5oZXJpdHMgaXRzIGZyYW1lIG9mIHJlZmVyZW5jZSBmcm9tIGl0cyBwYXJlbnQuIEZvciBWaWV3cG9ydCwgbWFyZ2luIHdpbGwgc2hyaW5rIHRoZVxcbi8vIGF2YWlsYWJsZSBhcmVhLCBwb3NzaWJseSB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCBub3RoaW5nIHdpbGwgYmUgcmVuZGVyZWQuXFxuLy8gTnVtIOKGkiBHcmFwaGljc0VsZW1lbnQg4oaSIEdyYXBoaWNzRWxlbWVudFxcbmxldHJlYyBmdW4gc2NhbGVUb1dpZHRoIHcge1xcbiAgIFJlY3QoeCwgeSwgXywgaCwgZmlsbCkg4oaSIFJlY3QoeCwgeSwgdywgaCwgZmlsbCk7XFxuICAgVmlld3BvcnQoeCwgeSwgdzAsIGgsIGZpbGwsIG1hcmdpbiwgU2NhbGUoeF9zY2FsZSwgeV9zY2FsZSksIHRyYW5zbGF0ZSwgZykg4oaSIFxcbiAgICAgIGxldCBzY2FsZSA9IFNjYWxlKHhfc2NhbGUgKiB3IC8gdzAsIHlfc2NhbGUpIGluIFZpZXdwb3J0KHgsIHksIHcsIGgsIGZpbGwsIG1hcmdpbiwgc2NhbGUsIHRyYW5zbGF0ZSwgZylcXG59O1xcblxcbi8vIE51bSDihpIgTGlzdCBHcmFwaGljc0VsZW1lbnQg4oaSIExpc3QgR3JhcGhpY3NFbGVtZW50XFxubGV0IHN0YWNrUmlnaHQgPSBmdW4gc2VwIGdzIOKGklxcbiAgIG1hcCAoc2NhbGVUb1dpZHRoICgxIC0gc2VwKSkgKHNwYWNlUmlnaHQgKHNlcCAvIDIpIDEgZ3MpO1xcblxcbi8vIE51bSDihpIgTGlzdCBHcmFwaGljc0VsZW1lbnQg4oaSIEdyYXBoaWNzRWxlbWVudFxcbmxldCBncm91cFJpZ2h0ID0gZnVuIHNlcCBncyDihpJcXG4gICBWaWV3cG9ydCgwLCAwLCBsZW5ndGggZ3MsIG1heCAobWFwIGhlaWdodCBncyksIFxcXCJub25lXFxcIiwgMCwgU2NhbGUoMSwgMSksIFRyYW5zbGF0ZSgwLCAwKSwgR3JvdXAoc3RhY2tSaWdodCBzZXAgZ3MpKTtcXG5cXG4vLyBIZXVyaXN0aWMgc2F5aW5nIGhvdyBvZnRlbiB0byBwbGFjZSBhIHRpY2sgb24gYW4gYXhpcyBvZiBsZW5ndGggbi5cXG4vLyBOdW0g4oaSIE51bVxcbmxldCB0aWNrRXZlcnkgPSBmdW4gbiDihpJcXG4gICBsZXQgbSA9IGZsb29yIChsb2dCYXNlIDEwIG4pIGluXFxuICAgbWF0Y2ggbiA8PSAyICogMTAgKiogbSBhcyB7XFxuICAgICAgVHJ1ZSDihpIgMiAqIDEwICoqIChtIC0gMSk7XFxuICAgICAgRmFsc2Ug4oaSIDEwICoqIG1cXG4gICB9O1xcblxcbmxldCBheGlzU3Ryb2tlV2lkdGggPSAwLjU7XFxubGV0IGF4aXNDb2xvdXIgPSBcXFwiYmxhY2tcXFwiO1xcbmxldCBiYWNrZ3JvdW5kQ29sb3VyID0gXFxcIndoaXRlXFxcIjtcXG5sZXQgZGVmYXVsdE1hcmdpbiA9IDI0O1xcbmxldCBtYXJrZXJSYWRpdXMgPSAzLjU7XFxubGV0IHRpY2tMZW5ndGggPSA0O1xcblxcbi8vIEhlbHBlcnMgZm9yIGF4aXMgZnVuY3Rpb25zLlxcbi8vIE9yaWVudCDihpIgQ29sb3VyIOKGkiBOdW0g4oaSIEdyYXBoaWNzRWxlbWVudFxcbmxldCB0aWNrID0gZnVuIHtcXG4gICBIb3JpeiBjb2xvdXIgbGVuIOKGklxcbiAgICAgIExpbmUoUG9pbnQoMCwgMCksIFBvaW50KDAsIDAgLSBsZW4pLCBjb2xvdXIsIGF4aXNTdHJva2VXaWR0aCk7XFxuICAgVmVydCBjb2xvdXIgbGVuIOKGklxcbiAgICAgIExpbmUoUG9pbnQoMCwgMCksIFBvaW50KDAgLSBsZW4sIDApLCBjb2xvdXIsIGF4aXNTdHJva2VXaWR0aClcXG4gICB9O1xcblxcbi8vIE9yaWVudCDihpIgTnVtIOKGkiBOdW0g4oaSIFN0ciDihpIgR3JhcGhpY3NFbGVtZW50XFxubGV0IGxhYmVsID0gZnVuIHtcXG4gICBIb3JpeiB4IGRpc3RhbmNlIHN0ciDihpIgVGV4dCh4LCAoMCAtIDQpIC0gZGlzdGFuY2UsIHN0ciwgXFxcIm1pZGRsZVxcXCIsIFxcXCJoYW5naW5nXFxcIik7IC8vIC00ICwgdWdoXFxuICAgVmVydCB4IGRpc3RhbmNlIHN0ciDihpIgVGV4dCgwIC0gZGlzdGFuY2UsIHgsIHN0ciwgXFxcImVuZFxcXCIsIFxcXCJjZW50cmFsXFxcIilcXG59O1xcblxcbi8vIE9yaWVudCDihpIgQ29sb3VyIOKGkiBOdW0g4oaSIFN0ciDihpIgR3JhcGhpY3NFbGVtZW50XFxubGV0IGxhYmVsbGVkVGljayA9IGZ1biBvcmllbnQgY29sb3VyIGxlbiBzdHIg4oaSXFxuICAgR3JvdXAoW3RpY2sgb3JpZW50IGNvbG91ciBsZW4sIGxhYmVsIG9yaWVudCAwIGxlbiBzdHJdKTtcXG5cXG4vLyBPcmllbnQg4oaSIE51bSDihpIgTnVtIOKGkiBQb2ludFxcbmxldCBta1BvaW50ID0gZnVuIHtcXG4gICBIb3JpeiB4IHkg4oaSIFBvaW50KHksIHgpO1xcbiAgIFZlcnQgeCB5IOKGkiBQb2ludCh4LCB5KVxcbn07XFxuXFxuLy8geCBpcyBwb3NpdGlvbiBvZiB0aGlzIGF4aXMgb24gdGhlIG90aGVyIGF4aXMuIFJldHVybnMgYXhpcyBhbmQgcG9zaXRpb24gb2YgbGFzdCB0aWNrLlxcbi8vIE9yaWVudCDihpIgTnVtIOKGkiBOdW0g4oaSIEdyYXBoaWNzRWxlbWVudCBcXG5sZXQgYXhpcyA9IGZ1biBvcmllbnQgeCBzdGFydCBlbmQg4oaSXFxuICAgbGV0IHRpY2tTcCA9IHRpY2tFdmVyeSAoZW5kIC0gc3RhcnQpO1xcbiAgIGxldCBmaXJzdFRpY2sgPSBjZWlsaW5nVG9OZWFyZXN0IHN0YXJ0IHRpY2tTcDtcXG4gICBsZXQgbGFzdFRpY2sgPSBjZWlsaW5nVG9OZWFyZXN0IGVuZCB0aWNrU3A7XFxuICAgbGV0IG4gPSBmbG9vciAoKGVuZCAtIGZpcnN0VGljaykgLyB0aWNrU3ApICsgMTtcXG4gICBsZXQgeXMgPSBpdGVyYXRlIG4gKGZ1biB5IOKGkiB5ICsgdGlja1NwKSBmaXJzdFRpY2s7XFxuICAgLy8gYXZvaWQgcmVkdW5kYW50IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXFxuICAgbGV0IHlzID0gbWF0Y2ggZmlyc3RUaWNrID4gc3RhcnQgYXMge1xcbiAgICAgIFRydWUg4oaSIFtzdGFydCwgLi4ueXNdO1xcbiAgICAgIEZhbHNlIOKGkiB5c1xcbiAgIH07XFxuICAgbGV0IHlzID0gbWF0Y2ggbGFzdFRpY2sgPiBlbmQgYXMge1xcbiAgICAgIFRydWUg4oaSIGNvbmNhdCB5cyBbbGFzdFRpY2tdO1xcbiAgICAgIEZhbHNlIOKGkiB5c1xcbiAgIH07XFxuICAgbGV0IHBzID0gbWFwIChta1BvaW50IG9yaWVudCB4KSB5cztcXG4gICBsZXQgYXggPSBHcm91cChbXFxuICAgICAgTGluZShoZWFkIHBzLCBsYXN0IHBzLCBheGlzQ29sb3VyLCBheGlzU3Ryb2tlV2lkdGgpLFxcbiAgICAgIFBvbHltYXJrZXJzKHBzLCBmbGlwIG1hcCB5cyAoY29tcG9zZSAobGFiZWxsZWRUaWNrIG9yaWVudCBheGlzQ29sb3VyIHRpY2tMZW5ndGgpIG51bVRvU3RyKSlcXG4gICBdKVxcbiAgIGluIChheCwgbGFzdFRpY2spO1xcblxcbi8vIHggaXMgcG9zaXRpb24gb2YgdGhpcyBheGlzIG9uIHRoZSBvdGhlciBheGlzLlxcbi8vIE9yaWVudCDihpIgTnVtIOKGkiBOdW0g4oaSIExpc3QgQ2F0IOKGkiBHcmFwaGljc0VsZW1lbnQgXFxubGV0IGNhdEF4aXMgPSBmdW4gb3JpZW50IHggY2F0VmFsdWVzIOKGklxcbiAgIGxldCB5cyA9IGl0ZXJhdGUgKGxlbmd0aCBjYXRWYWx1ZXMgKyAxKSAoZnVuIHkg4oaSIHkgKyAxKSAwO1xcbiAgIGxldCBwcyA9IG1hcCAobWtQb2ludCBvcmllbnQgeCkgeXNcXG4gICBpbiBHcm91cChbXFxuICAgICAgTGluZShoZWFkIHBzLCBsYXN0IHBzLCBheGlzQ29sb3VyLCBheGlzU3Ryb2tlV2lkdGgpLFxcbiAgICAgIFBvbHltYXJrZXJzKHRhaWwgcHMsIG1hcCAoY29uc3QgKHRpY2sgb3JpZW50IGF4aXNDb2xvdXIgdGlja0xlbmd0aCkpIGNhdFZhbHVlcyksXFxuICAgICAgUG9seW1hcmtlcnMoZmxpcCBtYXAgKHRhaWwgcHMpIChmdW4gUG9pbnQoeCwgeSkg4oaSIFBvaW50KHggLSAwLjUsIHkpKSwgbWFwIChsYWJlbCBvcmllbnQgLTAuNSAwKSBjYXRWYWx1ZXMpXFxuICAgXSk7XFxuXFxuLy8gTnVtIOKGkiBOdW0g4oaSIE51bSDihpIgTnVtIOKGkiBMaXN0IEdyYXBoaWNzRWxlbWVudCDihpIgR3JhcGhpY3NFbGVtZW50XFxubGV0IHZpZXdwb3J0ID0gZnVuIHhfc3RhcnQgeF9maW5pc2ggeV9maW5pc2ggbWFyZ2luIGdzIOKGklxcbiAgIFZpZXdwb3J0KDAsIDAsIHhfZmluaXNoIC0geF9zdGFydCwgeV9maW5pc2gsIGJhY2tncm91bmRDb2xvdXIsIG1hcmdpbiwgU2NhbGUoMSwgMSksIFRyYW5zbGF0ZSgwIC0geF9zdGFydCwgMCksIEdyb3VwKGdzKSk7XFxuXFxuLy8gUGxvdCBhIG1hcCBvZiB4IHZhbHVlcyB0byBsaXN0cyBvZiAoY2F0ZWdvcmljYWwgdmFsdWUsIHkgdmFsdWUpIHBhaXJzLiBJbXBvcnRhbnRseSwgYXNzdW1lIGFsbCBkYXRhIGlzIHVuaWZvcm0gXFxuLy8gKGNhdGVnb3JpY2FsIGtleXMgYXJlIHRoZSBzYW1lIGZvciBlYWNoIHggdmFsdWUgYW5kIGFyZSBvcmRlcmVkIHRoZSBzYW1lIGVhY2ggdGltZSkuXFxuLy8gQm9vbCDihpIgQ29sb3VycyDihpIgTnVtIOKGkiBMaXN0IChOdW0sIExpc3QgKENhdCwgTnVtKSkg4oaSIEdyYXBoaWNzRWxlbWVudFxcbmxldCBsaW5lQ2hhcnQgPSBmdW4gd2l0aEF4ZXMgY29sb3VycyB4X3N0YXJ0IGRhdGEg4oaSXFxuICAgbGV0IHhzID0gbWFwIGZzdCBkYXRhO1xcbiAgIGxldCBuQ2F0ID0gbGVuZ3RoIChzbmQgKGhlYWQgZGF0YSkpO1xcbiAgIC8vIChOdW0sIENvbG91cikg4oaSIEdyYXBoaWNzRWxlbWVudFxcbiAgIGxldCBwbG90ID0gZnVuIChuLCBjb2xvdXIpIOKGklxcbiAgICAgIGxldCBwcyA9IG1hcCAoZnVuICh4LCBrdnMpIOKGkiBQb2ludCh4LCBzbmQgKG50aCBuIGt2cykpKSBkYXRhXFxuICAgICAgaW4gR3JvdXAoW1xcbiAgICAgICAgIFBvbHlsaW5lKHBzLCBjb2xvdXIsIDEpLFxcbiAgICAgICAgIFBvbHltYXJrZXJzKHBzLCByZXBlYXQgKGxlbmd0aCBwcykgQ2lyY2xlKDAsIDAsIG1hcmtlclJhZGl1cywgY29sb3VyKSlcXG4gICAgICBdKTtcXG4gICAvLyBMaXN0IEdyYXBoaWNzRWxlbWVudFxcbiAgIGxldCBsaW5lcyA9IHppcFdpdGggcGxvdCAoaXRlcmF0ZSBuQ2F0IChmdW4gbiDihpIgbiArIDEpIDApIGNvbG91cnM7XFxuICAgbGV0IHhfZmluaXNoID0gbGFzdCB4cztcXG4gICBsZXQgeV9maW5pc2ggPSBtYXggKGZsaXAgbWFwIGRhdGEgKGZ1biAoXywga3ZzKSDihpIgbWF4IChtYXAgc25kIGt2cykpKVxcbiAgIGluIG1hdGNoIHdpdGhBeGVzIGFzIHtcXG4gICAgICBUcnVlIOKGklxcbiAgICAgICAgIG1hdGNoIGF4aXMgSG9yaXogMCB4X3N0YXJ0IHhfZmluaXNoIGFzXFxuICAgICAgICAgKHhfYXhpcywgeF9maW5pc2gpIOKGkiBtYXRjaCBheGlzIFZlcnQgeF9zdGFydCAwIHlfZmluaXNoIGFzIFxcbiAgICAgICAgICh5X2F4aXMsIHlfZmluaXNoJykg4oaSIHZpZXdwb3J0IHhfc3RhcnQgeF9maW5pc2ggeV9maW5pc2gnIGRlZmF1bHRNYXJnaW4gW3hfYXhpcywgeV9heGlzLCAuLi5saW5lc107XFxuICAgICAgRmFsc2Ug4oaSIHZpZXdwb3J0IHhfc3RhcnQgeF9maW5pc2ggeV9maW5pc2ggMCBsaW5lc1xcbiAgIH07XFxuXFxuLy8gUGxvdCBhIGNoYXJ0IG9mIGNhdGVnb3JpY2FsIHZhbHVlcyBvbiB0aGUgeC1heGlzIGFuZCByZW5kZXJpbmdzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGEtdmFsdWUgb24gdGhlIHktYXhpcy5cXG4vLyAoQ29sb3VycyDihpIgTGlzdCBhIOKGkiBHcmFwaGljc0VsZW1lbnQpIOKGkiBCb29sIOKGkiBDb2xvdXJzIOKGkiBOdW0g4oaSIExpc3QgKENhdCwgYSkg4oaSIEdyYXBoaWNzRWxlbWVudFxcbmxldCBjYXRlZ29yaWNhbENoYXJ0ID0gZnVuIHBsb3RWYWx1ZSB3aXRoQXhlcyBjb2xvdXJzIHNlcCBkYXRhIOKGklxcbiAgIGxldCBncyA9IHN0YWNrUmlnaHQgc2VwIChwbG90VmFsdWUgY29sb3VycyAobWFwIHNuZCBkYXRhKSk7XFxuICAgbGV0IHcgPSBsZW5ndGggZ3M7XFxuICAgbGV0IGggPSBtYXggKG1hcCBoZWlnaHQgZ3MpXFxuICAgaW4gbWF0Y2ggd2l0aEF4ZXMgYXMge1xcbiAgICAgIFRydWUg4oaSIFxcbiAgICAgICAgIG1hdGNoIGNhdEF4aXMgSG9yaXogMCAobWFwIGZzdCBkYXRhKSBhcyBcXG4gICAgICAgICB4X2F4aXMg4oaSIG1hdGNoIGF4aXMgVmVydCAwIDAgaCBhc1xcbiAgICAgICAgICh5X2F4aXMsIGgnKSDihpIgdmlld3BvcnQgMCB3IGgnIGRlZmF1bHRNYXJnaW4gKGNvbmNhdCBncyBbeF9heGlzLCB5X2F4aXNdKTsgLy8gYXhlcyBvbiB0b3BcXG4gICAgICBGYWxzZSDihpIgdmlld3BvcnQgMCB3IGggMCBnc1xcbiAgIH07XFxuXFxuLy8gQ29sb3VycyDihpIgTGlzdCBhIOKGkiBHcmFwaGljc0VsZW1lbnRcXG5sZXQgcmVjdHMgPSBmdW4gY29sb3VycyBucyDihpJcXG4gICB6aXBXaXRoIChmdW4gKGNvbG91ciwgbikg4oaSIFJlY3QoMCwgMCwgMSwgbiwgY29sb3VyKSkgY29sb3VycyBucztcXG5cXG4vLyBGaXJzdCBjb21wb25lbnQgb2YgZGF0YSAoY2F0ZWdvcmljYWwgdmFsdWUpIGN1cnJlbnRseSBpZ25vcmVkOyB2YWx1ZXMganVzdCBtYXBwZWQgcG9zaXRpb25hbGx5IHRvIGNvbG9ycy5cXG4vLyBDYW4gd2UgdXNlIEdyb3VwIGluc3RlYWQgb2YgVmlld3BvcnQgaGVyZT9cXG4vLyBDb2xvdXJzIOKGkiBMaXN0IChhLCBOdW0pIOKGkiBHcmFwaGljc0VsZW1lbnRcXG5sZXQgc3RhY2tlZEJhciA9IGZ1biBjb2xvdXJzIG5zIOKGklxcbiAgIGxldCBoZWlnaHRzID0gKG1hcCBzbmQgbnMpO1xcbiAgIGxldCBzdWJ0b3RhbHMgPSBzY2FubDEgKGZ1biAoeCwgeSkg4oaSIHggKyB5KSAwIGhlaWdodHM7XFxuICAgbGV0IGRpbXMgPSB6aXAgWzAsIC4uLnN1YnRvdGFsc10gaGVpZ2h0cztcXG4gICBsZXQgcmVjdHMgPSBtYXAgXFxuICAgICAgKGZ1biAoKHksIGhlaWdodCksIGNvbG91cikg4oaSIFJlY3QoMCwgeSwgMSwgaGVpZ2h0LCBjb2xvdXIpKVxcbiAgICAgICh6aXAgZGltcyBjb2xvdXJzKVxcbiAgIGluIFZpZXdwb3J0KDAsIDAsIDEsIGxhc3Qgc3VidG90YWxzLCBcXFwibm9uZVxcXCIsIDAsIFNjYWxlKDEsIDEpLCBUcmFuc2xhdGUoMCwgMCksIEdyb3VwKHJlY3RzKSk7XFxuXFxuLy8gQm9vbCDihpIgQ29sb3VycyDihpIgTnVtIOKGkiBMaXN0IChhLCBOdW0pIOKGkiBHcmFwaGljc0VsZW1lbnRcXG5sZXQgYmFyQ2hhcnQgPSBjYXRlZ29yaWNhbENoYXJ0IHJlY3RzO1xcblxcbi8vIEZvciBlYWNoIGNhdGVnb3JpY2FsIHZhbHVlIG9mIHR5cGUgYSwgcGxvdCBhIGJhciBjaGFydCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgYi1pbmRleGVkIGRhdGEuXFxuLy8gQm9vbCDihpIgQ29sb3VycyDihpIgTnVtIOKGkiBMaXN0IChhLCBMaXN0IChiLCBOdW0pKSDihpIgR3JhcGhpY3NFbGVtZW50XFxubGV0IGdyb3VwZWRCYXJDaGFydCA9IGNhdGVnb3JpY2FsQ2hhcnQgKGNvbXBvc2UgbWFwIChmbGlwIChiYXJDaGFydCBGYWxzZSkgMCkpO1xcblxcbi8vIFNlZSBzdGFja2VkQmFyIGZvciBzdHJvbmcgKHVuanVzdGlmaWVkKSBhc3N1bXB0aW9uIGFib3V0IHVuaWZvcm1pdHkgb2YgZGF0YS5cXG4vLyBCb29sIOKGkiBDb2xvdXJzIOKGkiBOdW0g4oaSIExpc3QgKGEsIExpc3QgKGIsIE51bSkpIOKGkiBHcmFwaGljc0VsZW1lbnRcXG5sZXQgc3RhY2tlZEJhckNoYXJ0ID0gY2F0ZWdvcmljYWxDaGFydCAoY29tcG9zZSBtYXAgc3RhY2tlZEJhcik7XFxuXFxuLy8gQml0IG9mIGEgaGFjaywgYnV0IGhvdyB0ZXh0IGZpdHMgaW50byBvdXIgbW9kZWwgaXMgYSBiaXQgdW5jbGVhciBhdCB0aGUgbW9tZW50Llxcbi8vIFN0ciDihpIgR3JhcGhpY3NFbGVtZW50IOKGkiBHcmFwaGljc0VsZW1lbnRcXG5sZXQgY2FwdGlvbiA9IGZ1biBzdHIgVmlld3BvcnQoeCwgeSwgdywgaCwgZmlsbCwgbWFyZ2luLCBzY2FsZSwgdHJhbnNsYXRlLCBnKSDihpJcXG4gICBsZXQgZycgPSBHcm91cChbXFxuICAgICAgVGV4dCh4ICsgdyAvIDIsIC0yLCBzdHIsIFxcXCJtaWRkbGVcXFwiLCBcXFwiaGFuZ2luZ1xcXCIpLCAvLyAtMywgdWdoXFxuICAgICAgVmlld3BvcnQoMCwgMCwgdywgaCwgZmlsbCwgbWFyZ2luLCBzY2FsZSwgdHJhbnNsYXRlLCBnKVxcbiAgIF0pXFxuICAgaW4gVmlld3BvcnQoeCwgeSwgdywgaCwgYmFja2dyb3VuZENvbG91ciwgZGVmYXVsdE1hcmdpbiAvIDIgKyA0LCBTY2FsZSgxLCAxKSwgVHJhbnNsYXRlKDAsIDApLCBnJylcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi8vIE51bSDihpIgTnVtXFxucHJpbWl0aXZlIGNlaWxpbmc7XFxuXFxuLy8gU3RyIOKGkiBhXFxucHJpbWl0aXZlIGVycm9yO1xcblxcbi8vIE51bSDihpIgTnVtXFxucHJpbWl0aXZlIGZsb29yO1xcblxcbi8vIE5hdHVyYWwgbG9nYXJpdGhtLlxcbi8vIE51bSDihpIgTnVtXFxucHJpbWl0aXZlIGxvZztcXG5cXG4vLyBOdW0g4oaSIFN0clxcbnByaW1pdGl2ZSBudW1Ub1N0cjtcXG5cXG4vLyBQcmludCBhcmd1bWVudCB0byB0aGUgY29uc29sZSBhbmQgcmV0dXJuIGl0Llxcbi8vIGEg4oaSIGFcXG5wcmltaXRpdmUgZGVidWdMb2c7XFxuXFxuLy8gQm9vbCDihpIgQm9vbFxcbmxldCBvciA9IGZ1biB7XFxuICAgVHJ1ZSB4IOKGkiBUcnVlO1xcbiAgIEZhbHNlIFRydWUg4oaSIFRydWU7XFxuICAgRmFsc2UgRmFsc2Ug4oaSIEZhbHNlXFxufTtcXG5cXG4vLyBCb29sIOKGkiBCb29sXFxubGV0IG5vdCA9IGZ1biB7XFxuICAgVHJ1ZSDihpIgRmFsc2U7XFxuICAgRmFsc2Ug4oaSIFRydWVcXG59O1xcblxcbi8vIChiIOKGkiBjKSDihpIgKGEg4oaSIGIpIOKGkiBhIOKGkiBjXFxuLy8gV291bGQgbGlrZSBpbmZpeCBvcGVyYXRvcnMuIFxcbmxldCBjb21wb3NlID0gZnVuIGYgZyB4IOKGkiBmIChnIHgpO1xcblxcbi8vIGEg4oaSIGIg4oaSIGFcXG5sZXQgY29uc3QgPSBmdW4geCBfIOKGkiB4O1xcblxcbi8vIChhIOKGkiBiKSDihpIgKGEsIGMpIOKGkiAoYiwgYylcXG5sZXQgZmlyc3QgPSBmdW4gZiAoYSwgYykg4oaSIChmIGEsIGMpO1xcblxcbi8vIChhLCBiKSDihpIgYVxcbmxldCBmc3QgPSBmdW4gKHgsIHkpIOKGkiB4O1xcblxcbi8vIExpc3QgYSDihpIgYVxcbmxldCBoZWFkID0gZnVuIFt4LCAuLi54c10g4oaSIHg7XFxuXFxuLy8gYSDihpIgYVxcbmxldCBpZCA9IGZ1biB4IOKGkiB4O1xcblxcbi8vIChhIOKGkiBiKSDihpIgKGEg4oaSIGMpIOKGkiBhIOKGkiAoYiwgYylcXG5sZXQgcHJvZCA9IGZ1biBmIGcgeCDihpIgKGYgeCwgZyB4KTtcXG5cXG4vLyBOdW0g4oaSIE51bSDihpIgT3JkZXJpbmdcXG5sZXQgY29tcGFyZSA9XFxuICAgZnVuICh4LCB5KSDihpJcXG4gICAgICBtYXRjaCB4IDwgeSBhcyB7XFxuICAgICAgICAgVHJ1ZSDihpIgTFQ7XFxuICAgICAgICAgRmFsc2Ug4oaSIG1hdGNoIHggPiB5IGFzIHtcXG4gICAgICAgICAgICBUcnVlIOKGkiBHVDtcXG4gICAgICAgICAgICBGYWxzZSDihpIgRVFcXG4gICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4vLyBMaXN0IGEg4oaSIExpc3QgYSDihpIgTGlzdCBhXFxubGV0cmVjIGZ1biBjb25jYXQge1xcbiAgIFtdIHlzIOKGkiB5cztcXG4gICBbeCwgLi4ueHNdIHlzIOKGkiBbeCwgLi4uY29uY2F0IHhzIHlzXVxcbn07XFxuXFxuLy8gYSDihpIgTGlzdCBhIOKGkiBCb29sICh3aGVyZSBhIOKIiCB7TnVtLCBTdHJ9KVxcbmxldHJlYyBmdW4gZWxlbSB4IHtcXG4gICBbXSDihpIgRmFsc2U7XFxuICAgW3gnLCAuLi54c10g4oaSIG9yICh4ID09IHgnKSAoZWxlbSB4IHhzKVxcbn07XFxuXFxuLy8gKGEg4oaSIEJvb2wpIOKGkiBMaXN0IGEg4oaSIExpc3QgYVxcbmxldHJlYyBmdW4gZmlsdGVyIHAge1xcbiAgIFtdIOKGkiBbXTtcXG4gICBbeCwgLi4ueHNdIOKGklxcbiAgICAgIGxldCB5cyA9IGZpbHRlciBwIHhzIGluXFxuICAgICAgbWF0Y2ggcCB4IGFzIHtcXG4gICAgICAgICBUcnVlIOKGkiBbeCwgLi4ueXNdO1xcbiAgICAgICAgIEZhbHNlIOKGkiB5c1xcbiAgICAgIH1cXG59O1xcblxcbi8vIChhIOKGkiBiIOKGkiBjKSDihpIgYiDihpIgYSDihpIgY1xcbmxldCBmbGlwID0gZnVuIGYgeCB5IOKGkiBmIHkgeDtcXG5cXG4vLyAoKGEsIGIpIOKGkiBhKSDihpIgYSDihpIgTGlzdCBiIOKGkiBhXFxubGV0cmVjIGZ1biBmb2xkbCBvcCB6IHtcXG4gICBbXSDihpIgejtcXG4gICBbeCwgLi4ueHNdIOKGkiBmb2xkbCBvcCAob3AgKHosIHgpKSB4c1xcbn07XFxuXFxuLy8gKChhLCBiKSDihpIgYSkg4oaSIExpc3QgYiDihpIgYVxcbmxldHJlYyBmdW4gZm9sZGwxIG9wIHtcXG4gICBbeCwgLi4ueHNdIOKGkiBmb2xkbCBvcCB4IHhzXFxufTtcXG5cXG4vLyAoKGEsIGIpIOKGkiBiKSDihpIgYiDihpIgTGlzdCBhIOKGkiBiXFxubGV0cmVjIGZ1biBmb2xkciBvcCB6IHtcXG4gICBbXSDihpIgejtcXG4gICBbeCwgLi4ueHNdIOKGkiBvcCAoeCwgZm9sZHIgb3AgeiB4cylcXG59O1xcblxcbi8vICgoYSwgYikg4oaSIGIpIOKGkiBMaXN0IGEg4oaSIGJcXG5sZXRyZWMgZnVuIGZvbGRyMSBvcCB7XFxuICAgW3hdIOKGkiB4O1xcbiAgIFt4LCB5LCAuLi54c10g4oaSIG9wICh4LCBmb2xkcjEgb3AgW3ksIC4uLnhzXSlcXG59O1xcblxcbi8vICgoYSwgYikg4oaSIGEpIOKGkiBhIOKGkiBMaXN0IGIgLT4gTGlzdCBhXFxubGV0cmVjIGZ1biBzY2FubDEgb3AgeiB4cyDihpIgXFxuICAgbGV0IGdvID0gZnVuICh4LCBjb250aW51ZSkgYWNjIOKGkiBcXG4gICAgICBsZXQgbmV4dCA9IG9wIChhY2MsIHgpIGluIFtuZXh0LCAuLi5jb250aW51ZSBuZXh0XSBpblxcbiAgIGZvbGRyIGdvIChjb25zdCBbXSkgeHMgejtcXG5cXG4vLyAoKGEsIGIpIOKGkiBhKSDihpIgYSDihpIgTGlzdCBiIC0+IExpc3QgYVxcbmxldCBzY2FubCA9IGZ1biBvcCB6IHhzIOKGkiBcXG4gICBbeiwgLi4uc2NhbmwxIG9wIHogeHNdO1xcblxcbi8vIExpc3QgYSDihpIgYSDihpIgTGlzdCBhXFxubGV0cmVjIGZ1biBpbnRlcnNwZXJzZSB7XFxuICAgW10gc2VwIOKGkiBbXTtcXG4gICBbeF0gc2VwIOKGkiBbeF07XFxuICAgW3gsIHksIC4uLnlzXSBzZXAg4oaSIFt4LCBzZXAsIC4uLmludGVyc3BlcnNlIFt5LCAuLi55c11dXFxufTtcXG5cXG4vLyBMaXN0IGEg4oaSIGFcXG5sZXRyZWMgZnVuIGxhc3Qge1xcbiAgIFt4XSDihpIgeDtcXG4gICBbeCwgeSwgLi4ueHNdIOKGkiBsYXN0IFt5LCAuLi54c11cXG59O1xcblxcbi8vIExvZyBvZiB4IGluIGJhc2UgeS5cXG4vLyBOdW0g4oaSIE51bSDihpIgTnVtXFxubGV0IGxvZ0Jhc2UgPSBmdW4geCB5IOKGkiBsb2cgeSAvIGxvZyB4O1xcblxcbi8vIChhIOKGkiBiKSDihpIgTGlzdCBhIOKGkiBMaXN0IGJcXG5sZXRyZWMgZnVuIG1hcCBmIHtcXG4gICBbXSDihpIgW107XFxuICAgW3gsIC4uLnhzXSDihpIgW2YgeCwgLi4ubWFwIGYgeHNdXFxufTtcXG5cXG4vLyBOdW0g4oaSIChhIOKGkiBhKSDihpIgYSDihpIgTGlzdCBhXFxubGV0cmVjIGZ1biBpdGVyYXRlIG4gZiB6IOKGkiBtYXRjaCBuID09IDAgYXMge1xcbiAgIFRydWUg4oaSIFtdO1xcbiAgIEZhbHNlIOKGkiBbeiwgLi4ubWFwIGYgKGl0ZXJhdGUgKG4gLSAxKSBmIHopXVxcbn07XFxuXFxuLy8gTGlzdCBhIOKGkiBOdW1cXG5sZXRyZWMgZnVuIGxlbmd0aCB7XFxuICAgW10g4oaSIDA7XFxuICAgW3gsIC4uLnhzXSDihpIgMSArIGxlbmd0aCB4c1xcbn07XFxuXFxuLy8gTnVtIOKGkiBOdW1cXG5sZXQgbmVnYXRlID0gZnVuIG4g4oaSIDAgLSBuO1xcblxcbi8vIExpc3QgYSDihpIgTGlzdCBhXFxubGV0cmVjIGZ1biByZXZlcnNlIHtcXG4gICBbXSDihpIgW107XFxuICAgW3gsIC4uLnhzXSDihpIgY29uY2F0IChyZXZlcnNlIHhzKSBbeF1cXG59O1xcblxcbi8vIExpc3QgKGEsIGIpIOKGkiAoTGlzdCBhLCBMaXN0IGIpXFxubGV0cmVjIGZ1biB1bnppcCB7XFxuICAgW10g4oaSIChbXSwgW10pO1xcbiAgIFsoeCwgeSksIC4uLnh5c10g4oaSIFxcbiAgICAgIG1hdGNoIHVuemlwIHh5cyBhcyAoeHMsIHlzKSDihpIgKFt4LCAuLi54c10sIFt5LCAuLi55c10pXFxufTtcXG5cXG4vLyAoKGEsIGIpIOKGkiBjKSDihpIgTGlzdCBhIOKGkiBMaXN0IGIg4oaSIExpc3QgY1xcbmxldHJlYyBmdW4gemlwV2l0aCBvcCB7XFxuICAgW10geXMg4oaSIFtdO1xcbiAgIFt4LCAuLi54c10ge1xcbiAgICAgIFtdIOKGkiBbXTtcXG4gICAgICBbeSwgLi4ueXNdIOKGkiBbb3AgKHgsIHkpLCAuLi56aXBXaXRoIG9wIHhzIHlzXVxcbiAgIH1cXG59O1xcblxcbmxldCB6aXAgPSB6aXBXaXRoIGlkO1xcblxcbi8vIE51bSDihpIgYSDihpIgTGlzdCBhXFxubGV0IHJlcGVhdCA9IGZsaXAgaXRlcmF0ZSBpZDtcXG5cXG4vLyBhIOKGkiBMaXN0IChhLCBiKSDihpIgYiAod2hlcmUgYSDiiIgge051bSwgU3RyfSlcXG5sZXRyZWMgZnVuIGxvb2t1cCBrIFsoaycsIHYpLCAuLi5rdnNdIOKGkiBcXG4gICBtYXRjaCBrID09IGsnIGFzIHtcXG4gICAgICBUcnVlIOKGkiB2O1xcbiAgICAgIEZhbHNlIOKGkiBsb29rdXAgayBrdnNcXG4gICB9O1xcblxcbi8vIChOdW0sIE51bSkg4oaSIE51bVxcbmxldCBtYXgyID0gZnVuIChuLCBtKSDihpJcXG4gICBtYXRjaCBuID4gbSBhcyB7IFRydWUg4oaSIG47IEZhbHNlIOKGkiBtIH07XFxuXFxuLy8gKE51bSwgTnVtKSDihpIgTnVtXFxubGV0IG1pbjIgPSBmdW4gKG4sIG0pIOKGklxcbiAgIG1hdGNoIG4gPCBtIGFzIHsgVHJ1ZSDihpIgbjsgRmFsc2Ug4oaSIG0gfTtcXG5cXG4vLyBMaXN0IE51bSDihpIgTnVtXFxubGV0IG1heCA9IGZvbGRyMSBtYXgyO1xcblxcbi8vIExpc3QgTnVtIOKGkiBOdW1cXG5sZXQgbWluID0gZm9sZHIxIG1pbjI7XFxuXFxuLy8gRXhwZWN0cyBub24tbmVnYXRpdmUgaW50ZWdlciBhcyBmaXJzdCBhcmd1bWVudCBhbmQgbm9uLWVtcHR5IGxpc3QgYXMgc2Vjb25kIGFyZ3VtZW50Llxcbi8vIE51bSDihpIgTGlzdCBhIOKGkiBhXFxubGV0cmVjIGZ1biBudGggbiBbeCwgLi4ueHNdIOKGkiBtYXRjaCBuID09IDAgYXMge1xcbiAgIFRydWUg4oaSIHg7XFxuICAgRmFsc2Ug4oaSIG50aCAobiAtIDEpIHhzXFxufTtcXG5cXG4vLyBOdW0g4oaSIE51bSDihpIgTnVtXFxubGV0IGNlaWxpbmdUb05lYXJlc3QgPSBmdW4gbiBtIOKGkiBcXG4gICBjZWlsaW5nIChuIC8gbSkgKiBtO1xcblxcbi8vIChhIOKGkiBiKSDihpIgKGMsIGEpIOKGkiAoYywgYilcXG5sZXQgc2Vjb25kID0gZnVuIGYgKGMsIGEpIOKGkiAoYywgZiBhKTtcXG5cXG4vLyAoYSwgYikg4oaSIGJcXG5sZXQgc25kID0gZnVuICh4LCB5KSDihpIgeTtcXG5cXG4vLyBMaXN0IE51bSDihpIgTnVtXFxubGV0IHN1bSA9IGZ1biB4cyDihpIgXFxuICAgZm9sZHIgKGZ1biAoeCwgeSkg4oaSIHggKyB5KSAwIHhzO1xcblxcbi8vIChhLCBiKSDihpIgKGIsIGEpXFxubGV0IHN3YXAgPSBmdW4gKGEsIGIpIOKGkiAoYiwgYSk7XFxuXFxuLy8gTGlzdCBhIOKGkiBMaXN0IGFcXG5sZXQgdGFpbCA9IGZ1biBbeCwgLi4ueHNdIOKGkiB4cztcXG5cXG4vLyAoYSwgYikg4oaSIGMpIOKGkiBhIOKGkiBiIOKGkiBjXFxubGV0IGN1cnJ5ID0gZnVuIGYgeCB5IOKGkiBmICh4LCB5KTtcXG5cXG4vLyAoYSDihpIgYiDihpIgYykg4oaSIChhLCBiKSDihpIgY1xcbmxldCB1bmN1cnJ5ID0gZnVuIGYgKHgsIHkpIOKGkiBmIHggeTtcXG5cXG5sZXRyZWMgZnVuIHRha2UgbiB4cyDihpJcXG4gICBtYXRjaCBuIDw9IDAgYXMge1xcbiAgICAgIFRydWUg4oaSIFtdO1xcbiAgICAgIEZhbHNlIOKGkiBtYXRjaCB4cyBhcyB7XFxuICAgICAgICAgW10g4oaSIFtdO1xcbiAgICAgICAgIFt4LCAuLi54c10g4oaSIFt4LCAuLi50YWtlIChuIC0gMSkgeHNdXFxuICAgICAgfVxcbiAgIH07XFxuXFxubGV0cmVjIGZ1biBkcm9wIG4geHMg4oaSXFxuICAgbWF0Y2ggbiA8PSAwIGFzIHtcXG4gICAgICBUcnVlIOKGkiB4cztcXG4gICAgICBGYWxzZSDihpIgbWF0Y2ggeHMgYXMge1xcbiAgICAgICAgIFtdIOKGkiBbXTtcXG4gICAgICAgICBbXywgLi4ueHNdIOKGkiBkcm9wIChuIC0gMSkgeHNcXG4gICAgICB9XFxuICAgfTtcXG5cXG4vLyBOdW0g4oaSIExpc3QgYSDihpIgTGlzdCBhXFxubGV0IGxhc3ROID0gZnVuIG4geHMg4oaSXFxuICAgZm9sZGwgKHVuY3VycnkgKGNvbXBvc2UgY29uc3QgKGRyb3AgMSkpKSB4cyAoZHJvcCBuIHhzKVxcblwiOyIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50aXBweS10b29sdGlwW2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjB9LnRpcHB5LWlPU3tjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnQ7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJ7cG9pbnRlci1ldmVudHM6bm9uZTttYXgtd2lkdGg6Y2FsYygxMDB2dyAtIDEwcHgpO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTY1LC44NCwuNDQsMSk7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm19LnRpcHB5LXRvb2x0aXB7cG9zaXRpb246cmVsYXRpdmU7Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjRweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjQ7YmFja2dyb3VuZC1jb2xvcjojMzMzO3RyYW5zaXRpb24tcHJvcGVydHk6dmlzaWJpbGl0eSxvcGFjaXR5LHRyYW5zZm9ybTtvdXRsaW5lOjB9LnRpcHB5LXRvb2x0aXBbZGF0YS1wbGFjZW1lbnRePXRvcF0+LnRpcHB5LWFycm93e2JvcmRlci13aWR0aDo4cHggOHB4IDA7Ym9yZGVyLXRvcC1jb2xvcjojMzMzO21hcmdpbjowIDNweDt0cmFuc2Zvcm0tb3JpZ2luOjUwJSAwO2JvdHRvbTotN3B4fS50aXBweS10b29sdGlwW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1hcnJvd3tib3JkZXItd2lkdGg6MCA4cHggOHB4O2JvcmRlci1ib3R0b20tY29sb3I6IzMzMzttYXJnaW46MCAzcHg7dHJhbnNmb3JtLW9yaWdpbjo1MCUgN3B4O3RvcDotN3B4fS50aXBweS10b29sdGlwW2RhdGEtcGxhY2VtZW50Xj1sZWZ0XT4udGlwcHktYXJyb3d7Ym9yZGVyLXdpZHRoOjhweCAwIDhweCA4cHg7Ym9yZGVyLWxlZnQtY29sb3I6IzMzMzttYXJnaW46M3B4IDA7dHJhbnNmb3JtLW9yaWdpbjowIDUwJTtyaWdodDotN3B4fS50aXBweS10b29sdGlwW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93e2JvcmRlci13aWR0aDo4cHggOHB4IDhweCAwO2JvcmRlci1yaWdodC1jb2xvcjojMzMzO21hcmdpbjozcHggMDt0cmFuc2Zvcm0tb3JpZ2luOjdweCA1MCU7bGVmdDotN3B4fS50aXBweS10b29sdGlwW2RhdGEtaW50ZXJhY3RpdmVdW2RhdGEtc3RhdGU9dmlzaWJsZV17cG9pbnRlci1ldmVudHM6YXV0b30udGlwcHktdG9vbHRpcFtkYXRhLWluZXJ0aWFdW2RhdGEtc3RhdGU9dmlzaWJsZV17dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC41NCwxLjUsLjM4LDEuMTEpfS50aXBweS1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXN0eWxlOnNvbGlkfS50aXBweS1jb250ZW50e3BhZGRpbmc6NXB4IDlweH1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1le2JhY2tncm91bmQtY29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDAsOCwxNiwuMTUpO2NvbG9yOiMyNjMyM2Q7Ym94LXNoYWRvdzowIDRweCAxNHB4IC0ycHggcmdiYSgwLDgsMTYsLjA4KX0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWU+LnRpcHB5LWJhY2tkcm9we2JhY2tncm91bmQtY29sb3I6I2ZmZn0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWU+LnRpcHB5LWFycm93OmFmdGVyLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZT4udGlwcHktYXJyb3c6YmVmb3JlLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZT4udGlwcHktc3ZnLWFycm93OmFmdGVyLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZT4udGlwcHktc3ZnLWFycm93OmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6LTF9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lPi50aXBweS1zdmctYXJyb3d7ZmlsbDojZmZmfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZT4udGlwcHktc3ZnLWFycm93OmFmdGVye2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnYzNSeWIydGxMV3hwYm1WcWIybHVQU0p5YjNWdVpDSWdjM1J5YjJ0bExXMXBkR1Z5YkdsdGFYUTlJakV1TkRFMElpQjJhV1YzUW05NFBTSXdJREFnTVRnZ055SWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCa1BTSk5NQ0EzY3pJdU1ESXhMUzR3TVRVZ05TNHlOVE10TkM0eU1UaEROaTQxT0RRZ01TNHdOVEVnTnk0M09UY3VNREEzSURrZ01HTXhMakl3TXkwdU1EQTNJREl1TkRFMklERXVNRE0xSURNdU56WXhJREl1TnpneVF6RTJMakF4TWlBM0xqQXdOU0F4T0NBM0lERTRJRGQ2SWlCbWFXeHNQU0lqTXpNeklpQm1hV3hzTFc5d1lXTnBkSGs5SWk0eU16VWlJR1pwYkd3dGNuVnNaVDBpYm05dWVtVnlieUl2UGp3dmMzWm5QZz09KTtiYWNrZ3JvdW5kLXNpemU6MThweCA3cHg7d2lkdGg6MThweDtoZWlnaHQ6N3B4O2xlZnQ6MDt0b3A6MDtmaWxsOnJnYmEoMCw4LDE2LC4xNSl9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1zdmctYXJyb3c6YWZ0ZXJ7dG9wOjFweDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyl9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1hcnJvd3tib3JkZXItdG9wLWNvbG9yOiNmZmZ9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1hcnJvdzphZnRlcntib3JkZXItdG9wOjdweCBzb2xpZCAjZmZmO3RvcDotN3B4fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3c6YmVmb3Jle2JvcmRlci10b3A6N3B4IHNvbGlkIHJnYmEoMCw4LDE2LC4yKTtib3R0b206LTFweH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LXN2Zy1hcnJvdzphZnRlcnt0b3A6LTFweH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93e2JvcmRlci1ib3R0b20tY29sb3I6I2ZmZn0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93OmFmdGVye2JvcmRlci1ib3R0b206N3B4IHNvbGlkICNmZmY7Ym90dG9tOi03cHh9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1hcnJvdzpiZWZvcmV7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgcmdiYSgwLDgsMTYsLjIpO2JvdHRvbTotNnB4fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LXN2Zy1hcnJvdzphZnRlcntsZWZ0OjFweDt0b3A6MDt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvd3tib3JkZXItbGVmdC1jb2xvcjojZmZmfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LWFycm93OmFmdGVye2JvcmRlci1sZWZ0OjdweCBzb2xpZCAjZmZmO2xlZnQ6LTdweH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvdzpiZWZvcmV7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHJnYmEoMCw4LDE2LC4yKTtsZWZ0Oi02cHh9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LXN2Zy1hcnJvdzphZnRlcntsZWZ0Oi0xcHg7dG9wOjA7dHJhbnNmb3JtOnJvdGF0ZSgtOTBkZWcpfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvd3tib3JkZXItcmlnaHQtY29sb3I6I2ZmZn0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXJpZ2h0XT4udGlwcHktYXJyb3c6YWZ0ZXJ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCAjZmZmO3JpZ2h0Oi03cHh9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93OmJlZm9yZXtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHJnYmEoMCw4LDE2LC4yKTtyaWdodDotNnB4fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktYXJyb3csLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1zdmctYXJyb3csLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1hcnJvdywudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXRvcF0+LnRpcHB5LXN2Zy1hcnJvd3t0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMXB4KX0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93OmFmdGVyLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktYXJyb3c6YmVmb3JlLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3c6YWZ0ZXIsLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1hcnJvdzpiZWZvcmV7bGVmdDotN3B4O2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LWFycm93LC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LXN2Zy1hcnJvdywudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXJpZ2h0XT4udGlwcHktYXJyb3csLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LXN2Zy1hcnJvd3t0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMXB4KX0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvdzphZnRlciwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvdzpiZWZvcmUsLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93OmFmdGVyLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvdzpiZWZvcmV7dG9wOi03cHg7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnR9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSByZXF1aXJlKFwiLi9pbmNvbnNvbGF0YS13ZWJmb250LndvZmZcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSByZXF1aXJlKFwiLi9TbGFibzEzcHgtUmVndWxhci53b2ZmXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gcmVxdWlyZShcIi4vQXZlbmlyTFRTdGQtQm9vay53b2ZmXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBmb250LWZhY2Uge1xcbiAgIGZvbnQtZmFtaWx5OiBcXFwiaW5jb25zb2xhdGFcXFwiO1xcbiAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICBmb250LXdlaWdodDogNDAwO1xcbiAgIHNyYzogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKSBmb3JtYXQoJ3dvZmYnKTtcXG59XFxuXFxuQGZvbnQtZmFjZSB7XFxuICAgZm9udC1mYW1pbHk6IFxcXCJTbGFibyAxM3B4XFxcIjtcXG4gICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICBzcmM6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIikgZm9ybWF0KCd3b2ZmJyk7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgIGZvbnQtZmFtaWx5OiBcXFwiQXZlbmlyTFRTdGQtQm9va1xcXCI7XFxuICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgc3JjOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpIGZvcm1hdCgnd29mZicpO1xcbn1cXG5cXG4uY29kZSB7XFxuICAgZm9udC1mYW1pbHk6IFxcXCJpbmNvbnNvbGF0YVxcXCI7XFxuICAgc3Ryb2tlOiBub25lO1xcbn1cXG5cXG4ubGFiZWwge1xcbiAgIGZvbnQtZmFtaWx5OiBcXFwiQXZlbmlyTFRTdGQtQm9va1xcXCI7XFxuICAgc3Ryb2tlOiBub25lO1xcbn1cXG5cXG4udW5jaGFuZ2VkIHtcXG4gICBmaWxsOiBibGFjaztcXG59XFxuXFxuLmNoYW5nZWQge1xcbiAgIGZpbGw6IGJsdWU7XFxufVxcblxcbi5uZXcge1xcbiAgIGZpbGw6IGxpbWVncmVlbjtcXG59XFxuXFxuLnRpcHB5LXRvb2x0aXAge1xcbiAgIGZvbnQtZmFtaWx5OiBcXFwiaW5jb25zb2xhdGFcXFwiO1xcbn1cXG5cXG4udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWUge1xcbiAgIGZvbnQtc2l6ZTogOXB0O1xcbn1cXG5cXG4uZm9jdXMge1xcbiAgIHN0cm9rZTogYmxhY2s7XFxuICAgc3Ryb2tlLW9wYWNpdHk6IDAuMTtcXG4gICBmaWxsLW9wYWNpdHk6IDAuNztcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIHVybCA9IHVybCAmJiB1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpIC8qIGdsb2JhbCBkZWZpbmUgKi9cbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5tb28gPSBmYWN0b3J5KClcbiAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICB2YXIgaGFzU3RpY2t5ID0gdHlwZW9mIG5ldyBSZWdFeHAoKS5zdGlja3kgPT09ICdib29sZWFuJ1xuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgZnVuY3Rpb24gaXNSZWdFeHAobykgeyByZXR1cm4gbyAmJiB0b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBSZWdFeHBdJyB9XG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG8pIHsgcmV0dXJuIG8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmICFpc1JlZ0V4cChvKSAmJiAhQXJyYXkuaXNBcnJheShvKSB9XG5cbiAgZnVuY3Rpb24gcmVFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpXG4gIH1cbiAgZnVuY3Rpb24gcmVHcm91cHMocykge1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ3wnICsgcylcbiAgICByZXR1cm4gcmUuZXhlYygnJykubGVuZ3RoIC0gMVxuICB9XG4gIGZ1bmN0aW9uIHJlQ2FwdHVyZShzKSB7XG4gICAgcmV0dXJuICcoJyArIHMgKyAnKSdcbiAgfVxuICBmdW5jdGlvbiByZVVuaW9uKHJlZ2V4cHMpIHtcbiAgICBpZiAoIXJlZ2V4cHMubGVuZ3RoKSByZXR1cm4gJyg/ISknXG4gICAgdmFyIHNvdXJjZSA9ICByZWdleHBzLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCIoPzpcIiArIHMgKyBcIilcIlxuICAgIH0pLmpvaW4oJ3wnKVxuICAgIHJldHVybiBcIig/OlwiICsgc291cmNlICsgXCIpXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2V4cE9yTGl0ZXJhbChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnKD86JyArIHJlRXNjYXBlKG9iaikgKyAnKSdcblxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAob2JqKSkge1xuICAgICAgLy8gVE9ETzogY29uc2lkZXIgL3Ugc3VwcG9ydFxuICAgICAgaWYgKG9iai5pZ25vcmVDYXNlKSB0aHJvdyBuZXcgRXJyb3IoJ1JlZ0V4cCAvaSBmbGFnIG5vdCBhbGxvd2VkJylcbiAgICAgIGlmIChvYmouZ2xvYmFsKSB0aHJvdyBuZXcgRXJyb3IoJ1JlZ0V4cCAvZyBmbGFnIGlzIGltcGxpZWQnKVxuICAgICAgaWYgKG9iai5zdGlja3kpIHRocm93IG5ldyBFcnJvcignUmVnRXhwIC95IGZsYWcgaXMgaW1wbGllZCcpXG4gICAgICBpZiAob2JqLm11bHRpbGluZSkgdGhyb3cgbmV3IEVycm9yKCdSZWdFeHAgL20gZmxhZyBpcyBpbXBsaWVkJylcbiAgICAgIHJldHVybiBvYmouc291cmNlXG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBwYXR0ZXJuOiAnICsgb2JqKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdFRvUnVsZXMob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpXG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgdmFyIHRoaW5nID0gb2JqZWN0W2tleV1cbiAgICAgIHZhciBydWxlcyA9IFtdLmNvbmNhdCh0aGluZylcbiAgICAgIGlmIChrZXkgPT09ICdpbmNsdWRlJykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe2luY2x1ZGU6IHJ1bGVzW2pdfSlcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIG1hdGNoID0gW11cbiAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocnVsZSkpIHtcbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoKSByZXN1bHQucHVzaChydWxlT3B0aW9ucyhrZXksIG1hdGNoKSlcbiAgICAgICAgICByZXN1bHQucHVzaChydWxlT3B0aW9ucyhrZXksIHJ1bGUpKVxuICAgICAgICAgIG1hdGNoID0gW11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaC5wdXNoKHJ1bGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAobWF0Y2gubGVuZ3RoKSByZXN1bHQucHVzaChydWxlT3B0aW9ucyhrZXksIG1hdGNoKSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlUb1J1bGVzKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGFycmF5W2ldXG4gICAgICBpZiAob2JqLmluY2x1ZGUpIHtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSBbXS5jb25jYXQob2JqLmluY2x1ZGUpXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5jbHVkZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtpbmNsdWRlOiBpbmNsdWRlW2pdfSlcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKCFvYmoudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGUgaGFzIG5vIHR5cGU6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2gocnVsZU9wdGlvbnMob2JqLnR5cGUsIG9iaikpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bGVPcHRpb25zKHR5cGUsIG9iaikge1xuICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgb2JqID0geyBtYXRjaDogb2JqIH1cbiAgICB9XG4gICAgaWYgKG9iai5pbmNsdWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGNoaW5nIHJ1bGVzIGNhbm5vdCBhbHNvIGluY2x1ZGUgc3RhdGVzJylcbiAgICB9XG5cbiAgICAvLyBuYi4gZXJyb3IgYW5kIGZhbGxiYWNrIGltcGx5IGxpbmVCcmVha3NcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGRlZmF1bHRUeXBlOiB0eXBlLFxuICAgICAgbGluZUJyZWFrczogISFvYmouZXJyb3IgfHwgISFvYmouZmFsbGJhY2ssXG4gICAgICBwb3A6IGZhbHNlLFxuICAgICAgbmV4dDogbnVsbCxcbiAgICAgIHB1c2g6IG51bGwsXG4gICAgICBlcnJvcjogZmFsc2UsXG4gICAgICBmYWxsYmFjazogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHR5cGU6IG51bGwsXG4gICAgICBzaG91bGRUaHJvdzogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gQXZvaWQgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSBzdXBwb3J0IElFOStcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gb2JqW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0eXBlIHRyYW5zZm9ybSBjYW5ub3QgYmUgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gb3B0aW9ucy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIHRyYW5zZm9ybSBjYW5ub3QgYmUgYSBzdHJpbmcgKHR5cGUgJ1wiICsgb3B0aW9ucy50eXBlICsgXCInIGZvciB0b2tlbiAnXCIgKyB0eXBlICsgXCInKVwiKVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gYXJyYXlcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoXG4gICAgb3B0aW9ucy5tYXRjaCA9IEFycmF5LmlzQXJyYXkobWF0Y2gpID8gbWF0Y2ggOiBtYXRjaCA/IFttYXRjaF0gOiBbXVxuICAgIG9wdGlvbnMubWF0Y2guc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gaXNSZWdFeHAoYSkgJiYgaXNSZWdFeHAoYikgPyAwXG4gICAgICAgICAgIDogaXNSZWdFeHAoYikgPyAtMSA6IGlzUmVnRXhwKGEpID8gKzEgOiBiLmxlbmd0aCAtIGEubGVuZ3RoXG4gICAgfSlcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gdG9SdWxlcyhzcGVjKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3BlYykgPyBhcnJheVRvUnVsZXMoc3BlYykgOiBvYmplY3RUb1J1bGVzKHNwZWMpXG4gIH1cblxuICB2YXIgZGVmYXVsdEVycm9yUnVsZSA9IHJ1bGVPcHRpb25zKCdlcnJvcicsIHtsaW5lQnJlYWtzOiB0cnVlLCBzaG91bGRUaHJvdzogdHJ1ZX0pXG4gIGZ1bmN0aW9uIGNvbXBpbGVSdWxlcyhydWxlcywgaGFzU3RhdGVzKSB7XG4gICAgdmFyIGVycm9yUnVsZSA9IG51bGxcbiAgICB2YXIgZmFzdCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB2YXIgZmFzdEFsbG93ZWQgPSB0cnVlXG4gICAgdmFyIHVuaWNvZGVGbGFnID0gbnVsbFxuICAgIHZhciBncm91cHMgPSBbXVxuICAgIHZhciBwYXJ0cyA9IFtdXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGZhbGxiYWNrIHJ1bGUsIHRoZW4gZGlzYWJsZSBmYXN0IG1hdGNoaW5nXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJ1bGVzW2ldLmZhbGxiYWNrKSB7XG4gICAgICAgIGZhc3RBbGxvd2VkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHJ1bGVzW2ldXG5cbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgLy8gYWxsIHZhbGlkIGluY2x1c2lvbnMgYXJlIHJlbW92ZWQgYnkgc3RhdGVzKCkgcHJlcHJvY2Vzc29yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5oZXJpdGFuY2UgaXMgbm90IGFsbG93ZWQgaW4gc3RhdGVsZXNzIGxleGVycycpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmVycm9yIHx8IG9wdGlvbnMuZmFsbGJhY2spIHtcbiAgICAgICAgLy8gZXJyb3JSdWxlIGNhbiBvbmx5IGJlIHNldCBvbmNlXG4gICAgICAgIGlmIChlcnJvclJ1bGUpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuZmFsbGJhY2sgPT09ICFlcnJvclJ1bGUuZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIFwiICsgKG9wdGlvbnMuZmFsbGJhY2sgPyBcImZhbGxiYWNrXCIgOiBcImVycm9yXCIpICsgXCIgcnVsZXMgbm90IGFsbG93ZWQgKGZvciB0b2tlbiAnXCIgKyBvcHRpb25zLmRlZmF1bHRUeXBlICsgXCInKVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWxsYmFjayBhbmQgZXJyb3IgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSAoZm9yIHRva2VuICdcIiArIG9wdGlvbnMuZGVmYXVsdFR5cGUgKyBcIicpXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yUnVsZSA9IG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaC5zbGljZSgpXG4gICAgICBpZiAoZmFzdEFsbG93ZWQpIHtcbiAgICAgICAgd2hpbGUgKG1hdGNoLmxlbmd0aCAmJiB0eXBlb2YgbWF0Y2hbMF0gPT09ICdzdHJpbmcnICYmIG1hdGNoWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB3b3JkID0gbWF0Y2guc2hpZnQoKVxuICAgICAgICAgIGZhc3Rbd29yZC5jaGFyQ29kZUF0KDApXSA9IG9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXYXJuIGFib3V0IGluYXBwcm9wcmlhdGUgc3RhdGUtc3dpdGNoaW5nIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLnBvcCB8fCBvcHRpb25zLnB1c2ggfHwgb3B0aW9ucy5uZXh0KSB7XG4gICAgICAgIGlmICghaGFzU3RhdGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUtc3dpdGNoaW5nIG9wdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIHN0YXRlbGVzcyBsZXhlcnMgKGZvciB0b2tlbiAnXCIgKyBvcHRpb25zLmRlZmF1bHRUeXBlICsgXCInKVwiKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUtc3dpdGNoaW5nIG9wdGlvbnMgYXJlIG5vdCBhbGxvd2VkIG9uIGZhbGxiYWNrIHRva2VucyAoZm9yIHRva2VuICdcIiArIG9wdGlvbnMuZGVmYXVsdFR5cGUgKyBcIicpXCIpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT25seSBydWxlcyB3aXRoIGEgLm1hdGNoIGFyZSBpbmNsdWRlZCBpbiB0aGUgUmVnRXhwXG4gICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmYXN0QWxsb3dlZCA9IGZhbHNlXG5cbiAgICAgIGdyb3Vwcy5wdXNoKG9wdGlvbnMpXG5cbiAgICAgIC8vIENoZWNrIHVuaWNvZGUgZmxhZyBpcyB1c2VkIGV2ZXJ5d2hlcmUgb3Igbm93aGVyZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgb2JqID0gbWF0Y2hbal1cbiAgICAgICAgaWYgKCFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmljb2RlRmxhZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHVuaWNvZGVGbGFnID0gb2JqLnVuaWNvZGVcbiAgICAgICAgfSBlbHNlIGlmICh1bmljb2RlRmxhZyAhPT0gb2JqLnVuaWNvZGUgJiYgb3B0aW9ucy5mYWxsYmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIG9uZSBydWxlIGlzIC91IHRoZW4gYWxsIG11c3QgYmUnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnZlcnQgdG8gUmVnRXhwXG4gICAgICB2YXIgcGF0ID0gcmVVbmlvbihtYXRjaC5tYXAocmVnZXhwT3JMaXRlcmFsKSlcblxuICAgICAgLy8gdmFsaWRhdGVcbiAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdClcbiAgICAgIGlmIChyZWdleHAudGVzdChcIlwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdFeHAgbWF0Y2hlcyBlbXB0eSBzdHJpbmc6IFwiICsgcmVnZXhwKVxuICAgICAgfVxuICAgICAgdmFyIGdyb3VwQ291bnQgPSByZUdyb3VwcyhwYXQpXG4gICAgICBpZiAoZ3JvdXBDb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnRXhwIGhhcyBjYXB0dXJlIGdyb3VwczogXCIgKyByZWdleHAgKyBcIlxcblVzZSAoPzog4oCmICkgaW5zdGVhZFwiKVxuICAgICAgfVxuXG4gICAgICAvLyB0cnkgYW5kIGRldGVjdCBydWxlcyBtYXRjaGluZyBuZXdsaW5lc1xuICAgICAgaWYgKCFvcHRpb25zLmxpbmVCcmVha3MgJiYgcmVnZXhwLnRlc3QoJ1xcbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZSBzaG91bGQgZGVjbGFyZSBsaW5lQnJlYWtzOiAnICsgcmVnZXhwKVxuICAgICAgfVxuXG4gICAgICAvLyBzdG9yZSByZWdleFxuICAgICAgcGFydHMucHVzaChyZUNhcHR1cmUocGF0KSlcbiAgICB9XG5cblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZmFsbGJhY2sgcnVsZSwgdXNlIHRoZSBzdGlja3kgZmxhZyBzbyB3ZSBvbmx5IGxvb2sgZm9yXG4gICAgLy8gbWF0Y2hlcyBhdCB0aGUgY3VycmVudCBpbmRleC5cbiAgICAvL1xuICAgIC8vIElmIHdlIGRvbid0IHN1cHBvcnQgdGhlIHN0aWNreSBmbGFnLCB0aGVuIGZha2UgaXQgdXNpbmcgYW4gaXJyZWZ1dGFibGVcbiAgICAvLyBtYXRjaCAoaS5lLiBhbiBlbXB0eSBwYXR0ZXJuKS5cbiAgICB2YXIgZmFsbGJhY2tSdWxlID0gZXJyb3JSdWxlICYmIGVycm9yUnVsZS5mYWxsYmFja1xuICAgIHZhciBmbGFncyA9IGhhc1N0aWNreSAmJiAhZmFsbGJhY2tSdWxlID8gJ3ltJyA6ICdnbSdcbiAgICB2YXIgc3VmZml4ID0gaGFzU3RpY2t5IHx8IGZhbGxiYWNrUnVsZSA/ICcnIDogJ3wnXG5cbiAgICBpZiAodW5pY29kZUZsYWcgPT09IHRydWUpIGZsYWdzICs9IFwidVwiXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFJlZ0V4cChyZVVuaW9uKHBhcnRzKSArIHN1ZmZpeCwgZmxhZ3MpXG4gICAgcmV0dXJuIHtyZWdleHA6IGNvbWJpbmVkLCBncm91cHM6IGdyb3VwcywgZmFzdDogZmFzdCwgZXJyb3I6IGVycm9yUnVsZSB8fCBkZWZhdWx0RXJyb3JSdWxlfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZShydWxlcykge1xuICAgIHZhciByZXN1bHQgPSBjb21waWxlUnVsZXModG9SdWxlcyhydWxlcykpXG4gICAgcmV0dXJuIG5ldyBMZXhlcih7c3RhcnQ6IHJlc3VsdH0sICdzdGFydCcpXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1N0YXRlR3JvdXAoZywgbmFtZSwgbWFwKSB7XG4gICAgdmFyIHN0YXRlID0gZyAmJiAoZy5wdXNoIHx8IGcubmV4dClcbiAgICBpZiAoc3RhdGUgJiYgIW1hcFtzdGF0ZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RhdGUgJ1wiICsgc3RhdGUgKyBcIicgKGluIHRva2VuICdcIiArIGcuZGVmYXVsdFR5cGUgKyBcIicgb2Ygc3RhdGUgJ1wiICsgbmFtZSArIFwiJylcIilcbiAgICB9XG4gICAgaWYgKGcgJiYgZy5wb3AgJiYgK2cucG9wICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3AgbXVzdCBiZSAxIChpbiB0b2tlbiAnXCIgKyBnLmRlZmF1bHRUeXBlICsgXCInIG9mIHN0YXRlICdcIiArIG5hbWUgKyBcIicpXCIpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbXBpbGVTdGF0ZXMoc3RhdGVzLCBzdGFydCkge1xuICAgIHZhciBhbGwgPSBzdGF0ZXMuJGFsbCA/IHRvUnVsZXMoc3RhdGVzLiRhbGwpIDogW11cbiAgICBkZWxldGUgc3RhdGVzLiRhbGxcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGVzKVxuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0ga2V5c1swXVxuXG4gICAgdmFyIHJ1bGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgcnVsZU1hcFtrZXldID0gdG9SdWxlcyhzdGF0ZXNba2V5XSkuY29uY2F0KGFsbClcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgdmFyIHJ1bGVzID0gcnVsZU1hcFtrZXldXG4gICAgICB2YXIgaW5jbHVkZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBydWxlID0gcnVsZXNbal1cbiAgICAgICAgaWYgKCFydWxlLmluY2x1ZGUpIGNvbnRpbnVlXG4gICAgICAgIHZhciBzcGxpY2UgPSBbaiwgMV1cbiAgICAgICAgaWYgKHJ1bGUuaW5jbHVkZSAhPT0ga2V5ICYmICFpbmNsdWRlZFtydWxlLmluY2x1ZGVdKSB7XG4gICAgICAgICAgaW5jbHVkZWRbcnVsZS5pbmNsdWRlXSA9IHRydWVcbiAgICAgICAgICB2YXIgbmV3UnVsZXMgPSBydWxlTWFwW3J1bGUuaW5jbHVkZV1cbiAgICAgICAgICBpZiAoIW5ld1J1bGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBub25leGlzdGVudCBzdGF0ZSAnXCIgKyBydWxlLmluY2x1ZGUgKyBcIicgKGluIHN0YXRlICdcIiArIGtleSArIFwiJylcIilcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuZXdSdWxlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIG5ld1J1bGUgPSBuZXdSdWxlc1trXVxuICAgICAgICAgICAgaWYgKHJ1bGVzLmluZGV4T2YobmV3UnVsZSkgIT09IC0xKSBjb250aW51ZVxuICAgICAgICAgICAgc3BsaWNlLnB1c2gobmV3UnVsZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVsZXMuc3BsaWNlLmFwcGx5KHJ1bGVzLCBzcGxpY2UpXG4gICAgICAgIGotLVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgbWFwW2tleV0gPSBjb21waWxlUnVsZXMocnVsZU1hcFtrZXldLCB0cnVlKVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBrZXlzW2ldXG4gICAgICB2YXIgc3RhdGUgPSBtYXBbbmFtZV1cbiAgICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHNcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoZWNrU3RhdGVHcm91cChncm91cHNbal0sIG5hbWUsIG1hcClcbiAgICAgIH1cbiAgICAgIHZhciBmYXN0S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlLmZhc3QpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZhc3RLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoZWNrU3RhdGVHcm91cChzdGF0ZS5mYXN0W2Zhc3RLZXlzW2pdXSwgbmFtZSwgbWFwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGV4ZXIobWFwLCBzdGFydClcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleXdvcmRUcmFuc2Zvcm0obWFwKSB7XG4gICAgdmFyIHJldmVyc2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdmFyIGJ5TGVuZ3RoID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHZhciB0eXBlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW5UeXBlID0gdHlwZXNbaV1cbiAgICAgIHZhciBpdGVtID0gbWFwW3Rva2VuVHlwZV1cbiAgICAgIHZhciBrZXl3b3JkTGlzdCA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dXG4gICAgICBrZXl3b3JkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGtleXdvcmQpIHtcbiAgICAgICAgKGJ5TGVuZ3RoW2tleXdvcmQubGVuZ3RoXSA9IGJ5TGVuZ3RoW2tleXdvcmQubGVuZ3RoXSB8fCBbXSkucHVzaChrZXl3b3JkKVxuICAgICAgICBpZiAodHlwZW9mIGtleXdvcmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5d29yZCBtdXN0IGJlIHN0cmluZyAoaW4ga2V5d29yZCAnXCIgKyB0b2tlblR5cGUgKyBcIicpXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV2ZXJzZU1hcFtrZXl3b3JkXSA9IHRva2VuVHlwZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBmYXN0IHN0cmluZyBsb29rdXBcbiAgICAvLyBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLWxvb2t1cHNcbiAgICBmdW5jdGlvbiBzdHIoeCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCkgfVxuICAgIHZhciBzb3VyY2UgPSAnJ1xuICAgIHNvdXJjZSArPSAnc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcXG4nXG4gICAgZm9yICh2YXIgbGVuZ3RoIGluIGJ5TGVuZ3RoKSB7XG4gICAgICB2YXIga2V5d29yZHMgPSBieUxlbmd0aFtsZW5ndGhdXG4gICAgICBzb3VyY2UgKz0gJ2Nhc2UgJyArIGxlbmd0aCArICc6XFxuJ1xuICAgICAgc291cmNlICs9ICdzd2l0Y2ggKHZhbHVlKSB7XFxuJ1xuICAgICAga2V5d29yZHMuZm9yRWFjaChmdW5jdGlvbihrZXl3b3JkKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGUgPSByZXZlcnNlTWFwW2tleXdvcmRdXG4gICAgICAgIHNvdXJjZSArPSAnY2FzZSAnICsgc3RyKGtleXdvcmQpICsgJzogcmV0dXJuICcgKyBzdHIodG9rZW5UeXBlKSArICdcXG4nXG4gICAgICB9KVxuICAgICAgc291cmNlICs9ICd9XFxuJ1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJ31cXG4nXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCd2YWx1ZScsIHNvdXJjZSkgLy8gdHlwZVxuICB9XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgTGV4ZXIgPSBmdW5jdGlvbihzdGF0ZXMsIHN0YXRlKSB7XG4gICAgdGhpcy5zdGFydFN0YXRlID0gc3RhdGVcbiAgICB0aGlzLnN0YXRlcyA9IHN0YXRlc1xuICAgIHRoaXMuYnVmZmVyID0gJydcbiAgICB0aGlzLnN0YWNrID0gW11cbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGRhdGEsIGluZm8pIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGRhdGEgfHwgJydcbiAgICB0aGlzLmluZGV4ID0gMFxuICAgIHRoaXMubGluZSA9IGluZm8gPyBpbmZvLmxpbmUgOiAxXG4gICAgdGhpcy5jb2wgPSBpbmZvID8gaW5mby5jb2wgOiAxXG4gICAgdGhpcy5xdWV1ZWRUb2tlbiA9IGluZm8gPyBpbmZvLnF1ZXVlZFRva2VuIDogbnVsbFxuICAgIHRoaXMucXVldWVkVGhyb3cgPSBpbmZvID8gaW5mby5xdWV1ZWRUaHJvdyA6IG51bGxcbiAgICB0aGlzLnNldFN0YXRlKGluZm8gPyBpbmZvLnN0YXRlIDogdGhpcy5zdGFydFN0YXRlKVxuICAgIHRoaXMuc3RhY2sgPSBpbmZvICYmIGluZm8uc3RhY2sgPyBpbmZvLnN0YWNrLnNsaWNlKCkgOiBbXVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICBjb2w6IHRoaXMuY29sLFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICBzdGFjazogdGhpcy5zdGFjay5zbGljZSgpLFxuICAgICAgcXVldWVkVG9rZW46IHRoaXMucXVldWVkVG9rZW4sXG4gICAgICBxdWV1ZWRUaHJvdzogdGhpcy5xdWV1ZWRUaHJvdyxcbiAgICB9XG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICghc3RhdGUgfHwgdGhpcy5zdGF0ZSA9PT0gc3RhdGUpIHJldHVyblxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuICAgIHZhciBpbmZvID0gdGhpcy5zdGF0ZXNbc3RhdGVdXG4gICAgdGhpcy5ncm91cHMgPSBpbmZvLmdyb3Vwc1xuICAgIHRoaXMuZXJyb3IgPSBpbmZvLmVycm9yXG4gICAgdGhpcy5yZSA9IGluZm8ucmVnZXhwXG4gICAgdGhpcy5mYXN0ID0gaW5mby5mYXN0XG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUucG9wU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuc3RhY2sucG9wKCkpXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSlcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKVxuICB9XG5cbiAgdmFyIGVhdCA9IGhhc1N0aWNreSA/IGZ1bmN0aW9uKHJlLCBidWZmZXIpIHsgLy8gYXNzdW1lIHJlIGlzIC95XG4gICAgcmV0dXJuIHJlLmV4ZWMoYnVmZmVyKVxuICB9IDogZnVuY3Rpb24ocmUsIGJ1ZmZlcikgeyAvLyBhc3N1bWUgcmUgaXMgL2dcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKGJ1ZmZlcilcbiAgICAvLyB3aWxsIGFsd2F5cyBtYXRjaCwgc2luY2Ugd2UgdXNlZCB0aGUgfCg/OikgdHJpY2tcbiAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5fZ2V0R3JvdXAgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHZhciBncm91cENvdW50ID0gdGhpcy5ncm91cHMubGVuZ3RoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cENvdW50OyBpKyspIHtcbiAgICAgIGlmIChtYXRjaFtpICsgMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNbaV1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCB0b2tlbiB0eXBlIGZvciBtYXRjaGVkIHRleHQnKVxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Ub1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4XG5cbiAgICAvLyBJZiBhIGZhbGxiYWNrIHRva2VuIG1hdGNoZWQsIHdlIGRvbid0IG5lZWQgdG8gcmUtcnVuIHRoZSBSZWdFeHBcbiAgICBpZiAodGhpcy5xdWV1ZWRHcm91cCkge1xuICAgICAgdmFyIHRva2VuID0gdGhpcy5fdG9rZW4odGhpcy5xdWV1ZWRHcm91cCwgdGhpcy5xdWV1ZWRUZXh0LCBpbmRleClcbiAgICAgIHRoaXMucXVldWVkR3JvdXAgPSBudWxsXG4gICAgICB0aGlzLnF1ZXVlZFRleHQgPSBcIlwiXG4gICAgICByZXR1cm4gdG9rZW5cbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJcbiAgICBpZiAoaW5kZXggPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAvLyBFT0ZcbiAgICB9XG5cbiAgICAvLyBGYXN0IG1hdGNoaW5nIGZvciBzaW5nbGUgY2hhcmFjdGVyc1xuICAgIHZhciBncm91cCA9IHRoaXMuZmFzdFtidWZmZXIuY2hhckNvZGVBdChpbmRleCldXG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9rZW4oZ3JvdXAsIGJ1ZmZlci5jaGFyQXQoaW5kZXgpLCBpbmRleClcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlIFJlZ0V4cFxuICAgIHZhciByZSA9IHRoaXMucmVcbiAgICByZS5sYXN0SW5kZXggPSBpbmRleFxuICAgIHZhciBtYXRjaCA9IGVhdChyZSwgYnVmZmVyKVxuXG4gICAgLy8gRXJyb3IgdG9rZW5zIG1hdGNoIHRoZSByZW1haW5pbmcgYnVmZmVyXG4gICAgdmFyIGVycm9yID0gdGhpcy5lcnJvclxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9rZW4oZXJyb3IsIGJ1ZmZlci5zbGljZShpbmRleCwgYnVmZmVyLmxlbmd0aCksIGluZGV4KVxuICAgIH1cblxuICAgIHZhciBncm91cCA9IHRoaXMuX2dldEdyb3VwKG1hdGNoKVxuICAgIHZhciB0ZXh0ID0gbWF0Y2hbMF1cblxuICAgIGlmIChlcnJvci5mYWxsYmFjayAmJiBtYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHRoaXMucXVldWVkR3JvdXAgPSBncm91cFxuICAgICAgdGhpcy5xdWV1ZWRUZXh0ID0gdGV4dFxuXG4gICAgICAvLyBGYWxsYmFjayB0b2tlbnMgY29udGFpbiB0aGUgdW5tYXRjaGVkIHBvcnRpb24gb2YgdGhlIGJ1ZmZlclxuICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuKGVycm9yLCBidWZmZXIuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSwgaW5kZXgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Rva2VuKGdyb3VwLCB0ZXh0LCBpbmRleClcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5fdG9rZW4gPSBmdW5jdGlvbihncm91cCwgdGV4dCwgb2Zmc2V0KSB7XG4gICAgLy8gY291bnQgbGluZSBicmVha3NcbiAgICB2YXIgbGluZUJyZWFrcyA9IDBcbiAgICBpZiAoZ3JvdXAubGluZUJyZWFrcykge1xuICAgICAgdmFyIG1hdGNoTkwgPSAvXFxuL2dcbiAgICAgIHZhciBubCA9IDFcbiAgICAgIGlmICh0ZXh0ID09PSAnXFxuJykge1xuICAgICAgICBsaW5lQnJlYWtzID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG1hdGNoTkwuZXhlYyh0ZXh0KSkgeyBsaW5lQnJlYWtzKys7IG5sID0gbWF0Y2hOTC5sYXN0SW5kZXggfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgIHR5cGU6ICh0eXBlb2YgZ3JvdXAudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBncm91cC50eXBlKHRleHQpKSB8fCBncm91cC5kZWZhdWx0VHlwZSxcbiAgICAgIHZhbHVlOiB0eXBlb2YgZ3JvdXAudmFsdWUgPT09ICdmdW5jdGlvbicgPyBncm91cC52YWx1ZSh0ZXh0KSA6IHRleHQsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgdG9TdHJpbmc6IHRva2VuVG9TdHJpbmcsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGxpbmVCcmVha3M6IGxpbmVCcmVha3MsXG4gICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICBjb2w6IHRoaXMuY29sLFxuICAgIH1cbiAgICAvLyBuYi4gYWRkaW5nIG1vcmUgcHJvcHMgdG8gdG9rZW4gb2JqZWN0IHdpbGwgbWFrZSBWOCBzYWQhXG5cbiAgICB2YXIgc2l6ZSA9IHRleHQubGVuZ3RoXG4gICAgdGhpcy5pbmRleCArPSBzaXplXG4gICAgdGhpcy5saW5lICs9IGxpbmVCcmVha3NcbiAgICBpZiAobGluZUJyZWFrcyAhPT0gMCkge1xuICAgICAgdGhpcy5jb2wgPSBzaXplIC0gbmwgKyAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sICs9IHNpemVcbiAgICB9XG5cbiAgICAvLyB0aHJvdywgaWYgbm8gcnVsZSB3aXRoIHtlcnJvcjogdHJ1ZX1cbiAgICBpZiAoZ3JvdXAuc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yKHRva2VuLCBcImludmFsaWQgc3ludGF4XCIpKVxuICAgIH1cblxuICAgIGlmIChncm91cC5wb3ApIHRoaXMucG9wU3RhdGUoKVxuICAgIGVsc2UgaWYgKGdyb3VwLnB1c2gpIHRoaXMucHVzaFN0YXRlKGdyb3VwLnB1c2gpXG4gICAgZWxzZSBpZiAoZ3JvdXAubmV4dCkgdGhpcy5zZXRTdGF0ZShncm91cC5uZXh0KVxuXG4gICAgcmV0dXJuIHRva2VuXG4gIH1cblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgdmFyIExleGVySXRlcmF0b3IgPSBmdW5jdGlvbihsZXhlcikge1xuICAgICAgdGhpcy5sZXhlciA9IGxleGVyXG4gICAgfVxuXG4gICAgTGV4ZXJJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuID0gdGhpcy5sZXhlci5uZXh0KClcbiAgICAgIHJldHVybiB7dmFsdWU6IHRva2VuLCBkb25lOiAhdG9rZW59XG4gICAgfVxuXG4gICAgTGV4ZXJJdGVyYXRvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBMZXhlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBMZXhlckl0ZXJhdG9yKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLmZvcm1hdEVycm9yID0gZnVuY3Rpb24odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgLy8gQW4gdW5kZWZpbmVkIHRva2VuIGluZGljYXRlcyBFT0ZcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5pbmRleClcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmluZGV4LFxuICAgICAgICBsaW5lQnJlYWtzOiB0ZXh0LmluZGV4T2YoJ1xcbicpID09PSAtMSA/IDAgOiAxLFxuICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgIGNvbDogdGhpcy5jb2wsXG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFydCA9IE1hdGgubWF4KDAsIHRva2VuLm9mZnNldCAtIHRva2VuLmNvbCArIDEpXG4gICAgdmFyIGVvbCA9IHRva2VuLmxpbmVCcmVha3MgPyB0b2tlbi50ZXh0LmluZGV4T2YoJ1xcbicpIDogdG9rZW4udGV4dC5sZW5ndGhcbiAgICB2YXIgZmlyc3RMaW5lID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHN0YXJ0LCB0b2tlbi5vZmZzZXQgKyBlb2wpXG4gICAgbWVzc2FnZSArPSBcIiBhdCBsaW5lIFwiICsgdG9rZW4ubGluZSArIFwiIGNvbCBcIiArIHRva2VuLmNvbCArIFwiOlxcblxcblwiXG4gICAgbWVzc2FnZSArPSBcIiAgXCIgKyBmaXJzdExpbmUgKyBcIlxcblwiXG4gICAgbWVzc2FnZSArPSBcIiAgXCIgKyBBcnJheSh0b2tlbi5jb2wpLmpvaW4oXCIgXCIpICsgXCJeXCJcbiAgICByZXR1cm4gbWVzc2FnZVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBMZXhlcih0aGlzLnN0YXRlcywgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbih0b2tlblR5cGUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cblxuICByZXR1cm4ge1xuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgc3RhdGVzOiBjb21waWxlU3RhdGVzLFxuICAgIGVycm9yOiBPYmplY3QuZnJlZXplKHtlcnJvcjogdHJ1ZX0pLFxuICAgIGZhbGxiYWNrOiBPYmplY3QuZnJlZXplKHtmYWxsYmFjazogdHJ1ZX0pLFxuICAgIGtleXdvcmRzOiBrZXl3b3JkVHJhbnNmb3JtLFxuICB9XG5cbn0pKTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubmVhcmxleSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gUnVsZShuYW1lLCBzeW1ib2xzLCBwb3N0cHJvY2Vzcykge1xuICAgICAgICB0aGlzLmlkID0gKytSdWxlLmhpZ2hlc3RJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gc3ltYm9sczsgICAgICAgIC8vIGEgbGlzdCBvZiBsaXRlcmFsIHwgcmVnZXggY2xhc3MgfCBub250ZXJtaW5hbFxuICAgICAgICB0aGlzLnBvc3Rwcm9jZXNzID0gcG9zdHByb2Nlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBSdWxlLmhpZ2hlc3RJZCA9IDA7XG5cbiAgICBSdWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKHdpdGhDdXJzb3JBdCkge1xuICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnlTeW1ib2xTZXF1ZW5jZSAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUubGl0ZXJhbCA/IEpTT04uc3RyaW5naWZ5KGUubGl0ZXJhbCkgOlxuICAgICAgICAgICAgICAgICAgIGUudHlwZSA/ICclJyArIGUudHlwZSA6IGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltYm9sU2VxdWVuY2UgPSAodHlwZW9mIHdpdGhDdXJzb3JBdCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnN5bWJvbHMubWFwKHN0cmluZ2lmeVN5bWJvbFNlcXVlbmNlKS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoICAgdGhpcy5zeW1ib2xzLnNsaWNlKDAsIHdpdGhDdXJzb3JBdCkubWFwKHN0cmluZ2lmeVN5bWJvbFNlcXVlbmNlKS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCIg4pePIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHRoaXMuc3ltYm9scy5zbGljZSh3aXRoQ3Vyc29yQXQpLm1hcChzdHJpbmdpZnlTeW1ib2xTZXF1ZW5jZSkuam9pbignICcpICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCIg4oaSIFwiICsgc3ltYm9sU2VxdWVuY2U7XG4gICAgfVxuXG5cbiAgICAvLyBhIFN0YXRlIGlzIGEgcnVsZSBhdCBhIHBvc2l0aW9uIGZyb20gYSBnaXZlbiBzdGFydGluZyBwb2ludCBpbiB0aGUgaW5wdXQgc3RyZWFtIChyZWZlcmVuY2UpXG4gICAgZnVuY3Rpb24gU3RhdGUocnVsZSwgZG90LCByZWZlcmVuY2UsIHdhbnRlZEJ5KSB7XG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XG4gICAgICAgIHRoaXMuZG90ID0gZG90O1xuICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMud2FudGVkQnkgPSB3YW50ZWRCeTtcbiAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdGhpcy5kb3QgPT09IHJ1bGUuc3ltYm9scy5sZW5ndGg7XG4gICAgfVxuXG4gICAgU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIHRoaXMucnVsZS50b1N0cmluZyh0aGlzLmRvdCkgKyBcIn0sIGZyb206IFwiICsgKHRoaXMucmVmZXJlbmNlIHx8IDApO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUubmV4dFN0YXRlID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKHRoaXMucnVsZSwgdGhpcy5kb3QgKyAxLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy53YW50ZWRCeSk7XG4gICAgICAgIHN0YXRlLmxlZnQgPSB0aGlzO1xuICAgICAgICBzdGF0ZS5yaWdodCA9IGNoaWxkO1xuICAgICAgICBpZiAoc3RhdGUuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlLnJpZ2h0LmRhdGEpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgfSB3aGlsZSAobm9kZS5sZWZ0KTtcbiAgICAgICAgY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcblxuICAgIFN0YXRlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucnVsZS5wb3N0cHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5ydWxlLnBvc3Rwcm9jZXNzKHRoaXMuZGF0YSwgdGhpcy5yZWZlcmVuY2UsIFBhcnNlci5mYWlsKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIENvbHVtbihncmFtbWFyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICAgIHRoaXMud2FudHMgPSB7fTsgLy8gc3RhdGVzIGluZGV4ZWQgYnkgdGhlIG5vbi10ZXJtaW5hbCB0aGV5IGV4cGVjdFxuICAgICAgICB0aGlzLnNjYW5uYWJsZSA9IFtdOyAvLyBsaXN0IG9mIHN0YXRlcyB0aGF0IGV4cGVjdCBhIHRva2VuXG4gICAgICAgIHRoaXMuY29tcGxldGVkID0ge307IC8vIHN0YXRlcyB0aGF0IGFyZSBudWxsYWJsZVxuICAgIH1cblxuXG4gICAgQ29sdW1uLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24obmV4dENvbHVtbikge1xuICAgICAgICB2YXIgc3RhdGVzID0gdGhpcy5zdGF0ZXM7XG4gICAgICAgIHZhciB3YW50cyA9IHRoaXMud2FudHM7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSB0aGlzLmNvbXBsZXRlZDtcblxuICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHN0YXRlcy5sZW5ndGg7IHcrKykgeyAvLyBuYi4gd2UgcHVzaCgpIGR1cmluZyBpdGVyYXRpb25cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1t3XTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZGF0YSAhPT0gUGFyc2VyLmZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhbnRlZEJ5ID0gc3RhdGUud2FudGVkQnk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB3YW50ZWRCeS5sZW5ndGg7IGktLTsgKSB7IC8vIHRoaXMgbGluZSBpcyBob3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gd2FudGVkQnlbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKGxlZnQsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwtY2FzZSBudWxsYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlZmVyZW5jZSA9PT0gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGZ1dHVyZSBwcmVkaWN0b3JzIG9mIHRoaXMgcnVsZSBnZXQgY29tcGxldGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cCA9IHN0YXRlLnJ1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNvbXBsZXRlZFtleHBdID0gdGhpcy5jb21wbGV0ZWRbZXhwXSB8fCBbXSkucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcXVldWUgc2Nhbm5hYmxlIHN0YXRlc1xuICAgICAgICAgICAgICAgIHZhciBleHAgPSBzdGF0ZS5ydWxlLnN5bWJvbHNbc3RhdGUuZG90XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmFibGUucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZWRpY3RcbiAgICAgICAgICAgICAgICBpZiAod2FudHNbZXhwXSkge1xuICAgICAgICAgICAgICAgICAgICB3YW50c1tleHBdLnB1c2goc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQuaGFzT3duUHJvcGVydHkoZXhwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bGxzID0gY29tcGxldGVkW2V4cF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbnVsbHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShzdGF0ZSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2FudHNbZXhwXSA9IFtzdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZGljdChleHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbHVtbi5wcm90b3R5cGUucHJlZGljdCA9IGZ1bmN0aW9uKGV4cCkge1xuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLmdyYW1tYXIuYnlOYW1lW2V4cF0gfHwgW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSBydWxlc1tpXTtcbiAgICAgICAgICAgIHZhciB3YW50ZWRCeSA9IHRoaXMud2FudHNbZXhwXTtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFN0YXRlKHIsIDAsIHRoaXMuaW5kZXgsIHdhbnRlZEJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb2x1bW4ucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBsZWZ0Lm5leHRTdGF0ZShyaWdodCk7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goY29weSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBHcmFtbWFyKHJ1bGVzLCBzdGFydCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8fCB0aGlzLnJ1bGVzWzBdLm5hbWU7XG4gICAgICAgIHZhciBieU5hbWUgPSB0aGlzLmJ5TmFtZSA9IHt9O1xuICAgICAgICB0aGlzLnJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgaWYgKCFieU5hbWUuaGFzT3duUHJvcGVydHkocnVsZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtydWxlLm5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieU5hbWVbcnVsZS5uYW1lXS5wdXNoKHJ1bGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTbyB3ZSBjYW4gYWxsb3cgcGFzc2luZyAocnVsZXMsIHN0YXJ0KSBkaXJlY3RseSB0byBQYXJzZXIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgR3JhbW1hci5mcm9tQ29tcGlsZWQgPSBmdW5jdGlvbihydWxlcywgc3RhcnQpIHtcbiAgICAgICAgdmFyIGxleGVyID0gcnVsZXMuTGV4ZXI7XG4gICAgICAgIGlmIChydWxlcy5QYXJzZXJTdGFydCkge1xuICAgICAgICAgIHN0YXJ0ID0gcnVsZXMuUGFyc2VyU3RhcnQ7XG4gICAgICAgICAgcnVsZXMgPSBydWxlcy5QYXJzZXJSdWxlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIChuZXcgUnVsZShyLm5hbWUsIHIuc3ltYm9scywgci5wb3N0cHJvY2VzcykpOyB9KTtcbiAgICAgICAgdmFyIGcgPSBuZXcgR3JhbW1hcihydWxlcywgc3RhcnQpO1xuICAgICAgICBnLmxleGVyID0gbGV4ZXI7IC8vIG5iLiBzdG9yaW5nIGxleGVyIG9uIEdyYW1tYXIgaXMgaWZmeSwgYnV0IHVuYXZvaWRhYmxlXG4gICAgICAgIHJldHVybiBnO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gU3RyZWFtTGV4ZXIoKSB7XG4gICAgICB0aGlzLnJlc2V0KFwiXCIpO1xuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGRhdGEsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZGF0YTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGluZSA9IHN0YXRlID8gc3RhdGUubGluZSA6IDE7XG4gICAgICAgIHRoaXMubGFzdExpbmVCcmVhayA9IHN0YXRlID8gLXN0YXRlLmNvbCA6IDA7XG4gICAgfVxuXG4gICAgU3RyZWFtTGV4ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHRoaXMubGluZSArPSAxO1xuICAgICAgICAgICAgICB0aGlzLmxhc3RMaW5lQnJlYWsgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogY2h9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RyZWFtTGV4ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgY29sOiB0aGlzLmluZGV4IC0gdGhpcy5sYXN0TGluZUJyZWFrLFxuICAgICAgfVxuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIG5iLiB0aGlzIGdldHMgY2FsbGVkIGFmdGVyIGNvbnN1bWluZyB0aGUgb2ZmZW5kaW5nIHRva2VuLFxuICAgICAgICAvLyBzbyB0aGUgY3VscHJpdCBpcyBpbmRleC0xXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgbmV4dExpbmVCcmVhayA9IGJ1ZmZlci5pbmRleE9mKCdcXG4nLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIGlmIChuZXh0TGluZUJyZWFrID09PSAtMSkgbmV4dExpbmVCcmVhayA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHJpbmcodGhpcy5sYXN0TGluZUJyZWFrLCBuZXh0TGluZUJyZWFrKVxuICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuaW5kZXggLSB0aGlzLmxhc3RMaW5lQnJlYWs7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIGF0IGxpbmUgXCIgKyB0aGlzLmxpbmUgKyBcIiBjb2wgXCIgKyBjb2wgKyBcIjpcXG5cXG5cIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgIFwiICsgbGluZSArIFwiXFxuXCJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgIFwiICsgQXJyYXkoY29sKS5qb2luKFwiIFwiKSArIFwiXlwiXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlICsgXCIgYXQgaW5kZXggXCIgKyAodGhpcy5pbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBQYXJzZXIocnVsZXMsIHN0YXJ0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydWxlcyBpbnN0YW5jZW9mIEdyYW1tYXIpIHtcbiAgICAgICAgICAgIHZhciBncmFtbWFyID0gcnVsZXM7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdyYW1tYXIgPSBHcmFtbWFyLmZyb21Db21waWxlZChydWxlcywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG5cbiAgICAgICAgLy8gUmVhZCBvcHRpb25zXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGtlZXBIaXN0b3J5OiBmYWxzZSxcbiAgICAgICAgICAgIGxleGVyOiBncmFtbWFyLmxleGVyIHx8IG5ldyBTdHJlYW1MZXhlcixcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIChvcHRpb25zIHx8IHt9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCBsZXhlclxuICAgICAgICB0aGlzLmxleGVyID0gdGhpcy5vcHRpb25zLmxleGVyO1xuICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gU2V0dXAgYSB0YWJsZVxuICAgICAgICB2YXIgY29sdW1uID0gbmV3IENvbHVtbihncmFtbWFyLCAwKTtcbiAgICAgICAgdmFyIHRhYmxlID0gdGhpcy50YWJsZSA9IFtjb2x1bW5dO1xuXG4gICAgICAgIC8vIEkgY291bGQgYmUgZXhwZWN0aW5nIGFueXRoaW5nLlxuICAgICAgICBjb2x1bW4ud2FudHNbZ3JhbW1hci5zdGFydF0gPSBbXTtcbiAgICAgICAgY29sdW1uLnByZWRpY3QoZ3JhbW1hci5zdGFydCk7XG4gICAgICAgIC8vIFRPRE8gd2hhdCBpZiBzdGFydCBydWxlIGlzIG51bGxhYmxlP1xuICAgICAgICBjb2x1bW4ucHJvY2VzcygpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSAwOyAvLyB0b2tlbiBpbmRleFxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIHJlc2VydmVkIHRva2VuIGZvciBpbmRpY2F0aW5nIGEgcGFyc2UgZmFpbFxuICAgIFBhcnNlci5mYWlsID0ge307XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmZlZWQgPSBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB2YXIgbGV4ZXIgPSB0aGlzLmxleGVyO1xuICAgICAgICBsZXhlci5yZXNldChjaHVuaywgdGhpcy5sZXhlclN0YXRlKTtcblxuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlICh0b2tlbiA9IGxleGVyLm5leHQoKSkge1xuICAgICAgICAgICAgLy8gV2UgYWRkIG5ldyBzdGF0ZXMgdG8gdGFibGVbY3VycmVudCsxXVxuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMudGFibGVbdGhpcy5jdXJyZW50XTtcblxuICAgICAgICAgICAgLy8gR0MgdW51c2VkIHN0YXRlc1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWJsZVt0aGlzLmN1cnJlbnQgLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgdmFyIG5leHRDb2x1bW4gPSBuZXcgQ29sdW1uKHRoaXMuZ3JhbW1hciwgbik7XG4gICAgICAgICAgICB0aGlzLnRhYmxlLnB1c2gobmV4dENvbHVtbik7XG5cbiAgICAgICAgICAgIC8vIEFkdmFuY2UgYWxsIHRva2VucyB0aGF0IGV4cGVjdCB0aGUgc3ltYm9sXG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRva2VuLnRleHQgIT09IHVuZGVmaW5lZCA/IHRva2VuLnRleHQgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxleGVyLmNvbnN0cnVjdG9yID09PSBTdHJlYW1MZXhlciA/IHRva2VuLnZhbHVlIDogdG9rZW47XG4gICAgICAgICAgICB2YXIgc2Nhbm5hYmxlID0gY29sdW1uLnNjYW5uYWJsZTtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBzY2FubmFibGUubGVuZ3RoOyB3LS07ICkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNjYW5uYWJsZVt3XTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGNvbnN1bWUgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHJlZ2V4IG9yIGxpdGVyYWxcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0LnRlc3QgPyBleHBlY3QudGVzdCh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBleHBlY3QudHlwZSA/IGV4cGVjdC50eXBlID09PSB0b2tlbi50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXhwZWN0LmxpdGVyYWwgPT09IGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGl0XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gc3RhdGUubmV4dFN0YXRlKHtkYXRhOiB2YWx1ZSwgdG9rZW46IHRva2VuLCBpc1Rva2VuOiB0cnVlLCByZWZlcmVuY2U6IG4gLSAxfSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb2x1bW4uc3RhdGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXh0LCBmb3IgZWFjaCBvZiB0aGUgcnVsZXMsIHdlIGVpdGhlclxuICAgICAgICAgICAgLy8gKGEpIGNvbXBsZXRlIGl0LCBhbmQgdHJ5IHRvIHNlZSBpZiB0aGUgcmVmZXJlbmNlIHJvdyBleHBlY3RlZCB0aGF0XG4gICAgICAgICAgICAvLyAgICAgcnVsZVxuICAgICAgICAgICAgLy8gKGIpIHByZWRpY3QgdGhlIG5leHQgbm9udGVybWluYWwgaXQgZXhwZWN0cyBieSBhZGRpbmcgdGhhdFxuICAgICAgICAgICAgLy8gICAgIG5vbnRlcm1pbmFsJ3Mgc3RhcnQgc3RhdGVcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgZHVwbGljYXRpb24sIHdlIGFsc28ga2VlcCB0cmFjayBvZiBydWxlcyB3ZSBoYXZlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGFkZGVkXG5cbiAgICAgICAgICAgIG5leHRDb2x1bW4ucHJvY2VzcygpO1xuXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQsIHRocm93IGFuIGVycm9yOlxuICAgICAgICAgICAgaWYgKG5leHRDb2x1bW4uc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHN0YXRlcyBhdCBhbGwhIFRoaXMgaXMgbm90IGdvb2QuXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLnJlcG9ydEVycm9yKHRva2VuKSk7XG4gICAgICAgICAgICAgICAgZXJyLm9mZnNldCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICBlcnIudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1heWJlIHNhdmUgbGV4ZXIgc3RhdGVcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgY29sdW1uLmxleGVyU3RhdGUgPSBsZXhlci5zYXZlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgIHRoaXMubGV4ZXJTdGF0ZSA9IGxleGVyLnNhdmUoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50YWxseSBrZWVwIHRyYWNrIG9mIHJlc3VsdHNcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5maW5pc2goKTtcblxuICAgICAgICAvLyBBbGxvdyBjaGFpbmluZywgZm9yIHdoYXRldmVyIGl0J3Mgd29ydGhcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuRGlzcGxheSA9ICh0b2tlbi50eXBlID8gdG9rZW4udHlwZSArIFwiIHRva2VuOiBcIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodG9rZW4udmFsdWUgIT09IHVuZGVmaW5lZCA/IHRva2VuLnZhbHVlIDogdG9rZW4pO1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMubGV4ZXIuZm9ybWF0RXJyb3IodG9rZW4sIFwiU3ludGF4IGVycm9yXCIpKTtcbiAgICAgICAgbGluZXMucHVzaCgnVW5leHBlY3RlZCAnICsgdG9rZW5EaXNwbGF5ICsgJy4gSW5zdGVhZCwgSSB3YXMgZXhwZWN0aW5nIHRvIHNlZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcXG4nKTtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW5JbmRleCA9IHRoaXMudGFibGUubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW4gPSB0aGlzLnRhYmxlW2xhc3RDb2x1bW5JbmRleF07XG4gICAgICAgIHZhciBleHBlY3RhbnRTdGF0ZXMgPSBsYXN0Q29sdW1uLnN0YXRlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U3ltYm9sID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTeW1ib2wgJiYgdHlwZW9mIG5leHRTeW1ib2wgIT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNwbGF5IGEgXCJzdGF0ZSBzdGFja1wiIGZvciBlYWNoIGV4cGVjdGFudCBzdGF0ZVxuICAgICAgICAvLyAtIHdoaWNoIHNob3dzIHlvdSBob3cgdGhpcyBzdGF0ZSBjYW1lIHRvIGJlLCBzdGVwIGJ5IHN0ZXAuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgZGVyaXZhdGlvbiwgd2Ugb25seSBkaXNwbGF5IHRoZSBmaXJzdCBvbmUuXG4gICAgICAgIHZhciBzdGF0ZVN0YWNrcyA9IGV4cGVjdGFudFN0YXRlc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRmlyc3RTdGF0ZVN0YWNrKHN0YXRlLCBbXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgLy8gRGlzcGxheSBlYWNoIHN0YXRlIHRoYXQgaXMgZXhwZWN0aW5nIGEgdGVybWluYWwgc3ltYm9sIG5leHQuXG4gICAgICAgIHN0YXRlU3RhY2tzLmZvckVhY2goZnVuY3Rpb24oc3RhdGVTdGFjaykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVTdGFja1swXTtcbiAgICAgICAgICAgIHZhciBuZXh0U3ltYm9sID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICB2YXIgc3ltYm9sRGlzcGxheSA9IHRoaXMuZ2V0U3ltYm9sRGlzcGxheShuZXh0U3ltYm9sKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJ0EgJyArIHN5bWJvbERpc3BsYXkgKyAnIGJhc2VkIG9uOicpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5U3RhdGVTdGFjayhzdGF0ZVN0YWNrLCBsaW5lcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmRpc3BsYXlTdGF0ZVN0YWNrID0gZnVuY3Rpb24oc3RhdGVTdGFjaywgbGluZXMpIHtcbiAgICAgICAgdmFyIGxhc3REaXNwbGF5O1xuICAgICAgICB2YXIgc2FtZURpc3BsYXlDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGVTdGFjay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVTdGFja1tqXTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gc3RhdGUucnVsZS50b1N0cmluZyhzdGF0ZS5kb3QpO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IGxhc3REaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgc2FtZURpc3BsYXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZURpc3BsYXlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnICAgIOKshiDvuI4nICsgc2FtZURpc3BsYXlDb3VudCArICcgbW9yZSBsaW5lcyBpZGVudGljYWwgdG8gdGhpcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYW1lRGlzcGxheUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcgICAgJyArIGRpc3BsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdERpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0U3ltYm9sRGlzcGxheSA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBzeW1ib2w7XG4gICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgc3ltYm9sLmxpdGVyYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzeW1ib2wubGl0ZXJhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiBzeW1ib2wgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiAnY2hhcmFjdGVyIG1hdGNoaW5nICcgKyBzeW1ib2w7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiBzeW1ib2wudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC50eXBlICsgJyB0b2tlbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3ltYm9sIHR5cGU6ICcgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQnVpbGRzIGEgdGhlIGZpcnN0IHN0YXRlIHN0YWNrLiBZb3UgY2FuIHRoaW5rIG9mIGEgc3RhdGUgc3RhY2sgYXMgdGhlIGNhbGwgc3RhY2tcbiAgICBvZiB0aGUgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyIHdoaWNoIHRoZSBOZWFybGV5IHBhcnNlIGFsZ29yaXRobSBzaW11bGF0ZXMuXG4gICAgQSBzdGF0ZSBzdGFjayBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZSBvYmplY3RzLiBXaXRoaW4gYVxuICAgIHN0YXRlIHN0YWNrLCB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgYXJyYXkgd2lsbCBiZSB0aGUgc3RhcnRpbmdcbiAgICBzdGF0ZSwgd2l0aCBlYWNoIHN1Y2Nlc3NpdmUgaXRlbSBpbiB0aGUgYXJyYXkgZ29pbmcgZnVydGhlciBiYWNrIGludG8gaGlzdG9yeS5cblxuICAgIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgZ2l2ZW4gYSBzdGFydGluZyBzdGF0ZSBhbmQgYW4gZW1wdHkgYXJyYXkgcmVwcmVzZW50aW5nXG4gICAgdGhlIHZpc2l0ZWQgc3RhdGVzLCBhbmQgaXQgcmV0dXJucyBhbiBzaW5nbGUgc3RhdGUgc3RhY2suXG5cbiAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuYnVpbGRGaXJzdFN0YXRlU3RhY2sgPSBmdW5jdGlvbihzdGF0ZSwgdmlzaXRlZCkge1xuICAgICAgICBpZiAodmlzaXRlZC5pbmRleE9mKHN0YXRlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGN5Y2xlLCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgLy8gdG8gZWxpbWluYXRlIHRoaXMgcGF0aCBmcm9tIHRoZSByZXN1bHRzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGhvdyB0byBkaXNwbGF5IGl0IG1lYW5pbmdmdWxseVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLndhbnRlZEJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzdGF0ZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHN0YXRlLndhbnRlZEJ5WzBdO1xuICAgICAgICB2YXIgY2hpbGRWaXNpdGVkID0gW3N0YXRlXS5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IHRoaXMuYnVpbGRGaXJzdFN0YXRlU3RhY2socHJldlN0YXRlLCBjaGlsZFZpc2l0ZWQpO1xuICAgICAgICBpZiAoY2hpbGRSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhdGVdLmNvbmNhdChjaGlsZFJlc3VsdCk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50YWJsZVt0aGlzLmN1cnJlbnRdO1xuICAgICAgICBjb2x1bW4ubGV4ZXJTdGF0ZSA9IHRoaXMubGV4ZXJTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvbHVtbi5pbmRleDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudGFibGVbaW5kZXhdID0gY29sdW1uO1xuICAgICAgICB0aGlzLnRhYmxlLnNwbGljZShpbmRleCArIDEpO1xuICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSBjb2x1bW4ubGV4ZXJTdGF0ZTtcblxuICAgICAgICAvLyBJbmNyZW1lbnRhbGx5IGtlZXAgdHJhY2sgb2YgcmVzdWx0c1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSB0aGlzLmZpbmlzaCgpO1xuICAgIH07XG5cbiAgICAvLyBuYi4gZGVwcmVjYXRlZDogdXNlIHNhdmUvcmVzdG9yZSBpbnN0ZWFkIVxuICAgIFBhcnNlci5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0IG9wdGlvbiBga2VlcEhpc3RvcnlgIHRvIGVuYWJsZSByZXdpbmRpbmcnKVxuICAgICAgICB9XG4gICAgICAgIC8vIG5iLiByZWNhbGwgY29sdW1uICh0YWJsZSkgaW5kaWNpZXMgZmFsbCBiZXR3ZWVuIHRva2VuIGluZGljaWVzLlxuICAgICAgICAvLyAgICAgICAgY29sIDAgICAtLSAgIHRva2VuIDAgICAtLSAgIGNvbCAxXG4gICAgICAgIHRoaXMucmVzdG9yZSh0aGlzLnRhYmxlW2luZGV4XSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcG9zc2libGUgcGFyc2luZ3NcbiAgICAgICAgdmFyIGNvbnNpZGVyYXRpb25zID0gW107XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ3JhbW1hci5zdGFydDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMudGFibGVbdGhpcy50YWJsZS5sZW5ndGggLSAxXVxuICAgICAgICBjb2x1bW4uc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGlmICh0LnJ1bGUubmFtZSA9PT0gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgJiYgdC5kb3QgPT09IHQucnVsZS5zeW1ib2xzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAmJiB0LnJlZmVyZW5jZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAmJiB0LmRhdGEgIT09IFBhcnNlci5mYWlsKSB7XG4gICAgICAgICAgICAgICAgY29uc2lkZXJhdGlvbnMucHVzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25zaWRlcmF0aW9ucy5tYXAoZnVuY3Rpb24oYykge3JldHVybiBjLmRhdGE7IH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBQYXJzZXI6IFBhcnNlcixcbiAgICAgICAgR3JhbW1hcjogR3JhbW1hcixcbiAgICAgICAgUnVsZTogUnVsZSxcbiAgICB9O1xuXG59KSk7XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE2LjFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcblxudmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn0oKTtcblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IHBhcnNlSW50KGh0bWxbJ29mZnNldCcgKyBheGlzXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0pIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgaXNJRTEwID0gaXNJRSgxMCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0pO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiB1cGRhdGUuIEl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxuZXhwb3J0IGRlZmF1bHQgUG9wcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiLyoqIVxuKiB0aXBweS5qcyB2NS4xLjRcbiogKGMpIDIwMTctMjAyMCBhdG9taWtzXG4qIE1JVCBMaWNlbnNlXG4qL1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiNS4xLjRcIjtcblxuLyoqXG4gKiBUcmlnZ2VycyByZWZsb3dcbiAqL1xuZnVuY3Rpb24gcmVmbG93KGVsZW1lbnQpIHtcbiAgdm9pZCBlbGVtZW50Lm9mZnNldEhlaWdodDtcbn1cbi8qKlxuICogU2V0cyB0aGUgaW5uZXJIVE1MIG9mIGFuIGVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBzZXRJbm5lckhUTUwoZWxlbWVudCwgaHRtbCkge1xuICBlbGVtZW50W2lubmVySFRNTCgpXSA9IGh0bWw7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGEgcmVmZXJlbmNlIGVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBpc1JlZmVyZW5jZUVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl90aXBweSAmJiB2YWx1ZS5fdGlwcHkucmVmZXJlbmNlID09PSB2YWx1ZSk7XG59XG4vKipcbiAqIFNhZmUgLmhhc093blByb3BlcnR5IGNoZWNrLCBmb3IgcHJvdG90eXBlLWxlc3Mgb2JqZWN0c1xuICovXG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50cyBiYXNlZCBvbiB0aGUgdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBnZXRBcnJheU9mRWxlbWVudHModmFsdWUpIHtcbiAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgfVxuXG4gIGlmIChpc05vZGVMaXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBhcnJheUZyb20odmFsdWUpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSk7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBhdCBhIGdpdmVuIGluZGV4IGRlcGVuZGluZyBvbiBpZiBpdCdzIGFuIGFycmF5IG9yIG51bWJlclxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB2ID0gdmFsdWVbaW5kZXhdO1xuICAgIHJldHVybiB2ID09IG51bGwgPyBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWVbaW5kZXhdIDogZGVmYXVsdFZhbHVlIDogdjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogUHJldmVudHMgZXJyb3JzIGZyb20gYmVpbmcgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBuZXN0ZWQgbW9kaWZpZXIgb2JqZWN0c1xuICogaW4gYHBvcHBlck9wdGlvbnNgXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kaWZpZXIob2JqLCBrZXkpIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmoubW9kaWZpZXJzICYmIG9iai5tb2RpZmllcnNba2V5XTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgb2YgdHlwZVxuICovXG5cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHJldHVybiBzdHIuaW5kZXhPZignW29iamVjdCcpID09PSAwICYmIHN0ci5pbmRleE9mKHR5cGUgKyBcIl1cIikgPiAtMTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgb2YgdHlwZSBFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdFbGVtZW50Jyk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIG9mIHR5cGUgTm9kZUxpc3RcbiAqL1xuXG5mdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdOb2RlTGlzdCcpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBvZiB0eXBlIE1vdXNlRXZlbnRcbiAqL1xuXG5mdW5jdGlvbiBpc01vdXNlRXZlbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ01vdXNlRXZlbnQnKTtcbn1cbi8qKlxuICogRmlyZWZveCBleHRlbnNpb25zIGRvbid0IGFsbG93IHNldHRpbmcgLmlubmVySFRNTCBkaXJlY3RseSwgdGhpcyB3aWxsIHRyaWNrXG4gKiBpdFxuICovXG5cbmZ1bmN0aW9uIGlubmVySFRNTCgpIHtcbiAgcmV0dXJuICdpbm5lckhUTUwnO1xufVxuLyoqXG4gKiBFdmFsdWF0ZXMgYSBmdW5jdGlvbiBpZiBvbmUsIG9yIHJldHVybnMgdGhlIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlV2l0aEFyZ3NPclJldHVybih2YWx1ZSwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKSA6IHZhbHVlO1xufVxuLyoqXG4gKiBTZXRzIGEgcG9wcGVySW5zdGFuY2UgbW9kaWZpZXIncyBwcm9wZXJ0eSB0byBhIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gc2V0TW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIG5hbWUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBtb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIG0ubmFtZSA9PT0gbmFtZTtcbiAgfSlbMF1bcHJvcGVydHldID0gdmFsdWU7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgYGRpdmAgZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGRpdigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNpdGlvbiBkdXJhdGlvbiB0byBhIGxpc3Qgb2YgZWxlbWVudHNcbiAqL1xuXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uRHVyYXRpb24oZWxzLCB2YWx1ZSkge1xuICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHZhbHVlICsgXCJtc1wiO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFNldHMgdGhlIHZpc2liaWxpdHkgc3RhdGUgdG8gZWxlbWVudHMgc28gdGhleSBjYW4gYmVnaW4gdG8gdHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNldFZpc2liaWxpdHlTdGF0ZShlbHMsIHN0YXRlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIERlYm91bmNlIHV0aWxpdHkuIFRvIGF2b2lkIGJsb2F0aW5nIGJ1bmRsZSBzaXplLCB3ZSdyZSBvbmx5IHBhc3NpbmcgMVxuICogYXJndW1lbnQgaGVyZSwgYSBtb3JlIGdlbmVyaWMgZnVuY3Rpb24gd291bGQgcGFzcyBhbGwgYXJndW1lbnRzLiBPbmx5XG4gKiBgb25Nb3VzZU1vdmVgIHVzZXMgdGhpcyB3aGljaCB0YWtlcyB0aGUgZXZlbnQgb2JqZWN0IGZvciBub3cuXG4gKi9cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIG1zKSB7XG4gIC8vIEF2b2lkIHdyYXBwaW5nIGluIGBzZXRUaW1lb3V0YCBpZiBtcyBpcyAwIGFueXdheVxuICBpZiAobXMgPT09IDApIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZm4oYXJnKTtcbiAgICB9LCBtcyk7XG4gIH07XG59XG4vKipcbiAqIFByZXNlcnZlcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaW52b2NhdGlvbiB3aGVuIGFub3RoZXIgZnVuY3Rpb24gcmVwbGFjZXMgaXRcbiAqL1xuXG5mdW5jdGlvbiBwcmVzZXJ2ZUludm9jYXRpb24ob3JpZ2luYWxGbiwgY3VycmVudEZuLCBhcmdzKSB7XG4gIGlmIChvcmlnaW5hbEZuICYmIG9yaWdpbmFsRm4gIT09IGN1cnJlbnRGbikge1xuICAgIG9yaWdpbmFsRm4uYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfVxufVxuLyoqXG4gKiBEZWxldGVzIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QgKHB1cmUpXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhvYmosIGtleXMpIHtcbiAgdmFyIGNsb25lID0gX2V4dGVuZHMoe30sIG9iaik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgY2xvbmVba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogUG9ueWZpbGwgZm9yIEFycmF5LmZyb20gLSBjb252ZXJ0cyBpdGVyYWJsZSB2YWx1ZXMgdG8gYW4gYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBhcnJheUZyb20odmFsdWUpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodmFsdWUpO1xufVxuLyoqXG4gKiBXb3JrcyBsaWtlIEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QsIGJ1dCB1c2VzIGEgY2FsbGJhY2sgaW5zdGVhZFxuICovXG5cbmZ1bmN0aW9uIGNsb3Nlc3RDYWxsYmFjayhlbGVtZW50LCBjYWxsYmFjaykge1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGlmIChjYWxsYmFjayhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIGFycmF5IG9yIHN0cmluZyBpbmNsdWRlcyBhIHN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEuaW5kZXhPZihiKSA+IC0xO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gc3RyaW5nIG9mIHZhbHVlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZVxuICovXG5cbmZ1bmN0aW9uIHNwbGl0QnlTcGFjZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBgbmV4dFZhbHVlYCBpZiBgbmV4dFZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAsIG90aGVyd2lzZSByZXR1cm5zXG4gKiBgY3VycmVudFZhbHVlYFxuICovXG5cbmZ1bmN0aW9uIHVzZUlmRGVmaW5lZChuZXh0VmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuICByZXR1cm4gbmV4dFZhbHVlICE9PSB1bmRlZmluZWQgPyBuZXh0VmFsdWUgOiBjdXJyZW50VmFsdWU7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgdmFsdWUgdGhhdCdzIGFuIGFycmF5IG9yIHNpbmdsZSB2YWx1ZSB0byBhbiBhcnJheVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh2YWx1ZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG93bmVyRG9jdW1lbnQgb2YgdGhlIGZpcnN0IGF2YWlsYWJsZSBlbGVtZW50LCBvdGhlcndpc2UgZ2xvYmFsXG4gKiBkb2N1bWVudFxuICovXG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnQoZWxlbWVudE9yRWxlbWVudHMpIHtcbiAgdmFyIF9ub3JtYWxpemVUb0FycmF5ID0gbm9ybWFsaXplVG9BcnJheShlbGVtZW50T3JFbGVtZW50cyksXG4gICAgICBlbGVtZW50ID0gX25vcm1hbGl6ZVRvQXJyYXlbMF07XG5cbiAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgOiBkb2N1bWVudDtcbn1cbi8qKlxuICogQWRkcyBpdGVtIHRvIGFycmF5IGlmIGFycmF5IGRvZXMgbm90IGNvbnRhaW4gaXRcbiAqL1xuXG5mdW5jdGlvbiBwdXNoSWZVbmlxdWUoYXJyLCB2YWx1ZSkge1xuICBpZiAoYXJyLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxufVxuLyoqXG4gKiBBZGRzIGBweGAgaWYgdmFsdWUgaXMgYSBudW1iZXIsIG9yIHJldHVybnMgaXQgZGlyZWN0bHlcbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmRQeElmTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgKyBcInB4XCIgOiB2YWx1ZTtcbn1cbi8qKlxuICogRmlsdGVycyBvdXQgZHVwbGljYXRlIGVsZW1lbnRzIGluIGFuIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSkgPT09IGluZGV4O1xuICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBudW1iZXIgZnJvbSBudW1iZXIgb3IgQ1NTIHVuaXRzIHN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG59XG4vKipcbiAqIEdldHMgbnVtYmVyIG9yIENTUyBzdHJpbmcgdW5pdHMgaW4gcGl4ZWxzIChlLmcuIGAxcmVtYCAtPiAxNilcbiAqL1xuXG5mdW5jdGlvbiBnZXRVbml0c0luUHgoZG9jLCB2YWx1ZSkge1xuICB2YXIgaXNSZW0gPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGluY2x1ZGVzKHZhbHVlLCAncmVtJyk7XG4gIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJvb3RGb250U2l6ZSA9IDE2O1xuXG4gIGlmIChodG1sICYmIGlzUmVtKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShodG1sKS5mb250U2l6ZSB8fCBTdHJpbmcocm9vdEZvbnRTaXplKSkgKiBnZXROdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGdldE51bWJlcih2YWx1ZSk7XG59XG4vKipcbiAqIEFkZHMgdGhlIGBkaXN0YW5jZVB4YCB2YWx1ZSB0byB0aGUgcGxhY2VtZW50IG9mIGEgUG9wcGVyLlBhZGRpbmcgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRQYWRkaW5nKGJhc2VQbGFjZW1lbnQsIHBhZGRpbmcsIGRpc3RhbmNlUHgpIHtcbiAgaWYgKHBhZGRpbmcgPT09IHZvaWQgMCkge1xuICAgIHBhZGRpbmcgPSA1O1xuICB9XG5cbiAgdmFyIGZyZXNoUGFkZGluZ09iamVjdCA9IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmVzaFBhZGRpbmdPYmplY3QpO1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgb2JqW2tleV0gPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xuXG4gICAgaWYgKGJhc2VQbGFjZW1lbnQgPT09IGtleSkge1xuICAgICAgb2JqW2tleV0gPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicgPyBwYWRkaW5nICsgZGlzdGFuY2VQeCA6IHBhZGRpbmdbYmFzZVBsYWNlbWVudF0gKyBkaXN0YW5jZVB4O1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0sIGZyZXNoUGFkZGluZ09iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKG1ldGhvZCkge1xuICB2YXIgdHh0ID0gbWV0aG9kID09PSAnZGVzdHJveScgPyAnbiBhbHJlYWR5LScgOiAnICc7XG4gIHJldHVybiBcIlxcbiAgICBcIiArIG1ldGhvZCArIFwiKCkgd2FzIGNhbGxlZCBvbiBhXCIgKyB0eHQgKyBcImRlc3Ryb3llZCBpbnN0YW5jZS4gVGhpcyBpcyBhIG5vLW9wIGJ1dFxcbiAgICBpbmRpY2F0ZXMgYSBwb3RlbnRpYWwgbWVtb3J5IGxlYWsuXFxuICBcIjtcbn1cbmZ1bmN0aW9uIGNsZWFuKHZhbHVlKSB7XG4gIHZhciBzcGFjZXNBbmRUYWJzID0gL1sgXFx0XXsyLH0vZztcbiAgdmFyIGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBnZXREZXZNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNsZWFuKFwiXFxuICAlY3RpcHB5LmpzXFxuXFxuICAlY1wiICsgY2xlYW4obWVzc2FnZSkgKyBcIlxcblxcbiAgJWNcXHVEODNEXFx1REM3N1xcdTIwMEQgVGhpcyBpcyBhIGRldmVsb3BtZW50LW9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24uXFxuICBcIik7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gW2dldERldk1lc3NhZ2UobWVzc2FnZSksIC8vIHRpdGxlXG4gICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjNlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgLy8gbWVzc2FnZVxuICAnbGluZS1oZWlnaHQ6IDEuNScsIC8vIGZvb3RlclxuICAnY29sb3I6ICNhNmEwOTU7J107XG59XG4vKipcbiAqIEhlbHBmdWwgd3JhcHBlciBhcm91bmQgYGNvbnNvbGUud2FybigpYC5cbiAqIFRPRE86IFNob3VsZCB3ZSB1c2UgYSBjYWNoZSBzbyBpdCBvbmx5IHdhcm5zIGEgc2luZ2xlIHRpbWUgYW5kIG5vdCBzcGFtIHRoZVxuICogY29uc29sZT8gKE5lZWQgdG8gY29uc2lkZXIgaG90IHJlbG9hZGluZyBhbmQgaW52YWxpZGF0aW9uIHRob3VnaCkuIENocm9tZVxuICogYWxyZWFkeSBiYXRjaGVzIHdhcm5pbmdzIGFzIHdlbGwuXG4gKi9cblxuZnVuY3Rpb24gd2FybldoZW4oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuLyoqXG4gKiBIZWxwZnVsIHdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLmVycm9yKClgXG4gKi9cblxuZnVuY3Rpb24gZXJyb3JXaGVuKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgdmFyIF9jb25zb2xlMjtcblxuICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZTIsIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgYHRhcmdldHNgIHZhbHVlIHBhc3NlZCB0byBgdGlwcHkoKWBcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgZGlkUGFzc0ZhbHN5VmFsdWUgPSAhdGFyZ2V0cztcbiAgdmFyIGRpZFBhc3NQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXRzKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgIXRhcmdldHMuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgZXJyb3JXaGVuKGRpZFBhc3NGYWxzeVZhbHVlLCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCcsICdgJyArIFN0cmluZyh0YXJnZXRzKSArICdgJywgJ2FzIGl0cyB0YXJnZXRzIChmaXJzdCkgYXJndW1lbnQuIFZhbGlkIHR5cGVzIGFyZTogU3RyaW5nLCBFbGVtZW50LCBFbGVtZW50W10sJywgJ29yIE5vZGVMaXN0LiddLmpvaW4oJyAnKSk7XG4gIGVycm9yV2hlbihkaWRQYXNzUGxhaW5PYmplY3QsIFsndGlwcHkoKSB3YXMgcGFzc2VkIGEgcGxhaW4gb2JqZWN0IHdoaWNoIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQuJywgJ1NlZTogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL21pc2MvI2N1c3RvbS1wb3NpdGlvbiddLmpvaW4oJyAnKSk7XG59XG5cbnZhciBwbHVnaW5Qcm9wcyA9IHtcbiAgYW5pbWF0ZUZpbGw6IGZhbHNlLFxuICBmb2xsb3dDdXJzb3I6IGZhbHNlLFxuICBpbmxpbmVQb3NpdGlvbmluZzogZmFsc2UsXG4gIHN0aWNreTogZmFsc2Vcbn07XG52YXIgZGVmYXVsdFByb3BzID0gX2V4dGVuZHMoe1xuICBhbGxvd0hUTUw6IHRydWUsXG4gIGFuaW1hdGlvbjogJ2ZhZGUnLFxuICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH0sXG4gIGFyaWE6ICdkZXNjcmliZWRieScsXG4gIGFycm93OiB0cnVlLFxuICBib3VuZGFyeTogJ3Njcm9sbFBhcmVudCcsXG4gIGNvbnRlbnQ6ICcnLFxuICBkZWxheTogMCxcbiAgZGlzdGFuY2U6IDEwLFxuICBkdXJhdGlvbjogWzMwMCwgMjUwXSxcbiAgZmxpcDogdHJ1ZSxcbiAgZmxpcEJlaGF2aW9yOiAnZmxpcCcsXG4gIGZsaXBPblVwZGF0ZTogZmFsc2UsXG4gIGhpZGVPbkNsaWNrOiB0cnVlLFxuICBpZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgaW5lcnRpYTogZmFsc2UsXG4gIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmVCb3JkZXI6IDIsXG4gIGludGVyYWN0aXZlRGVib3VuY2U6IDAsXG4gIGxhenk6IHRydWUsXG4gIG1heFdpZHRoOiAzNTAsXG4gIG11bHRpcGxlOiBmYWxzZSxcbiAgb2Zmc2V0OiAwLFxuICBvbkFmdGVyVXBkYXRlOiBmdW5jdGlvbiBvbkFmdGVyVXBkYXRlKCkge30sXG4gIG9uQmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBvbkJlZm9yZVVwZGF0ZSgpIHt9LFxuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcbiAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7fSxcbiAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge30sXG4gIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge30sXG4gIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7fSxcbiAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7fSxcbiAgb25TaG93bjogZnVuY3Rpb24gb25TaG93bigpIHt9LFxuICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcigpIHt9LFxuICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7fSxcbiAgcGxhY2VtZW50OiAndG9wJyxcbiAgcGx1Z2luczogW10sXG4gIHBvcHBlck9wdGlvbnM6IHt9LFxuICByb2xlOiAndG9vbHRpcCcsXG4gIHNob3dPbkNyZWF0ZTogZmFsc2UsXG4gIHRoZW1lOiAnJyxcbiAgdG91Y2g6IHRydWUsXG4gIHRyaWdnZXI6ICdtb3VzZWVudGVyIGZvY3VzJyxcbiAgdHJpZ2dlclRhcmdldDogbnVsbCxcbiAgdXBkYXRlRHVyYXRpb246IDAsXG4gIHpJbmRleDogOTk5OVxufSwgcGx1Z2luUHJvcHMpO1xudmFyIGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFByb3BzKTtcbi8qKlxuICogSWYgdGhlIHNldFByb3BzKCkgbWV0aG9kIGVuY291bnRlcnMgb25lIG9mIHRoZXNlLCB0aGUgcG9wcGVySW5zdGFuY2UgbXVzdCBiZVxuICogcmVjcmVhdGVkXG4gKi9cblxudmFyIFBPUFBFUl9JTlNUQU5DRV9ERVBFTkRFTkNJRVMgPSBbJ2Fycm93JywgJ2JvdW5kYXJ5JywgJ2Rpc3RhbmNlJywgJ2ZsaXAnLCAnZmxpcEJlaGF2aW9yJywgJ2ZsaXBPblVwZGF0ZScsICdvZmZzZXQnLCAncGxhY2VtZW50JywgJ3BvcHBlck9wdGlvbnMnXTtcbi8qKlxuICogTXV0YXRlcyB0aGUgZGVmYXVsdFByb3BzIG9iamVjdCBieSBzZXR0aW5nIHRoZSBwcm9wcyBzcGVjaWZpZWRcbiAqL1xuXG52YXIgc2V0RGVmYXVsdFByb3BzID0gZnVuY3Rpb24gc2V0RGVmYXVsdFByb3BzKHBhcnRpYWxQcm9wcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIFtdKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWZhdWx0UHJvcHNba2V5XSA9IHBhcnRpYWxQcm9wc1trZXldO1xuICB9KTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gZXh0ZW5kZWQgcHJvcHMgb2JqZWN0IGluY2x1ZGluZyBwbHVnaW4gcHJvcHNcbiAqL1xuXG5mdW5jdGlvbiBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHBhc3NlZFByb3BzKSB7XG4gIHZhciBwbHVnaW5zID0gcGFzc2VkUHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgdmFyIHBsdWdpblByb3BzID0gcGx1Z2lucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGx1Z2luKSB7XG4gICAgdmFyIG5hbWUgPSBwbHVnaW4ubmFtZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcGx1Z2luLmRlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBhY2NbbmFtZV0gPSBwYXNzZWRQcm9wc1tuYW1lXSAhPT0gdW5kZWZpbmVkID8gcGFzc2VkUHJvcHNbbmFtZV0gOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHBhc3NlZFByb3BzLCB7fSwgcGx1Z2luUHJvcHMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBvcHRpb25hbCBwcm9wcyBmcm9tIGRhdGEtdGlwcHktKiBhdHRyaWJ1dGVzXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcGx1Z2lucykge1xuICB2YXIgcHJvcEtleXMgPSBwbHVnaW5zID8gT2JqZWN0LmtleXMoZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KSkpIDogZGVmYXVsdEtleXM7XG4gIHZhciBwcm9wcyA9IHByb3BLZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWVBc1N0cmluZyA9IChyZWZlcmVuY2UuZ2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS1cIiArIGtleSkgfHwgJycpLnRyaW0oKTtcblxuICAgIGlmICghdmFsdWVBc1N0cmluZykge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlQXNTdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gcHJvcHM7XG59XG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgcHJvcHMgb2JqZWN0IGJ5IG1lcmdpbmcgZGF0YSBhdHRyaWJ1dGVzIGFuZCBkaXNhYmxpbmdcbiAqIGNvbmZsaWN0aW5nIHByb3BzIHdoZXJlIG5lY2Vzc2FyeVxuICovXG5cbmZ1bmN0aW9uIGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBwcm9wcykge1xuICB2YXIgb3V0ID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY29udGVudDogaW52b2tlV2l0aEFyZ3NPclJldHVybihwcm9wcy5jb250ZW50LCBbcmVmZXJlbmNlXSlcbiAgfSwgcHJvcHMuaWdub3JlQXR0cmlidXRlcyA/IHt9IDogZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMucGx1Z2lucykpO1xuXG4gIGlmIChvdXQuaW50ZXJhY3RpdmUpIHtcbiAgICBvdXQuYXJpYSA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgcHJvcHMgd2l0aCB0aGUgdmFsaWQgYGRlZmF1bHRQcm9wc2Agb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIHBsdWdpbnMpIHtcbiAgaWYgKHBhcnRpYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbFByb3BzID0ge307XG4gIH1cblxuICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSB7XG4gICAgcGx1Z2lucyA9IFtdO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0aWFsUHJvcHNbcHJvcF07XG4gICAgdmFyIGRpZFNwZWNpZnlQbGFjZW1lbnRJblBvcHBlck9wdGlvbnMgPSBwcm9wID09PSAncG9wcGVyT3B0aW9ucycgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgJ3BsYWNlbWVudCcpO1xuICAgIHZhciBub25QbHVnaW5Qcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMoZGVmYXVsdFByb3BzLCBbJ2FuaW1hdGVGaWxsJywgJ2ZvbGxvd0N1cnNvcicsICdpbmxpbmVQb3NpdGlvbmluZycsICdzdGlja3knXSk7IC8vIFRoZXNlIHByb3BzIGhhdmUgY3VzdG9tIHdhcm5pbmdzXG5cbiAgICB2YXIgY3VzdG9tV2FybmluZ1Byb3BzID0gWydhMTF5JywgJ2Fycm93VHlwZScsICdzaG93T25Jbml0JywgJ3NpemUnLCAndGFyZ2V0JywgJ3RvdWNoSG9sZCddO1xuICAgIHZhciBkaWRQYXNzVW5rbm93blByb3AgPSAhaGFzT3duUHJvcGVydHkobm9uUGx1Z2luUHJvcHMsIHByb3ApICYmICFpbmNsdWRlcyhjdXN0b21XYXJuaW5nUHJvcHMsIHByb3ApOyAvLyBDaGVjayBpZiB0aGUgcHJvcCBleGlzdHMgaW4gYHBsdWdpbnNgXG5cbiAgICBpZiAoZGlkUGFzc1Vua25vd25Qcm9wKSB7XG4gICAgICBkaWRQYXNzVW5rbm93blByb3AgPSBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4ubmFtZSA9PT0gcHJvcDtcbiAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICB3YXJuV2hlbihwcm9wID09PSAndGFyZ2V0JywgWydUaGUgYHRhcmdldGAgcHJvcCB3YXMgcmVtb3ZlZCBpbiB2NSBhbmQgcmVwbGFjZWQgd2l0aCB0aGUgZGVsZWdhdGUoKSBhZGRvbicsICdpbiBvcmRlciB0byBjb25zZXJ2ZSBidW5kbGUgc2l6ZS4nLCAnU2VlOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvYWRkb25zLyNldmVudC1kZWxlZ2F0aW9uJ10uam9pbignICcpKTtcbiAgICB3YXJuV2hlbihwcm9wID09PSAnYTExeScsIFsnVGhlIGBhMTF5YCBwcm9wIHdhcyByZW1vdmVkIGluIHY1LiBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgeW91IGFyZSBnaXZpbmcgYScsICd0aXBweSB0byBpcyBuYXRpdmVseSBmb2N1c2FibGUsIHN1Y2ggYXMgPGJ1dHRvbj4gb3IgPGlucHV0Piwgbm90IDxkaXY+JywgJ29yIDxzcGFuPi4nXS5qb2luKCcgJykpO1xuICAgIHdhcm5XaGVuKHByb3AgPT09ICdzaG93T25Jbml0JywgJ1RoZSBgc2hvd09uSW5pdGAgcHJvcCB3YXMgcmVuYW1lZCB0byBgc2hvd09uQ3JlYXRlYCBpbiB2NS4nKTtcbiAgICB3YXJuV2hlbihwcm9wID09PSAnYXJyb3dUeXBlJywgWydUaGUgYGFycm93VHlwZWAgcHJvcCB3YXMgcmVtb3ZlZCBpbiB2NSBpbiBmYXZvciBvZiBvdmVybG9hZGluZyB0aGUgYGFycm93YCcsICdwcm9wLicsICdcXG5cXG4nLCAnXCJyb3VuZFwiIHN0cmluZyB3YXMgcmVwbGFjZWQgd2l0aCBpbXBvcnRpbmcgdGhlIHN0cmluZyBmcm9tIHRoZSBwYWNrYWdlLicsICdcXG5cXG4nLCBcIiogaW1wb3J0IHtyb3VuZEFycm93fSBmcm9tICd0aXBweS5qcyc7IChFU00gdmVyc2lvbilcXG5cIiwgJyogY29uc3Qge3JvdW5kQXJyb3d9ID0gdGlwcHk7IChJSUZFIENETiB2ZXJzaW9uKScsICdcXG5cXG4nLCAnQmVmb3JlOiB7YXJyb3c6IHRydWUsIGFycm93VHlwZTogXCJyb3VuZFwifVxcbicsICdBZnRlcjoge2Fycm93OiByb3VuZEFycm93fWAnXS5qb2luKCcgJykpO1xuICAgIHdhcm5XaGVuKHByb3AgPT09ICd0b3VjaEhvbGQnLCBbJ1RoZSBgdG91Y2hIb2xkYCBwcm9wIHdhcyByZW1vdmVkIGluIHY1IGluIGZhdm9yIG9mIG92ZXJsb2FkaW5nIHRoZSBgdG91Y2hgJywgJ3Byb3AuJywgJ1xcblxcbicsICdCZWZvcmU6IHt0b3VjaEhvbGQ6IHRydWV9XFxuJywgJ0FmdGVyOiB7dG91Y2g6IFwiaG9sZFwifSddLmpvaW4oJyAnKSk7XG4gICAgd2FybldoZW4ocHJvcCA9PT0gJ3NpemUnLCBbJ1RoZSBgc2l6ZWAgcHJvcCB3YXMgcmVtb3ZlZCBpbiB2NS4gSW5zdGVhZCwgdXNlIGEgdGhlbWUgdGhhdCBzcGVjaWZpZXMnLCAnQ1NTIHBhZGRpbmcgYW5kIGZvbnQtc2l6ZSBwcm9wZXJ0aWVzLiddLmpvaW4oJyAnKSk7XG4gICAgd2FybldoZW4ocHJvcCA9PT0gJ3RoZW1lJyAmJiB2YWx1ZSA9PT0gJ2dvb2dsZScsICdUaGUgaW5jbHVkZWQgdGhlbWUgXCJnb29nbGVcIiB3YXMgcmVuYW1lZCB0byBcIm1hdGVyaWFsXCIgaW4gdjUuJyk7XG4gICAgd2FybldoZW4oZGlkU3BlY2lmeVBsYWNlbWVudEluUG9wcGVyT3B0aW9ucywgWydTcGVjaWZ5aW5nIHBsYWNlbWVudCBpbiBgcG9wcGVyT3B0aW9uc2AgaXMgbm90IHN1cHBvcnRlZC4gVXNlIHRoZSBiYXNlLWxldmVsJywgJ2BwbGFjZW1lbnRgIHByb3AgaW5zdGVhZC4nLCAnXFxuXFxuJywgJ0JlZm9yZToge3BvcHBlck9wdGlvbnM6IHtwbGFjZW1lbnQ6IFwiYm90dG9tXCJ9fVxcbicsICdBZnRlcjoge3BsYWNlbWVudDogXCJib3R0b21cIn0nXS5qb2luKCcgJykpO1xuICAgIHdhcm5XaGVuKGRpZFBhc3NVbmtub3duUHJvcCwgW1wiYFwiICsgcHJvcCArIFwiYFwiLCBcImlzIG5vdCBhIHZhbGlkIHByb3AuIFlvdSBtYXkgaGF2ZSBzcGVsbGVkIGl0IGluY29ycmVjdGx5LCBvciBpZiBpdCdzIGFcIiwgJ3BsdWdpbiwgZm9yZ290IHRvIHBhc3MgaXQgaW4gYW4gYXJyYXkgYXMgcHJvcHMucGx1Z2lucy4nLCAnXFxuXFxuJywgJ0luIHY1LCB0aGUgZm9sbG93aW5nIHByb3BzIHdlcmUgdHVybmVkIGludG8gcGx1Z2luczonLCAnXFxuXFxuJywgJyogYW5pbWF0ZUZpbGxcXG4nLCAnKiBmb2xsb3dDdXJzb3JcXG4nLCAnKiBzdGlja3knLCAnXFxuXFxuJywgJ0FsbCBwcm9wczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL2FsbC1wcm9wcy9cXG4nLCAnUGx1Z2luczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3BsdWdpbnMvJ10uam9pbignICcpKTtcbiAgfSk7XG59XG5cbnZhciBQQVNTSVZFID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xudmFyIFJPVU5EX0FSUk9XID0gJzxzdmcgdmlld0JveD1cIjAgMCAxOCA3XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMCA3czIuMDIxLS4wMTUgNS4yNTMtNC4yMThDNi41ODQgMS4wNTEgNy43OTcuMDA3IDkgMGMxLjIwMy0uMDA3IDIuNDE2IDEuMDM1IDMuNzYxIDIuNzgyQzE2LjAxMiA3LjAwNSAxOCA3IDE4IDdIMHpcIi8+PC9zdmc+JztcbnZhciBJT1NfQ0xBU1MgPSBcInRpcHB5LWlPU1wiO1xudmFyIFBPUFBFUl9DTEFTUyA9IFwidGlwcHktcG9wcGVyXCI7XG52YXIgVE9PTFRJUF9DTEFTUyA9IFwidGlwcHktdG9vbHRpcFwiO1xudmFyIENPTlRFTlRfQ0xBU1MgPSBcInRpcHB5LWNvbnRlbnRcIjtcbnZhciBCQUNLRFJPUF9DTEFTUyA9IFwidGlwcHktYmFja2Ryb3BcIjtcbnZhciBBUlJPV19DTEFTUyA9IFwidGlwcHktYXJyb3dcIjtcbnZhciBTVkdfQVJST1dfQ0xBU1MgPSBcInRpcHB5LXN2Zy1hcnJvd1wiO1xudmFyIFBPUFBFUl9TRUxFQ1RPUiA9IFwiLlwiICsgUE9QUEVSX0NMQVNTO1xudmFyIFRPT0xUSVBfU0VMRUNUT1IgPSBcIi5cIiArIFRPT0xUSVBfQ0xBU1M7XG52YXIgQ09OVEVOVF9TRUxFQ1RPUiA9IFwiLlwiICsgQ09OVEVOVF9DTEFTUztcbnZhciBBUlJPV19TRUxFQ1RPUiA9IFwiLlwiICsgQVJST1dfQ0xBU1M7XG52YXIgU1ZHX0FSUk9XX1NFTEVDVE9SID0gXCIuXCIgKyBTVkdfQVJST1dfQ0xBU1M7XG5cbnZhciBjdXJyZW50SW5wdXQgPSB7XG4gIGlzVG91Y2g6IGZhbHNlXG59O1xudmFyIGxhc3RNb3VzZU1vdmVUaW1lID0gMDtcbi8qKlxuICogV2hlbiBhIGB0b3VjaHN0YXJ0YCBldmVudCBpcyBmaXJlZCwgaXQncyBhc3N1bWVkIHRoZSB1c2VyIGlzIHVzaW5nIHRvdWNoXG4gKiBpbnB1dC4gV2UnbGwgYmluZCBhIGBtb3VzZW1vdmVgIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgbW91c2UgaW5wdXQgaW5cbiAqIHRoZSBmdXR1cmUuIFRoaXMgd2F5LCB0aGUgYGlzVG91Y2hgIHByb3BlcnR5IGlzIGZ1bGx5IGR5bmFtaWMgYW5kIHdpbGwgaGFuZGxlXG4gKiBoeWJyaWQgZGV2aWNlcyB0aGF0IHVzZSBhIG1peCBvZiB0b3VjaCArIG1vdXNlIGlucHV0LlxuICovXG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaFN0YXJ0KCkge1xuICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG59XG4vKipcbiAqIFdoZW4gdHdvIGBtb3VzZW1vdmVgIGV2ZW50IGFyZSBmaXJlZCBjb25zZWN1dGl2ZWx5IHdpdGhpbiAyMG1zLCBpdCdzIGFzc3VtZWRcbiAqIHRoZSB1c2VyIGlzIHVzaW5nIG1vdXNlIGlucHV0IGFnYWluLiBgbW91c2Vtb3ZlYCBjYW4gZmlyZSBvbiB0b3VjaCBkZXZpY2VzIGFzXG4gKiB3ZWxsLCBidXQgdmVyeSByYXJlbHkgdGhhdCBxdWlja2x5LlxuICovXG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRNb3VzZU1vdmUoKSB7XG4gIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBpZiAobm93IC0gbGFzdE1vdXNlTW92ZVRpbWUgPCAyMCkge1xuICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gZmFsc2U7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cblxuICBsYXN0TW91c2VNb3ZlVGltZSA9IG5vdztcbn1cbi8qKlxuICogV2hlbiBhbiBlbGVtZW50IGlzIGluIGZvY3VzIGFuZCBoYXMgYSB0aXBweSwgbGVhdmluZyB0aGUgdGFiL3dpbmRvdyBhbmRcbiAqIHJldHVybmluZyBjYXVzZXMgaXQgdG8gc2hvdyBhZ2Fpbi4gRm9yIG1vdXNlIHVzZXJzIHRoaXMgaXMgdW5leHBlY3RlZCwgYnV0XG4gKiBmb3Iga2V5Ym9hcmQgdXNlIGl0IG1ha2VzIHNlbnNlLlxuICogVE9ETzogZmluZCBhIGJldHRlciB0ZWNobmlxdWUgdG8gc29sdmUgdGhpcyBwcm9ibGVtXG4gKi9cblxuZnVuY3Rpb24gb25XaW5kb3dCbHVyKCkge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgaWYgKGlzUmVmZXJlbmNlRWxlbWVudChhY3RpdmVFbGVtZW50KSkge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUVsZW1lbnQuX3RpcHB5O1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQuYmx1ciAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQWRkcyB0aGUgbmVlZGVkIGdsb2JhbCBldmVudCBsaXN0ZW5lcnNcbiAqL1xuXG5mdW5jdGlvbiBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkRvY3VtZW50VG91Y2hTdGFydCwgX2V4dGVuZHMoe30sIFBBU1NJVkUsIHtcbiAgICBjYXB0dXJlOiB0cnVlXG4gIH0pKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbldpbmRvd0JsdXIpO1xufVxuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciB1YSA9IGlzQnJvd3NlciA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAnJztcbnZhciBpc0lFID0gL01TSUUgfFRyaWRlbnRcXC8vLnRlc3QodWEpO1xudmFyIGlzVUNCcm93c2VyID0gL1VDQnJvd3NlclxcLy8udGVzdCh1YSk7XG52YXIgaXNJT1MgPSBpc0Jyb3dzZXIgJiYgL2lQaG9uZXxpUGFkfGlQb2QvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmZ1bmN0aW9uIHVwZGF0ZUlPU0NsYXNzKGlzQWRkKSB7XG4gIHZhciBzaG91bGRBZGQgPSBpc0FkZCAmJiBpc0lPUyAmJiBjdXJyZW50SW5wdXQuaXNUb3VjaDtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3Rbc2hvdWxkQWRkID8gJ2FkZCcgOiAncmVtb3ZlJ10oSU9TX0NMQVNTKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQsIGlnbm9yaW5nIHNoaWZ0aW5nICh0b3Atc3RhcnQsIGV0YylcbiAqL1xuXG5mdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG4vKipcbiAqIEFkZHMgYGRhdGEtaW5lcnRpYWAgYXR0cmlidXRlXG4gKi9cblxuZnVuY3Rpb24gYWRkSW5lcnRpYSh0b29sdGlwKSB7XG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnLCAnJyk7XG59XG4vKipcbiAqIFJlbW92ZXMgYGRhdGEtaW5lcnRpYWAgYXR0cmlidXRlXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlSW5lcnRpYSh0b29sdGlwKSB7XG4gIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnKTtcbn1cbi8qKlxuICogQWRkcyBpbnRlcmFjdGl2ZS1yZWxhdGVkIGF0dHJpYnV0ZXNcbiAqL1xuXG5mdW5jdGlvbiBhZGRJbnRlcmFjdGl2ZSh0b29sdGlwKSB7XG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWludGVyYWN0aXZlJywgJycpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGludGVyYWN0aXZlLXJlbGF0ZWQgYXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUludGVyYWN0aXZlKHRvb2x0aXApIHtcbiAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJhY3RpdmUnKTtcbn1cbi8qKlxuICogU2V0cyB0aGUgY29udGVudCBvZiBhIHRvb2x0aXBcbiAqL1xuXG5mdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnRFbCwgcHJvcHMpIHtcbiAgaWYgKGlzRWxlbWVudChwcm9wcy5jb250ZW50KSkge1xuICAgIHNldElubmVySFRNTChjb250ZW50RWwsICcnKTtcbiAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIga2V5ID0gcHJvcHMuYWxsb3dIVE1MID8gJ2lubmVySFRNTCcgOiAndGV4dENvbnRlbnQnO1xuICAgIGNvbnRlbnRFbFtrZXldID0gcHJvcHMuY29udGVudDtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGlsZCBlbGVtZW50cyBvZiBhIHBvcHBlciBlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4ocG9wcGVyKSB7XG4gIHJldHVybiB7XG4gICAgdG9vbHRpcDogcG9wcGVyLnF1ZXJ5U2VsZWN0b3IoVE9PTFRJUF9TRUxFQ1RPUiksXG4gICAgY29udGVudDogcG9wcGVyLnF1ZXJ5U2VsZWN0b3IoQ09OVEVOVF9TRUxFQ1RPUiksXG4gICAgYXJyb3c6IHBvcHBlci5xdWVyeVNlbGVjdG9yKEFSUk9XX1NFTEVDVE9SKSB8fCBwb3BwZXIucXVlcnlTZWxlY3RvcihTVkdfQVJST1dfU0VMRUNUT1IpXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUFycm93RWxlbWVudChhcnJvdykge1xuICB2YXIgYXJyb3dFbGVtZW50ID0gZGl2KCk7XG5cbiAgaWYgKGFycm93ID09PSB0cnVlKSB7XG4gICAgYXJyb3dFbGVtZW50LmNsYXNzTmFtZSA9IEFSUk9XX0NMQVNTO1xuICB9IGVsc2Uge1xuICAgIGFycm93RWxlbWVudC5jbGFzc05hbWUgPSBTVkdfQVJST1dfQ0xBU1M7XG5cbiAgICBpZiAoaXNFbGVtZW50KGFycm93KSkge1xuICAgICAgYXJyb3dFbGVtZW50LmFwcGVuZENoaWxkKGFycm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGFycm93RWxlbWVudCwgYXJyb3cpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJvd0VsZW1lbnQ7XG59XG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIHBvcHBlciBlbGVtZW50IGFuZCByZXR1cm5zIGl0XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUG9wcGVyRWxlbWVudChpZCwgcHJvcHMpIHtcbiAgdmFyIHBvcHBlciA9IGRpdigpO1xuICBwb3BwZXIuY2xhc3NOYW1lID0gUE9QUEVSX0NMQVNTO1xuICBwb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBwb3BwZXIuc3R5bGUudG9wID0gJzAnO1xuICBwb3BwZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgdmFyIHRvb2x0aXAgPSBkaXYoKTtcbiAgdG9vbHRpcC5jbGFzc05hbWUgPSBUT09MVElQX0NMQVNTO1xuICB0b29sdGlwLmlkID0gXCJ0aXBweS1cIiArIGlkO1xuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIHVwZGF0ZVRoZW1lKHRvb2x0aXAsICdhZGQnLCBwcm9wcy50aGVtZSk7XG4gIHZhciBjb250ZW50ID0gZGl2KCk7XG4gIGNvbnRlbnQuY2xhc3NOYW1lID0gQ09OVEVOVF9DTEFTUztcbiAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG5cbiAgaWYgKHByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgYWRkSW50ZXJhY3RpdmUodG9vbHRpcCk7XG4gIH1cblxuICBpZiAocHJvcHMuYXJyb3cpIHtcbiAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1hcnJvdycsICcnKTtcbiAgICB0b29sdGlwLmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChwcm9wcy5hcnJvdykpO1xuICB9XG5cbiAgaWYgKHByb3BzLmluZXJ0aWEpIHtcbiAgICBhZGRJbmVydGlhKHRvb2x0aXApO1xuICB9XG5cbiAgc2V0Q29udGVudChjb250ZW50LCBwcm9wcyk7XG4gIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIHBvcHBlci5hcHBlbmRDaGlsZCh0b29sdGlwKTtcbiAgdXBkYXRlUG9wcGVyRWxlbWVudChwb3BwZXIsIHByb3BzLCBwcm9wcyk7XG4gIHJldHVybiBwb3BwZXI7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvcHBlciBlbGVtZW50IGJhc2VkIG9uIHRoZSBuZXcgcHJvcHNcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVQb3BwZXJFbGVtZW50KHBvcHBlciwgcHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIF9nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuKHBvcHBlciksXG4gICAgICB0b29sdGlwID0gX2dldENoaWxkcmVuLnRvb2x0aXAsXG4gICAgICBjb250ZW50ID0gX2dldENoaWxkcmVuLmNvbnRlbnQsXG4gICAgICBhcnJvdyA9IF9nZXRDaGlsZHJlbi5hcnJvdztcblxuICBwb3BwZXIuc3R5bGUuekluZGV4ID0gJycgKyBuZXh0UHJvcHMuekluZGV4O1xuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBuZXh0UHJvcHMuYW5pbWF0aW9uKTtcbiAgdG9vbHRpcC5zdHlsZS5tYXhXaWR0aCA9IGFwcGVuZFB4SWZOdW1iZXIobmV4dFByb3BzLm1heFdpZHRoKTtcblxuICBpZiAobmV4dFByb3BzLnJvbGUpIHtcbiAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgncm9sZScsIG5leHRQcm9wcy5yb2xlKTtcbiAgfSBlbHNlIHtcbiAgICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICB9XG5cbiAgaWYgKHByZXZQcm9wcy5jb250ZW50ICE9PSBuZXh0UHJvcHMuY29udGVudCkge1xuICAgIHNldENvbnRlbnQoY29udGVudCwgbmV4dFByb3BzKTtcbiAgfSAvLyBhcnJvd1xuXG5cbiAgaWYgKCFwcmV2UHJvcHMuYXJyb3cgJiYgbmV4dFByb3BzLmFycm93KSB7XG4gICAgLy8gZmFsc2UgdG8gdHJ1ZVxuICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KG5leHRQcm9wcy5hcnJvdykpO1xuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFycm93JywgJycpO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcy5hcnJvdyAmJiAhbmV4dFByb3BzLmFycm93KSB7XG4gICAgLy8gdHJ1ZSB0byBmYWxzZVxuICAgIHRvb2x0aXAucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFycm93Jyk7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzLmFycm93ICE9PSBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAvLyB0cnVlIHRvICdyb3VuZCcgb3IgdmljZS12ZXJzYVxuICAgIHRvb2x0aXAucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KG5leHRQcm9wcy5hcnJvdykpO1xuICB9IC8vIGludGVyYWN0aXZlXG5cblxuICBpZiAoIXByZXZQcm9wcy5pbnRlcmFjdGl2ZSAmJiBuZXh0UHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICBhZGRJbnRlcmFjdGl2ZSh0b29sdGlwKTtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMuaW50ZXJhY3RpdmUgJiYgIW5leHRQcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgIHJlbW92ZUludGVyYWN0aXZlKHRvb2x0aXApO1xuICB9IC8vIGluZXJ0aWFcblxuXG4gIGlmICghcHJldlByb3BzLmluZXJ0aWEgJiYgbmV4dFByb3BzLmluZXJ0aWEpIHtcbiAgICBhZGRJbmVydGlhKHRvb2x0aXApO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcy5pbmVydGlhICYmICFuZXh0UHJvcHMuaW5lcnRpYSkge1xuICAgIHJlbW92ZUluZXJ0aWEodG9vbHRpcCk7XG4gIH0gLy8gdGhlbWVcblxuXG4gIGlmIChwcmV2UHJvcHMudGhlbWUgIT09IG5leHRQcm9wcy50aGVtZSkge1xuICAgIHVwZGF0ZVRoZW1lKHRvb2x0aXAsICdyZW1vdmUnLCBwcmV2UHJvcHMudGhlbWUpO1xuICAgIHVwZGF0ZVRoZW1lKHRvb2x0aXAsICdhZGQnLCBuZXh0UHJvcHMudGhlbWUpO1xuICB9XG59XG4vKipcbiAqIEFkZC9yZW1vdmUgdHJhbnNpdGlvbmVuZCBsaXN0ZW5lciBmcm9tIHRvb2x0aXBcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIodG9vbHRpcCwgYWN0aW9uLCBsaXN0ZW5lcikge1xuICB2YXIgZXZlbnROYW1lID0gaXNVQ0Jyb3dzZXIgJiYgZG9jdW1lbnQuYm9keS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gIHRvb2x0aXBbYWN0aW9uICsgJ0V2ZW50TGlzdGVuZXInXShldmVudE5hbWUsIGxpc3RlbmVyKTtcbn1cbi8qKlxuICogQWRkcy9yZW1vdmVzIHRoZW1lIGZyb20gdG9vbHRpcCdzIGNsYXNzTGlzdFxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZVRoZW1lKHRvb2x0aXAsIGFjdGlvbiwgdGhlbWUpIHtcbiAgc3BsaXRCeVNwYWNlcyh0aGVtZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHRvb2x0aXAuY2xhc3NMaXN0W2FjdGlvbl0obmFtZSArIFwiLXRoZW1lXCIpO1xuICB9KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgbW91c2UgY3Vyc29yIGlzIG91dHNpZGUgb2YgdGhlIHBvcHBlcidzIGludGVyYWN0aXZlIGJvcmRlclxuICogcmVnaW9uXG4gKi9cblxuZnVuY3Rpb24gaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSB7XG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICByZXR1cm4gcG9wcGVyVHJlZURhdGEuZXZlcnkoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IF9yZWYucG9wcGVyUmVjdCxcbiAgICAgICAgdG9vbHRpcFJlY3QgPSBfcmVmLnRvb2x0aXBSZWN0LFxuICAgICAgICBpbnRlcmFjdGl2ZUJvcmRlciA9IF9yZWYuaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgLy8gR2V0IG1pbi9tYXggYm91bmRzIG9mIGJvdGggdGhlIHBvcHBlciBhbmQgdG9vbHRpcCByZWN0cyBkdWUgdG9cbiAgICAvLyBgZGlzdGFuY2VgIG9mZnNldFxuICAgIHZhciBtZXJnZWRSZWN0ID0ge1xuICAgICAgdG9wOiBNYXRoLm1pbihwb3BwZXJSZWN0LnRvcCwgdG9vbHRpcFJlY3QudG9wKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChwb3BwZXJSZWN0LnJpZ2h0LCB0b29sdGlwUmVjdC5yaWdodCksXG4gICAgICBib3R0b206IE1hdGgubWF4KHBvcHBlclJlY3QuYm90dG9tLCB0b29sdGlwUmVjdC5ib3R0b20pLFxuICAgICAgbGVmdDogTWF0aC5taW4ocG9wcGVyUmVjdC5sZWZ0LCB0b29sdGlwUmVjdC5sZWZ0KVxuICAgIH07XG4gICAgdmFyIGV4Y2VlZHNUb3AgPSBtZXJnZWRSZWN0LnRvcCAtIGNsaWVudFkgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc0JvdHRvbSA9IGNsaWVudFkgLSBtZXJnZWRSZWN0LmJvdHRvbSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzTGVmdCA9IG1lcmdlZFJlY3QubGVmdCAtIGNsaWVudFggPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc1JpZ2h0ID0gY2xpZW50WCAtIG1lcmdlZFJlY3QucmlnaHQgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICByZXR1cm4gZXhjZWVkc1RvcCB8fCBleGNlZWRzQm90dG9tIHx8IGV4Y2VlZHNMZWZ0IHx8IGV4Y2VlZHNSaWdodDtcbiAgfSk7XG59XG5cbnZhciBpZENvdW50ZXIgPSAxO1xudmFyIG1vdXNlTW92ZUxpc3RlbmVycyA9IFtdO1xuLyoqXG4gKiBVc2VkIGJ5IGBoaWRlQWxsKClgXG4gKi9cblxudmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBbXTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFRpcHB5IG9iamVjdC4gV2UncmUgdXNpbmcgYSBjbG9zdXJlIHBhdHRlcm4gaW5zdGVhZCBvZlxuICogYSBjbGFzcyBzbyB0aGF0IHRoZSBleHBvc2VkIG9iamVjdCBBUEkgaXMgY2xlYW4gd2l0aG91dCBwcml2YXRlIG1lbWJlcnNcbiAqIHByZWZpeGVkIHdpdGggYF9gLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpIHtcbiAgdmFyIHByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHt9LCBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHBhc3NlZFByb3BzKSkpOyAvLyBJZiB0aGUgcmVmZXJlbmNlIHNob3VsZG4ndCBoYXZlIG11bHRpcGxlIHRpcHB5cywgcmV0dXJuIG51bGwgZWFybHlcblxuICBpZiAoIXByb3BzLm11bHRpcGxlICYmIHJlZmVyZW5jZS5fdGlwcHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PSDwn5SSIFByaXZhdGUgbWVtYmVycyDwn5SSID09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICB2YXIgc2hvd1RpbWVvdXQ7XG4gIHZhciBoaWRlVGltZW91dDtcbiAgdmFyIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lO1xuICB2YXIgaXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2YXIgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gIHZhciBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICB2YXIgcG9wcGVyVXBkYXRlcyA9IDA7XG4gIHZhciBsYXN0VHJpZ2dlckV2ZW50O1xuICB2YXIgY3VycmVudE1vdW50Q2FsbGJhY2s7XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBwcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7IC8vIFN1cHBvcnQgaWZyYW1lIGNvbnRleHRzXG4gIC8vIFN0YXRpYyBjaGVjayB0aGF0IGFzc3VtZXMgYW55IG9mIHRoZSBgdHJpZ2dlclRhcmdldGAgb3IgYHJlZmVyZW5jZWBcbiAgLy8gbm9kZXMgd2lsbCBuZXZlciBjaGFuZ2UgZG9jdW1lbnRzLCBldmVuIHdoZW4gdGhleSBhcmUgdXBkYXRlZFxuXG4gIHZhciBkb2MgPSBnZXRPd25lckRvY3VtZW50KHByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgLyogPT09PT09PT09PT09PT09PT09PT09PT0g8J+UkSBQdWJsaWMgbWVtYmVycyDwn5SRID09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgdmFyIGlkID0gaWRDb3VudGVyKys7XG4gIHZhciBwb3BwZXIgPSBjcmVhdGVQb3BwZXJFbGVtZW50KGlkLCBwcm9wcyk7XG4gIHZhciBwb3BwZXJDaGlsZHJlbiA9IGdldENoaWxkcmVuKHBvcHBlcik7XG4gIHZhciBwb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBwbHVnaW5zID0gdW5pcXVlKHByb3BzLnBsdWdpbnMpOyAvLyBUaGVzZSB0d28gZWxlbWVudHMgYXJlIHN0YXRpY1xuXG4gIHZhciB0b29sdGlwID0gcG9wcGVyQ2hpbGRyZW4udG9vbHRpcCxcbiAgICAgIGNvbnRlbnQgPSBwb3BwZXJDaGlsZHJlbi5jb250ZW50O1xuICB2YXIgdHJhbnNpdGlvbmFibGVFbGVtZW50cyA9IFt0b29sdGlwLCBjb250ZW50XTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIFRoZSBjdXJyZW50IHJlYWwgcGxhY2VtZW50IChgZGF0YS1wbGFjZW1lbnRgIGF0dHJpYnV0ZSlcbiAgICBjdXJyZW50UGxhY2VtZW50OiBudWxsLFxuICAgIC8vIElzIHRoZSBpbnN0YW5jZSBjdXJyZW50bHkgZW5hYmxlZD9cbiAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBzaG93aW5nIGFuZCBub3QgdHJhbnNpdGlvbmluZyBvdXQ/XG4gICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIGluc3RhbmNlIGJlZW4gZGVzdHJveWVkP1xuICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IG1vdW50ZWQgdG8gdGhlIERPTT9cbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgdGlwcHkgZmluaXNoZWQgdHJhbnNpdGlvbmluZyBpbj9cbiAgICBpc1Nob3duOiBmYWxzZVxuICB9O1xuICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgLy8gcHJvcGVydGllc1xuICAgIGlkOiBpZCxcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICBwb3BwZXI6IHBvcHBlcixcbiAgICBwb3BwZXJDaGlsZHJlbjogcG9wcGVyQ2hpbGRyZW4sXG4gICAgcG9wcGVySW5zdGFuY2U6IHBvcHBlckluc3RhbmNlLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAvLyBtZXRob2RzXG4gICAgY2xlYXJEZWxheVRpbWVvdXRzOiBjbGVhckRlbGF5VGltZW91dHMsXG4gICAgc2V0UHJvcHM6IHNldFByb3BzLFxuICAgIHNldENvbnRlbnQ6IHNldENvbnRlbnQsXG4gICAgc2hvdzogc2hvdyxcbiAgICBoaWRlOiBoaWRlLFxuICAgIGVuYWJsZTogZW5hYmxlLFxuICAgIGRpc2FibGU6IGRpc2FibGUsXG4gICAgZGVzdHJveTogZGVzdHJveVxuICB9O1xuICAvKiA9PT09PT09PT09PT09PT09PT09PSBJbml0aWFsIGluc3RhbmNlIG11dGF0aW9ucyA9PT09PT09PT09PT09PT09PT09ICovXG5cbiAgcmVmZXJlbmNlLl90aXBweSA9IGluc3RhbmNlO1xuICBwb3BwZXIuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHZhciBwbHVnaW5zSG9va3MgPSBwbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgcmV0dXJuIHBsdWdpbi5mbihpbnN0YW5jZSk7XG4gIH0pO1xuICBhZGRMaXN0ZW5lcnNUb1RyaWdnZXJUYXJnZXQoKTtcbiAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgaWYgKCFwcm9wcy5sYXp5KSB7XG4gICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgfVxuXG4gIGludm9rZUhvb2soJ29uQ3JlYXRlJywgW2luc3RhbmNlXSk7XG5cbiAgaWYgKHByb3BzLnNob3dPbkNyZWF0ZSkge1xuICAgIHNjaGVkdWxlU2hvdygpO1xuICB9IC8vIFByZXZlbnQgYSB0aXBweSB3aXRoIGEgZGVsYXkgZnJvbSBoaWRpbmcgaWYgdGhlIGN1cnNvciBsZWZ0IHRoZW4gcmV0dXJuZWRcbiAgLy8gYmVmb3JlIGl0IHN0YXJ0ZWQgaGlkaW5nXG5cblxuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICB9XG4gIH0pO1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5jbHVkZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlciwgJ21vdXNlZW50ZXInKSkge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09IPCflJIgUHJpdmF0ZSBtZXRob2RzIPCflJIgPT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICBmdW5jdGlvbiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpIHtcbiAgICB2YXIgdG91Y2ggPSBpbnN0YW5jZS5wcm9wcy50b3VjaDtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0b3VjaCkgPyB0b3VjaCA6IFt0b3VjaCwgMF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSB7XG4gICAgcmV0dXJuIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKClbMF0gPT09ICdob2xkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQgfHwgcmVmZXJlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVsYXkoaXNTaG93KSB7XG4gICAgLy8gRm9yIHRvdWNoIG9yIGtleWJvYXJkIGlucHV0LCBmb3JjZSBgMGAgZGVsYXkgZm9yIFVYIHJlYXNvbnNcbiAgICAvLyBBbHNvIGlmIHRoZSBpbnN0YW5jZSBpcyBtb3VudGVkIGJ1dCBub3QgdmlzaWJsZSAodHJhbnNpdGlvbmluZyBvdXQpLFxuICAgIC8vIGlnbm9yZSBkZWxheVxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fCBsYXN0VHJpZ2dlckV2ZW50ICYmIGxhc3RUcmlnZ2VyRXZlbnQudHlwZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmRlbGF5LCBpc1Nob3cgPyAwIDogMSwgZGVmYXVsdFByb3BzLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUhvb2soaG9vaywgYXJncywgc2hvdWxkSW52b2tlUHJvcHNIb29rKSB7XG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vayA9PT0gdm9pZCAwKSB7XG4gICAgICBzaG91bGRJbnZva2VQcm9wc0hvb2sgPSB0cnVlO1xuICAgIH1cblxuICAgIHBsdWdpbnNIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5Ib29rcykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KHBsdWdpbkhvb2tzLCBob29rKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBsdWdpbkhvb2tzW2hvb2tdLmFwcGx5KHBsdWdpbkhvb2tzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcHJvcHM7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIChfaW5zdGFuY2UkcHJvcHMgPSBpbnN0YW5jZS5wcm9wcylbaG9va10uYXBwbHkoX2luc3RhbmNlJHByb3BzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhRGVzY3JpYmVkQnlBdHRyaWJ1dGUoKSB7XG4gICAgdmFyIGFyaWEgPSBpbnN0YW5jZS5wcm9wcy5hcmlhO1xuXG4gICAgaWYgKCFhcmlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0dHIgPSBcImFyaWEtXCIgKyBhcmlhO1xuICAgIHZhciBpZCA9IHRvb2x0aXAuaWQ7XG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpO1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIGN1cnJlbnRWYWx1ZSA/IGN1cnJlbnRWYWx1ZSArIFwiIFwiICsgaWQgOiBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5yZXBsYWNlKGlkLCAnJykudHJpbSgpO1xuXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBuZXh0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKSB7XG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIG5vZGUgPT09IGdldEN1cnJlbnRUYXJnZXQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCkge1xuICAgIGRvYy5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzY2hlZHVsZUhpZGUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgbW91c2VNb3ZlTGlzdGVuZXJzID0gbW91c2VNb3ZlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lciAhPT0gZGVib3VuY2VkT25Nb3VzZU1vdmU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50TW91c2VEb3duKGV2ZW50KSB7XG4gICAgLy8gQ2xpY2tlZCBvbiBpbnRlcmFjdGl2ZSBwb3BwZXJcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENsaWNrZWQgb24gdGhlIGV2ZW50IGxpc3RlbmVycyB0YXJnZXRcblxuXG4gICAgaWYgKGdldEN1cnJlbnRUYXJnZXQoKS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGluY2x1ZGVzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIsICdjbGljaycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgPT09IHRydWUpIHtcbiAgICAgIGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7IC8vIGBtb3VzZWRvd25gIGV2ZW50IGlzIGZpcmVkIHJpZ2h0IGJlZm9yZSBgZm9jdXNgIGlmIHByZXNzaW5nIHRoZVxuICAgICAgLy8gY3VycmVudFRhcmdldC4gVGhpcyBsZXRzIGEgdGlwcHkgd2l0aCBgZm9jdXNgIHRyaWdnZXIga25vdyB0aGF0IGl0XG4gICAgICAvLyBzaG91bGQgbm90IHNob3dcblxuICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gZmFsc2U7XG4gICAgICB9KTsgLy8gVGhlIGxpc3RlbmVyIGdldHMgYWRkZWQgaW4gYHNjaGVkdWxlU2hvdygpYCwgYnV0IHRoaXMgbWF5IGJlIGhpZGluZyBpdFxuICAgICAgLy8gYmVmb3JlIGl0IHNob3dzLCBhbmQgaGlkZSgpJ3MgZWFybHkgYmFpbC1vdXQgYmVoYXZpb3IgY2FuIHByZXZlbnQgaXRcbiAgICAgIC8vIGZyb20gYmVpbmcgY2xlYW5lZCB1cFxuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZW1vdmVEb2N1bWVudE1vdXNlRG93bkxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpIHtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudE1vdXNlRG93biwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEb2N1bWVudE1vdXNlRG93bkxpc3RlbmVyKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50TW91c2VEb3duLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkT3V0KGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgcG9wcGVyLnBhcmVudE5vZGUgJiYgcG9wcGVyLnBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdG9vbHRpcCkge1xuICAgICAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIodG9vbHRpcCwgJ3JlbW92ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgY2FsbGJhY2sgc3luY2hyb25vdXMgaWYgZHVyYXRpb24gaXMgMFxuICAgIC8vIGB0cmFuc2l0aW9uZW5kYCB3b24ndCBmaXJlIG90aGVyd2lzZVxuXG5cbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcih0b29sdGlwLCAncmVtb3ZlJywgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcik7XG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKHRvb2x0aXAsICdhZGQnLCBsaXN0ZW5lcik7XG4gICAgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gb24oZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnNUb1RyaWdnZXJUYXJnZXQoKSB7XG4gICAgaWYgKGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpKSB7XG4gICAgICBvbigndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwgUEFTU0lWRSk7XG4gICAgICBvbigndG91Y2hlbmQnLCBvbk1vdXNlTGVhdmUsIFBBU1NJVkUpO1xuICAgIH1cblxuICAgIHNwbGl0QnlTcGFjZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlcikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAnbWFudWFsJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9uKGV2ZW50VHlwZSwgb25UcmlnZ2VyKTtcblxuICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgICAgb24oJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICBvbihpc0lFID8gJ2ZvY3Vzb3V0JyA6ICdibHVyJywgb25CbHVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyc0Zyb21UcmlnZ2VyVGFyZ2V0KCkge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgICBldmVudFR5cGUgPSBfcmVmLmV2ZW50VHlwZSxcbiAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyLFxuICAgICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudCkge1xuICAgIHZhciBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgfHwgaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkgfHwgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXN0VHJpZ2dlckV2ZW50ID0gZXZlbnQ7XG4gICAgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAvLyBJZiBzY3JvbGxpbmcsIGBtb3VzZWVudGVyYCBldmVudHMgY2FuIGJlIGZpcmVkIGlmIHRoZSBjdXJzb3IgbGFuZHNcbiAgICAgIC8vIG92ZXIgYSBuZXcgdGFyZ2V0LCBidXQgYG1vdXNlbW92ZWAgZXZlbnRzIGRvbid0IGdldCBmaXJlZC4gVGhpc1xuICAgICAgLy8gY2F1c2VzIGludGVyYWN0aXZlIHRvb2x0aXBzIHRvIGdldCBzdHVjayBvcGVuIHVudGlsIHRoZSBjdXJzb3IgaXNcbiAgICAgIC8vIG1vdmVkXG4gICAgICBtb3VzZU1vdmVMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gVG9nZ2xlIHNob3cvaGlkZSB3aGVuIGNsaWNraW5nIGNsaWNrLXRyaWdnZXJlZCB0b29sdGlwc1xuXG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiAoIWluY2x1ZGVzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIsICdtb3VzZWVudGVyJykgfHwgaXNWaXNpYmxlRnJvbUNsaWNrKSAmJiBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZ2V0Tm9ybWFsaXplZFRvdWNoU2UgPSBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpLFxuICAgICAgICAgIHZhbHVlID0gX2dldE5vcm1hbGl6ZWRUb3VjaFNlWzBdLFxuICAgICAgICAgIGR1cmF0aW9uID0gX2dldE5vcm1hbGl6ZWRUb3VjaFNlWzFdO1xuXG4gICAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2ggJiYgdmFsdWUgPT09ICdob2xkJyAmJiBkdXJhdGlvbikge1xuICAgICAgICAvLyBXZSBjYW4gaGlqYWNrIHRoZSBzaG93IHRpbWVvdXQgaGVyZSwgaXQgd2lsbCBiZSBjbGVhcmVkIGJ5XG4gICAgICAgIC8vIGBzY2hlZHVsZUhpZGUoKWAgd2hlbiBuZWNlc3NhcnlcbiAgICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY2hlZHVsZVNob3coZXZlbnQpO1xuICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZVNob3coZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSAhc2hvdWxkU2NoZWR1bGVDbGlja0hpZGU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlKSB7XG4gICAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyID0gY2xvc2VzdENhbGxiYWNrKGV2ZW50LnRhcmdldCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwgPT09IHJlZmVyZW5jZSB8fCBlbCA9PT0gcG9wcGVyO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcHBlclRyZWVEYXRhID0gYXJyYXlGcm9tKHBvcHBlci5xdWVyeVNlbGVjdG9yQWxsKFBPUFBFUl9TRUxFQ1RPUikpLmNvbmNhdChwb3BwZXIpLm1hcChmdW5jdGlvbiAocG9wcGVyKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBwb3BwZXIuX3RpcHB5O1xuICAgICAgdmFyIHRvb2x0aXAgPSBpbnN0YW5jZS5wb3BwZXJDaGlsZHJlbi50b29sdGlwO1xuICAgICAgdmFyIGludGVyYWN0aXZlQm9yZGVyID0gaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3BwZXJSZWN0OiBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHRvb2x0aXBSZWN0OiB0b29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBpbnRlcmFjdGl2ZUJvcmRlcjogaW50ZXJhY3RpdmVCb3JkZXJcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBpZiAoaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgaWYgKGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIsICdjbGljaycpICYmIGlzVmlzaWJsZUZyb21DbGljaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHNjaGVkdWxlSGlkZSk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgICAgcHVzaElmVW5pcXVlKG1vdXNlTW92ZUxpc3RlbmVycywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkJsdXIoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIGZvY3VzIHdhcyBtb3ZlZCB0byB3aXRoaW4gdGhlIHBvcHBlclxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgZXZlbnQucmVsYXRlZFRhcmdldCAmJiBwb3BwZXIuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkge1xuICAgIHZhciBzdXBwb3J0c1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIHZhciBpc1RvdWNoRXZlbnQgPSBpbmNsdWRlcyhldmVudC50eXBlLCAndG91Y2gnKTtcbiAgICB2YXIgaXNDdXN0b21Ub3VjaCA9IGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpO1xuICAgIHJldHVybiBzdXBwb3J0c1RvdWNoICYmIGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmIGlzQ3VzdG9tVG91Y2ggJiYgIWlzVG91Y2hFdmVudCB8fCBjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiAhaXNDdXN0b21Ub3VjaCAmJiBpc1RvdWNoRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpIHtcbiAgICB2YXIgcG9wcGVyT3B0aW9ucyA9IGluc3RhbmNlLnByb3BzLnBvcHBlck9wdGlvbnM7XG4gICAgdmFyIGFycm93ID0gaW5zdGFuY2UucG9wcGVyQ2hpbGRyZW4uYXJyb3c7XG4gICAgdmFyIGZsaXBNb2RpZmllciA9IGdldE1vZGlmaWVyKHBvcHBlck9wdGlvbnMsICdmbGlwJyk7XG4gICAgdmFyIHByZXZlbnRPdmVyZmxvd01vZGlmaWVyID0gZ2V0TW9kaWZpZXIocG9wcGVyT3B0aW9ucywgJ3ByZXZlbnRPdmVyZmxvdycpO1xuICAgIHZhciBkaXN0YW5jZVB4O1xuXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoZGF0YSkge1xuICAgICAgdmFyIHByZXZQbGFjZW1lbnQgPSBpbnN0YW5jZS5zdGF0ZS5jdXJyZW50UGxhY2VtZW50O1xuICAgICAgaW5zdGFuY2Uuc3RhdGUuY3VycmVudFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZmxpcCAmJiAhaW5zdGFuY2UucHJvcHMuZmxpcE9uVXBkYXRlKSB7XG4gICAgICAgIGlmIChkYXRhLmZsaXBwZWQpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLnBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0TW9kaWZpZXJWYWx1ZShpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5tb2RpZmllcnMsICdmbGlwJywgJ2VuYWJsZWQnLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcsIGRhdGEucGxhY2VtZW50KTtcblxuICAgICAgaWYgKGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddICE9PSBmYWxzZSkge1xuICAgICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1vdXQtb2YtYm91bmRhcmllcycsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW91dC1vZi1ib3VuZGFyaWVzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChkYXRhLnBsYWNlbWVudCk7XG4gICAgICB2YXIgaXNWZXJ0aWNhbFBsYWNlbWVudCA9IGluY2x1ZGVzKFsndG9wJywgJ2JvdHRvbSddLCBiYXNlUGxhY2VtZW50KTtcbiAgICAgIHZhciBpc1NlY29uZGFyeVBsYWNlbWVudCA9IGluY2x1ZGVzKFsnYm90dG9tJywgJ3JpZ2h0J10sIGJhc2VQbGFjZW1lbnQpOyAvLyBBcHBseSBgZGlzdGFuY2VgIHByb3BcblxuICAgICAgdG9vbHRpcC5zdHlsZS50b3AgPSAnMCc7XG4gICAgICB0b29sdGlwLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICB0b29sdGlwLnN0eWxlW2lzVmVydGljYWxQbGFjZW1lbnQgPyAndG9wJyA6ICdsZWZ0J10gPSAoaXNTZWNvbmRhcnlQbGFjZW1lbnQgPyAxIDogLTEpICogZGlzdGFuY2VQeCArICdweCc7IC8vIENhcmVmdWwgbm90IHRvIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgaGVyZVxuICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzc4NFxuXG4gICAgICBpZiAocHJldlBsYWNlbWVudCAmJiBwcmV2UGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gX2V4dGVuZHMoe1xuICAgICAgZXZlbnRzRW5hYmxlZDogZmFsc2UsXG4gICAgICBwbGFjZW1lbnQ6IGluc3RhbmNlLnByb3BzLnBsYWNlbWVudFxuICAgIH0sIHBvcHBlck9wdGlvbnMsIHtcbiAgICAgIG1vZGlmaWVyczogX2V4dGVuZHMoe30sIHBvcHBlck9wdGlvbnMgJiYgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMsIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIGBwYWRkaW5nYCBvbiB0aGUgcG9wcGVyIGVsIGJlY2F1c2Ugb2YgdGhlc2UgYnVncyB3aGVuXG4gICAgICAgIC8vIGZsaXBwaW5nIGZyb20gYSB2ZXJ0aWNhbCB0byBob3Jpem9udGFsIHBsYWNlbWVudCBvciB2aWNlLXZlcnNhLFxuICAgICAgICAvLyB0aGVyZSBpcyBzZXZlcmUgZmxpY2tlcmluZy5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzcyMFxuICAgICAgICAvLyBUaGlzIHdvcmthcm91bmQgaW5jcmVhc2VzIGJ1bmRsZSBzaXplIGJ5IDI1MEIgbWluemlwIHVuZm9ydHVuYXRlbHksXG4gICAgICAgIC8vIGR1ZSB0byBuZWVkIHRvIGN1c3RvbSBjb21wdXRlIHRoZSBkaXN0YW5jZSAoc2luY2UgUG9wcGVyIHJlY3QgZG9lc1xuICAgICAgICAvLyBub3QgZ2V0IGFmZmVjdGVkIGJ5IHRoZSBpbm5lciB0b29sdGlwJ3MgZGlzdGFuY2Ugb2Zmc2V0KVxuICAgICAgICB0aXBweURpc3RhbmNlOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBvcmRlcjogMCxcbiAgICAgICAgICBmbjogZnVuY3Rpb24gZm4oZGF0YSkge1xuICAgICAgICAgICAgLy8gYGh0bWxgIGZvbnRTaXplIG1heSBjaGFuZ2Ugd2hpbGUgYHBvcHBlckluc3RhbmNlYCBpcyBhbGl2ZVxuICAgICAgICAgICAgLy8gZS5nLiBvbiByZXNpemUgaW4gbWVkaWEgcXVlcmllc1xuICAgICAgICAgICAgZGlzdGFuY2VQeCA9IGdldFVuaXRzSW5QeChkb2MsIGluc3RhbmNlLnByb3BzLmRpc3RhbmNlKTtcbiAgICAgICAgICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChkYXRhLnBsYWNlbWVudCk7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRQcmV2ZW50T3ZlcmZsb3dQYWRkaW5nID0gZ2V0Q29tcHV0ZWRQYWRkaW5nKGJhc2VQbGFjZW1lbnQsIHByZXZlbnRPdmVyZmxvd01vZGlmaWVyICYmIHByZXZlbnRPdmVyZmxvd01vZGlmaWVyLnBhZGRpbmcsIGRpc3RhbmNlUHgpO1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkRmxpcFBhZGRpbmcgPSBnZXRDb21wdXRlZFBhZGRpbmcoYmFzZVBsYWNlbWVudCwgZmxpcE1vZGlmaWVyICYmIGZsaXBNb2RpZmllci5wYWRkaW5nLCBkaXN0YW5jZVB4KTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZU1vZGlmaWVycyA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLm1vZGlmaWVycztcbiAgICAgICAgICAgIHNldE1vZGlmaWVyVmFsdWUoaW5zdGFuY2VNb2RpZmllcnMsICdwcmV2ZW50T3ZlcmZsb3cnLCAncGFkZGluZycsIGNvbXB1dGVkUHJldmVudE92ZXJmbG93UGFkZGluZyk7XG4gICAgICAgICAgICBzZXRNb2RpZmllclZhbHVlKGluc3RhbmNlTW9kaWZpZXJzLCAnZmxpcCcsICdwYWRkaW5nJywgY29tcHV0ZWRGbGlwUGFkZGluZyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzogX2V4dGVuZHMoe1xuICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiBpbnN0YW5jZS5wcm9wcy5ib3VuZGFyeVxuICAgICAgICB9LCBwcmV2ZW50T3ZlcmZsb3dNb2RpZmllciksXG4gICAgICAgIGZsaXA6IF9leHRlbmRzKHtcbiAgICAgICAgICBlbmFibGVkOiBpbnN0YW5jZS5wcm9wcy5mbGlwLFxuICAgICAgICAgIGJlaGF2aW9yOiBpbnN0YW5jZS5wcm9wcy5mbGlwQmVoYXZpb3JcbiAgICAgICAgfSwgZmxpcE1vZGlmaWVyKSxcbiAgICAgICAgYXJyb3c6IF9leHRlbmRzKHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBlbmFibGVkOiAhIWFycm93XG4gICAgICAgIH0sIGdldE1vZGlmaWVyKHBvcHBlck9wdGlvbnMsICdhcnJvdycpKSxcbiAgICAgICAgb2Zmc2V0OiBfZXh0ZW5kcyh7XG4gICAgICAgICAgb2Zmc2V0OiBpbnN0YW5jZS5wcm9wcy5vZmZzZXRcbiAgICAgICAgfSwgZ2V0TW9kaWZpZXIocG9wcGVyT3B0aW9ucywgJ29mZnNldCcpKVxuICAgICAgfSksXG4gICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoZGF0YSkge1xuICAgICAgICBhcHBseU11dGF0aW9ucyhkYXRhKTtcbiAgICAgICAgcHJlc2VydmVJbnZvY2F0aW9uKHBvcHBlck9wdGlvbnMgJiYgcG9wcGVyT3B0aW9ucy5vbkNyZWF0ZSwgY29uZmlnLm9uQ3JlYXRlLCBbZGF0YV0pO1xuICAgICAgICBydW5Nb3VudENhbGxiYWNrKCk7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYXBwbHlNdXRhdGlvbnMoZGF0YSk7XG4gICAgICAgIHByZXNlcnZlSW52b2NhdGlvbihwb3BwZXJPcHRpb25zICYmIHBvcHBlck9wdGlvbnMub25VcGRhdGUsIGNvbmZpZy5vblVwZGF0ZSwgW2RhdGFdKTtcbiAgICAgICAgcnVuTW91bnRDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBuZXcgUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBjb25maWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuTW91bnRDYWxsYmFjaygpIHtcbiAgICAvLyBPbmx5IGludm9rZSBjdXJyZW50TW91bnRDYWxsYmFjayBhZnRlciAyIHVwZGF0ZXNcbiAgICAvLyBUaGlzIGZpeGVzIHNvbWUgYnVncyBpbiBQb3BwZXIuanMgKFRPRE86IGFpbSBmb3Igb25seSAxIHVwZGF0ZSlcbiAgICBpZiAocG9wcGVyVXBkYXRlcyA9PT0gMCkge1xuICAgICAgcG9wcGVyVXBkYXRlcysrOyAvLyAxXG5cbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudE1vdW50Q2FsbGJhY2sgJiYgcG9wcGVyVXBkYXRlcyA9PT0gMSkge1xuICAgICAgcG9wcGVyVXBkYXRlcysrOyAvLyAyXG5cbiAgICAgIHJlZmxvdyhwb3BwZXIpO1xuICAgICAgY3VycmVudE1vdW50Q2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAvLyBUaGUgbW91bnRpbmcgY2FsbGJhY2sgKGBjdXJyZW50TW91bnRDYWxsYmFja2ApIGlzIG9ubHkgcnVuIGR1ZSB0byBhXG4gICAgLy8gcG9wcGVySW5zdGFuY2UgdXBkYXRlL2NyZWF0ZVxuICAgIHBvcHBlclVwZGF0ZXMgPSAwO1xuICAgIHZhciBhcHBlbmRUbyA9IGluc3RhbmNlLnByb3BzLmFwcGVuZFRvO1xuICAgIHZhciBwYXJlbnROb2RlOyAvLyBCeSBkZWZhdWx0LCB3ZSdsbCBhcHBlbmQgdGhlIHBvcHBlciB0byB0aGUgdHJpZ2dlclRhcmdldHMncyBwYXJlbnROb2RlIHNvXG4gICAgLy8gaXQncyBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgc28gdGhlIGVsZW1lbnRzIGluc2lkZSB0aGVcbiAgICAvLyB0aXBweSBjYW4gYmUgdGFiYmVkIHRvXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNsaXBwaW5nIGlzc3VlcywgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYXBwZW5kVG9cbiAgICAvLyBhbmQgZW5zdXJlIGZvY3VzIG1hbmFnZW1lbnQgaXMgaGFuZGxlZCBjb3JyZWN0bHkgbWFudWFsbHlcblxuICAgIHZhciBub2RlID0gZ2V0Q3VycmVudFRhcmdldCgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdwYXJlbnQnKSB7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlID0gaW52b2tlV2l0aEFyZ3NPclJldHVybihhcHBlbmRUbywgW25vZGVdKTtcbiAgICB9IC8vIFRoZSBwb3BwZXIgZWxlbWVudCBuZWVkcyB0byBleGlzdCBvbiB0aGUgRE9NIGJlZm9yZSBpdHMgcG9zaXRpb24gY2FuIGJlXG4gICAgLy8gdXBkYXRlZCBhcyBQb3BwZXIuanMgbmVlZHMgdG8gcmVhZCBpdHMgZGltZW5zaW9uc1xuXG5cbiAgICBpZiAoIXBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIEFjY2Vzc2liaWxpdHkgY2hlY2tcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IHBvcHBlciwgWydJbnRlcmFjdGl2ZSB0aXBweSBlbGVtZW50IG1heSBub3QgYmUgYWNjZXNzaWJsZSB2aWEga2V5Ym9hcmQgbmF2aWdhdGlvbicsICdiZWNhdXNlIGl0IGlzIG5vdCBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaW4gdGhlIERPTSBzb3VyY2UnLCAnb3JkZXIuJywgJ1xcblxcbicsICdVc2luZyBhIHdyYXBwZXIgPGRpdj4gb3IgPHNwYW4+IHRhZyBhcm91bmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50IHNvbHZlcycsICd0aGlzIGJ5IGNyZWF0aW5nIGEgbmV3IHBhcmVudE5vZGUgY29udGV4dC4nLCAnXFxuXFxuJywgJ1NwZWNpZnlpbmcgYGFwcGVuZFRvOiBkb2N1bWVudC5ib2R5YCBzaWxlbmNlcyB0aGlzIHdhcm5pbmcsIGJ1dCBpdCcsICdhc3N1bWVzIHlvdSBhcmUgdXNpbmcgYSBmb2N1cyBtYW5hZ2VtZW50IHNvbHV0aW9uIHRvIGhhbmRsZSBrZXlib2FyZCcsICduYXZpZ2F0aW9uLicsICdcXG5cXG4nLCAnU2VlOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvYWNjZXNzaWJpbGl0eS8jaW50ZXJhY3Rpdml0eSddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgc2V0TW9kaWZpZXJWYWx1ZShpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5tb2RpZmllcnMsICdmbGlwJywgJ2VuYWJsZWQnLCBpbnN0YW5jZS5wcm9wcy5mbGlwKTtcbiAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5lbmFibGVFdmVudExpc3RlbmVycygpOyAvLyBNb3VudGluZyBjYWxsYmFjayBpbnZva2VkIGluIGBvblVwZGF0ZWBcblxuICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVTaG93KGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgaW52b2tlSG9vaygnb25UcmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGFkZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIoKTtcbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheSh0cnVlKTtcblxuICAgIGlmIChkZWxheSkge1xuICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgaW52b2tlSG9vaygnb25VbnRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIHNjaGVkdWxlSGlkZSBpcyBhZGRlZCB0byBhIGRvY3VtZW50LmJvZHkgaGFuZGxlclxuICAgIC8vIGZyb20gb25Nb3VzZUxlYXZlIHNvIG11c3QgaW50ZXJjZXB0IHNjaGVkdWxlZCBoaWRlcyBmcm9tIG1vdXNlbW92ZS9sZWF2ZVxuICAgIC8vIGV2ZW50cyB3aGVuIHRyaWdnZXIgY29udGFpbnMgbW91c2VlbnRlciBhbmQgY2xpY2ssIGFuZCB0aGUgdGlwIGlzXG4gICAgLy8gY3VycmVudGx5IHNob3duIGFzIGEgcmVzdWx0IG9mIGEgY2xpY2suXG5cblxuICAgIGlmIChpbmNsdWRlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLCAnbW91c2VlbnRlcicpICYmIGluY2x1ZGVzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIsICdjbGljaycpICYmIGluY2x1ZGVzKFsnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnXSwgZXZlbnQudHlwZSkgJiYgaXNWaXNpYmxlRnJvbUNsaWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXkoZmFsc2UpO1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpeGVzIGEgYHRyYW5zaXRpb25lbmRgIHByb2JsZW0gd2hlbiBpdCBmaXJlcyAxIGZyYW1lIHRvb1xuICAgICAgLy8gbGF0ZSBzb21ldGltZXMsIHdlIGRvbid0IHdhbnQgaGlkZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09IPCflJEgUHVibGljIG1ldGhvZHMg8J+UkSA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIC8vIERpc2FibGluZyB0aGUgaW5zdGFuY2Ugc2hvdWxkIGFsc28gaGlkZSBpdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5LmpzLXJlYWN0L2lzc3Vlcy8xMDZcbiAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRlbGF5VGltZW91dHMoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNob3dUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQoaGlkZVRpbWVvdXQpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2V0UHJvcHMnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIHBsdWdpbnMpO1xuICAgICAgd2FybldoZW4ocGFydGlhbFByb3BzLnBsdWdpbnMgPyBwYXJ0aWFsUHJvcHMucGx1Z2lucy5sZW5ndGggIT09IHBsdWdpbnMubGVuZ3RoIHx8IHBsdWdpbnMuc29tZShmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICBpZiAocGFydGlhbFByb3BzLnBsdWdpbnMgJiYgcGFydGlhbFByb3BzLnBsdWdpbnNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gcCAhPT0gcGFydGlhbFByb3BzLnBsdWdpbnNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pIDogZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSBwbHVnaW5zXCIpO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQmVmb3JlVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgICByZW1vdmVMaXN0ZW5lcnNGcm9tVHJpZ2dlclRhcmdldCgpO1xuICAgIHZhciBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIF9leHRlbmRzKHt9LCBpbnN0YW5jZS5wcm9wcywge30sIHBhcnRpYWxQcm9wcywge1xuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pKTtcbiAgICBuZXh0UHJvcHMuaWdub3JlQXR0cmlidXRlcyA9IHVzZUlmRGVmaW5lZChwYXJ0aWFsUHJvcHMuaWdub3JlQXR0cmlidXRlcywgcHJldlByb3BzLmlnbm9yZUF0dHJpYnV0ZXMpO1xuICAgIGluc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuICAgIGFkZExpc3RlbmVyc1RvVHJpZ2dlclRhcmdldCgpO1xuXG4gICAgaWYgKHByZXZQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlICE9PSBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVQb3BwZXJFbGVtZW50KHBvcHBlciwgcHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKTsgLy8gRW5zdXJlIHN0YWxlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlcyBhcmUgcmVtb3ZlZFxuXG4gICAgaWYgKHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0ICYmICFuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgbm9ybWFsaXplVG9BcnJheShwcmV2UHJvcHMudHJpZ2dlclRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgcmVmZXJlbmNlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgIH1cblxuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpZiAoUE9QUEVSX0lOU1RBTkNFX0RFUEVOREVOQ0lFUy5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShwYXJ0aWFsUHJvcHMsIHByb3ApICYmIHBhcnRpYWxQcm9wc1twcm9wXSAhPT0gcHJldlByb3BzW3Byb3BdO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSZWZlcmVuY2UgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0gY3VycmVudFJlZmVyZW5jZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25BZnRlclVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDAsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzaG93JykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeVZpc2libGUgPSBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIHZhciBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCA9IGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmICFpbnN0YW5jZS5wcm9wcy50b3VjaDtcblxuICAgIGlmIChpc0FscmVhZHlWaXNpYmxlIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQgfHwgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE5vcm1hbGl6ZSBgZGlzYWJsZWRgIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAvLyBGaXJlZm94IGFsbG93cyBldmVudHMgb24gZGlzYWJsZWQgZWxlbWVudHMsIGJ1dCBDaHJvbWUgZG9lc24ndC5cbiAgICAvLyBVc2luZyBhIHdyYXBwZXIgZWxlbWVudCAoaS5lLiA8c3Bhbj4pIGlzIHJlY29tbWVuZGVkLlxuXG5cbiAgICBpZiAoZ2V0Q3VycmVudFRhcmdldCgpLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25TaG93JywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IHRydWU7IC8vIFByZXZlbnQgYSB0cmFuc2l0aW9uIG9mIHRoZSBwb3BwZXIgZnJvbSBpdHMgcHJldmlvdXMgcG9zaXRpb24gYW5kIG9mIHRoZVxuICAgIC8vIGVsZW1lbnRzIGF0IGEgZGlmZmVyZW50IHBsYWNlbWVudFxuICAgIC8vIENoZWNrIGlmIHRoZSB0aXBweSB3YXMgZnVsbHkgdW5tb3VudGVkIGJlZm9yZSBgc2hvdygpYCB3YXMgY2FsbGVkLCB0b1xuICAgIC8vIGFsbG93IGZvciBzbW9vdGggdHJhbnNpdGlvbiBmb3IgYGNyZWF0ZVNpbmdsZXRvbigpYFxuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLmNvbmNhdChwb3BwZXIpLCAwKTtcbiAgICB9XG5cbiAgICBjdXJyZW50TW91bnRDYWxsYmFjayA9IGZ1bmN0aW9uIGN1cnJlbnRNb3VudENhbGxiYWNrKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW3BvcHBlcl0sIGluc3RhbmNlLnByb3BzLnVwZGF0ZUR1cmF0aW9uKTtcbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLCBkdXJhdGlvbik7XG4gICAgICBzZXRWaXNpYmlsaXR5U3RhdGUodHJhbnNpdGlvbmFibGVFbGVtZW50cywgJ3Zpc2libGUnKTtcbiAgICAgIGhhbmRsZUFyaWFEZXNjcmliZWRCeUF0dHJpYnV0ZSgpO1xuICAgICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgICBwdXNoSWZVbmlxdWUobW91bnRlZEluc3RhbmNlcywgaW5zdGFuY2UpO1xuICAgICAgdXBkYXRlSU9TQ2xhc3ModHJ1ZSk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgaW52b2tlSG9vaygnb25Nb3VudCcsIFtpbnN0YW5jZV0pO1xuICAgICAgb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgaW52b2tlSG9vaygnb25TaG93bicsIFtpbnN0YW5jZV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIG1vdW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDEsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlJykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeUhpZGRlbiA9ICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgIWlzQmVpbmdEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkICYmICFpc0JlaW5nRGVzdHJveWVkO1xuXG4gICAgaWYgKGlzQWxyZWFkeUhpZGRlbiB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25IaWRlJywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uSGlkZShpbnN0YW5jZSkgPT09IGZhbHNlICYmICFpc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVtb3ZlRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IGZhbHNlO1xuICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLCBkdXJhdGlvbik7XG4gICAgc2V0VmlzaWJpbGl0eVN0YXRlKHRyYW5zaXRpb25hYmxlRWxlbWVudHMsICdoaWRkZW4nKTtcbiAgICBoYW5kbGVBcmlhRGVzY3JpYmVkQnlBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLnBsYWNlbWVudCA9IGluc3RhbmNlLnByb3BzLnBsYWNlbWVudDtcbiAgICAgIHBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHBlcik7XG4gICAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkgIT09IGluc3RhbmNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtb3VudGVkSW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB1cGRhdGVJT1NDbGFzcyhmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgaW52b2tlSG9vaygnb25IaWRkZW4nLCBbaW5zdGFuY2VdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdkZXN0cm95JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGluc3RhbmNlLmhpZGUoMCk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzRnJvbVRyaWdnZXJUYXJnZXQoKTtcbiAgICBkZWxldGUgcmVmZXJlbmNlLl90aXBweTtcblxuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgaW52b2tlSG9vaygnb25EZXN0cm95JywgW2luc3RhbmNlXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGlwcHkodGFyZ2V0cywgb3B0aW9uYWxQcm9wcyxcbi8qKiBAZGVwcmVjYXRlZCB1c2UgUHJvcHMucGx1Z2lucyAqL1xucGx1Z2lucykge1xuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIHBsdWdpbnMgPSBkZWZhdWx0UHJvcHMucGx1Z2lucy5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IHBsdWdpbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cyk7XG4gICAgdmFsaWRhdGVQcm9wcyhvcHRpb25hbFByb3BzLCBwbHVnaW5zKTtcbiAgfVxuXG4gIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpO1xuXG4gIHZhciBwYXNzZWRQcm9wcyA9IF9leHRlbmRzKHt9LCBvcHRpb25hbFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KTtcblxuICB2YXIgZWxlbWVudHMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ID0gaXNFbGVtZW50KHBhc3NlZFByb3BzLmNvbnRlbnQpO1xuICAgIHZhciBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oaXNTaW5nbGVDb250ZW50RWxlbWVudCAmJiBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYW4gRWxlbWVudCBhcyB0aGUgYGNvbnRlbnRgIHByb3AsIGJ1dCBtb3JlIHRoYW4gb25lIHRpcHB5JywgJ2luc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHRoaXMgaW52b2NhdGlvbi4gVGhpcyBtZWFucyB0aGUgY29udGVudCBlbGVtZW50IHdpbGwnLCAnb25seSBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCB0aXBweSBpbnN0YW5jZS4nLCAnXFxuXFxuJywgJ0luc3RlYWQsIHBhc3MgdGhlIC5pbm5lckhUTUwgb2YgdGhlIGVsZW1lbnQsIG9yIHVzZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhJywgJ2Nsb25lZCB2ZXJzaW9uIG9mIHRoZSBlbGVtZW50IGluc3RlYWQuJywgJ1xcblxcbicsICcxKSBjb250ZW50OiBlbGVtZW50LmlubmVySFRNTFxcbicsICcyKSBjb250ZW50OiAoKSA9PiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKSddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZmVyZW5jZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHJlZmVyZW5jZSAmJiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgYWNjLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXRzKSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbn1cblxudGlwcHkudmVyc2lvbiA9IHZlcnNpb247XG50aXBweS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG50aXBweS5zZXREZWZhdWx0UHJvcHMgPSBzZXREZWZhdWx0UHJvcHM7XG50aXBweS5jdXJyZW50SW5wdXQgPSBjdXJyZW50SW5wdXQ7XG4vKipcbiAqIEhpZGVzIGFsbCB2aXNpYmxlIHBvcHBlcnMgb24gdGhlIGRvY3VtZW50XG4gKi9cblxudmFyIGhpZGVBbGwgPSBmdW5jdGlvbiBoaWRlQWxsKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgPSBfcmVmLmV4Y2x1ZGUsXG4gICAgICBkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb247XG5cbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA6IGluc3RhbmNlLnBvcHBlciA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLnBvcHBlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoZHVyYXRpb24pO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgcHJveHkgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHBhc3NlcyB0aGUgcGx1Z2luc1xuICogQGRlcHJlY2F0ZWQgdXNlIHRpcHB5LnNldERlZmF1bHRQcm9wcyh7cGx1Z2luczogWy4uLl19KTtcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUaXBweVdpdGhQbHVnaW5zKG91dGVyUGx1Z2lucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgd2FybldoZW4odHJ1ZSwgWydjcmVhdGVUaXBweVdpdGhQbHVnaW5zKFsuLi5dKSBoYXMgYmVlbiBkZXByZWNhdGVkLicsICdcXG5cXG4nLCAnVXNlIHRpcHB5LnNldERlZmF1bHRQcm9wcyh7cGx1Z2luczogWy4uLl19KSBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgdGlwcHlQbHVnaW5zV3JhcHBlciA9IGZ1bmN0aW9uIHRpcHB5UGx1Z2luc1dyYXBwZXIodGFyZ2V0cywgb3B0aW9uYWxQcm9wcywgaW5uZXJQbHVnaW5zKSB7XG4gICAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChpbm5lclBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgICAgaW5uZXJQbHVnaW5zID0gW107XG4gICAgfVxuXG4gICAgaW5uZXJQbHVnaW5zID0gb3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IGlubmVyUGx1Z2lucztcbiAgICByZXR1cm4gdGlwcHkodGFyZ2V0cywgX2V4dGVuZHMoe30sIG9wdGlvbmFsUHJvcHMsIHtcbiAgICAgIHBsdWdpbnM6IFtdLmNvbmNhdChvdXRlclBsdWdpbnMsIGlubmVyUGx1Z2lucylcbiAgICB9KSk7XG4gIH07XG5cbiAgdGlwcHlQbHVnaW5zV3JhcHBlci52ZXJzaW9uID0gdmVyc2lvbjtcbiAgdGlwcHlQbHVnaW5zV3JhcHBlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gIHRpcHB5UGx1Z2luc1dyYXBwZXIuc2V0RGVmYXVsdFByb3BzID0gc2V0RGVmYXVsdFByb3BzO1xuICB0aXBweVBsdWdpbnNXcmFwcGVyLmN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnB1dDsgLy8gQHRzLWlnbm9yZVxuXG4gIHJldHVybiB0aXBweVBsdWdpbnNXcmFwcGVyO1xufVxuXG5leHBvcnQgeyBCQUNLRFJPUF9DTEFTUyBhcyBCLCBST1VORF9BUlJPVyBhcyBSLCBfZXh0ZW5kcyBhcyBfLCBkaXYgYXMgYSwgaXNVQ0Jyb3dzZXIgYXMgYiwgaXNNb3VzZUV2ZW50IGFzIGMsIGRlZmF1bHRQcm9wcyBhcyBkLCBlcnJvcldoZW4gYXMgZSwgY3VycmVudElucHV0IGFzIGYsIGdldE93bmVyRG9jdW1lbnQgYXMgZywgY2xvc2VzdENhbGxiYWNrIGFzIGgsIGluY2x1ZGVzIGFzIGksIGdldEJhc2VQbGFjZW1lbnQgYXMgaiwgYXJyYXlGcm9tIGFzIGssIGhpZGVBbGwgYXMgbCwgY3JlYXRlVGlwcHlXaXRoUGx1Z2lucyBhcyBtLCBub3JtYWxpemVUb0FycmF5IGFzIG4sIGlzQnJvd3NlciBhcyBvLCByZW1vdmVQcm9wZXJ0aWVzIGFzIHIsIHNldFZpc2liaWxpdHlTdGF0ZSBhcyBzLCB0aXBweSBhcyB0LCB1c2VJZkRlZmluZWQgYXMgdSwgd2FybldoZW4gYXMgdyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlwcHkuY2h1bmsuZXNtLmpzLm1hcFxuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi90aXBweS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7IiwiLyoqIVxuKiB0aXBweS5qcyB2NS4xLjRcbiogKGMpIDIwMTctMjAyMCBhdG9taWtzXG4qIE1JVCBMaWNlbnNlXG4qL1xuaW1wb3J0IHsgZSBhcyBlcnJvcldoZW4sIF8gYXMgX2V4dGVuZHMsIGQgYXMgZGVmYXVsdFByb3BzLCB0IGFzIHRpcHB5LCBhIGFzIGRpdiwgciBhcyByZW1vdmVQcm9wZXJ0aWVzLCBuIGFzIG5vcm1hbGl6ZVRvQXJyYXksIGkgYXMgaW5jbHVkZXMsIGIgYXMgaXNVQ0Jyb3dzZXIsIHMgYXMgc2V0VmlzaWJpbGl0eVN0YXRlLCB3IGFzIHdhcm5XaGVuLCBCIGFzIEJBQ0tEUk9QX0NMQVNTLCBnIGFzIGdldE93bmVyRG9jdW1lbnQsIGMgYXMgaXNNb3VzZUV2ZW50LCB1IGFzIHVzZUlmRGVmaW5lZCwgZiBhcyBjdXJyZW50SW5wdXQsIGggYXMgY2xvc2VzdENhbGxiYWNrLCBqIGFzIGdldEJhc2VQbGFjZW1lbnQsIGsgYXMgYXJyYXlGcm9tIH0gZnJvbSAnLi90aXBweS5jaHVuay5lc20uanMnO1xuZXhwb3J0IHsgbSBhcyBjcmVhdGVUaXBweVdpdGhQbHVnaW5zLCB0IGFzIGRlZmF1bHQsIGwgYXMgaGlkZUFsbCwgUiBhcyByb3VuZEFycm93IH0gZnJvbSAnLi90aXBweS5jaHVuay5lc20uanMnO1xuaW1wb3J0ICdwb3BwZXIuanMnO1xuXG4vKipcbiAqIFJlLXVzZXMgYSBzaW5nbGUgdGlwcHkgZWxlbWVudCBmb3IgbWFueSBkaWZmZXJlbnQgdGlwcHkgaW5zdGFuY2VzLlxuICogUmVwbGFjZXMgdjQncyBgdGlwcHkuZ3JvdXAoKWAuXG4gKi9cblxudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbih0aXBweUluc3RhbmNlcywgb3B0aW9uYWxQcm9wcyxcbi8qKiBAZGVwcmVjYXRlZCB1c2UgUHJvcHMucGx1Z2lucyAqL1xucGx1Z2lucykge1xuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcldoZW4oIUFycmF5LmlzQXJyYXkodGlwcHlJbnN0YW5jZXMpLCBbJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU2luZ2xldG9uKCkgbXVzdCBiZSBhbiBhcnJheSBvZiB0aXBweScsICdpbnN0YW5jZXMuIFRoZSBwYXNzZWQgdmFsdWUgd2FzJywgU3RyaW5nKHRpcHB5SW5zdGFuY2VzKV0uam9pbignICcpKTtcbiAgfVxuXG4gIHBsdWdpbnMgPSBvcHRpb25hbFByb3BzLnBsdWdpbnMgfHwgcGx1Z2lucztcbiAgdGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gIH0pO1xuXG4gIHZhciB1c2VyQXJpYSA9IF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHt9LCBvcHRpb25hbFByb3BzKS5hcmlhO1xuXG4gIHZhciBjdXJyZW50QXJpYTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7XG4gIHZhciBzaG91bGRTa2lwVXBkYXRlID0gZmFsc2U7XG4gIHZhciByZWZlcmVuY2VzID0gdGlwcHlJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gIH0pO1xuICB2YXIgc2luZ2xldG9uID0ge1xuICAgIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlQXJpYURlc2NyaWJlZEJ5QXR0cmlidXRlKGlzU2hvdykge1xuICAgICAgICBpZiAoIWN1cnJlbnRBcmlhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHIgPSBcImFyaWEtXCIgKyBjdXJyZW50QXJpYTtcblxuICAgICAgICBpZiAoaXNTaG93ICYmICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQuc2V0QXR0cmlidXRlKGF0dHIsIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuLnRvb2x0aXAuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoXywgX3JlZikge1xuICAgICAgICAgIHZhciBhcmlhID0gX3JlZi5hcmlhO1xuXG4gICAgICAgICAgLy8gRW5zdXJlIGBhcmlhYCBmb3IgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBzdGF5cyBgbnVsbGAsIHdoaWxlXG4gICAgICAgICAgLy8gY2hhbmdpbmcgdGhlIGB1c2VyQXJpYWAgdmFsdWVcbiAgICAgICAgICBpZiAoYXJpYSAhPT0gdW5kZWZpbmVkICYmIGFyaWEgIT09IHVzZXJBcmlhKSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXNlckFyaWEgPSBhcmlhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2hvdWxkU2tpcFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBhcmlhOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzaG91bGRTa2lwVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgICAgICB0aXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZW5hYmxlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgICAgaGFuZGxlQXJpYURlc2NyaWJlZEJ5QXR0cmlidXRlKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7XG4gICAgICAgICAgaGFuZGxlQXJpYURlc2NyaWJlZEJ5QXR0cmlidXRlKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICB2YXIgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YodGFyZ2V0KTsgLy8gYmFpbC1vdXRcblxuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIGN1cnJlbnRBcmlhID0gdXNlckFyaWE7XG5cbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBoYW5kbGVBcmlhRGVzY3JpYmVkQnlBdHRyaWJ1dGUodHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0gdGFyZ2V0O1xuICAgICAgICAgIGluc3RhbmNlLnNldENvbnRlbnQodGlwcHlJbnN0YW5jZXNbaW5kZXhdLnByb3BzLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRpcHB5KGRpdigpLCBfZXh0ZW5kcyh7fSwgb3B0aW9uYWxQcm9wcywge1xuICAgIHBsdWdpbnM6IFtzaW5nbGV0b25dLmNvbmNhdChwbHVnaW5zKSxcbiAgICBhcmlhOiBudWxsLFxuICAgIHRyaWdnZXJUYXJnZXQ6IHJlZmVyZW5jZXNcbiAgfSkpO1xufTtcblxudmFyIEJVQkJMSU5HX0VWRU5UU19NQVAgPSB7XG4gIG1vdXNlb3ZlcjogJ21vdXNlZW50ZXInLFxuICBmb2N1c2luOiAnZm9jdXMnLFxuICBjbGljazogJ2NsaWNrJ1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGRlbGVnYXRlIGluc3RhbmNlIHRoYXQgY29udHJvbHMgdGhlIGNyZWF0aW9uIG9mIHRpcHB5IGluc3RhbmNlc1xuICogZm9yIGNoaWxkIGVsZW1lbnRzIChgdGFyZ2V0YCBDU1Mgc2VsZWN0b3IpLlxuICovXG5cbmZ1bmN0aW9uIGRlbGVnYXRlKHRhcmdldHMsIHByb3BzLFxuLyoqIEBkZXByZWNhdGVkIHVzZSBQcm9wcy5wbHVnaW5zICovXG5wbHVnaW5zKSB7XG4gIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHtcbiAgICBwbHVnaW5zID0gW107XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JXaGVuKCEocHJvcHMgJiYgcHJvcHMudGFyZ2V0KSwgWydZb3UgbXVzdCBzcGVjaXR5IGEgYHRhcmdldGAgcHJvcCBpbmRpY2F0aW5nIGEgQ1NTIHNlbGVjdG9yIHN0cmluZyBtYXRjaGluZycsICd0aGUgdGFyZ2V0IGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlY2VpdmUgYSB0aXBweS4nXS5qb2luKCcgJykpO1xuICB9XG5cbiAgcGx1Z2lucyA9IHByb3BzLnBsdWdpbnMgfHwgcGx1Z2lucztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICB2YXIgbmF0aXZlUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKHByb3BzLCBbJ3RhcmdldCddKTtcblxuICB2YXIgcGFyZW50UHJvcHMgPSBfZXh0ZW5kcyh7fSwgbmF0aXZlUHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zLFxuICAgIHRyaWdnZXI6ICdtYW51YWwnXG4gIH0pO1xuXG4gIHZhciBjaGlsZFByb3BzID0gX2V4dGVuZHMoe30sIG5hdGl2ZVByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICBzaG93T25DcmVhdGU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gdGlwcHkodGFyZ2V0cywgcGFyZW50UHJvcHMpO1xuICB2YXIgbm9ybWFsaXplZFJldHVyblZhbHVlID0gbm9ybWFsaXplVG9BcnJheShyZXR1cm5WYWx1ZSk7XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KHRhcmdldCk7XG5cbiAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCByZWxldmFudCB0cmlnZ2VyIHdpdGggZmFsbGJhY2tzOlxuICAgIC8vIDEuIENoZWNrIGBkYXRhLXRpcHB5LXRyaWdnZXJgIGF0dHJpYnV0ZSBvbiB0YXJnZXQgbm9kZVxuICAgIC8vIDIuIEZhbGxiYWNrIHRvIGB0cmlnZ2VyYCBwYXNzZWQgdG8gYGRlbGVnYXRlKClgXG4gICAgLy8gMy4gRmFsbGJhY2sgdG8gYGRlZmF1bHRQcm9wcy50cmlnZ2VyYFxuXG5cbiAgICB2YXIgdHJpZ2dlciA9IHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXRyaWdnZXInKSB8fCBwcm9wcy50cmlnZ2VyIHx8IGRlZmF1bHRQcm9wcy50cmlnZ2VyOyAvLyBPbmx5IGNyZWF0ZSB0aGUgaW5zdGFuY2UgaWYgdGhlIGJ1YmJsaW5nIGV2ZW50IG1hdGNoZXMgdGhlIHRyaWdnZXIgdHlwZVxuXG4gICAgaWYgKCFpbmNsdWRlcyh0cmlnZ2VyLCBCVUJCTElOR19FVkVOVFNfTUFQW2V2ZW50LnR5cGVdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKG5vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIG9uKHJlZmVyZW5jZSwgJ21vdXNlb3ZlcicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnZm9jdXNpbicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnY2xpY2snLCBvblRyaWdnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcblxuICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICBub3JtYWxpemVkUmV0dXJuVmFsdWUuZm9yRWFjaChhcHBseU11dGF0aW9ucyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxudmFyIGFuaW1hdGVGaWxsID0ge1xuICBuYW1lOiAnYW5pbWF0ZUZpbGwnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlJHBvcHBlckNoaWxkID0gaW5zdGFuY2UucG9wcGVyQ2hpbGRyZW4sXG4gICAgICAgIHRvb2x0aXAgPSBfaW5zdGFuY2UkcG9wcGVyQ2hpbGQudG9vbHRpcCxcbiAgICAgICAgY29udGVudCA9IF9pbnN0YW5jZSRwb3BwZXJDaGlsZC5jb250ZW50O1xuICAgIHZhciBiYWNrZHJvcCA9IGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsICYmICFpc1VDQnJvd3NlciA/IGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIDogbnVsbDtcblxuICAgIGZ1bmN0aW9uIGFkZEJhY2tkcm9wVG9Qb3BwZXJDaGlsZHJlbigpIHtcbiAgICAgIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuLmJhY2tkcm9wID0gYmFja2Ryb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYWRkQmFja2Ryb3BUb1BvcHBlckNoaWxkcmVuKCk7XG4gICAgICAgICAgdG9vbHRpcC5pbnNlcnRCZWZvcmUoYmFja2Ryb3AsIHRvb2x0aXAuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGVmaWxsJywgJycpO1xuICAgICAgICAgIHRvb2x0aXAuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgICBhbmltYXRpb246ICdzaGlmdC1hd2F5JyxcbiAgICAgICAgICAgIGFycm93OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXAuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IE51bWJlcih0cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgnbXMnLCAnJykpOyAvLyBUaGUgY29udGVudCBzaG91bGQgZmFkZSBpbiBhZnRlciB0aGUgYmFja2Ryb3AgaGFzIG1vc3RseSBmaWxsZWQgdGhlXG4gICAgICAgICAgLy8gdG9vbHRpcCBlbGVtZW50LiBgY2xpcC1wYXRoYCBpcyB0aGUgb3RoZXIgYWx0ZXJuYXRpdmUgYnV0IGlzIG5vdFxuICAgICAgICAgIC8vIHdlbGwtc3VwcG9ydGVkIGFuZCBpcyBidWdneSBvbiBzb21lIGRldmljZXMuXG5cbiAgICAgICAgICBjb250ZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IE1hdGgucm91bmQoZHVyYXRpb24gLyAxMCkgKyBcIm1zXCI7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAndmlzaWJsZScpOyAvLyBXYXJuIGlmIHRoZSBzdHlsZXNoZWV0cyBhcmUgbm90IGxvYWRlZFxuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgd2FybldoZW4oZ2V0Q29tcHV0ZWRTdHlsZShiYWNrZHJvcCkucG9zaXRpb24gIT09ICdhYnNvbHV0ZScsIFwiVGhlIGB0aXBweS5qcy9kaXN0L2JhY2tkcm9wLmNzc2Agc3R5bGVzaGVldCBoYXMgbm90IGJlZW5cXG4gICAgICAgICAgICAgIGltcG9ydGVkIVxcbiAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICBUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhpcyBzdHlsZXNoZWV0IHRvIHdvcmsuXCIpO1xuICAgICAgICAgICAgd2FybldoZW4oZ2V0Q29tcHV0ZWRTdHlsZSh0b29sdGlwKS50cmFuc2Zvcm0gPT09ICdub25lJywgXCJUaGUgYHRpcHB5LmpzL2FuaW1hdGlvbnMvc2hpZnQtYXdheS5jc3NgIHN0eWxlc2hlZXQgaGFzIG5vdFxcbiAgICAgICAgICAgICAgYmVlbiBpbXBvcnRlZCFcXG4gICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgVGhlIGBhbmltYXRlRmlsbGAgcGx1Z2luIHJlcXVpcmVzIHRoaXMgc3R5bGVzaGVldCB0byB3b3JrLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoKSB7XG4gICAgICAgIC8vIFdpdGggdGhpcyB0eXBlIG9mIHByb3AsIGl0J3MgaGlnaGx5IHVubGlrZWx5IGl0IHdpbGwgYmUgY2hhbmdlZFxuICAgICAgICAvLyBkeW5hbWljYWxseS4gV2UnbGwgbGVhdmUgb3V0IHRoZSBkaWZmL3VwZGF0ZSBsb2dpYyBpdCB0byBzYXZlIGJ5dGVzLlxuICAgICAgICAvLyBgcG9wcGVyQ2hpbGRyZW5gIGlzIGFzc2lnbmVkIGEgbmV3IG9iamVjdCBvbkFmdGVyVXBkYXRlXG4gICAgICAgIGFkZEJhY2tkcm9wVG9Qb3BwZXJDaGlsZHJlbigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIHtcbiAgdmFyIGJhY2tkcm9wID0gZGl2KCk7XG4gIGJhY2tkcm9wLmNsYXNzTmFtZSA9IEJBQ0tEUk9QX0NMQVNTO1xuICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICByZXR1cm4gYmFja2Ryb3A7XG59XG5cbnZhciBmb2xsb3dDdXJzb3IgPSB7XG4gIG5hbWU6ICdmb2xsb3dDdXJzb3InLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBpbnN0YW5jZS5wb3BwZXI7XG4gICAgdmFyIG9yaWdpbmFsUmVmZXJlbmNlID0gbnVsbDsgLy8gU3VwcG9ydCBpZnJhbWUgY29udGV4dHNcbiAgICAvLyBTdGF0aWMgY2hlY2sgdGhhdCBhc3N1bWVzIGFueSBvZiB0aGUgYHRyaWdnZXJUYXJnZXRgIG9yIGByZWZlcmVuY2VgXG4gICAgLy8gbm9kZXMgd2lsbCBuZXZlciBjaGFuZ2UgZG9jdW1lbnRzLCBldmVuIHdoZW4gdGhleSBhcmUgdXBkYXRlZFxuXG4gICAgdmFyIGRvYyA9IGdldE93bmVyRG9jdW1lbnQoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpOyAvLyBJbnRlcm5hbCBzdGF0ZVxuXG4gICAgdmFyIGxhc3RNb3VzZU1vdmVFdmVudDtcbiAgICB2YXIgbW91c2VDb29yZHMgPSBudWxsO1xuICAgIHZhciBpc0ludGVybmFsbHlTZXR0aW5nQ29udHJvbGxlZFByb3AgPSBmYWxzZTsgLy8gVGhlc2UgYXJlIGNvbnRyb2xsZWQgYnkgdGhpcyBwbHVnaW4sIHNvIHdlIG5lZWQgdG8gc3RvcmUgdGhlIHVzZXInc1xuICAgIC8vIG9yaWdpbmFsIHByb3AgdmFsdWVcblxuICAgIHZhciB1c2VyUHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGZ1bmN0aW9uIHNldFVzZXJQcm9wcyhwcm9wcykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdXNlclByb3BzW3Byb3BdID0gdXNlSWZEZWZpbmVkKHByb3BzW3Byb3BdLCB1c2VyUHJvcHNbcHJvcF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SXNNYW51YWwoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMudHJpZ2dlci50cmltKCkgPT09ICdtYW51YWwnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElzRW5hYmxlZCgpIHtcbiAgICAgIC8vICM1OTdcbiAgICAgIHZhciBpc1ZhbGlkTW91c2VFdmVudCA9IGdldElzTWFudWFsKCkgPyB0cnVlIDogLy8gQ2hlY2sgaWYgYSBrZXlib2FyZCBcImNsaWNrXCJcbiAgICAgIG1vdXNlQ29vcmRzICE9PSBudWxsICYmICEobW91c2VDb29yZHMuY2xpZW50WCA9PT0gMCAmJiBtb3VzZUNvb3Jkcy5jbGllbnRZID09PSAwKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgJiYgaXNWYWxpZE1vdXNlRXZlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSB7XG4gICAgICByZXR1cm4gY3VycmVudElucHV0LmlzVG91Y2ggfHwgaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0UmVmZXJlbmNlKCkge1xuICAgICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlICYmIG9yaWdpbmFsUmVmZXJlbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnJlZmVyZW5jZSA9IG9yaWdpbmFsUmVmZXJlbmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVBsYWNlbWVudCgpIHtcbiAgICAgIC8vIER1ZSB0byBgZ2V0VmlydHVhbE9mZnNldHMoKWAsIHdlIG5lZWQgdG8gcmV2ZXJzZSB0aGUgcGxhY2VtZW50IGlmIGl0J3NcbiAgICAgIC8vIHNoaWZ0ZWQgKHN0YXJ0IC0+IGVuZCwgYW5kIHZpY2UtdmVyc2EpXG4gICAgICAvLyBFYXJseSBiYWlsLW91dFxuICAgICAgaWYgKCFnZXRJc0VuYWJsZWQoKSAmJiBpbnN0YW5jZS5wcm9wcy5wbGFjZW1lbnQgPT09IHVzZXJQcm9wcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGxhY2VtZW50ID0gdXNlclByb3BzLnBsYWNlbWVudDtcbiAgICAgIHZhciBzaGlmdCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuICAgICAgaXNJbnRlcm5hbGx5U2V0dGluZ0NvbnRyb2xsZWRQcm9wID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgcGxhY2VtZW50OiBnZXRJc0VuYWJsZWQoKSAmJiBzaGlmdCA/IHBsYWNlbWVudC5yZXBsYWNlKHNoaWZ0LCBzaGlmdCA9PT0gJ3N0YXJ0JyA/ICdlbmQnIDogJ3N0YXJ0JykgOiBwbGFjZW1lbnRcbiAgICAgIH0pO1xuICAgICAgaXNJbnRlcm5hbGx5U2V0dGluZ0NvbnRyb2xsZWRQcm9wID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9wcGVyTGlzdGVuZXJzKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFBvcHBlcidzIHNjcm9sbCBsaXN0ZW5lcnMgbWFrZSBzZW5zZSBmb3IgYHRydWVgIG9ubHkuIFRPRE86IHdvcmsgb3V0XG4gICAgICAvLyBob3cgdG8gb25seSBsaXN0ZW4gaG9yaXpvbnRhbCBzY3JvbGwgZm9yIFwiaG9yaXpvbnRhbFwiIGFuZCB2ZXJ0aWNhbFxuICAgICAgLy8gc2Nyb2xsIGZvciBcInZlcnRpY2FsXCJcblxuXG4gICAgICBpZiAoZ2V0SXNFbmFibGVkKCkgJiYgKGdldElzSW5pdGlhbEJlaGF2aW9yKCkgfHwgaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yICE9PSB0cnVlKSkge1xuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChnZXRJc0VuYWJsZWQoKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRSZWZlcmVuY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyTGFzdE1vdXNlTW92ZSgpIHtcbiAgICAgIGlmIChnZXRJc0VuYWJsZWQoKSkge1xuICAgICAgICBvbk1vdXNlTW92ZShsYXN0TW91c2VNb3ZlRXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKCkge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIHZhciBfbGFzdE1vdXNlTW92ZUV2ZW50ID0gbGFzdE1vdXNlTW92ZUV2ZW50ID0gZXZlbnQsXG4gICAgICAgICAgY2xpZW50WCA9IF9sYXN0TW91c2VNb3ZlRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX2xhc3RNb3VzZU1vdmVFdmVudC5jbGllbnRZO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLnBvcHBlckluc3RhbmNlIHx8ICFpbnN0YW5jZS5zdGF0ZS5jdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgdGhlIGluc3RhbmNlIGlzIGludGVyYWN0aXZlLCBhdm9pZCB1cGRhdGluZyB0aGUgcG9zaXRpb24gdW5sZXNzIGl0J3NcbiAgICAgIC8vIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG5cblxuICAgICAgdmFyIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSA9IGNsb3Nlc3RDYWxsYmFjayhldmVudC50YXJnZXQsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwgPT09IHJlZmVyZW5jZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgZm9sbG93Q3Vyc29yID0gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yO1xuICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgdmFyIGlzVmVydGljYWwgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCc7XG4gICAgICB2YXIgaXNWZXJ0aWNhbFBsYWNlbWVudCA9IGluY2x1ZGVzKFsndG9wJywgJ2JvdHRvbSddLCBnZXRCYXNlUGxhY2VtZW50KGluc3RhbmNlLnN0YXRlLmN1cnJlbnRQbGFjZW1lbnQpKTsgLy8gVGhlIHZpcnR1YWwgcmVmZXJlbmNlIG5lZWRzIHNvbWUgc2l6ZSB0byBwcmV2ZW50IGl0c2VsZiBmcm9tIG92ZXJmbG93aW5nXG5cbiAgICAgIHZhciBfZ2V0VmlydHVhbE9mZnNldHMgPSBnZXRWaXJ0dWFsT2Zmc2V0cyhwb3BwZXIsIGlzVmVydGljYWxQbGFjZW1lbnQpLFxuICAgICAgICAgIHNpemUgPSBfZ2V0VmlydHVhbE9mZnNldHMuc2l6ZSxcbiAgICAgICAgICB4ID0gX2dldFZpcnR1YWxPZmZzZXRzLngsXG4gICAgICAgICAgeSA9IF9nZXRWaXJ0dWFsT2Zmc2V0cy55O1xuXG4gICAgICBpZiAoaXNDdXJzb3JPdmVyUmVmZXJlbmNlIHx8ICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBQcmVzZXJ2ZSBjdXN0b20gcG9zaXRpb24gUmVmZXJlbmNlT2JqZWN0cywgd2hpY2ggbWF5IG5vdCBiZSB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgdGFyZ2V0cyByZWZlcmVuY2UgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG4gICAgICAgIGlmIChvcmlnaW5hbFJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG9yaWdpbmFsUmVmZXJlbmNlID0gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0ge1xuICAgICAgICAgIHJlZmVyZW5jZU5vZGU6IHJlZmVyZW5jZSxcbiAgICAgICAgICAvLyBUaGVzZSBgY2xpZW50YCB2YWx1ZXMgZG9uJ3QgZ2V0IHVzZWQgYnkgUG9wcGVyLmpzIGlmIHRoZXkgYXJlIDBcbiAgICAgICAgICBjbGllbnRXaWR0aDogMCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQ6IDAsXG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogaXNWZXJ0aWNhbFBsYWNlbWVudCA/IHNpemUgOiAwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGlzVmVydGljYWxQbGFjZW1lbnQgPyAwIDogc2l6ZSxcbiAgICAgICAgICAgICAgdG9wOiAoaXNIb3Jpem9udGFsID8gcmVjdC50b3AgOiBjbGllbnRZKSAtIHksXG4gICAgICAgICAgICAgIGJvdHRvbTogKGlzSG9yaXpvbnRhbCA/IHJlY3QuYm90dG9tIDogY2xpZW50WSkgKyB5LFxuICAgICAgICAgICAgICBsZWZ0OiAoaXNWZXJ0aWNhbCA/IHJlY3QubGVmdCA6IGNsaWVudFgpIC0geCxcbiAgICAgICAgICAgICAgcmlnaHQ6IChpc1ZlcnRpY2FsID8gcmVjdC5yaWdodCA6IGNsaWVudFgpICsgeFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkFmdGVyVXBkYXRlOiBmdW5jdGlvbiBvbkFmdGVyVXBkYXRlKF8sIHBhcnRpYWxQcm9wcykge1xuICAgICAgICBpZiAoIWlzSW50ZXJuYWxseVNldHRpbmdDb250cm9sbGVkUHJvcCkge1xuICAgICAgICAgIHNldFVzZXJQcm9wcyhwYXJ0aWFsUHJvcHMpO1xuXG4gICAgICAgICAgaWYgKHBhcnRpYWxQcm9wcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZVBsYWNlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBIG5ldyBwbGFjZW1lbnQgY2F1c2VzIHRoZSBwb3BwZXJJbnN0YW5jZSB0byBiZSByZWNyZWF0ZWRcblxuXG4gICAgICAgIGlmIChwYXJ0aWFsUHJvcHMucGxhY2VtZW50KSB7XG4gICAgICAgICAgaGFuZGxlUG9wcGVyTGlzdGVuZXJzKCk7XG4gICAgICAgIH0gLy8gV2FpdCBmb3IgYC51cGRhdGUoKWAgdG8gc2V0IGBpbnN0YW5jZS5zdGF0ZS5jdXJyZW50UGxhY2VtZW50YCB0b1xuICAgICAgICAvLyB0aGUgbmV3IHBsYWNlbWVudFxuXG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRyaWdnZXJMYXN0TW91c2VNb3ZlKTtcbiAgICAgIH0sXG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICB0cmlnZ2VyTGFzdE1vdXNlTW92ZSgpO1xuICAgICAgICBoYW5kbGVQb3BwZXJMaXN0ZW5lcnMoKTtcbiAgICAgIH0sXG4gICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgaWYgKGdldElzTWFudWFsKCkpIHtcbiAgICAgICAgICAvLyBTaW5jZSB0aGVyZSdzIG5vIHRyaWdnZXIgZXZlbnQgdG8gdXNlLCB3ZSBoYXZlIHRvIHVzZSB0aGVzZSBhc1xuICAgICAgICAgIC8vIGJhc2VsaW5lIGNvb3Jkc1xuICAgICAgICAgIG1vdXNlQ29vcmRzID0ge1xuICAgICAgICAgICAgY2xpZW50WDogMCxcbiAgICAgICAgICAgIGNsaWVudFk6IDBcbiAgICAgICAgICB9OyAvLyBFbnN1cmUgYGxhc3RNb3VzZU1vdmVFdmVudGAgZG9lc24ndCBhY2Nlc3MgYW55IG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAvLyBvZiBhIE1vdXNlRXZlbnQgaGVyZVxuXG4gICAgICAgICAgbGFzdE1vdXNlTW92ZUV2ZW50ID0gbW91c2VDb29yZHM7XG4gICAgICAgICAgaGFuZGxlUGxhY2VtZW50KCk7XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKF8sIGV2ZW50KSB7XG4gICAgICAgIC8vIFRhcHBpbmcgb24gdG91Y2ggZGV2aWNlcyBjYW4gdHJpZ2dlciBgbW91c2VlbnRlcmAgdGhlbiBgZm9jdXNgXG4gICAgICAgIGlmIChtb3VzZUNvb3Jkcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgbW91c2VDb29yZHMgPSB7XG4gICAgICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WVxuICAgICAgICAgIH07XG4gICAgICAgICAgbGFzdE1vdXNlTW92ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVQbGFjZW1lbnQoKTtcbiAgICAgICAgaGFuZGxlTW91c2VNb3ZlTGlzdGVuZXIoKTtcbiAgICAgIH0sXG4gICAgICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7XG4gICAgICAgIC8vIElmIHVudHJpZ2dlcmVkIGJlZm9yZSBzaG93aW5nIChgb25IaWRkZW5gIHdpbGwgbmV2ZXIgYmUgaW52b2tlZClcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgIG1vdXNlQ29vcmRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVzZXRSZWZlcmVuY2UoKTtcbiAgICAgICAgbW91c2VDb29yZHMgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRWaXJ0dWFsT2Zmc2V0cyhwb3BwZXIsIGlzVmVydGljYWxQbGFjZW1lbnQpIHtcbiAgdmFyIHNpemUgPSBpc1ZlcnRpY2FsUGxhY2VtZW50ID8gcG9wcGVyLm9mZnNldFdpZHRoIDogcG9wcGVyLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICBzaXplOiBzaXplLFxuICAgIHg6IGlzVmVydGljYWxQbGFjZW1lbnQgPyBzaXplIDogMCxcbiAgICB5OiBpc1ZlcnRpY2FsUGxhY2VtZW50ID8gMCA6IHNpemVcbiAgfTtcbn1cblxuLy8gcG9zaXRpb24uIFRoaXMgd2lsbCByZXF1aXJlIHRoZSBgZm9sbG93Q3Vyc29yYCBwbHVnaW4ncyBmaXhlcyBmb3Igb3ZlcmZsb3dcbi8vIGR1ZSB0byB1c2luZyBldmVudC5jbGllbnRYL1kgdmFsdWVzLiAobm9ybWFsaXplZFBsYWNlbWVudCwgZ2V0VmlydHVhbE9mZnNldHMpXG5cbnZhciBpbmxpbmVQb3NpdGlvbmluZyA9IHtcbiAgbmFtZTogJ2lubGluZVBvc2l0aW9uaW5nJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcblxuICAgIGZ1bmN0aW9uIGdldElzRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiAhIWluc3RhbmNlLnByb3BzLmlubGluZVBvc2l0aW9uaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7XG4gICAgICAgIGlmIChnZXRJc0VuYWJsZWQoKSkge1xuICAgICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge1xuICAgICAgICBpZiAoIWdldElzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0ge1xuICAgICAgICAgIHJlZmVyZW5jZU5vZGU6IHJlZmVyZW5jZSxcbiAgICAgICAgICAvLyBUaGVzZSBgY2xpZW50YCB2YWx1ZXMgZG9uJ3QgZ2V0IHVzZWQgYnkgUG9wcGVyLmpzIGlmIHRoZXkgYXJlIDBcbiAgICAgICAgICBjbGllbnRXaWR0aDogMCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQ6IDAsXG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KGluc3RhbmNlLnN0YXRlLmN1cnJlbnRQbGFjZW1lbnQgJiYgZ2V0QmFzZVBsYWNlbWVudChpbnN0YW5jZS5zdGF0ZS5jdXJyZW50UGxhY2VtZW50KSwgcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhcnJheUZyb20ocmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChjdXJyZW50QmFzZVBsYWNlbWVudCwgYm91bmRpbmdSZWN0LCBjbGllbnRSZWN0cykge1xuICAvLyBOb3QgYW4gaW5saW5lIGVsZW1lbnQsIG9yIHBsYWNlbWVudCBpcyBub3QgeWV0IGtub3duXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPCAyIHx8IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgfVxuXG4gIHN3aXRjaCAoY3VycmVudEJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB7XG4gICAgICAgIHZhciBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgdmFyIGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc1RvcCA9IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSAndG9wJztcbiAgICAgICAgdmFyIHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgIHZhciBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgIHZhciBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgIHZhciByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1pbkxlZnQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBjbGllbnRSZWN0cy5tYXAoZnVuY3Rpb24gKHJlY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RzLmxlZnQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG1heFJpZ2h0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgY2xpZW50UmVjdHMubWFwKGZ1bmN0aW9uIChyZWN0cykge1xuICAgICAgICAgIHJldHVybiByZWN0cy5yaWdodDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSAnbGVmdCcgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgdmFyIF9ib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgdmFyIF9sZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgdmFyIF9yaWdodCA9IG1heFJpZ2h0O1xuXG4gICAgICAgIHZhciBfd2lkdGggPSBfcmlnaHQgLSBfbGVmdDtcblxuICAgICAgICB2YXIgX2hlaWdodCA9IF9ib3R0b20gLSBfdG9wO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiBfdG9wLFxuICAgICAgICAgIGJvdHRvbTogX2JvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBfbGVmdCxcbiAgICAgICAgICByaWdodDogX3JpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICAgICAgfVxuICB9XG59XG5cbnZhciBzdGlja3kgPSB7XG4gIG5hbWU6ICdzdGlja3knLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBpbnN0YW5jZS5wb3BwZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRSZWZlcmVuY2UoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPyBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5yZWZlcmVuY2UgOiByZWZlcmVuY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkQ2hlY2sodmFsdWUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHRydWUgfHwgaW5zdGFuY2UucHJvcHMuc3RpY2t5ID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlJlZlJlY3QgPSBudWxsO1xuICAgIHZhciBwcmV2UG9wUmVjdCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgIHZhciBjdXJyZW50UmVmUmVjdCA9IHNob3VsZENoZWNrKCdyZWZlcmVuY2UnKSA/IGdldFJlZmVyZW5jZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcbiAgICAgIHZhciBjdXJyZW50UG9wUmVjdCA9IHNob3VsZENoZWNrKCdwb3BwZXInKSA/IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG5cbiAgICAgIGlmIChjdXJyZW50UmVmUmVjdCAmJiBhcmVSZWN0c0RpZmZlcmVudChwcmV2UmVmUmVjdCwgY3VycmVudFJlZlJlY3QpIHx8IGN1cnJlbnRQb3BSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZQb3BSZWN0LCBjdXJyZW50UG9wUmVjdCkpIHtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHByZXZSZWZSZWN0ID0gY3VycmVudFJlZlJlY3Q7XG4gICAgICBwcmV2UG9wUmVjdCA9IGN1cnJlbnRQb3BSZWN0O1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zdGlja3kpIHtcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlUmVjdHNEaWZmZXJlbnQocmVjdEEsIHJlY3RCKSB7XG4gIGlmIChyZWN0QSAmJiByZWN0Qikge1xuICAgIHJldHVybiByZWN0QS50b3AgIT09IHJlY3RCLnRvcCB8fCByZWN0QS5yaWdodCAhPT0gcmVjdEIucmlnaHQgfHwgcmVjdEEuYm90dG9tICE9PSByZWN0Qi5ib3R0b20gfHwgcmVjdEEubGVmdCAhPT0gcmVjdEIubGVmdDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgeyBhbmltYXRlRmlsbCwgY3JlYXRlU2luZ2xldG9uLCBkZWxlZ2F0ZSwgZm9sbG93Q3Vyc29yLCBpbmxpbmVQb3NpdGlvbmluZywgc3RpY2t5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aXBweS5lc20uanMubWFwXG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xpZ2h0LWJvcmRlci5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7IiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiaW1wb3J0IHsgX19ub25OdWxsLCBhYnN1cmQgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgQW5ub3RhdGlvbiwgYm9vbF8gfSBmcm9tIFwiLi91dGlsL0xhdHRpY2VcIlxuaW1wb3J0IHsgaW50ZXJzZWN0aW9uLCB1bmlvbiB9IGZyb20gXCIuL3V0aWwvU2V0XCJcbmltcG9ydCB7IERhdGFWYWx1ZSwgRXhwbFZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IF9fZGVsdGFzIH0gZnJvbSBcIi4vRGVsdGFcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuL0V4cGxcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IHsgVmFsdWUsIF8gfSBmcm9tIFwiLi9WYWx1ZVwiXG5cbmV4cG9ydCB0eXBlIEFubm90YXRlZCA9IEV4cHIuU3ludGF4Tm9kZSB8IEV4cGxWYWx1ZVxuZXhwb3J0IHR5cGUgU2xpY2UgPSBTZXQ8QW5ub3RhdGVkPlxuXG5leHBvcnQgZnVuY3Rpb24gYW5ub3RhdGVkICh2OiBWYWx1ZSk6IHYgaXMgQW5ub3RhdGVkIHtcbiAgIHJldHVybiB2IGluc3RhbmNlb2YgRXhwci5TeW50YXhOb2RlIHx8IHYgaW5zdGFuY2VvZiBFeHBsVmFsdWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzzrEgKHY6IEFubm90YXRlZCk6IEFubm90YXRpb24ge1xuICAgcmV0dXJuIF9fc2xpY2UuaXModilcbn1cblxuLy8gQ3VycmVudGx5IG5vIGRlbHRhcyBhcmUgYXNzb2NpYXRlZCB3aXRoIGFubm90YXRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHNldM6xPFQgZXh0ZW5kcyBBbm5vdGF0ZWQ+ICjOsTogQW5ub3RhdGlvbiwgdjogVCk6IHZvaWQge1xuICAgX19zbGljZS5zZXQodiwgzrEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRqb2luzrEgKM6xOiBBbm5vdGF0aW9uLCB2OiBBbm5vdGF0ZWQpOiB2b2lkIHtcbiAgIHNldM6xKGJvb2xfLmpvaW4ozrEsIGlzzrEodikpLCB2KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0bWVldM6xICjOsTogQW5ub3RhdGlvbiwgdjogQW5ub3RhdGVkKTogdm9pZCB7XG4gICBzZXTOsShib29sXy5tZWV0KM6xLCBpc86xKHYpKSwgdilcbn1cblxuZXhwb3J0IGVudW0gRGlyZWN0aW9uIHsgRndkLCBCd2QgfVxuXG5leHBvcnQgY2xhc3MgQW5ub3RhdGlvbnMge1xuICAgYW5uOiBTbGljZSA9IG5ldyBTZXQoKSAvLyB1bmF2YWlsYWJsZSBub2RlcyAoZndkKSBvciBuZWVkZWQgbm9kZXMgKGJ3ZClcbiAgIGRpcmVjdGlvbjogRGlyZWN0aW9uID0gRGlyZWN0aW9uLkZ3ZFxuXG4gICAvLyBXaGV0aGVyIHYgaXMgbmVlZGVkIChnb2luZyBiYWNrd2FyZCkgb3IgYXZhaWxhYmxlIChnb2luZyBmb3J3YXJkKS5cbiAgIGlzICh2OiBBbm5vdGF0ZWQpOiBBbm5vdGF0aW9uIHtcbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLkZ3ZCkge1xuICAgICAgICAgcmV0dXJuIGJvb2xfLm5lZ2F0ZSh0aGlzLmFubi5oYXModikpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHRoaXMuYW5uLmhhcyh2KVxuICAgICAgfVxuICAgfVxuICAgXG4gICAvLyBHb2luZyBmb3J3YXJkLCBhbm5vdGF0aW9uIHVwZGF0ZXMgbXVzdCBiZSBkZWNyZWFzaW5nOyBnb2luZyBiYWNrd2FyZCwgaW5jcmVhc2luZy4gVGhpcyBpcyBiZWNhdXNlIFxuICAgLy8gZm9yd2FyZCBzbGljaW5nIHByb3BhZ2F0ZXMgbm9uLWF2YWlsYWJpbGl0eSwgd2hlcmVhcyBiYWNrd2FyZCBzbGljaW5nIHByb3BhZ2F0ZXMgZGVtYW5kLlxuICAgc2V0ICh2OiBBbm5vdGF0ZWQsIM6xOiBBbm5vdGF0aW9uKTogdm9pZCB7XG4gICAgICBjb25zdCBjdXJyZW50OiBBbm5vdGF0aW9uID0gdGhpcy5pcyh2KVxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uRndkICYmIM6xIDwgY3VycmVudCB8fFxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uQndkICYmIM6xID4gY3VycmVudCkge1xuICAgICAgICAgdGhpcy5hbm4uYWRkKHYpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLkZ3ZCAmJiDOsSA+IGN1cnJlbnQgfHxcbiAgICAgICAgIHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uQndkICYmIM6xIDwgY3VycmVudCkge1xuICAgICAgICAgYWJzdXJkKGBJbmNvbXBhdGlibGUgdXBkYXRlIG9mIGFubm90YXRpb24gZnJvbSAke2N1cnJlbnR9IHRvICR7zrF9LmAsIGN1cnJlbnQsIM6xKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIGlkZW1wb3RlbnRcbiAgICAgIH1cbiAgIH1cblxuICAgcmVzZXQgKGRpcmVjdGlvbjogRGlyZWN0aW9uKTogdm9pZCB7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvblxuICAgICAgdGhpcy5hbm4gPSBuZXcgU2V0KClcbiAgIH1cblxuICAgcmVzdHJpY3RUbyAodHZzOiBFeHBsVmFsdWVbXSk6IFNsaWNlIHtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24odGhpcy5hbm4sIHVuaW9uKC4uLnR2cy5tYXAodHYgPT4gZXhwbERlc2NlbmRhbnRzKHR2KSkpKVxuICAgfVxufVxuXG5mdW5jdGlvbiBleHBsRGVzY2VuZGFudHMgKHR2OiBFeHBsVmFsdWUpOiBTZXQ8RXhwbFZhbHVlPiB7XG4gICBjb25zdCBkZXNjOiBTZXQ8RXhwbFZhbHVlPiA9IG5ldyBTZXQoKVxuICAgZXhwbERlc2NlbmRhbnRzX2F1eCh0diwgZGVzYylcbiAgIHJldHVybiBkZXNjXG59XG5cbmZ1bmN0aW9uIGV4cGxEZXNjZW5kYW50c19hdXggKHR2OiBFeHBsVmFsdWUsIGRlc2M6IFNldDxFeHBsVmFsdWU+KTogdm9pZCB7XG4gICBkZXNjLmFkZCh0dilcbiAgIGlmICh0di52IGluc3RhbmNlb2YgRGF0YVZhbHVlKSB7XG4gICAgICBjb25zdCB7dCwgdn06IEV4cGxWYWx1ZTxEYXRhVmFsdWU+ID0gdHYgYXMgRXhwbFZhbHVlPERhdGFWYWx1ZT5cbiAgICAgIEV4cGwuZXhwbENoaWxkcmVuKHQsdikuZm9yRWFjaCgodHY6IEV4cGxWYWx1ZSk6IHZvaWQgPT4geyBcbiAgICAgICAgIGV4cGxEZXNjZW5kYW50c19hdXgodHYsIGRlc2MpXG4gICAgICB9KVxuICAgfVxufVxuXG5leHBvcnQgY29uc3QgX19zbGljZTogQW5ub3RhdGlvbnMgPSBuZXcgQW5ub3RhdGlvbnMoKVxuIiwiaW1wb3J0IHsgYWJzdXJkIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IGluaXREYXRhVHlwZSB9IGZyb20gXCIuL0RhdGFUeXBlXCJcbmltcG9ydCB7IERhdGFWYWx1ZSB9IGZyb20gXCIuL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBJZCwgUGVyc2lzdGVudCwgVmFsdWUsIF8sIG1ha2UgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyBhdCB9IGZyb20gXCIuL1ZlcnNpb25lZFwiXG5cbi8vIFNlZSBFbnYgZm9yIGNvbnZlbnRpb24gcmVnYXJkaW5nIGluc3RhbmNlIG1lbWJlcnMgb24gcmVmbGVjdGVkIGRhdGF0eXBlcy5cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJvb2wgZXh0ZW5kcyBEYXRhVmFsdWU8XCJCb29sXCI+IHtcbn1cblxuZXhwb3J0IGNsYXNzIFRydWUgZXh0ZW5kcyBCb29sIHtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRydWVfICgpOiAoazogSWQpID0+IEJvb2wge1xuICAgcmV0dXJuIGF0KFRydWUpXG59XG5cbmV4cG9ydCBjbGFzcyBGYWxzZSBleHRlbmRzIEJvb2wge1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmFsc2VfICgpOiAoazogSWQpID0+IEJvb2wge1xuICAgcmV0dXJuIGF0KEZhbHNlKVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTGlzdDxUID0gVmFsdWU+IGV4dGVuZHMgRGF0YVZhbHVlPFwiTGlzdFwiPiB7XG4gICBzdGF0aWMgZnJvbUFycmF5PFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAoeMyFOiBUW10pOiBMaXN0PFQ+IHtcbiAgICAgIGxldCB4zIXKuTogTGlzdDxUPiA9IG5pbCgpXG4gICAgICBmb3IgKGxldCBuOiBudW1iZXIgPSB4zIUubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgICAgIHjMhcq5ID0gY29ucyh4zIVbbl0sIHjMhcq5KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHjMhcq5XG4gICB9XG5cbiAgIHRvQXJyYXkgKCk6IFRbXSB7XG4gICAgICBjb25zdCB4zIU6IFRbXSA9IFtdXG4gICAgICB0aGlzLnRvQXJyYXlfKHjMhSlcbiAgICAgIHJldHVybiB4zIVcbiAgIH1cblxuICAgdG9BcnJheV8gKHjMhTogVFtdKTogdm9pZCB7XG4gICAgICBpZiAoQ29ucy5pcyh0aGlzKSkge1xuICAgICAgICAgeMyFLnB1c2godGhpcy5oZWFkKVxuICAgICAgICAgdGhpcy50YWlsLnRvQXJyYXlfKHjMhSlcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKE5pbC5pcyh0aGlzKSkge1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmlsPFQgPSBWYWx1ZT4gZXh0ZW5kcyBMaXN0PFQ+IHtcbiAgIHN0YXRpYyBpczxUPiAoeHM6IExpc3Q8VD4pOiB4cyBpcyBOaWw8VD4ge1xuICAgICAgcmV0dXJuIHhzIGluc3RhbmNlb2YgTmlsXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuaWw8VD4gKCk6IExpc3Q8VD4ge1xuICAgcmV0dXJuIG1ha2UoTmlsKSBhcyBOaWw8VD5cbn1cblxuZXhwb3J0IGNsYXNzIENvbnM8VCA9IFZhbHVlPiBleHRlbmRzIExpc3Q8VD4ge1xuICAgaGVhZDogVCA9IF9cbiAgIHRhaWw6IExpc3Q8VD4gPSBfXG5cbiAgIHN0YXRpYyBpczxUPiAoeHM6IExpc3Q8VD4pOiB4cyBpcyBDb25zPFQ+IHtcbiAgICAgIHJldHVybiB4cyBpbnN0YW5jZW9mIENvbnNcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnM8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IChoZWFkOiBULCB0YWlsOiBMaXN0PFQ+KTogQ29uczxUPiB7XG4gICByZXR1cm4gbWFrZShDb25zLCBoZWFkLCB0YWlsKSBhcyBDb25zPFQ+XG59XG5cbmV4cG9ydCBjbGFzcyBQYWlyPFQgPSBWYWx1ZSwgVSA9IFZhbHVlPiBleHRlbmRzIERhdGFWYWx1ZTxcIlBhaXJcIj4ge1xuICAgZnN0OiBUID0gX1xuICAgc25kOiBVID0gX1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFpcjxUIGV4dGVuZHMgUGVyc2lzdGVudCwgVSBleHRlbmRzIFBlcnNpc3RlbnQ+IChmc3Q6IFQsIHNuZDogVSk6IFBhaXI8VCwgVT4ge1xuICAgcmV0dXJuIG1ha2UoUGFpciwgZnN0LCBzbmQpIGFzIFBhaXI8VCwgVT5cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyZWU8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IGV4dGVuZHMgRGF0YVZhbHVlPFwiVHJlZVwiPiB7XG4gICB0b0FycmF5ICgpOiBUW10ge1xuICAgICAgY29uc3QgeMyFOiBUW10gPSBbXVxuICAgICAgdGhpcy50b0FycmF5Xyh4zIUpXG4gICAgICByZXR1cm4geMyFXG4gICB9XG5cbiAgIHRvQXJyYXlfICh4zIU6IFRbXSk6IHZvaWQge1xuICAgICAgaWYgKE5vbkVtcHR5LmlzKHRoaXMpKSB7XG4gICAgICAgICB0aGlzLmxlZnQudG9BcnJheV8oeMyFKVxuICAgICAgICAgeMyFLnB1c2godGhpcy50KVxuICAgICAgICAgdGhpcy5yaWdodC50b0FycmF5Xyh4zIUpXG4gICAgICB9IGVsc2UgXG4gICAgICBpZiAoRW1wdHkuaXModGhpcykpIHtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVtcHR5PFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiBleHRlbmRzIFRyZWU8VD4ge1xuICAgc3RhdGljIGlzPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAodDogVHJlZTxUPik6IHQgaXMgRW1wdHk8VD4ge1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBFbXB0eVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHk8VCBleHRlbmRzIFBlcnNpc3RlbnQ+ICgpOiBFbXB0eTxUPiB7XG4gICByZXR1cm4gbWFrZShFbXB0eSkgYXMgRW1wdHk8VD5cbn1cblxuZXhwb3J0IGNsYXNzIE5vbkVtcHR5PFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiBleHRlbmRzIFRyZWU8VD4ge1xuICAgbGVmdDogVHJlZTxUPiA9IF9cbiAgIHQ6IFQgPSBfXG4gICByaWdodDogVHJlZTxUPiA9IF9cblxuICAgc3RhdGljIGlzPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAodDogVHJlZTxUPik6IHQgaXMgTm9uRW1wdHk8VD4ge1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBOb25FbXB0eVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9uRW1wdHkgPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAobGVmdDogVHJlZTxUPiwgdDogVCwgcmlnaHQ6IFRyZWU8VD4pOiBOb25FbXB0eTxUPiB7XG4gICByZXR1cm4gbWFrZShOb25FbXB0eSwgbGVmdCwgdCwgcmlnaHQpIGFzIE5vbkVtcHR5PFQ+XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPcHRpb248VCBleHRlbmRzIFBlcnNpc3RlbnQ+IGV4dGVuZHMgRGF0YVZhbHVlPFwiT3B0aW9uXCI+IHtcbn1cblxuZXhwb3J0IGNsYXNzIE5vbmU8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IGV4dGVuZHMgT3B0aW9uPFQ+IHtcbiAgIHN0YXRpYyBpczxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKG86IE9wdGlvbjxUPik6IG8gaXMgTm9uZTxUPiB7XG4gICAgICByZXR1cm4gbyBpbnN0YW5jZW9mIE5vbmVcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNvbWU8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IGV4dGVuZHMgT3B0aW9uPFQ+IHtcbiAgIHQ6IFQgPSBfXG5cbiAgIHN0YXRpYyBpczxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKG86IE9wdGlvbjxUPik6IG8gaXMgU29tZTxUPiB7XG4gICAgICByZXR1cm4gbyBpbnN0YW5jZW9mIFNvbWVcbiAgIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE9yZGVyaW5nIGV4dGVuZHMgRGF0YVZhbHVlPFwiT3JkZXJpbmdcIj4ge1xufVxuXG5leHBvcnQgY2xhc3MgTFQgZXh0ZW5kcyBPcmRlcmluZyB7XG59XG5cbmV4cG9ydCBjbGFzcyBHVCBleHRlbmRzIE9yZGVyaW5nIHtcbn1cblxuZXhwb3J0IGNsYXNzIEVRIGV4dGVuZHMgT3JkZXJpbmcge1xufVxuXG5pbml0RGF0YVR5cGUoQm9vbCwgW1RydWUsIEZhbHNlXSlcbmluaXREYXRhVHlwZShMaXN0LCBbTmlsLCBDb25zXSlcbmluaXREYXRhVHlwZShPcHRpb24sIFtTb21lLCBOb25lXSlcbmluaXREYXRhVHlwZShPcmRlcmluZywgW0xULCBHVCwgRVFdKVxuaW5pdERhdGFUeXBlKFBhaXIsIFtQYWlyXSlcbmluaXREYXRhVHlwZShUcmVlLCBbRW1wdHksIE5vbkVtcHR5XSlcbiIsImltcG9ydCB7IEFDbGFzcywgQ2xhc3MsIF9fbm9uTnVsbCB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBEYXRhVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuL0V4cGxcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IHsgRGF0YUVsaW0gfSBmcm9tIFwiLi9NYXRjaFwiXG5pbXBvcnQgeyBOdW0sIFByaW1WYWx1ZSwgU3RyLCBfLCBmaWVsZHMgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyDOvSwgc3RyIH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuZXhwb3J0IGNsYXNzIFByaW1UeXBlIHtcbiAgIG5hbWU6IFN0clxuICAgQzogQ2xhc3M8UHJpbVZhbHVlPlxuXG4gICBjb25zdHJ1Y3RvciAobmFtZTogU3RyLCBDOiBDbGFzczxQcmltVmFsdWU+KSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgICB0aGlzLkMgPSBDXG4gICB9XG59XG5cbi8vIE5laXRoZXIgb2YgdGhlc2UgaXMgY3VycmVudGx5IHJlZmxlY3RpdmUgYmVjYXVzZSBvZiBub24tc3RhbmRhcmQgZmllbGRzLlxuZXhwb3J0IGNsYXNzIERhdGFUeXBlIHtcbiAgIG5hbWU6IFN0clxuICAgZWxpbUM6IENsYXNzPERhdGFFbGltPiAgICAgICAgICAgIFxuICAgY3RyczogTWFwPHN0cmluZywgQ3RyPiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzIG9mIG15IGNvbnN0cnVjdG9yc1xuICAgZXhwckPMhTogTWFwPHN0cmluZywgQ2xhc3M8RXhwci5EYXRhRXhwcj4+ICAvLyBcImV4cHJlc3Npb25cIiBjbGFzcyBwZXIgY29uc3RydWN0b3JcbiAgIGV4cGxDzIU6IE1hcDxzdHJpbmcsIENsYXNzPEV4cGwuRGF0YUV4cGw+PiAgLy8gXCJleHBsYW5hdGlvblwiIGNsYXNzIHBlciBjb25zdHJ1Y3RvclxuXG4gICBjb25zdHJ1Y3RvciAoXG4gICAgICBuYW1lOiBTdHIsXG4gICAgICBlbGltQzogQ2xhc3M8RGF0YUVsaW0+LCBcbiAgICAgIGN0cnM6IE1hcDxzdHJpbmcsIEN0cj4sIFxuICAgICAgZXhwckPMhTogTWFwPHN0cmluZywgQ2xhc3M8RXhwci5EYXRhRXhwcj4+LFxuICAgICAgZXhwbEPMhTogTWFwPHN0cmluZywgQ2xhc3M8RXhwbC5EYXRhRXhwbD4+XG4gICApIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICAgIHRoaXMuZWxpbUMgPSBlbGltQ1xuICAgICAgdGhpcy5jdHJzID0gY3Ryc1xuICAgICAgdGhpcy5leHByQ8yFID0gZXhwckPMhVxuICAgICAgdGhpcy5leHBsQ8yFID0gZXhwbEPMhVxuICAgfVxufVxuXG4vLyBDb25zdHJ1Y3RvciBvZiBhIGRhdGF0eXBlLCBub3QgdG8gYmUgY29uZnVzZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiBzdWNoIGEgdGhpbmcgKERhdGFWYWx1ZSkgb3IgbmFtZSBvZiBzdWNoIGEgdGhpbmdcbi8vIChMZXguQ3RyKS4gRmllbGRzIGhhdmUgYSB0b3RhbCBvcmRlcmluZyBnaXZlbiBieSB0aGUgb3JkZXIgb2YgZGVmaW5pdGlvbiBpbiB0aGUgY29ycmVzcG9uZGluZyBjbGFzcy5cbmV4cG9ydCBjbGFzcyBDdHIge1xuICAgQzogQ2xhc3M8RGF0YVZhbHVlPlxuICAgZsyFOiBzdHJpbmdbXVxuXG4gICBjb25zdHJ1Y3RvciAoQzogQ2xhc3M8RGF0YVZhbHVlPiwgZsyFOiBzdHJpbmdbXSkge1xuICAgICAgdGhpcy5DID0gQ1xuICAgICAgdGhpcy5mzIUgPSBmzIVcbiAgIH1cblxuICAgZ2V0IGFyaXR5ICgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuZsyFLmxlbmd0aFxuICAgfVxuXG4gICBnZXQgYyAoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiB0aGlzLkMubmFtZVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3RyRm9yIChjOiBzdHJpbmcpOiBDdHIge1xuICAgcmV0dXJuIF9fbm9uTnVsbChjdHJUb0RhdGFUeXBlLmdldChjKSwgYFVua25vd24gY29uc3RydWN0b3IgJHtjfS5gKS5jdHJzLmdldChjKSFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxDbGFzcyAoQzogQ2xhc3M8RGF0YVZhbHVlPik6IENsYXNzPEV4cGwuRGF0YUV4cGw+IHtcbiAgIHJldHVybiBfX25vbk51bGwoY3RyVG9EYXRhVHlwZS5nZXQoQy5uYW1lKSkuZXhwbEPMhS5nZXQoQy5uYW1lKSFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cHJDbGFzcyAoQzogQ2xhc3M8RGF0YVZhbHVlPik6IENsYXNzPEV4cHIuRGF0YUV4cHI+IHtcbiAgIHJldHVybiBfX25vbk51bGwoY3RyVG9EYXRhVHlwZS5nZXQoQy5uYW1lKSkuZXhwckPMhS5nZXQoQy5uYW1lKSFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlQ2xhc3MgKEM6IENsYXNzPEV4cHIuRGF0YUV4cHI+KTogQ2xhc3M8RGF0YVZhbHVlPiB7XG4gICByZXR1cm4gY3RyRm9yKEMubmFtZSkuQ1xufVxuXG4vLyBQb3B1bGF0ZWQgYnkgaW5pdERhdGFUeXBlcygpLiBDb25zdHJ1Y3RvcnMgYXJlIG5vdCB5ZXQgZmlyc3QtY2xhc3MuXG5leHBvcnQgY29uc3QgdHlwZXM6IE1hcDxzdHJpbmcsIERhdGFUeXBlIHwgUHJpbVR5cGU+ID0gbmV3IE1hcFxuZXhwb3J0IGNvbnN0IGN0clRvRGF0YVR5cGU6IE1hcDxzdHJpbmcsIERhdGFUeXBlPiA9IG5ldyBNYXBcbmV4cG9ydCBjb25zdCBlbGltVG9EYXRhVHlwZTogTWFwPHN0cmluZywgRGF0YVR5cGU+ID0gbmV3IE1hcFxuXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzM2MDU3NzUgZm9yIHRoZSBkeW5hbWljIGNsYXNzLW5hbWluZyBpZGlvbS5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RGF0YVR5cGU8VCBleHRlbmRzIERhdGFWYWx1ZT4gKEQ6IEFDbGFzczxUPiwgQ8yFOiBDbGFzczxUPltdKSB7XG4gICBDzIUuc29ydCgoQywgQ8q5KTogbnVtYmVyID0+IEMubmFtZS5sb2NhbGVDb21wYXJlKEPKuS5uYW1lKSkgLy8gY29uc2lzdGVudCB3aXRoIFN0ci5sZXFcbiAgIGNvbnN0IGN0cnM6IFtzdHJpbmcsIEN0cl1bXSA9IEPMhS5tYXAoXG4gICAgICAgICAgICAoQzogQ2xhc3M8VD4pOiBbc3RyaW5nLCBDdHJdID0+IFtDLm5hbWUsIG5ldyBDdHIoQywgZmllbGRzKG5ldyBDKSBhcyBzdHJpbmdbXSldXG4gICAgICAgICApLFxuICAgICAgICAgZWxpbUM6IENsYXNzPERhdGFFbGltPiA9IHtcbiAgICAgICAgICAgIFtELm5hbWVdOiBjbGFzcyBleHRlbmRzIERhdGFFbGltIHtcbiAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgICAgICAgICAgIHN1cGVyKClcbiAgICAgICAgICAgICAgICAgIC8vIGxleGljb2dyYXBoaWNhbCBvcmRlciBob3BlZnVsbHkgcHJlc2VydmVkIGJ5IGdldE93blByb3BlcnR5TmFtZXMoKVxuICAgICAgICAgICAgICAgICAgQ8yFLmZvckVhY2goKEM6IENsYXNzPFQ+KTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpW0MubmFtZV0gPSBfXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVtELm5hbWVdLFxuICAgICAgICAgZXhwckPMhTogW3N0cmluZywgQ2xhc3M8RXhwci5EYXRhRXhwcj5dW10gPSBjdHJzLm1hcCgoW2Nfc3RyLCBjXTogW3N0cmluZywgQ3RyXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtjX3N0ciwge1xuICAgICAgICAgICAgICAgW2Nfc3RyXTogY2xhc3MgZXh0ZW5kcyBFeHByLkRhdGFFeHByIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgICAgICAgICAgICAgIHN1cGVyKClcbiAgICAgICAgICAgICAgICAgICAgIGMuZsyFLmZvckVhY2goKGY6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgYXMgYW55KVtmXSA9IF9cbiAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9W2Nfc3RyXV1cbiAgICAgICAgIH0pLFxuICAgICAgICAgZXhwbEPMhTogW3N0cmluZywgQ2xhc3M8RXhwbC5EYXRhRXhwbD5dW10gPSBjdHJzLm1hcCgoW2Nfc3RyLCBjXTogW3N0cmluZywgQ3RyXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtjX3N0ciwge1xuICAgICAgICAgICAgICAgW2Nfc3RyXTogY2xhc3MgZXh0ZW5kcyBFeHBsLkRhdGFFeHBsIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgICAgICAgICAgICAgIHN1cGVyKClcbiAgICAgICAgICAgICAgICAgICAgIGMuZsyFLmZvckVhY2goKGY6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgYXMgYW55KVtmXSA9IF9cbiAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9W2Nfc3RyXV1cbiAgICAgICAgIH0pLFxuICAgICAgICAgZDogRGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoc3RyKEQubmFtZSkozr0oKSksIGVsaW1DLCBuZXcgTWFwKGN0cnMpLCBuZXcgTWFwKGV4cHJDzIUpLCBuZXcgTWFwKGV4cGxDzIUpKVxuICAgQ8yFLmZvckVhY2goKEM6IENsYXNzPFQ+KTogdm9pZCA9PiB7XG4gICAgICBjdHJUb0RhdGFUeXBlLnNldChDLm5hbWUsIGQpXG4gICB9KVxuICAgZWxpbVRvRGF0YVR5cGUuc2V0KEQubmFtZSwgZClcbiAgIHR5cGVzLnNldChkLm5hbWUudmFsLCBkKVxufVxuXG50eXBlcy5zZXQoTnVtLm5hbWUsIG5ldyBQcmltVHlwZShzdHIoTnVtLm5hbWUpKM69KCkpLCBOdW0pKVxudHlwZXMuc2V0KFN0ci5uYW1lLCBuZXcgUHJpbVR5cGUoc3RyKFN0ci5uYW1lKSjOvSgpKSwgU3RyKSlcbiIsImltcG9ydCB7IF9fbm9uTnVsbCwgY2xhc3NOYW1lIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi9FeHBsXCJcbmltcG9ydCB7IERhdGFWYWx1ZVRhZywgVmFsdWUsIF8sIG1ha2UgfSBmcm9tIFwiLi9WYWx1ZVwiXG5cbi8vIFZhbHVlIG9mIGEgZGF0YXR5cGUgY29uc3RydWN0b3I7IGNoaWxkcmVuIGFyZSBhbHdheXMgdXNlci1sZXZlbCB2YWx1ZXMgKGkuZS4gbm90IEVTNiBwcmltaXRpdmVzKS5cbmV4cG9ydCBjbGFzcyBEYXRhVmFsdWU8VGFnIGV4dGVuZHMgRGF0YVZhbHVlVGFnID0gRGF0YVZhbHVlVGFnPiBleHRlbmRzIFZhbHVlPFRhZz4ge1xuICAgZ2V0IGN0ciAoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWUodGhpcylcbiAgIH1cblxuICAgX19jaGlsZCAoazoga2V5b2YgdGhpcyk6IFZhbHVlIHtcbiAgICAgIHJldHVybiBzdXBlci5fX2NoaWxkKGspIGFzIFZhbHVlXG4gICB9XG5cbiAgIGdldCBfX2NoaWxkcmVuICgpOiBWYWx1ZVtdIHtcbiAgICAgIHJldHVybiBzdXBlci5fX2NoaWxkcmVuIGFzIFZhbHVlW11cbiAgIH1cbn1cblxuLy8gSGVyZSB0byBicmVhayBjeWNsaWMgZGVwZW5kZW5jeS5cbmV4cG9ydCBjbGFzcyBFeHBsVmFsdWU8VCBleHRlbmRzIFZhbHVlID0gVmFsdWU+IGV4dGVuZHMgRGF0YVZhbHVlPFwiRXhwbFZhbHVlXCI+IHtcbiAgIHQ6IEV4cGwgPSBfXG4gICB2OiBUID0gX1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwbFZhbHVlPFQgZXh0ZW5kcyBWYWx1ZSA9IFZhbHVlPiAodDogRXhwbCwgdjogVCk6IEV4cGxWYWx1ZTxUPiB7XG4gICByZXR1cm4gbWFrZShFeHBsVmFsdWUsIHQsIHYpIGFzIEV4cGxWYWx1ZTxUPlxufVxuIiwiaW1wb3J0IHsgYWJzdXJkLCBhc3NlcnQgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgT3JkIH0gZnJvbSBcIi4vdXRpbC9PcmRcIlxuaW1wb3J0IHsgUGVyc2lzdGVudCwgVmFsdWUsIGZpZWxkcywgbWVyZ2VJbnRvIH0gZnJvbSBcIi4vVmFsdWVcIlxuXG4vLyBEaWZmZXJlbmNlIGJldHdlZW4gdHdvIHN0YXRlcyAob2YgdGhlIHNhbWUgdmFsdWUgY2xhc3MpLiBTaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgbGlrZSBWYWx1ZSwgYW5kXG4vLyBwYXJhbWV0ZXJpc2VkIG9uIHR5cGUgb2YgdmFsdWVzIGJlaW5nIGNvbXBhcmVkLlxuZXhwb3J0IGludGVyZmFjZSBWYWx1ZURlbHRhIHtcbiAgIFtwcm9wOiBzdHJpbmddOiB7IGJlZm9yZTogUGVyc2lzdGVudCwgYWZ0ZXI6IFBlcnNpc3RlbnQgfSAvLyBbYmVmb3JlLCBhZnRlcl1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcSAoczE6IFZhbHVlRGVsdGEsIHMyOiBWYWx1ZURlbHRhKTogYm9vbGVhbiB7XG4gICByZXR1cm4gT2JqZWN0LmtleXMoczEpLmV2ZXJ5KChwcm9wOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgIHJldHVybiBzMi5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzMVtwcm9wXS5iZWZvcmUgPT09IHMyW3Byb3BdLmJlZm9yZSAmJiBzMVtwcm9wXS5hZnRlciA9PT0gczJbcHJvcF0uYWZ0ZXJcbiAgIH0pXG59XG5cbmZ1bmN0aW9uIGVtcHR5ICjhup86IFZhbHVlRGVsdGEpOiBib29sZWFuIHtcbiAgIHJldHVybiBmaWVsZHMo4bqfKS5sZW5ndGggPT09IDBcbn1cblxuZXhwb3J0IGNsYXNzIERlbHRhcyB7XG4gICDhup/MhTogTWFwPFZhbHVlLCBEZWx0YT4gPSBuZXcgTWFwKClcblxuICAgZ2V0IHNpemUgKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy7hup/MhS5zaXplXG4gICB9XG5cbiAgIC8vIENoYW5nZSBzZXRzIG11c3QgYmUgZGlzam9pbnQgYXQgYSBnaXZlbiByZXZpc2lvbi4gQmVjYXVzZSBvZiBzaGFyaW5nIHdpdGhpbiBhIHJldmlzaW9uLCBcbiAgIC8vIGEgbm9kZSBtYXkgZmlyc3QgYXBwZWFyIG5ldyAob3IgcmVjbGFzc2lmaWVkKSBhbmQgdGhlbiBsYXRlciBhcHBlYXIgY2hhbmdlZCwgYnV0IHRoZSBcbiAgIC8vIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgbXVzdCBiZSBlbXB0eS5cbiAgIGNoYW5nZWQgKHY6IFZhbHVlLCBzX+G6nzogVmFsdWVEZWx0YSk6IHZvaWQge1xuICAgICAgbGV0IHZf4bqfOiBEZWx0YSB8IHVuZGVmaW5lZCA9IHRoaXMu4bqfzIUuZ2V0KHYpXG4gICAgICBpZiAodl/hup8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy7hup/MhS5zZXQodiwgbmV3IENoYW5nZShzX+G6nykpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh2X+G6nyBpbnN0YW5jZW9mIENoYW5nZSkge1xuICAgICAgICAgbWVyZ2VJbnRvKHZf4bqfLmNoYW5nZWQsIHNf4bqfKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodl/hup8gaW5zdGFuY2VvZiBOZXcgfHwgdl/hup8gaW5zdGFuY2VvZiBSZWNsYXNzaWZ5KSB7XG4gICAgICAgICBhc3NlcnQoZW1wdHkoc1/hup8pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIC8vIEEgdmFsdWUgY2Fubm90IGJlIHJlY2xhc3NpZmllZCB0d2ljZSBhdCB0aGUgc2FtZSByZXZpc2lvbi5cbiAgIHJlY2xhc3NpZmllZCAodjogVmFsdWUpOiB2b2lkIHtcbiAgICAgIGxldCB2X+G6nzogRGVsdGEgfCB1bmRlZmluZWQgPSB0aGlzLuG6n8yFLmdldCh2KVxuICAgICAgaWYgKHZf4bqfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMu4bqfzIUuc2V0KHYsIG5ldyBSZWNsYXNzaWZ5KCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gQSB2YWx1ZSBjYW5ub3QgYmUgY3JlYXRlZCB0d2ljZSBhdCB0aGUgc2FtZSByZXZpc2lvbi5cbiAgIGNyZWF0ZWQgKHY6IFZhbHVlKTogdm9pZCB7XG4gICAgICBsZXQgdl/hup86IERlbHRhIHwgdW5kZWZpbmVkID0gdGhpcy7hup/MhS5nZXQodilcbiAgICAgIGlmICh2X+G6nyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aGlzLuG6n8yFLnNldCh2LCBuZXcgTmV3KCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgY2xlYXIgKCk6IHZvaWQge1xuICAgICAgdGhpcy7hup/MhS5jbGVhcigpXG4gICB9XG59XG5cbmV4cG9ydCBjb25zdCBfX2RlbHRhczogRGVsdGFzID0gbmV3IERlbHRhcygpXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEZWx0YSBpbXBsZW1lbnRzIE9yZDxEZWx0YT4ge1xuICAgYWJzdHJhY3QgbGVxICjhup86IERlbHRhKTogYm9vbGVhblxuXG4gICBlcSAo4bqfOiBEZWx0YSk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMubGVxKOG6nykgJiYg4bqfLmxlcSh0aGlzKVxuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmV3IGV4dGVuZHMgRGVsdGEge1xuICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuICAgfVxuXG4gICBsZXEgKOG6nzogRGVsdGEpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiDhup8gaW5zdGFuY2VvZiBOZXdcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENoYW5nZSBleHRlbmRzIERlbHRhIHtcbiAgIGNoYW5nZWQ6IFZhbHVlRGVsdGFcblxuICAgY29uc3RydWN0b3IgKGNoYW5nZWQ6IFZhbHVlRGVsdGEpIHtcbiAgICAgIHN1cGVyKClcbiAgICAgIHRoaXMuY2hhbmdlZCA9IGNoYW5nZWRcbiAgIH1cblxuICAgbGVxICjhup86IERlbHRhKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4g4bqfIGluc3RhbmNlb2YgQ2hhbmdlICYmIGxlcSh0aGlzLmNoYW5nZWQsIOG6ny5jaGFuZ2VkKVxuICAgfVxuXG4gICBoYXNDaGFuZ2VkIChwcm9wOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmaWVsZHModGhpcy5jaGFuZ2VkKS5pbmNsdWRlcyhwcm9wKVxuICAgfVxufVxuXG4vLyBDb25zdHJ1Y3RvciBoYXMgY2hhbmdlZCwgYW5kIHRoZXJlZm9yZSBmaWVsZHMgbWF5IG5vdCBhbGlnbi4gTW9yZSBzb3BoaXN0aWNhdGVkIHJlY2xhc3NpZmljYXRpb25cbi8vIGRlbHRhIGNvdWxkIGFsbG93IGZvciBmaWVsZHMgdG8gYmUgc2hhcmVkIHdoZW4gYW4gb2JqZWN0IGNoYW5nZXMgY2xhc3MuXG5leHBvcnQgY2xhc3MgUmVjbGFzc2lmeSBleHRlbmRzIERlbHRhIHtcbiAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcbiAgIH1cblxuICAgbGVxICjhup86IERlbHRhKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4g4bqfIGluc3RhbmNlb2YgUmVjbGFzc2lmeVxuICAgfVxufVxuIiwiaW1wb3J0IHsgYWJzdXJkIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IERhdGFWYWx1ZSwgRXhwbFZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IFN0ciwgXywgbWFrZSB9IGZyb20gXCIuL1ZhbHVlXCJcblxuLy8gRW52aXJvbm1lbnRzIGFyZSBzbm9jIGxpc3RzOyB0aGUgdmFsdWVzIGFyZSBcImV4cGxhaW5lZFwiIGJlY2F1c2UgdXNhZ2UgaW5mb3JtYXRpb24gaXMgcmVjb3JkZWQgb24gdHJhY2VzLlxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEVudiBleHRlbmRzIERhdGFWYWx1ZTxcIkVudlwiPiB7XG4gICBnZXQgKGs6IFN0cik6IEV4cGxWYWx1ZSB8IHVuZGVmaW5lZCB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEVtcHR5RW52KSB7XG4gICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXh0ZW5kRW52KSB7XG4gICAgICAgICBpZiAodGhpcy5rLnZhbCA9PT0gay52YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR2XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuz4EuZ2V0KGspXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG4gICBcbiAgIGhhcyAoazogU3RyKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaykgIT09IHVuZGVmaW5lZFxuICAgfVxuXG4gICBzdGF0aWMgc2luZ2xldG9uIChrOiBTdHIsIHR2OiBFeHBsVmFsdWUpOiBFeHRlbmRFbnYge1xuICAgICAgcmV0dXJuIGV4dGVuZEVudihlbXB0eUVudigpLCBrLCB0dilcbiAgIH1cbiAgIFxuICAgY29uY2F0ICjPgTogRW52KTogRW52IHtcbiAgICAgIGlmICjPgSBpbnN0YW5jZW9mIEVtcHR5RW52KSB7XG4gICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSBlbHNlXG4gICAgICBpZiAoz4EgaW5zdGFuY2VvZiBFeHRlbmRFbnYpIHtcbiAgICAgICAgIHJldHVybiBleHRlbmRFbnYodGhpcy5jb25jYXQoz4Euz4EpLCDPgS5rLCDPgS50dilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgdmFsdWVzICgpOiBFeHBsVmFsdWVbXSB7XG4gICAgICBjb25zdCB0dnM6IEV4cGxWYWx1ZVtdID0gW11cbiAgICAgIGZvciAobGV0IM+BOiBFbnYgPSB0aGlzOyDPgSBpbnN0YW5jZW9mIEV4dGVuZEVudjsgz4EgPSDPgS7PgSkge1xuICAgICAgICAgdHZzLnB1c2goz4EudHYpXG4gICAgICB9XG4gICAgICByZXR1cm4gdHZzXG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbXB0eUVudiBleHRlbmRzIEVudiB7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUVudiAoKTogRW1wdHlFbnYge1xuICAgcmV0dXJuIG1ha2UoRW1wdHlFbnYpXG59XG5cbmV4cG9ydCBjbGFzcyBFeHRlbmRFbnYgZXh0ZW5kcyBFbnYge1xuICAgz4E6IEVudiA9IF9cbiAgIGs6IFN0ciA9IF9cbiAgIHR2OiBFeHBsVmFsdWUgPSBfXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRFbnYgKM+BOiBFbnYsIGs6IFN0ciwgdHY6IEV4cGxWYWx1ZSk6IEV4dGVuZEVudiB7XG4gICByZXR1cm4gbWFrZShFeHRlbmRFbnYsIM+BLCBrLCB0dilcbn1cbiIsImltcG9ydCB7IHppcCB9IGZyb20gXCIuL3V0aWwvQXJyYXlcIlxuaW1wb3J0IHsgQ2xhc3MsIF9fbm9uTnVsbCwgYWJzdXJkLCBhcywgYXNzZXJ0LCBjbGFzc05hbWUsIGNsYXNzT2YsIHVzZXJFcnJvciB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBib29sXyB9IGZyb20gXCIuL3V0aWwvTGF0dGljZVwiXG5pbXBvcnQgeyBEaXJlY3Rpb24sIGlzzrEsIHNldGpvaW7OsSwgc2V0bWVldM6xLCBzZXTOsSB9IGZyb20gXCIuL0Fubm90YXRpb25cIlxuaW1wb3J0IHsgQ29ucywgTGlzdCwgTmlsLCBjb25zLCBuaWwgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRGF0YVR5cGUsIFByaW1UeXBlLCBjdHJUb0RhdGFUeXBlLCBleHBsQ2xhc3MsIGluaXREYXRhVHlwZSwgdHlwZXMsIHZhbHVlQ2xhc3MgfSBmcm9tIFwiLi9EYXRhVHlwZVwiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSwgZXhwbFZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IEVudiwgZW1wdHlFbnYsIGV4dGVuZEVudiB9IGZyb20gXCIuL0VudlwiXG5pbXBvcnQgeyBFeHBsIH0gZnJvbSBcIi4vRXhwbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4vRXhwclwiXG5pbXBvcnQgeyBnZXQgfSBmcm9tIFwiLi9GaW5pdGVNYXBcIlxuaW1wb3J0IHsgRWxpbSwgTWF0Y2gsIGFwcGx5X2J3ZCwgYXBwbHlfZndkIH0gZnJvbSBcIi4vTWF0Y2hcIlxuaW1wb3J0IHsgVW5hcnlPcCwgQmluYXJ5T3AsIGJpbmFyeU9wcywgdW5hcnlPcHMgfSBmcm9tIFwiLi9QcmltaXRpdmVcIlxuaW1wb3J0IHsgSWQsIE1lbW9JZCwgUHJpbVZhbHVlLCBOdW0sIFN0ciwgVGFnZ2VkSWQsIFZhbHVlLCBfLCBtZW1vSWQgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyBhdCwgbnVtLCBzdHIgfSBmcm9tIFwiLi9WZXJzaW9uZWRcIlxuXG50eXBlIERlZiA9IEV4cHIuRGVmXG50eXBlIFJlY0RlZiA9IEV4cHIuUmVjRGVmXG5cbmV4cG9ydCB0eXBlIEV4cGxJZCA9IFRhZ2dlZElkPFwidFwiPlxuZXhwb3J0IHR5cGUgVmFsSWQgPSBUYWdnZWRJZDxcInZcIj5cblxuZXhwb3J0IG1vZHVsZSBFdmFsIHtcblxuLy8gz4EgcGx1cyBiaW5kaW5ncyBpbiDOtCBhcmUgY2xvc2luZyBmb3IgZi5cbmV4cG9ydCBjbGFzcyBDbG9zdXJlIGV4dGVuZHMgRGF0YVZhbHVlPFwiQ2xvc3VyZVwiPiB7XG4gICDPgTogRW52ID0gXyBcbiAgIM60OiBMaXN0PFJlY0RlZj4gPSBfXG4gICBmOiBFbGltPEV4cHI+ID0gX1xufVxuXG5mdW5jdGlvbiBjbG9zdXJlICjPgTogRW52LCDOtDogTGlzdDxSZWNEZWY+LCBmOiBFbGltPEV4cHI+KTogKGs6IElkKSA9PiBDbG9zdXJlIHtcbiAgIHJldHVybiBhdChDbG9zdXJlLCDPgSwgzrQsIGYpXG59XG5cbi8vIEVudmlyb25tZW50cyBhcmUgc25vYy1saXN0cywgc28gdGhpcyAoaW5jb25zZXF1ZW50aWFsbHkpIHJldmVyc2VzIGRlY2xhcmF0aW9uIG9yZGVyLlxuZnVuY3Rpb24gcmVjRGVmcyAozrRfMDogTGlzdDxSZWNEZWY+LCDPgTogRW52LCDOtDogTGlzdDxSZWNEZWY+KTogW0xpc3Q8RXhwbC5SZWNEZWY+LCBFbnZdIHtcbiAgIGlmIChDb25zLmlzKM60KSkge1xuICAgICAgY29uc3QgZGVmOiBSZWNEZWYgPSDOtC5oZWFkLFxuICAgICAgICAgICAgW8604oKcLCDPgV9leHRdOiBbTGlzdDxFeHBsLlJlY0RlZj4sIEVudl0gPSByZWNEZWZzKM60XzAsIM+BLCDOtC50YWlsKSxcbiAgICAgICAgICAgIGs6IE1lbW9JZCA9IG1lbW9JZChyZWNEZWZzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgdGY6IEV4cGxWYWx1ZTxDbG9zdXJlPiA9IGV4cGxWYWx1ZShFeHBsLmZ1bihkZWYuz4MpKGsudGFnKFwidFwiKSksIGNsb3N1cmUoz4EsIM60XzAsIGRlZi7Pgykoay50YWcoXCJ2XCIpKSlcbiAgICAgIHJldHVybiBbY29ucyhFeHBsLnJlY0RlZihkZWYueCwgdGYpKGspLCDOtOKCnCksIGV4dGVuZEVudijPgV9leHQsIGRlZi54LCB0ZildXG4gICB9IGVsc2VcbiAgIGlmIChOaWwuaXMozrQpKSB7XG4gICAgICByZXR1cm4gW25pbCgpLCBlbXB0eUVudigpXVxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgfVxufVxuXG5mdW5jdGlvbiByZWNEZWZzXyAoZGlyOiBEaXJlY3Rpb24sIM60OiBMaXN0PEV4cGwuUmVjRGVmPik6IHZvaWQge1xuICAgaWYgKENvbnMuaXMozrQpKSB7XG4gICAgICB6aXAozrQuaGVhZC50Zi52Ls60LnRvQXJyYXkoKSwgzrQudG9BcnJheSgpKS5tYXAoKFtkZWYsIGRlZuKCnF06IFtSZWNEZWYsIEV4cGwuUmVjRGVmXSk6IHZvaWQgPT4ge1xuICAgICAgICAgYXNzZXJ0KGRlZi54LmVxKGRlZuKCnC54KSlcbiAgICAgICAgIGlmIChkaXIgPT09IERpcmVjdGlvbi5Gd2QpIHtcbiAgICAgICAgICAgIHNldM6xKGlzzrEoZGVmKSwgZGVm4oKcLnRmKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldGpvaW7OsShpc86xKGRlZuKCnC50ZiksIGRlZilcbiAgICAgICAgIH1cbiAgICAgIH0pXG4gICB9IGVsc2VcbiAgIGlmIChOaWwuaXMozrQpKSB7XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICB9XG59XG5cbi8vIEhlcmUgd2UgbXVzdG4ndCBpbnZlcnQgZGVmaW5pdGlvbiBvcmRlci5cbmV4cG9ydCBmdW5jdGlvbiBkZWZzICjPgTogRW52LCBkZWbMhTogTGlzdDxEZWY+LCDPgV9leHQ6IEVudik6IFtMaXN0PEV4cGwuRGVmPiwgRW52XSB7XG4gICBjb25zdCBrOiBNZW1vSWQgPSBtZW1vSWQoZGVmcywgYXJndW1lbnRzKVxuICAgaWYgKENvbnMuaXMoZGVmzIUpKSB7XG4gICAgICBjb25zdCBkZWY6IERlZiA9IGRlZsyFLmhlYWRcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCkge1xuICAgICAgICAgY29uc3QgdHY6IEV4cGxWYWx1ZSA9IGV2YWxfKM+BLmNvbmNhdCjPgV9leHQpLCBkZWYuZSksXG4gICAgICAgICAgICAgICBbZGVmzIXigpwsIM+BX2V4dMq5XTogW0xpc3Q8RXhwbC5EZWY+LCBFbnZdID0gZGVmcyjPgSwgZGVmzIUudGFpbCwgZXh0ZW5kRW52KM+BX2V4dCwgZGVmLngsIHR2KSlcbiAgICAgICAgIHJldHVybiBbY29ucyhFeHBsLmxldF8oZGVmLngsIHR2KShrKSwgZGVmzIXigpwpLCDPgV9leHTKuV1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuUHJpbSkge1xuICAgICAgICAgLy8gZmlyc3QtY2xhc3MgcHJpbWl0aXZlcyBjdXJyZW50bHkgaGFwcGVuIHRvIGJlIHVuYXJ5XG4gICAgICAgICBpZiAodW5hcnlPcHMuaGFzKGRlZi54LnZhbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRfb3A6IEV4cGxWYWx1ZTxVbmFyeU9wPiA9IHVuYXJ5T3BzLmdldChkZWYueC52YWwpISxcbiAgICAgICAgICAgICAgICAgIFtkZWbMheKCnCwgz4FfZXh0yrldOiBbTGlzdDxFeHBsLkRlZj4sIEVudl0gPSBkZWZzKM+BLCBkZWbMhS50YWlsLCBleHRlbmRFbnYoz4FfZXh0LCBkZWYueCwgdF9vcCkpXG4gICAgICAgICAgICByZXR1cm4gW2NvbnMoRXhwbC5wcmltKGRlZi54LCB0X29wKShrKSwgZGVmzIXigpwpLCDPgV9leHTKuV1cbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckVycm9yKGBObyBpbXBsZW1lbnRhdGlvbiBmb3VuZCBmb3IgcHJpbWl0aXZlIFwiJHtkZWYueC52YWx9XCIuYClcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuTGV0UmVjKSB7XG4gICAgICAgICBjb25zdCBbzrQsIM+B4bWfXTogW0xpc3Q8RXhwbC5SZWNEZWY+LCBFbnZdID0gcmVjRGVmcyhkZWYuzrQsIM+BLmNvbmNhdCjPgV9leHQpLCBkZWYuzrQpLFxuICAgICAgICAgICAgICAgW2RlZsyF4oKcLCDPgV9leHTKuV06IFtMaXN0PEV4cGwuRGVmPiwgRW52XSA9IGRlZnMoz4EsIGRlZsyFLnRhaWwsIM+BX2V4dC5jb25jYXQoz4HhtZ8pKVxuICAgICAgICAgcmV0dXJuIFtjb25zKEV4cGwubGV0UmVjKM60KShrKSwgZGVmzIXigpwpLCDPgV9leHTKuV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKE5pbC5pcyhkZWbMhSkpIHtcbiAgICAgIHJldHVybiBbbmlsKCksIM+BX2V4dF1cbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cblxuZnVuY3Rpb24gZGVmc19md2QgKGRlZsyFOiBMaXN0PERlZj4sIGRlZsyF4oKcOiBMaXN0PEV4cGwuRGVmPik6IHZvaWQge1xuICAgemlwKGRlZsyFLnRvQXJyYXkoKSwgZGVmzIXigpwudG9BcnJheSgpKS5mb3JFYWNoKChbZGVmLCBkZWbigpxdOiBbRGVmLCBFeHBsLkRlZl0pID0+IHtcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLkxldCkge1xuICAgICAgICAgZXZhbF9md2QoZGVmLmUsIGRlZuKCnC50dilcbiAgICAgICAgIHNldG1lZXTOsShpc86xKGRlZiksIGRlZuKCnC50dilcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuUHJpbSAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLlByaW0pIHtcbiAgICAgICAgIHNldM6xKGlzzrEoZGVmKSwgZGVm4oKcLnRfb3ApXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldFJlYyAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLkxldFJlYykge1xuICAgICAgICAgcmVjRGVmc18oRGlyZWN0aW9uLkZ3ZCwgZGVm4oKcLs60KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZCgpXG4gICAgICB9XG4gICB9KVxufVxuXG5mdW5jdGlvbiBkZWZzX2J3ZCAoZGVmzIU6IExpc3Q8RGVmPiwgZGVmzIXigpw6IExpc3Q8RXhwbC5EZWY+KTogdm9pZCB7XG4gICB6aXAoZGVmzIUudG9BcnJheSgpLCBkZWbMheKCnC50b0FycmF5KCkpLnJldmVyc2UoKS5mb3JFYWNoKChbZGVmLCBkZWbigpxdOiBbRGVmLCBFeHBsLkRlZl0pID0+IHtcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLkxldCkge1xuICAgICAgICAgc2V0am9pbs6xKGlzzrEoZGVm4oKcLnR2KSwgZGVmKVxuICAgICAgICAgZXZhbF9id2QoZGVmLmUsIGRlZuKCnC50dilcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuUHJpbSAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLlByaW0pIHtcbiAgICAgICAgIHNldGpvaW7OsShpc86xKGRlZuKCnC50X29wKSwgZGVmKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwci5MZXRSZWMgJiYgZGVm4oKcIGluc3RhbmNlb2YgRXhwbC5MZXRSZWMpIHtcbiAgICAgICAgIHJlY0RlZnNfKERpcmVjdGlvbi5Cd2QsIGRlZuKCnC7OtClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhYnN1cmQoKVxuICAgICAgfVxuICAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWxfICjPgTogRW52LCBlOiBFeHByKTogRXhwbFZhbHVlIHtcbiAgIGNvbnN0IGs6IE1lbW9JZCA9IG1lbW9JZChldmFsXywgYXJndW1lbnRzKSwgXG4gICAgICAgICBba+KCnCwga+G1pV06IFtFeHBsSWQsIFZhbElkXSA9IFtrLnRhZyhcInRcIiksIGsudGFnKFwidlwiKV1cbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5Db25zdE51bSkge1xuICAgICAgcmV0dXJuIGV4cGxWYWx1ZShFeHBsLmNvbnN0XygpKGvigpwpLCBudW0oZS52YWwudmFsKShr4bWlKSlcbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkNvbnN0U3RyKSB7XG4gICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuY29uc3RfKCkoa+KCnCksIHN0cihlLnZhbC52YWwpKGvhtaUpKVxuICAgfSBlbHNlXG4gICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuRnVuKSB7XG4gICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuZnVuKGUuz4MpKGvigpwpLCBjbG9zdXJlKM+BLCBuaWwoKSwgZS7Pgykoa+G1pSkpXG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5EYXRhRXhwcikge1xuICAgICAgY29uc3QgdHbMhTogRXhwbFZhbHVlW10gPSBlLl9fY2hpbGRyZW4ubWFwKChlOiBFeHByKSA9PiBldmFsXyjPgSwgZSkpLFxuICAgICAgICAgICAgQzogQ2xhc3M8RGF0YVZhbHVlPiA9IHZhbHVlQ2xhc3MoY2xhc3NPZihlKSksXG4gICAgICAgICAgICB0OiBFeHBsID0gYXQoZXhwbENsYXNzKEMpLCAuLi50dsyFLm1hcCgoe3R9KSA9PiB0KSkoa+KCnCksXG4gICAgICAgICAgICB2OiBWYWx1ZSA9IGF0KEMsIC4uLnR2zIUubWFwKCh7dn0pID0+IHYpKShr4bWlKVxuICAgICAgcmV0dXJuIGV4cGxWYWx1ZSh0LCB2KVxuICAgfSBlbHNlXG4gICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuUXVvdGUpIHtcbiAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5xdW90ZSgpKGvigpwpLCBlLmUpXG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5WYXIpIHtcbiAgICAgIGlmICjPgS5oYXMoZS54KSkge1xuICAgICAgICAgY29uc3Qge3QsIHZ9OiBFeHBsVmFsdWUgPSDPgS5nZXQoZS54KSFcbiAgICAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC52YXJfKGUueCwgdCkoa+KCnCksIHYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgVmFyaWFibGUgXCIke2UueC52YWx9XCIgbm90IGZvdW5kLmApXG4gICAgICB9XG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5BcHApIHtcbiAgICAgIGNvbnN0IFt0ZiwgdHVdOiBbRXhwbFZhbHVlLCBFeHBsVmFsdWVdID0gW2V2YWxfKM+BLCBlLmYpLCBldmFsXyjPgSwgZS5lKV0sXG4gICAgICAgICAgICBbdiwgdV06IFtWYWx1ZSwgVmFsdWVdID0gW3RmLnYsIHR1LnZdXG4gICAgICBpZiAodiBpbnN0YW5jZW9mIENsb3N1cmUpIHtcbiAgICAgICAgIGNvbnN0IFvOtCwgz4HhtZ9dOiBbTGlzdDxFeHBsLlJlY0RlZj4sIEVudl0gPSByZWNEZWZzKHYuzrQsIHYuz4EsIHYuzrQpLFxuICAgICAgICAgICAgICAgW8+ByrksIM6+zrpdOiBbRW52LCBNYXRjaDxFeHByPl0gPSB2LmYuYXBwbHkodHUpLFxuICAgICAgICAgICAgICAge3QsIHY6IHbKuX06IEV4cGxWYWx1ZSA9IGV2YWxfKHYuz4EuY29uY2F0KM+B4bWfLmNvbmNhdCjPgcq5KSksIM6+zrouzropXG4gICAgICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuYXBwKHRmIGFzIEV4cGxWYWx1ZTxDbG9zdXJlPiwgdHUsIM60LCDOvs66LCB0KShr4oKcKSwgdsq5KVxuICAgICAgfSBlbHNlIFxuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBVbmFyeU9wKSB7XG4gICAgICAgICBpZiAodSBpbnN0YW5jZW9mIE51bSB8fCB1IGluc3RhbmNlb2YgU3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwudW5hcnlBcHAodGYgYXMgRXhwbFZhbHVlPFVuYXJ5T3A+LCB0dSBhcyBFeHBsVmFsdWU8UHJpbVZhbHVlPikoa+KCnCksIHYub3AodSkoa+G1pSkpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgQXBwbHlpbmcgXCIke3YubmFtZX1cIiB0byBub24tcHJpbWl0aXZlIHZhbHVlLmAsIHUpXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgQ2Fubm90IGFwcGx5ICR7Y2xhc3NOYW1lKHYpfWApXG4gICAgICB9XG4gICB9IGVsc2VcbiAgIC8vIEJpbmFyeSBvcGVyYXRvcnMgYXJlIChjdXJyZW50bHkpIFwic3ludGF4XCIsIHJhdGhlciB0aGFuIGZpcnN0LWNsYXNzLlxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkJpbmFyeUFwcCkge1xuICAgICAgaWYgKGJpbmFyeU9wcy5oYXMoZS5vcE5hbWUudmFsKSkge1xuICAgICAgICAgY29uc3Qgb3A6IEJpbmFyeU9wID0gYmluYXJ5T3BzLmdldChlLm9wTmFtZS52YWwpIS52LFxuICAgICAgICAgICAgICAgW3R2MSwgdHYyXTogW0V4cGxWYWx1ZSwgRXhwbFZhbHVlXSA9IFtldmFsXyjPgSwgZS5lMSksIGV2YWxfKM+BLCBlLmUyKV0sXG4gICAgICAgICAgICAgICBbdjEsIHYyXTogW1ZhbHVlLCBWYWx1ZV0gPSBbdHYxLnYsIHR2Mi52XVxuICAgICAgICAgaWYgKCh2MSBpbnN0YW5jZW9mIE51bSB8fCB2MSBpbnN0YW5jZW9mIFN0cikgJiYgKHYyIGluc3RhbmNlb2YgTnVtIHx8IHYyIGluc3RhbmNlb2YgU3RyKSkge1xuICAgICAgICAgICAgY29uc3QgazogTWVtb0lkID0gbWVtb0lkKG9wLm9wLCBbdjEsIHYyXSlcbiAgICAgICAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5iaW5hcnlBcHAodHYxIGFzIEV4cGxWYWx1ZTxQcmltVmFsdWU+LCBlLm9wTmFtZSwgdHYyIGFzIEV4cGxWYWx1ZTxQcmltVmFsdWU+KShr4oKcKSwgb3Aub3AodjEsIHYyKShrKSlcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckVycm9yKGBBcHBseWluZyBcIiR7ZS5vcE5hbWUudmFsfVwiIHRvIG5vbi1wcmltaXRpdmUgdmFsdWUuYCwgdjEsIHYyKVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoYEJpbmFyeSBwcmltaXRpdmUgXCIke2Uub3BOYW1lLnZhbH1cIiBub3QgZm91bmQuYClcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkRlZnMpIHtcbiAgICAgIGNvbnN0IFtkZWbMheKCnCwgz4HKuV06IFtMaXN0PEV4cGwuRGVmPiwgRW52XSA9IGRlZnMoz4EsIGUuZGVmzIUsIGVtcHR5RW52KCkpLFxuICAgICAgICAgICAge3QsIHZ9OiBFeHBsVmFsdWUgPSBldmFsXyjPgS5jb25jYXQoz4HKuSksIGUuZSlcbiAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5kZWZzKGRlZsyF4oKcLCB0KShr4oKcKSwgdilcbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLk1hdGNoQXMpIHtcbiAgICAgIGNvbnN0IHR1OiBFeHBsVmFsdWUgPSBldmFsXyjPgSwgZS5lKSxcbiAgICAgICAgICAgIFvPgcq5LCDOvs66XTogW0VudiwgTWF0Y2g8RXhwcj5dID0gZS7Pgy5hcHBseSh0dSksXG4gICAgICAgICAgICB7dCwgdn06IEV4cGxWYWx1ZSA9IGV2YWxfKM+BLmNvbmNhdCjPgcq5KSwgzr7Oui7OuilcbiAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5tYXRjaEFzKHR1LCDOvs66LCB0KShr4oKcKSwgdilcbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLlR5cGVtYXRjaCkge1xuICAgICAgY29uc3QgdHU6IEV4cGxWYWx1ZSA9IGV2YWxfKM+BLCBlLmUpLFxuICAgICAgICAgICAgZDogRGF0YVR5cGUgfCBQcmltVHlwZSA9IGN0clRvRGF0YVR5cGUuZ2V0KGNsYXNzTmFtZSh0dS52KSkgfHwgdHlwZXMuZ2V0KGNsYXNzTmFtZSh0dS52KSkhLFxuICAgICAgICAgICAgZcq5OiBFeHByIHwgdW5kZWZpbmVkID0gZ2V0KGUuY2FzZXMsIGQubmFtZSlcbiAgICAgIGlmIChlyrkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgVHlwZWNhc2UgbWlzbWF0Y2g6IG5vIGNsYXVzZSBmb3IgJHtjbGFzc05hbWUodHUudil9LmApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY29uc3Qge3QsIHZ9OiBFeHBsVmFsdWUgPSBldmFsXyjPgSwgZcq5KVxuICAgICAgICAgcmV0dXJuIGV4cGxWYWx1ZShFeHBsLnR5cGVtYXRjaCh0dSwgZC5uYW1lLCB0KShr4oKcKSwgdilcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKGBVbmltcGxlbWVudGVkIGV4cHJlc3Npb24gZm9ybTogJHtjbGFzc05hbWUoZSl9LmApXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsX2Z3ZCAoZTogRXhwciwgdHY6IEV4cGxWYWx1ZSk6IHZvaWQge1xuICAgY29uc3Qge3QsIHZ9OiBFeHBsVmFsdWUgPSB0dlxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkNvbnN0ICYmICh2IGluc3RhbmNlb2YgTnVtIHx8IHYgaW5zdGFuY2VvZiBTdHIpKSB7XG4gICAgICBzZXTOsShpc86xKGUpLCB0dilcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkZ1biAmJiB2IGluc3RhbmNlb2YgQ2xvc3VyZSkge1xuICAgICAgc2V0zrEoaXPOsShlKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5RdW90ZSkge1xuICAgICAgc2V0zrEoaXPOsShlKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5WYXIpIHtcbiAgICAgIHNldM6xKGJvb2xfLm1lZXQoaXPOsShlKSwgaXPOsShleHBsVmFsdWUodC50LCB2KSkpLCB0dilcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkRhdGFFeHBsKSB7XG4gICAgICBpZiAodiBpbnN0YW5jZW9mIERhdGFWYWx1ZSkge1xuICAgICAgICAgY29uc3QgZcq5OiBFeHByLkRhdGFFeHByID0gYXMoZSwgRXhwci5EYXRhRXhwcilcbiAgICAgICAgIHppcChFeHBsLmV4cGxDaGlsZHJlbih0LCB2KSwgZcq5Ll9fY2hpbGRyZW4pLm1hcCgoW3R2LCBlXSkgPT4gZXZhbF9md2QoZSwgdHYpKVxuICAgICAgICAgc2V0zrEoaXPOsShlKSwgdHYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgYWJzdXJkKClcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkFwcCkge1xuICAgICAgY29uc3QgZcq5OiBFeHByLkFwcCA9IGFzKGUsIEV4cHIuQXBwKVxuICAgICAgZXZhbF9md2QoZcq5LmYsIHQudGYpXG4gICAgICBldmFsX2Z3ZChlyrkuZSwgdC50dSlcbiAgICAgIHJlY0RlZnNfKERpcmVjdGlvbi5Gd2QsIHQuzrQpXG4gICAgICBldmFsX2Z3ZCh0Ls6+Ls66LCBleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIHNldM6xKGJvb2xfLm1lZXQoaXPOsSh0LnRmKSwgYXBwbHlfZndkKHQuzr4pLCBpc86xKGUpLCBpc86xKGV4cGxWYWx1ZSh0LnQsIHYpKSksIHR2KVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuVW5hcnlBcHApIHtcbiAgICAgIGNvbnN0IGXKuTogRXhwci5BcHAgPSBhcyhlLCBFeHByLkFwcClcbiAgICAgIGV2YWxfZndkKGXKuS5mLCB0LnRmKVxuICAgICAgZXZhbF9md2QoZcq5LmUsIHQudHYpXG4gICAgICBzZXTOsShib29sXy5tZWV0KGlzzrEodC50ZiksIGlzzrEodC50diksIGlzzrEoZSkpLCB0dilcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkJpbmFyeUFwcCkge1xuICAgICAgY29uc3QgZcq5OiBFeHByLkJpbmFyeUFwcCA9IGFzKGUsIEV4cHIuQmluYXJ5QXBwKVxuICAgICAgZXZhbF9md2QoZcq5LmUxLCB0LnR2MSlcbiAgICAgIGV2YWxfZndkKGXKuS5lMiwgdC50djIpXG4gICAgICBzZXTOsShib29sXy5tZWV0KGlzzrEodC50djEpLCBpc86xKHQudHYyKSwgaXPOsShlKSksIHR2KVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuRGVmcykge1xuICAgICAgY29uc3QgZcq5OiBFeHByLkRlZnMgPSBhcyhlLCBFeHByLkRlZnMpXG4gICAgICBkZWZzX2Z3ZChlyrkuZGVmzIUsIHQuZGVmzIUpXG4gICAgICBldmFsX2Z3ZChlyrkuZSwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBzZXTOsShib29sXy5tZWV0KGlzzrEoZSksIGlzzrEoZXhwbFZhbHVlKHQudCwgdikpKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5NYXRjaEFzKSB7XG4gICAgICBjb25zdCBlyrk6IEV4cHIuTWF0Y2hBcyA9IGFzKGUsIEV4cHIuTWF0Y2hBcylcbiAgICAgIGV2YWxfZndkKGXKuS5lLCB0LnR1KVxuICAgICAgZXZhbF9md2QodC7Ovi7OuiwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBzZXTOsShib29sXy5tZWV0KGFwcGx5X2Z3ZCh0Ls6+KSwgaXPOsShlKSwgaXPOsShleHBsVmFsdWUodC50LCB2KSkpLCB0dilcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlR5cGVtYXRjaCkge1xuICAgICAgY29uc3QgZcq5OiBFeHByLlR5cGVtYXRjaCA9IGFzKGUsIEV4cHIuVHlwZW1hdGNoKVxuICAgICAgZXZhbF9md2QoZcq5LmUsIHQudHUpXG4gICAgICBldmFsX2Z3ZChnZXQoZcq5LmNhc2VzLCB0LmQpISwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBzZXTOsShib29sXy5tZWV0KGlzzrEoZSksIGlzzrEoZXhwbFZhbHVlKHQudCwgdikpKSwgdHYpXG4gICB9IGVsc2Uge1xuICAgICAgYWJzdXJkKClcbiAgIH1cbn1cblxuLy8gQXZvaWQgZXhjZXNzaXZlIGpvaW5zIHZpYSBhIG1lcmdpbmcgaW1wbGVtZW50YXRpb247IHJlcXVpcmVzIGFsbCBhbm5vdGF0aW9ucyB0byBoYXZlIGJlZW4gY2xlYXJlZCBmaXJzdC5cbmV4cG9ydCBmdW5jdGlvbiBldmFsX2J3ZCAoZTogRXhwciwgdHY6IEV4cGxWYWx1ZSk6IHZvaWQge1xuICAgY29uc3Qge3QsIHZ9OiBFeHBsVmFsdWUgPSB0dlxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkNvbnN0ICYmICh2IGluc3RhbmNlb2YgTnVtIHx8IHYgaW5zdGFuY2VvZiBTdHIpKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5GdW4gJiYgdiBpbnN0YW5jZW9mIENsb3N1cmUpIHtcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkRhdGFFeHBsKSB7XG4gICAgICBpZiAodiBpbnN0YW5jZW9mIERhdGFWYWx1ZSkge1xuICAgICAgICAgY29uc3QgZcq5OiBFeHByLkRhdGFFeHByID0gYXMoZSwgRXhwci5EYXRhRXhwcilcbiAgICAgICAgIC8vIHJldmVyc2Ugb3JkZXIgYnV0IHNob3VsZG4ndCBtYXR0ZXIgaW4gYWJzZW5jZSBvZiBzaWRlLWVmZmVjdHM6XG4gICAgICAgICB6aXAoRXhwbC5leHBsQ2hpbGRyZW4odCwgdiksIGXKuS5fX2NoaWxkcmVuKS5tYXAoKFt0diwgZV0pID0+IGV2YWxfYndkKGUsIHR2KSlcbiAgICAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhYnN1cmQoKVxuICAgICAgfVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuUXVvdGUpIHtcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlZhcikge1xuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCBleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkFwcCkge1xuICAgICAgYXNzZXJ0KHQudGYudiBpbnN0YW5jZW9mIENsb3N1cmUpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgZXZhbF9id2QodC7Ovi7OuiwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBhcHBseV9id2QodC7OviwgaXPOsSh0dikpXG4gICAgICByZWNEZWZzXyhEaXJlY3Rpb24uQndkLCB0Ls60KVxuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCB0LnRmKVxuICAgICAgY29uc3QgZcq5OiBFeHByLkFwcCA9IGFzKGUsIEV4cHIuQXBwKVxuICAgICAgZXZhbF9id2QoZcq5LmYsIHQudGYpXG4gICAgICBldmFsX2J3ZChlyrkuZSwgdC50dSlcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlVuYXJ5QXBwKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIHQudGYpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIHQudHYpXG4gICAgICBjb25zdCBlyrk6IEV4cHIuQXBwID0gYXMoZSwgRXhwci5BcHApXG4gICAgICBldmFsX2J3ZChlyrkuZiwgdC50ZilcbiAgICAgIGV2YWxfYndkKGXKuS5lLCB0LnR2KVxuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCBlKVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuQmluYXJ5QXBwKSB7XG4gICAgICBhc3NlcnQoYmluYXJ5T3BzLmhhcyh0Lm9wTmFtZS52YWwpKVxuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCB0LnR2MSlcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgdC50djIpXG4gICAgICBjb25zdCBlyrk6IEV4cHIuQmluYXJ5QXBwID0gYXMoZSwgRXhwci5CaW5hcnlBcHApXG4gICAgICBldmFsX2J3ZChlyrkuZTEsIHQudHYxKVxuICAgICAgZXZhbF9id2QoZcq5LmUyLCB0LnR2MilcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkRlZnMpIHtcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBjb25zdCBlyrk6IEV4cHIuRGVmcyA9IGFzKGUsIEV4cHIuRGVmcylcbiAgICAgIGV2YWxfYndkKGXKuS5lLCBleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIGRlZnNfYndkKGXKuS5kZWbMhSwgdC5kZWbMhSlcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLk1hdGNoQXMpIHtcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBjb25zdCBlyrk6IEV4cHIuTWF0Y2hBcyA9IGFzKGUsIEV4cHIuTWF0Y2hBcylcbiAgICAgIGV2YWxfYndkKHQuzr4uzrosIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgYXBwbHlfYndkKHQuzr4sIGlzzrEodHYpKVxuICAgICAgZXZhbF9id2QoZcq5LmUsIHQudHUpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5UeXBlbWF0Y2gpIHtcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBjb25zdCBlyrk6IEV4cHIuVHlwZW1hdGNoID0gYXMoZSwgRXhwci5UeXBlbWF0Y2gpXG4gICAgICBldmFsX2J3ZChnZXQoZcq5LmNhc2VzLCB0LmQpISwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBldmFsX2J3ZChlyrkuZSwgdC50dSlcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZSB7XG4gICAgICBhYnN1cmQoKVxuICAgfVxufVxuXG59XG5cbmluaXREYXRhVHlwZShcbiAgIEV4cHIuRXhwcixcbiAgIFtFeHByLkFwcCwgRXhwci5CaW5hcnlBcHAsIEV4cHIuQ29uc3ROdW0sIEV4cHIuQ29uc3RTdHIsIEV4cHIuRGF0YUV4cHIsIEV4cHIuRGVmcywgRXhwci5GdW4sIEV4cHIuTWF0Y2hBcywgRXhwci5RdW90ZSwgRXhwci5WYXJdXG4pXG4iLCJpbXBvcnQgeyBfX25vbk51bGwsIGFic3VyZCwgYXNzZXJ0LCBjbGFzc05hbWUgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgTGlzdCB9IGZyb20gXCIuL0Jhc2VUeXBlc1wiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSwgZXhwbFZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IEV2YWwgfSBmcm9tIFwiLi9FdmFsXCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi9FeHByXCJcbmltcG9ydCB7IEVsaW0sIE1hdGNoIH0gZnJvbSBcIi4vTWF0Y2hcIlxuaW1wb3J0IHsgVW5hcnlPcCB9IGZyb20gXCIuL1ByaW1pdGl2ZVwiXG5pbXBvcnQgeyBJZCwgUHJpbVZhbHVlLCBTdHIsIF8sIGZpZWxkcyB9IGZyb20gXCIuL1ZhbHVlXCJcbmltcG9ydCB7IGF0IH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuZXhwb3J0IHR5cGUgQ2xvc3VyZSA9IEV2YWwuQ2xvc3VyZVxuZXhwb3J0IHR5cGUgRXhwbCA9IEV4cGwuRXhwbFxuXG5leHBvcnQgbmFtZXNwYWNlIEV4cGwge1xuICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEV4cGwgZXh0ZW5kcyBEYXRhVmFsdWU8XCJFeHBsXCI+IHtcbiAgIH1cblxuICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5vblRlcm1pbmFsIGV4dGVuZHMgRXhwbCB7XG4gICAgICBhYnN0cmFjdCB0OiBFeHBsXG4gICB9XG5cbiAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUZXJtaW5hbCBleHRlbmRzIEV4cGwge1xuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgQXBwIGV4dGVuZHMgTm9uVGVybWluYWwge1xuICAgICAgdGY6IEV4cGxWYWx1ZTxDbG9zdXJlPiA9IF9cbiAgICAgIHR1OiBFeHBsVmFsdWUgPSBfXG4gICAgICDOtDogTGlzdDxSZWNEZWY+ID0gXyAvLyBhZGRpdGlvbmFsIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgYm91bmQgYXQgdGhpcyBzdGVwXG4gICAgICDOvjogTWF0Y2g8RXhwcj4gPSBfXG4gICAgICB0OiBFeHBsID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gYXBwICh0ZjogRXhwbFZhbHVlPENsb3N1cmU+LCB0dTogRXhwbFZhbHVlLCDOtDogTGlzdDxSZWNEZWY+LCDOvjogTWF0Y2g8RXhwcj4sIHQ6IEV4cGwpOiAoazogSWQpID0+IEFwcCB7XG4gICAgICByZXR1cm4gYXQoQXBwLCB0ZiwgdHUsIM60LCDOviwgdClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFVuYXJ5QXBwIGV4dGVuZHMgVGVybWluYWwge1xuICAgICAgdGY6IEV4cGxWYWx1ZTxVbmFyeU9wPiA9IF9cbiAgICAgIHR2OiBFeHBsVmFsdWU8UHJpbVZhbHVlPiA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHVuYXJ5QXBwICh0ZjogRXhwbFZhbHVlPFVuYXJ5T3A+LCB0djogRXhwbFZhbHVlPFByaW1WYWx1ZT4pOiAoazogSWQpID0+IFVuYXJ5QXBwIHtcbiAgICAgIHJldHVybiBhdChVbmFyeUFwcCwgdGYsIHR2KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgQmluYXJ5QXBwIGV4dGVuZHMgVGVybWluYWwge1xuICAgICAgdHYxOiBFeHBsVmFsdWU8UHJpbVZhbHVlPiA9IF9cbiAgICAgIG9wTmFtZTogU3RyID0gX1xuICAgICAgdHYyOiBFeHBsVmFsdWU8UHJpbVZhbHVlPiA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeUFwcCAodHYxOiBFeHBsVmFsdWU8UHJpbVZhbHVlPiwgb3BOYW1lOiBTdHIsIHR2MjogRXhwbFZhbHVlPFByaW1WYWx1ZT4pOiAoazogSWQpID0+IEJpbmFyeUFwcCB7XG4gICAgICByZXR1cm4gYXQoQmluYXJ5QXBwLCB0djEsIG9wTmFtZSwgdHYyKVxuICAgfVxuXG4gICAvLyBIYXMgYSBjb25jcmV0ZSBzdWJjbGFzcyBmb3IgZWFjaCBkYXRhdHlwZS5cbiAgIGV4cG9ydCBjbGFzcyBEYXRhRXhwbCBleHRlbmRzIFRlcm1pbmFsIHtcbiAgICAgIGdldCBjdHIgKCk6IHN0cmluZyB7XG4gICAgICAgICByZXR1cm4gY2xhc3NOYW1lKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGdldCBfX2NoaWxkcmVuICgpOiBFeHBsW10ge1xuICAgICAgICAgcmV0dXJuIHN1cGVyLl9fY2hpbGRyZW4gYXMgRXhwbFtdXG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEZWYgZXh0ZW5kcyBEYXRhVmFsdWU8XCJFeHBsLkRlZlwiPiB7XG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBMZXQgZXh0ZW5kcyBEZWYge1xuICAgICAgeDogU3RyID0gX1xuICAgICAgdHY6IEV4cGxWYWx1ZSA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGxldF8gKHg6IFN0ciwgdHY6IEV4cGxWYWx1ZSk6IChrOiBJZCkgPT4gTGV0IHtcbiAgICAgIHJldHVybiBhdChMZXQsIHgsIHR2KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgUHJpbSBleHRlbmRzIERlZiB7XG4gICAgICB4OiBTdHIgPSBfXG4gICAgICB0X29wOiBFeHBsVmFsdWU8VW5hcnlPcD4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBwcmltICh4OiBTdHIsIHRfb3A6IEV4cGxWYWx1ZTxVbmFyeU9wPik6IChrOiBJZCkgPT4gUHJpbSB7XG4gICAgICByZXR1cm4gYXQoUHJpbSwgeCwgdF9vcClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFJlY0RlZiBleHRlbmRzIERhdGFWYWx1ZTxcIkV4cGwuUmVjRGVmXCI+IHtcbiAgICAgIHg6IFN0ciA9IF9cbiAgICAgIHRmOiBFeHBsVmFsdWU8Q2xvc3VyZT4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiByZWNEZWYgKHg6IFN0ciwgdGY6IEV4cGxWYWx1ZTxDbG9zdXJlPik6IChrOiBJZCkgPT4gUmVjRGVmIHtcbiAgICAgIHJldHVybiBhdChSZWNEZWYsIHgsIHRmKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgTGV0UmVjIGV4dGVuZHMgRGVmIHtcbiAgICAgIM60OiBMaXN0PFJlY0RlZj4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBsZXRSZWMgKM60OiBMaXN0PFJlY0RlZj4pOiAoazogSWQpID0+IExldFJlYyB7XG4gICAgICByZXR1cm4gYXQoTGV0UmVjLCDOtClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIERlZnMgZXh0ZW5kcyBOb25UZXJtaW5hbCB7XG4gICAgICBkZWbMhTogTGlzdDxEZWY+ID0gX1xuICAgICAgdDogRXhwbCA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGRlZnMgKGRlZsyFOiBMaXN0PERlZj4sIHQ6IEV4cGwpOiAoazogSWQpID0+IERlZnMge1xuICAgICAgcmV0dXJuIGF0KERlZnMsIGRlZsyFLCB0KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgQ29uc3QgZXh0ZW5kcyBUZXJtaW5hbCB7XG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBjb25zdF8gKCk6IChrOiBJZCkgPT4gQ29uc3Qge1xuICAgICAgcmV0dXJuIGF0KENvbnN0KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgRnVuIGV4dGVuZHMgVGVybWluYWwge1xuICAgICAgz4M6IEVsaW08RXhwcj4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBmdW4gKM+DOiBFbGltPEV4cHI+KTogKGs6IElkKSA9PiBGdW4ge1xuICAgICAgcmV0dXJuIGF0KEZ1biwgz4MpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBNYXRjaEFzIGV4dGVuZHMgTm9uVGVybWluYWwge1xuICAgICAgdHU6IEV4cGxWYWx1ZSA9IF9cbiAgICAgIM6+OiBNYXRjaDxFeHByPiA9IF9cbiAgICAgIHQ6IEV4cGwgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBtYXRjaEFzICh0dTogRXhwbFZhbHVlLCDOvjogTWF0Y2g8RXhwcj4sIHQ6IEV4cGwpOiAoazogSWQpID0+IE1hdGNoQXMge1xuICAgICAgcmV0dXJuIGF0KE1hdGNoQXMsIHR1LCDOviwgdClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFF1b3RlIGV4dGVuZHMgVGVybWluYWwge1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gcXVvdGUgKCk6IChrOiBJZCkgPT4gUXVvdGUge1xuICAgICAgcmV0dXJuIGF0KFF1b3RlKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgVHlwZW1hdGNoIGV4dGVuZHMgTm9uVGVybWluYWwge1xuICAgICAgdHU6IEV4cGxWYWx1ZSA9IF9cbiAgICAgIGQ6IFN0ciA9IF9cbiAgICAgIHQ6IEV4cGwgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiB0eXBlbWF0Y2ggKHR1OiBFeHBsVmFsdWUsIGQ6IFN0ciwgdDogRXhwbCk6IChrOiBJZCkgPT4gVHlwZW1hdGNoIHtcbiAgICAgIHJldHVybiBhdChUeXBlbWF0Y2gsIHR1LCBkLCB0KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgVmFyIGV4dGVuZHMgTm9uVGVybWluYWwge1xuICAgICAgeDogU3RyID0gX1xuICAgICAgdDogRXhwbCA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHZhcl8gKHg6IFN0ciwgdDogRXhwbCk6IChrOiBJZCkgPT4gVmFyIHtcbiAgICAgIHJldHVybiBhdChWYXIsIHgsIHQpXG4gICB9XG5cbiAgIC8vIFNob3VsZCBwcm9iYWJseSBkbyBhIGJldHRlciBqb2Igb2YgcmVzdHJpY3RpbmcgayB0byBiZSBhIGJvbmEgZmlkZSBmaWVsZCBuYW1lLlxuICAgZXhwb3J0IGZ1bmN0aW9uIGV4cGxDaGlsZDxUIGV4dGVuZHMgRGF0YVZhbHVlPiAodDogRXhwbCwgdjogVCwgcHJvcDoga2V5b2YgVCk6IEV4cGxWYWx1ZSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICBhc3NlcnQodCBpbnN0YW5jZW9mIERhdGFFeHBsKVxuICAgICAgICAgcmV0dXJuIGV4cGxWYWx1ZSh0Ll9fY2hpbGQocHJvcCBhcyBrZXlvZiBFeHBsKSBhcyBFeHBsLCB2Ll9fY2hpbGQocHJvcCkpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgIHJldHVybiBleHBsQ2hpbGQodC50LCB2LCBwcm9wKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIFByaW1pdGl2ZSBhcHBsaWNhdGlvbnMgYXJlIGN1cnJlbnRseSBcInRlcm1pbmFsXCIgZm9ybXMsIHdoaWNoIGlzIHRlY2huaWNhbGx5IGluY29uc2lzdGVudCB3aXRoIHRoZSBmYWN0IFxuICAgICAgICAgLy8gdGhhdCB0aGV5IGNhbiByZXR1cm4gc3RydWN0dXJlZCBkYXRhLiBJbiBwcmFjdGljZSB0aGlzIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2UgdGhleSBvbmx5IHJldHVybiB2YWx1ZXMgXG4gICAgICAgICAvLyBsaWtlIFRydWUgYW5kIEZhbHNlLCB3aGljaCBoYXZlIG5vIGNoaWxkcmVuLiBQcm9iYWJseSBwcmltaXRpdmVzIHNob3VsZCBiZSBub24tdGVybWluYWwuXG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGV4cGxDaGlsZHJlbiAodDogRXhwbCwgdjogRGF0YVZhbHVlKTogRXhwbFZhbHVlW10ge1xuICAgICAgcmV0dXJuIGZpZWxkcyh2KS5tYXAoayA9PiBleHBsQ2hpbGQodCwgdiwgayBhcyBhbnkpKVxuICAgfVxufVxuIiwiaW1wb3J0IHsgX19ub25OdWxsLCBhYnN1cmQsIGNsYXNzTmFtZSB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBkaWZmLCB1bmlvbiB9IGZyb20gXCIuL3V0aWwvU2V0XCJcbmltcG9ydCB7IENvbnMsIExpc3QsIE5pbCB9IGZyb20gXCIuL0Jhc2VUeXBlc1wiXG5pbXBvcnQgeyBEYXRhVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgRmluaXRlTWFwIH0gZnJvbSBcIi4vRmluaXRlTWFwXCJcbmltcG9ydCB7IEVsaW0sIERhdGFFbGltLCBWYXJFbGltIH0gZnJvbSBcIi4vTWF0Y2hcIlxuaW1wb3J0IHsgSWQsIE51bSwgU3RyLCBfIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgYXQgfSBmcm9tIFwiLi9WZXJzaW9uZWRcIlxuXG4vLyBDb25zdGFudHMgdXNlZCBmb3IgcGFyc2luZywgYW5kIGFsc28gZm9yIHRvU3RyaW5nKCkgaW1wbGVtZW50YXRpb25zLlxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gICBhcnJvdzogXCLihpJcIixcbiAgIGFzOiBcImFzXCIsXG4gICBicmFja2V0TDogXCJbXCIsXG4gICBicmFja2V0UjogXCJdXCIsXG4gICBjb21tYTogXCIsXCIsXG4gICBjdXJseUw6IFwie1wiLFxuICAgY3VybHlSOiBcIn1cIixcbiAgIGVsbGlwc2lzOiBcIi4uLlwiLFxuICAgZXF1YWxzOiBcIj1cIixcbiAgIGZ1bjogXCJmdW5cIixcbiAgIGluXzogXCJpblwiLFxuICAgbGV0XzogXCJsZXRcIixcbiAgIGxldFJlYzogXCJsZXRyZWNcIixcbiAgIG1hdGNoOiBcIm1hdGNoXCIsXG4gICBwcmltaXRpdmU6IFwicHJpbWl0aXZlXCIsXG4gICBwYXJlbkw6IFwiKFwiLFxuICAgcGFyZW5SOiBcIilcIixcbiAgIHF1b3RlczogJ1wiJyxcbiAgIHNlbWljb2xvbjogXCI7XCIsXG4gICB0eXBlbWF0Y2g6IFwidHlwZW1hdGNoXCJcbn1cblxuZXhwb3J0IHR5cGUgRXhwciA9IEV4cHIuRXhwclxuZXhwb3J0IHR5cGUgQ29udCA9IEV4cHIuQ29udFxuXG5leHBvcnQgbmFtZXNwYWNlIEV4cHIge1xuICAgLy8gVXNlIHRvIGJlIGEgcGFyYW1ldGVyaXNlZCBjbGFzcyBidXQgd2UgY2FuIHNpbXBsaWZ5IHVzaW5nIG91ciBub21pbmFsIHR5cGUgaWRpb20uXG4gICBleHBvcnQgdHlwZSBDb250ID0gRXhwciB8IERhdGFWYWx1ZTxcIkVsaW1cIj5cblxuICAgdHlwZSBTeW50YXhOb2RlVGFnID0gXCJFeHByXCIgfCBcIkV4cHIuRGVmXCIgfCBcIkV4cHIuUmVjRGVmXCJcblxuICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN5bnRheE5vZGU8VGFnIGV4dGVuZHMgU3ludGF4Tm9kZVRhZyA9IFN5bnRheE5vZGVUYWc+IGV4dGVuZHMgRGF0YVZhbHVlPFRhZz4ge1xuICAgfVxuXG4gICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRXhwciBleHRlbmRzIFN5bnRheE5vZGU8XCJFeHByXCI+IHtcbiAgIH1cbiAgIFxuICAgZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIEV4cHIge1xuICAgICAgZjogRXhwciA9IF9cbiAgICAgIGU6IEV4cHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBhcHAgKGY6IEV4cHIsIGU6IEV4cHIpOiAoazogSWQpID0+IEFwcCB7XG4gICAgICByZXR1cm4gYXQoQXBwLCBmLCBlKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgQmluYXJ5QXBwIGV4dGVuZHMgRXhwciB7XG4gICAgICBlMTogRXhwciA9IF9cbiAgICAgIG9wTmFtZTogU3RyID0gX1xuICAgICAgZTI6IEV4cHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBiaW5hcnlBcHAgKGUxOiBFeHByLCBvcE5hbWU6IFN0ciwgZTI6IEV4cHIpOiAoazogSWQpID0+IEJpbmFyeUFwcCB7XG4gICAgICByZXR1cm4gYXQoQmluYXJ5QXBwLCBlMSwgb3BOYW1lLCBlMilcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIENvbnN0TnVtIGV4dGVuZHMgRXhwciB7XG4gICAgICB2YWw6IE51bSA9IF9cbiAgIH1cbiAgIFxuICAgZXhwb3J0IGZ1bmN0aW9uIGNvbnN0TnVtICh2YWw6IE51bSk6IChrOiBJZCkgPT4gQ29uc3ROdW0ge1xuICAgICAgcmV0dXJuIGF0KENvbnN0TnVtLCB2YWwpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBDb25zdFN0ciBleHRlbmRzIEV4cHIge1xuICAgICAgdmFsOiBTdHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBjb25zdFN0ciAodmFsOiBTdHIpOiAoazogSWQpID0+IENvbnN0U3RyIHtcbiAgICAgIHJldHVybiBhdChDb25zdFN0ciwgdmFsKVxuICAgfVxuXG4gICAvLyBIYXMgYSBjb25jcmV0ZSBzdWJjbGFzcyBmb3IgZWFjaCBkYXRhdHlwZS4gU2hvdWxkIHRoaXMgYmUgcGFyYW1ldGVyaXNlZCBieSBUIGV4dGVuZHMgRGF0YVZhbHVlP1xuICAgZXhwb3J0IGNsYXNzIERhdGFFeHByIGV4dGVuZHMgRXhwciB7XG4gICAgICBnZXQgY3RyICgpOiBzdHJpbmcge1xuICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBfX2NoaWxkIChwcm9wOiBrZXlvZiB0aGlzKTogRXhwciB7XG4gICAgICAgICByZXR1cm4gc3VwZXIuX19jaGlsZChwcm9wKSBhcyBFeHByXG4gICAgICB9XG5cbiAgICAgIGdldCBfX2NoaWxkcmVuICgpOiBFeHByW10ge1xuICAgICAgICAgcmV0dXJuIHN1cGVyLl9fY2hpbGRyZW4gYXMgRXhwcltdXG4gICAgICB9XG4gICB9XG4gICBcbiAgIGV4cG9ydCBjbGFzcyBEZWYgZXh0ZW5kcyBTeW50YXhOb2RlPFwiRXhwci5EZWZcIj4ge1xuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgTGV0IGV4dGVuZHMgRGVmIHtcbiAgICAgIHg6IFN0ciA9IF9cbiAgICAgIGU6IEV4cHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBsZXRfICh4OiBTdHIsIGU6IEV4cHIpOiAoazogSWQpID0+IExldCB7XG4gICAgICByZXR1cm4gYXQoTGV0LCB4LCBlKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgUHJpbSBleHRlbmRzIERlZiB7XG4gICAgICB4OiBTdHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBwcmltICh4OiBTdHIpOiAoazogSWQpID0+IFByaW0ge1xuICAgICAgcmV0dXJuIGF0KFByaW0sIHgpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBSZWNEZWYgZXh0ZW5kcyBTeW50YXhOb2RlPFwiRXhwci5SZWNEZWZcIj4ge1xuICAgICAgeDogU3RyID0gX1xuICAgICAgz4M6IEVsaW08RXhwcj4gPSBfXG4gICB9XG4gXG4gICBleHBvcnQgZnVuY3Rpb24gcmVjRGVmICh4OiBTdHIsIM+DOiBFbGltPEV4cHI+KTogKGs6IElkKSA9PiBSZWNEZWYge1xuICAgICAgcmV0dXJuIGF0KFJlY0RlZiwgeCwgz4MpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBMZXRSZWMgZXh0ZW5kcyBEZWYge1xuICAgICAgzrQ6IExpc3Q8UmVjRGVmPiA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGxldFJlYyAozrQ6IExpc3Q8UmVjRGVmPik6IChrOiBJZCkgPT4gTGV0UmVjIHtcbiAgICAgIHJldHVybiBhdChMZXRSZWMsIM60KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgRGVmcyBleHRlbmRzIEV4cHIge1xuICAgICAgZGVmzIU6IExpc3Q8RGVmPiA9IF9cbiAgICAgIGU6IEV4cHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBkZWZzIChkZWbMhTogTGlzdDxEZWY+LCBlOiBFeHByKTogKGs6IElkKSA9PiBEZWZzIHtcbiAgICAgIHJldHVybiBhdChEZWZzLCBkZWbMhSwgZSlcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIEZ1biBleHRlbmRzIEV4cHIge1xuICAgICAgz4M6IEVsaW08RXhwcj4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBmdW4gKM+DOiBFbGltPEV4cHI+KTogKGs6IElkKSA9PiBGdW4ge1xuICAgICAgcmV0dXJuIGF0KEZ1biwgz4MpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBNYXRjaEFzIGV4dGVuZHMgRXhwciB7XG4gICAgICBlOiBFeHByID0gX1xuICAgICAgz4M6IEVsaW08RXhwcj4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBtYXRjaEFzIChlOiBFeHByLCDPgzogRWxpbTxFeHByPik6IChrOiBJZCkgPT4gTWF0Y2hBcyB7XG4gICAgICByZXR1cm4gYXQoTWF0Y2hBcywgZSwgz4MpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBRdW90ZSBleHRlbmRzIEV4cHIge1xuICAgICAgZTogRXhwciA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHF1b3RlIChlOiBFeHByKTogKGs6IElkKSA9PiBRdW90ZSB7XG4gICAgICByZXR1cm4gYXQoUXVvdGUsIGUpXG4gICB9XG5cbiAgIC8vIEJyaW5nIGluIGxpbmUgd2l0aCB0aGUgY3VycmVudCBlbGltaW5hdG9yIGRlc2lnbiwgaS5lLiBvcHRpbWlzZSBpbnRvIGFuIG9iamVjdD9cbiAgIGV4cG9ydCBjbGFzcyBUeXBlbWF0Y2ggZXh0ZW5kcyBFeHByIHtcbiAgICAgIGU6IEV4cHIgPSBfXG4gICAgICBjYXNlczogRmluaXRlTWFwPEV4cHI+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gdHlwZW1hdGNoIChlOiBFeHByLCBjYXNlczogRmluaXRlTWFwPEV4cHI+KTogKGs6IElkKSA9PiBUeXBlbWF0Y2gge1xuICAgICAgcmV0dXJuIGF0KFR5cGVtYXRjaCwgZSwgY2FzZXMpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBWYXIgZXh0ZW5kcyBFeHByIHtcbiAgICAgIHg6IFN0ciA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHZhcl8gKHg6IFN0cik6IChrOiBJZCkgPT4gVmFyIHtcbiAgICAgIHJldHVybiBhdChWYXIsIHgpXG4gICB9XG5cbiAgIC8vIHVzZWQgYnkgV3JhdHRsZXJcbiAgIGV4cG9ydCBmdW5jdGlvbiBmcmVlVmFycyAoZTogRXhwcik6IFNldDxzdHJpbmc+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29uc3ROdW0pIHtcbiAgICAgICAgIHJldHVybiBuZXcgU2V0KClcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25zdFN0cikge1xuICAgICAgICAgcmV0dXJuIG5ldyBTZXQoKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEZ1bikge1xuICAgICAgICAgcmV0dXJuIGZyZWVWYXJzRWxpbShlLs+DKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIERhdGFFeHByKSB7XG4gICAgICAgICByZXR1cm4gdW5pb24oLi4uZS5fX2NoaWxkcmVuLm1hcChmcmVlVmFycykpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgUXVvdGUpIHtcbiAgICAgICAgIHJldHVybiBmcmVlVmFycyhlLmUpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgVmFyKSB7XG4gICAgICAgICByZXR1cm4gbmV3IFNldChbZS54LnZhbF0pXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQXBwKSB7XG4gICAgICAgICByZXR1cm4gdW5pb24oZnJlZVZhcnMoZS5mKSwgZnJlZVZhcnMoZS5lKSlcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBCaW5hcnlBcHApIHtcbiAgICAgICAgIHJldHVybiB1bmlvbihmcmVlVmFycyhlLmUxKSwgZnJlZVZhcnMoZS5lMikpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRGVmcykge1xuICAgICAgICAgY29uc3QgW2JvdW5kLCBmcmVlXTogW1NldDxzdHJpbmc+LCBTZXQ8c3RyaW5nPl0gPSBmcmVlVmFyc0RlZnMoZS5kZWbMhSwgbmV3IFNldCgpKVxuICAgICAgICAgcmV0dXJuIHVuaW9uKGRpZmYoZnJlZVZhcnMoZS5lKSwgYm91bmQpLCBmcmVlKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIE1hdGNoQXMpIHtcbiAgICAgICAgIHJldHVybiB1bmlvbihmcmVlVmFycyhlLmUpLCBmcmVlVmFyc0VsaW0oZS7PgykpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZW1hdGNoKSB7XG4gICAgICAgICByZXR1cm4gdW5pb24oZnJlZVZhcnMoZS5lKSwgLi4uZS5jYXNlcy50b0FycmF5KCkubWFwKCh7IHNuZCB9KSA9PiBmcmVlVmFycyhzbmQpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gZnJlZVZhcnNDb250ICjOujogQ29udCk6IFNldDxzdHJpbmc+IHtcbiAgICAgIGlmICjOuiBpbnN0YW5jZW9mIEV4cHIpIHtcbiAgICAgICAgIHJldHVybiBmcmVlVmFycyjOuilcbiAgICAgIH0gZWxzZSBcbiAgICAgIGlmICjOuiBpbnN0YW5jZW9mIEVsaW0pIHtcbiAgICAgICAgIHJldHVybiBmcmVlVmFyc0VsaW0ozropXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGZyZWVWYXJzRWxpbTxLIGV4dGVuZHMgQ29udD4gKM+DOiBFbGltPEs+KTogU2V0PHN0cmluZz4ge1xuICAgICAgaWYgKFZhckVsaW0uaXMoz4MpKSB7XG4gICAgICAgICByZXR1cm4gZGlmZihmcmVlVmFyc0NvbnQoz4MuzropLCBuZXcgU2V0KFvPgy54LnZhbF0pKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoRGF0YUVsaW0uaXMoz4MpKSB7XG4gICAgICAgICByZXR1cm4gdW5pb24oLi4uKM+DLl9fY2hpbGRyZW4gYXMgS1tdKS5tYXAoZnJlZVZhcnNDb250KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gKGJvdW5kLCBmcmVlKSB2YXJzIC0gbm90IG5lY2Vzc2FyaWx5IGRpc2pvaW50LCBiZWNhdXNlIHRoZSBkZWZzIG5lc3RcbiAgIGZ1bmN0aW9uIGZyZWVWYXJzRGVmcyAoZGVmzIU6IExpc3Q8RGVmPiwgYm91bmQ6IFNldDxzdHJpbmc+KTogW1NldDxzdHJpbmc+LCBTZXQ8c3RyaW5nPl0ge1xuICAgICAgaWYgKENvbnMuaXMoZGVmzIUpKSB7XG4gICAgICAgICBjb25zdCBkZWY6IERlZiA9IGRlZsyFLmhlYWRcbiAgICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBQcmltKSB7XG4gICAgICAgICAgICBjb25zdCB4zIU6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbZGVmLngudmFsXSksXG4gICAgICAgICAgICAgICAgICBbYm91bmTKuSwgZnJlZV0gPSBmcmVlVmFyc0RlZnMoZGVmzIUudGFpbCwgYm91bmQpXG4gICAgICAgICAgICByZXR1cm4gW2JvdW5kyrksIGRpZmYoZnJlZSwgeMyFKV1cbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIExldCkge1xuICAgICAgICAgICAgY29uc3QgeMyFOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoW2RlZi54LnZhbF0pLFxuICAgICAgICAgICAgICAgICAgW2JvdW5kyrksIGZyZWVdID0gZnJlZVZhcnNEZWZzKGRlZsyFLnRhaWwsIHVuaW9uKGJvdW5kLCB4zIUpKVxuICAgICAgICAgICAgcmV0dXJuIFtib3VuZMq5LCB1bmlvbihkaWZmKGZyZWUsIHjMhSksIGZyZWVWYXJzKGRlZi5lKSldXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBMZXRSZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGbMhTogUmVjRGVmW10gPSBkZWYuzrQudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgeMyFOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoZsyFLm1hcChmID0+IGYueC52YWwpKSxcbiAgICAgICAgICAgICAgICAgIFtib3VuZMq5LCBmcmVlXSA9IGZyZWVWYXJzRGVmcyhkZWbMhS50YWlsLCB1bmlvbihib3VuZCwgeMyFKSlcbiAgICAgICAgICAgIHJldHVybiBbYm91bmTKuSwgZGlmZih1bmlvbihmcmVlLCAuLi5mzIUubWFwKGYgPT4gZnJlZVZhcnNFbGltKGYuz4MpKSksIHjMhSldXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChOaWwuaXMoZGVmzIUpKSB7XG4gICAgICAgICByZXR1cm4gW2JvdW5kLCBuZXcgU2V0KCldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG59XG4iLCJpbXBvcnQgeyBhYnN1cmQgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgRW1wdHksIE5vbkVtcHR5LCBQYWlyLCBUcmVlLCBlbXB0eSwgbm9uRW1wdHksIHBhaXIgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgUGVyc2lzdGVudCwgU3RyIH0gZnJvbSBcIi4vVmFsdWVcIlxuXG4vLyBTaW1wbGlmeSB0byBrZXlzIG9mIHR5cGUgU3RyIHVudGlsIHdlIGhhdmUgc29tZXRoaW5nIGxpa2UgdHlwZSBjbGFzc2VzLlxuZXhwb3J0IHR5cGUgRmluaXRlTWFwPFY+ID0gVHJlZTxQYWlyPFN0ciwgVj4+XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQgPFYgZXh0ZW5kcyBQZXJzaXN0ZW50PiAobTogRmluaXRlTWFwPFY+LCBrOiBTdHIpOiBWIHwgdW5kZWZpbmVkIHtcbiAgIGlmIChOb25FbXB0eS5pcyhtKSkge1xuICAgICAgaWYgKGsubGVxKG0udC5mc3QpKSB7XG4gICAgICAgICBpZiAobS50LmZzdC5sZXEoaykpIHtcbiAgICAgICAgICAgIHJldHVybiBtLnQuc25kXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldChtLmxlZnQsIGspXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGdldChtLnJpZ2h0LCBrKVxuICAgICAgfVxuICAgfSBlbHNlXG4gICBpZiAoRW1wdHkuaXMobSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydCA8ViBleHRlbmRzIFBlcnNpc3RlbnQ+IChtOiBGaW5pdGVNYXA8Vj4sIGs6IFN0ciwgdjogVik6IEZpbml0ZU1hcDxWPiB7XG4gICBpZiAoTm9uRW1wdHkuaXMobSkpIHtcbiAgICAgIGlmIChrLmxlcShtLnQuZnN0KSkge1xuICAgICAgICAgaWYgKG0udC5mc3QubGVxKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9uRW1wdHkobS5sZWZ0LCBwYWlyKGssIHYpLCBtLnJpZ2h0KVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub25FbXB0eShpbnNlcnQobS5sZWZ0LCBrLCB2KSwgbS50LCBtLnJpZ2h0KVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBub25FbXB0eShtLmxlZnQsIG0udCwgaW5zZXJ0KG0ucmlnaHQsIGssIHYpKVxuICAgICAgfVxuICAgfSBlbHNlXG4gICBpZiAoRW1wdHkuaXMobSkpIHtcbiAgICAgIHJldHVybiBub25FbXB0eShtLCBwYWlyKGssIHYpLCBtKVxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xldG9uIDxWIGV4dGVuZHMgUGVyc2lzdGVudD4gKGs6IFN0ciwgdjogVik6IEZpbml0ZU1hcDxWPiB7XG4gICByZXR1cm4gaW5zZXJ0KGVtcHR5KCksIGssIHYpXG59XG5cbi8vIFVuaW9uIHdpdGggYSBjb21iaW5pbmcgZnVuY3Rpb24uIElmIGtleXMgYXJlIGVxdWFsLCByaWdodC1oYW5kIGtleSB3aWxsIGJlIHVzZWQgaW4gdGhlIG91dHB1dC5cbi8vIEF2b2lkIHByaW1lcyBpbiBzaWduYXR1cmU7IHNlZW1zIHRvIGJlIGluY29tcGF0aWJsZSB3aXRoIHZlcnNpb24gb2YgdHMtbG9hZGVyIHVzZWQgYnkgV3JhdHRsZXIuXG5leHBvcnQgZnVuY3Rpb24gdW5pb25XaXRoIDxWIGV4dGVuZHMgUGVyc2lzdGVudCwgVCBleHRlbmRzIEZpbml0ZU1hcDxWPj4gKG0xOiBULCBtMjogVCwgZjogKHYxOiBWLCB2MjogVikgPT4gVik6IFQge1xuICAgaWYgKE5vbkVtcHR5LmlzKG0yKSkge1xuICAgICAgY29uc3QgazogU3RyID0gbTIudC5mc3QsXG4gICAgICAgICAgICB2OiBWID0gbTIudC5zbmQsXG4gICAgICAgICAgICB2yrk6IFYgfCB1bmRlZmluZWQgPSBnZXQobTEsIGspLFxuICAgICAgICAgICAgdTogViA9IHbKuSA9PT0gdW5kZWZpbmVkID8gdiA6IGYodiwgdsq5KVxuICAgICAgcmV0dXJuIHVuaW9uV2l0aChpbnNlcnQodW5pb25XaXRoKG0xLCBtMi5sZWZ0LCBmKSwgaywgdSksIG0yLnJpZ2h0LCBmKSBhcyBUXG4gICB9IGVsc2VcbiAgIGlmIChFbXB0eS5pcyhtMikpIHtcbiAgICAgIHJldHVybiBtMVxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgfVxufVxuIiwiaW1wb3J0IHsgTGlzdCB9IGZyb20gXCIuL0Jhc2VUeXBlc1wiXG5pbXBvcnQgeyBpbml0RGF0YVR5cGUgfSBmcm9tIFwiLi9EYXRhVHlwZVwiXG5pbXBvcnQgeyBEYXRhVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgTnVtLCBTdHIsIF8gfSBmcm9tIFwiLi9WYWx1ZVwiXG5cbmV4cG9ydCBjbGFzcyBQb2ludCBleHRlbmRzIERhdGFWYWx1ZTxcIlBvaW50XCI+IHtcbiAgIHg6IE51bSA9IF9cbiAgIHk6IE51bSA9IF9cbn1cblxuLy8gSXNvbW9ycGhpYyB0byBCb29sXG5leHBvcnQgY2xhc3MgT3JpZW50IGV4dGVuZHMgRGF0YVZhbHVlPFwiT3JpZW50XCI+IHtcbn1cblxuZXhwb3J0IGNsYXNzIEhvcml6IGV4dGVuZHMgT3JpZW50IHtcbn1cblxuZXhwb3J0IGNsYXNzIFZlcnQgZXh0ZW5kcyBPcmllbnQge1xufVxuXG5leHBvcnQgdHlwZSBHcmFwaGljc0VsZW1lbnRUYWcgPSBcIkNpcmNsZVwiIHwgXCJHcm91cFwiIHwgXCJMaW5lXCIgfCBcIlBvbHlsaW5lXCIgfCBcIlBvbHltYXJrZXJzXCIgfCBcIlJlY3RcIiB8IFwiVGV4dFwiIHwgXCJWaWV3cG9ydFwiXG5cbmV4cG9ydCBjbGFzcyBHcmFwaGljc0VsZW1lbnQ8VGFnIGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50VGFnID0gR3JhcGhpY3NFbGVtZW50VGFnPiBleHRlbmRzIERhdGFWYWx1ZTxUYWc+IHtcbn1cblxuZXhwb3J0IGNsYXNzIENpcmNsZSBleHRlbmRzIEdyYXBoaWNzRWxlbWVudDxcIkNpcmNsZVwiPiB7ICAgXG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG4gICByYWRpdXM6IE51bSA9IF9cbiAgIGZpbGw6IFN0ciA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIEdyb3VwIGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50PFwiR3JvdXBcIj4ge1xuICAgZ3M6IExpc3Q8R3JhcGhpY3NFbGVtZW50PiA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIExpbmUgZXh0ZW5kcyBHcmFwaGljc0VsZW1lbnQ8XCJMaW5lXCI+IHtcbiAgIHAxOiBQb2ludCA9IF9cbiAgIHAyOiBQb2ludCA9IF9cbiAgIHN0cm9rZTogU3RyID0gX1xuICAgc3Ryb2tlV2lkdGg6IE51bSA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFBvbHlsaW5lIGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50PFwiUG9seWxpbmVcIj4ge1xuICAgcG9pbnRzOiBMaXN0PFBvaW50PiA9IF9cbiAgIHN0cm9rZTogU3RyID0gX1xuICAgc3Ryb2tlV2lkdGg6IE51bSA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFBvbHltYXJrZXJzIGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50PFwiUG9seW1hcmtlcnNcIj4ge1xuICAgcG9pbnRzOiBMaXN0PFBvaW50PiA9IF9cbiAgIG1hcmtlcnM6IExpc3Q8R3JhcGhpY3NFbGVtZW50PiA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFJlY3QgZXh0ZW5kcyBHcmFwaGljc0VsZW1lbnQ8XCJSZWN0XCI+IHtcbiAgIHg6IE51bSA9IF9cbiAgIHk6IE51bSA9IF9cbiAgIHdpZHRoOiBOdW0gPSBfXG4gICBoZWlnaHQ6IE51bSA9IF9cbiAgIGZpbGw6IFN0ciA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFRleHQgZXh0ZW5kcyBHcmFwaGljc0VsZW1lbnQ8XCJUZXh0XCI+IHtcbiAgIHg6IE51bSA9IF9cbiAgIHk6IE51bSA9IF9cbiAgIHN0cjogU3RyID0gX1xuICAgYW5jaG9yOiBTdHIgPSBfICAgLy8gU1ZHIHRleHQtYW5jaG9yXG4gICBiYXNlbGluZTogU3RyID0gXyAvLyBTVkcgYWxpZ25tZW50LWJhc2VsaW5lXG59XG5cbmV4cG9ydCBjbGFzcyBWaWV3cG9ydCBleHRlbmRzIEdyYXBoaWNzRWxlbWVudDxcIlZpZXdwb3J0XCI+IHtcbiAgIHg6IE51bSA9IF9cbiAgIHk6IE51bSA9IF9cbiAgIHdpZHRoOiBOdW0gPSBfXG4gICBoZWlnaHQ6IE51bSA9IF9cbiAgIGZpbGw6IFN0ciA9IF9cbiAgIG1hcmdpbjogTnVtID0gXyAvLyBpbiAqcGFyZW50KiByZWZlcmVuY2UgZnJhbWVcbiAgIHNjYWxlOiBUcmFuc2Zvcm0gPSBfXG4gICB0cmFuc2xhdGU6IFRyYW5zZm9ybSA9IF8gLy8gc2NhbGluZyBhcHBsaWVzIHRvIHRyYW5zbGF0ZWQgY29vcmRpbmF0ZXNcbiAgIGc6IEdyYXBoaWNzRWxlbWVudCA9IF9cbn1cblxuZXhwb3J0IHR5cGUgVHJhbnNmb3JtVGFnID0gXCJTY2FsZVwiIHwgXCJUcmFuc2xhdGVcIlxuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtPFRhZyBleHRlbmRzIFRyYW5zZm9ybVRhZyA9IFRyYW5zZm9ybVRhZz4gZXh0ZW5kcyBEYXRhVmFsdWU8VGFnPiB7XG59XG5cbmV4cG9ydCBjbGFzcyBTY2FsZSBleHRlbmRzIFRyYW5zZm9ybTxcIlNjYWxlXCI+IHtcbiAgIHg6IE51bSA9IF9cbiAgIHk6IE51bSA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0ZSBleHRlbmRzIFRyYW5zZm9ybTxcIlRyYW5zbGF0ZVwiPiB7XG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG59XG5cbmV4cG9ydCB0eXBlIE1hcmtlclRhZyA9IFwiQXJyb3doZWFkXCJcblxuZXhwb3J0IGNsYXNzIE1hcmtlcjxUYWcgZXh0ZW5kcyBNYXJrZXJUYWcgPSBNYXJrZXJUYWc+IGV4dGVuZHMgRGF0YVZhbHVlPFRhZz4ge1xufVxuXG5leHBvcnQgY2xhc3MgQXJyb3doZWFkIGV4dGVuZHMgTWFya2VyPFwiQXJyb3doZWFkXCI+IHsgICBcbn1cblxuaW5pdERhdGFUeXBlKFBvaW50LCBbUG9pbnRdKVxuaW5pdERhdGFUeXBlKE9yaWVudCwgW0hvcml6LCBWZXJ0XSlcbmluaXREYXRhVHlwZShHcmFwaGljc0VsZW1lbnQsIFtDaXJjbGUsIEdyb3VwLCBMaW5lLCBQb2x5bGluZSwgUG9seW1hcmtlcnMsIFJlY3QsIFRleHQsIFZpZXdwb3J0XSlcbmluaXREYXRhVHlwZShUcmFuc2Zvcm0sIFtTY2FsZSwgVHJhbnNsYXRlXSlcbmluaXREYXRhVHlwZShNYXJrZXIsIFtBcnJvd2hlYWRdKVxuIiwiLy8gXCJ0eXBpbmdzXCIgcHJvcGVydHkgb2YgcGFja2FnZS5qc29uIHJlcXVpcmVzIGEgc2luZ2xlIFR5cGVTY3JpcHQgaW50ZXJmYWNlLlxuaW1wb3J0IFwiLi9CYXNlVHlwZXNcIiAvLyBuZWVkIHRoZXNlIGVhcmx5IGJlY2F1c2Ugb2YgYSBXZWJwYWNrIGRlcGVuZGVuY3kgcHJvYmxlbVxuaW1wb3J0IHsgUGFuZSB9IGZyb20gXCIuL2FwcC9QYW5lXCJcbmltcG9ydCB7IFBhbmVDb29yZGluYXRvciB9IGZyb20gXCIuL2FwcC9QYW5lQ29vcmRpbmF0b3JcIlxuaW1wb3J0IHsgRW52LCBlbXB0eUVudiB9IGZyb20gXCIuL0VudlwiXG5pbXBvcnQgeyBFdmFsIH0gZnJvbSBcIi4vRXZhbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4vRXhwclwiXG5pbXBvcnQgeyBiaW5kRGF0YXNldCwgb3BlbkRhdGFzZXRBcywgcGFyc2VXaXRoSW1wb3J0cyB9IGZyb20gXCIuL01vZHVsZVwiXG5cbmV4cG9ydCB7IFBhbmUsIFBhbmVDb29yZGluYXRvciwgRW52LCBFdmFsLCBFeHByLCBiaW5kRGF0YXNldCwgZW1wdHlFbnYsIG9wZW5EYXRhc2V0QXMsIHBhcnNlV2l0aEltcG9ydHMgfVxuIiwiaW1wb3J0IHsgemlwLCB6aXBXaXRoIH0gZnJvbSBcIi4vdXRpbC9BcnJheVwiXG5pbXBvcnQgeyBDbGFzcywgX19ub25OdWxsLCBhYnN1cmQsIGFzc2VydCwgY2xhc3NOYW1lLCB1c2VyRXJyb3IgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgZXEgfSBmcm9tIFwiLi91dGlsL09yZFwiXG5pbXBvcnQgeyBBbm5vdGF0aW9uLCBib29sXyB9IGZyb20gXCIuL3V0aWwvTGF0dGljZVwiXG5pbXBvcnQgeyBpc86xLCBzZXRqb2luzrEgfSBmcm9tIFwiLi9Bbm5vdGF0aW9uXCJcbmltcG9ydCB7IExpc3QsIGNvbnMsIG5pbCB9IGZyb20gXCIuL0Jhc2VUeXBlc1wiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSB9IGZyb20gXCIuL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBEYXRhVHlwZSwgY3RyVG9EYXRhVHlwZSwgZWxpbVRvRGF0YVR5cGUgfSBmcm9tIFwiLi9EYXRhVHlwZVwiXG5pbXBvcnQgeyBFbnYsIGVtcHR5RW52IH0gZnJvbSBcIi4vRW52XCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi9FeHBsXCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi9FeHByXCJcbmltcG9ydCB7IElkLCBNZW1vSWQsIFN0ciwgVmFsdWUsIF8sIGZpZWxkcywgbWFrZSwgbWVtb0lkIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgYXQgfSBmcm9tIFwiLi9WZXJzaW9uZWRcIlxuXG5pbXBvcnQgQ29udCA9IEV4cHIuQ29udFxuXG4vLyBVbnJlbGF0ZWQgdG8gdGhlIGFubm90YXRpb24gbGF0dGljZS4gRXhwciBjYXNlIGludGVudGlvbmFsbHkgb25seSBkZWZpbmVkIGZvciBoaWdoZXItb3JkZXIgKGZ1bmN0aW9uKSBjYXNlLlxuZnVuY3Rpb24gam9pbjxLIGV4dGVuZHMgQ29udD4gKM66OiBLLCDOusq5OiBLKTogSyB7XG4gICBjb25zdCBrOiBNZW1vSWQgPSBtZW1vSWQoam9pbiwgYXJndW1lbnRzKVxuICAgaWYgKM66IGluc3RhbmNlb2YgRWxpbSAmJiDOusq5IGluc3RhbmNlb2YgRWxpbSkge1xuICAgICAgcmV0dXJuIERhdGFFbGltLmpvaW48Sz4ozrosIM66yrkpIGFzIENvbnQgYXMgS1xuICAgfSBlbHNlXG4gICBpZiAozrogaW5zdGFuY2VvZiBFeHByLkZ1biAmJiDOusq5IGluc3RhbmNlb2YgRXhwci5GdW4pIHtcbiAgICAgIHJldHVybiBFeHByLmZ1bihqb2luKM66Ls+DLCDOusq5Ls+DKSkoaykgYXMgRXhwciBhcyBLXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZChcIlVuZGVmaW5lZCBqb2luLlwiLCDOuiwgzrrKuSlcbiAgIH1cbn1cblxuLy8gUHJlb3JkZXIgdHJhdmVyc2FsIG9mIGFsbCBub2RlcyBpbiB0aGUgbWF0Y2hlZCBwcmVmaXguXG50eXBlIE1hdGNoUHJlZml4ID0gTGlzdDxFeHBsVmFsdWU8RGF0YVZhbHVlPj5cblxuZXhwb3J0IGNsYXNzIE1hdGNoPEs+IGV4dGVuZHMgRGF0YVZhbHVlPFwiTWF0Y2hcIj4ge1xuICAgdHbMhTogTWF0Y2hQcmVmaXggPSBfXG4gICDOujogSyA9IF9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPEsgZXh0ZW5kcyBDb250PiAozr46IE1hdGNoUHJlZml4LCDOujogSyk6IE1hdGNoPEs+IHtcbiAgIHJldHVybiBtYWtlKE1hdGNoLCDOviwgzropIGFzIE1hdGNoPEs+XG59XG5cbi8vIFNlZSBHaXRIdWIgaXNzdWUgIzEyOC5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFbGltPEsgZXh0ZW5kcyBDb250ID0gQ29udD4gZXh0ZW5kcyBEYXRhVmFsdWU8XCJFbGltXCI+IHtcbiAgIC8vIGNvdWxkIGhhdmUgY2FsbGVkIHRoaXMgXCJtYXRjaFwiLCBidXQgY29uZmxpY3RzIHdpdGggZmFjdG9yeSBtZXRob2Qgb2Ygc2FtZSBuYW1lXG4gICBhcHBseSAodHY6IEV4cGxWYWx1ZSk6IFtFbnYsIE1hdGNoPEs+XSB7XG4gICAgICByZXR1cm4gYXBwbHlfKHRoaXMsIHR2LCBuaWwoKSlcbiAgIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlfPEsgZXh0ZW5kcyBDb250PiAoz4M6IEVsaW08Sz4sIHR2OiBFeHBsVmFsdWUsIHXMhTogTWF0Y2hQcmVmaXgpOiBbRW52LCBNYXRjaDxLPl0ge1xuICAgaWYgKFZhckVsaW0uaXMoz4MpKSB7XG4gICAgICBjb25zdCDPgTogRW52ID0gz4MueC52YWwgPT09IFwiX1wiID8gZW1wdHlFbnYoKSA6IEVudi5zaW5nbGV0b24oz4MueCwgdHYpXG4gICAgICByZXR1cm4gW8+BLCBtYXRjaCh1zIUsIM+DLs66KV1cbiAgIH0gZWxzZVxuICAgaWYgKERhdGFFbGltLmlzKM+DKSkge1xuICAgICAgY29uc3QgdjogVmFsdWUgPSB0di52LFxuICAgICAgICAgICAgYzogc3RyaW5nID0gY2xhc3NOYW1lKHYpXG4gICAgICBpZiAodiBpbnN0YW5jZW9mIERhdGFWYWx1ZSkge1xuICAgICAgICAgY29uc3Qgzro6IEsgPSAoz4MgYXMgYW55KVtjXSBhcyBLXG4gICAgICAgICBpZiAozrogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdHbMhTogRXhwbFZhbHVlW10gPSBFeHBsLmV4cGxDaGlsZHJlbih0di50LCB2KSxcbiAgICAgICAgICAgIFvPgSwgzr5dOiBbRW52LCBNYXRjaDxLPl0gPSBtYXRjaEFyZ3MozrosIHR2zIUsIHXMhSlcbiAgICAgICAgICAgIHJldHVybiBbz4EsIG1hdGNoKGNvbnModHYgYXMgRXhwbFZhbHVlPERhdGFWYWx1ZT4sIM6+LnR2zIUpLCDOvi7OuildXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZDogRGF0YVR5cGUgPSBlbGltVG9EYXRhVHlwZS5nZXQoY2xhc3NOYW1lKM+DKSkhXG4gICAgICAgICAgICBpZiAoZC5jdHJzLmhhcyhjKSkge1xuICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgUGF0dGVybiBtaXNtYXRjaDogXCIke2N9XCIgY2FzZSB1bmRlZmluZWQgZm9yICR7ZC5uYW1lLnZhbH0uYClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICByZXR1cm4gdXNlckVycm9yKGBQYXR0ZXJuIG1pc21hdGNoOiBmb3VuZCAke2N9LCBleHBlY3RlZCAke2QubmFtZS52YWx9LmApXG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgUGF0dGVybiBtaXNtYXRjaDogJHtjfSBpcyBub3QgYSBkYXRhdHlwZS5gLCB2LCDPgylcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cblxuLy8gUGFyc2VyIGVuc3VyZXMgY29uc3RydWN0b3IgY2FsbHMgYXJlIHNhdHVyYXRlZC5cbmZ1bmN0aW9uIG1hdGNoQXJnczxLIGV4dGVuZHMgQ29udD4gKM66OiBLLCB0dsyFOiBFeHBsVmFsdWVbXSwgdcyFOiBNYXRjaFByZWZpeCk6IFtFbnYsIE1hdGNoPEs+XSB7XG4gICBpZiAodHbMhS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbZW1wdHlFbnYoKSwgbWF0Y2godcyFLCDOuildXG4gICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3R2LCAuLi50dsyFyrldID0gdHbMhVxuICAgICAgaWYgKM66IGluc3RhbmNlb2YgRWxpbSkge1xuICAgICAgICAgY29uc3Qgz4M6IEVsaW08Sz4gPSDOuiwgLy8gXCJ1bmZvbGRcIiBLIGludG8gRWxpbTxLPlxuICAgICAgICAgICAgICAgW8+BLCDOvl06IFtFbnYsIE1hdGNoPEs+XSA9IGFwcGx5XyjPgywgdHYsIHXMhSksXG4gICAgICAgICAgICAgICBbz4HKuSwgzr7KuV06IFtFbnYsIE1hdGNoPEs+XSA9IG1hdGNoQXJncyjOvi7OuiwgdHbMhcq5LCDOvi50dsyFKVxuICAgICAgICAgcmV0dXJuIFvPgS5jb25jYXQoz4HKuSksIM6+yrldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZChcIlRvbyBtYW55IGFyZ3VtZW50cyB0byBjb25zdHJ1Y3Rvci5cIilcbiAgICAgIH1cbiAgIH1cbn1cblxuLy8gQ29uY3JldGUgaW5zdGFuY2VzIGhhdmUgYSBmaWVsZCBwZXIgY29uc3RydWN0b3IsIGluICpsZXhpY29ncmFwaGljYWwqIG9yZGVyLlxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFFbGltPEsgZXh0ZW5kcyBDb250ID0gQ29udD4gZXh0ZW5kcyBFbGltPEs+IHtcbiAgIHN0YXRpYyBpczxLIGV4dGVuZHMgQ29udD4gKM+DOiBFbGltPEs+KTogz4MgaXMgRGF0YUVsaW08Sz4ge1xuICAgICAgcmV0dXJuIM+DIGluc3RhbmNlb2YgRGF0YUVsaW1cbiAgIH1cblxuICAgc3RhdGljIGpvaW48SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPiwgz4Q6IEVsaW08Sz4pOiBFbGltPEs+IHtcbiAgICAgIGNvbnN0IGs6IE1lbW9JZCA9IG1lbW9JZChEYXRhRWxpbS5qb2luLCBhcmd1bWVudHMpXG4gICAgICBpZiAoVmFyRWxpbS5pcyjPgykgJiYgVmFyRWxpbS5pcyjPhCkgJiYgZXEoz4MueCwgz4QueCkpIHtcbiAgICAgICAgIHJldHVybiB2YXJFbGltKM+DLngsIGpvaW4oz4MuzrosIM+ELs66KSkoaylcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKERhdGFFbGltLmlzKM+DKSAmJiBEYXRhRWxpbS5pcyjPhCkpIHtcbiAgICAgICAgIC8vIEJvdGggbWFwcyAod2hpY2ggYXJlIG5vbi1lbXB0eSkgY2FuIChpbmR1Y3RpdmVseSkgYmUgYXNzdW1lZCB0byBoYXZlIGtleXMgdGFrZW4gZnJvbSB0aGUgXG4gICAgICAgICAvLyBzYW1lIGRhdGF0eXBlLiBFbnN1cmUgdGhhdCBpbnZhcmlhbnQgaXMgcHJlc2VydmVkOlxuICAgICAgICAgY29uc3QgY1/Pgzogc3RyaW5nID0gZmllbGRzKM+DKVswXSxcbiAgICAgICAgICAgICAgIGNfz4Q6IHN0cmluZyA9IGZpZWxkcyjPhClbMF1cbiAgICAgICAgIGlmIChjdHJUb0RhdGFUeXBlLmdldChjX8+DKSAhPT0gY3RyVG9EYXRhVHlwZS5nZXQoY1/PhCkpIHtcbiAgICAgICAgICAgIHVzZXJFcnJvcihgJHtjX8+DfSBhbmQgJHtjX8+EfSBhcmUgY29uc3RydWN0b3JzIG9mIGRpZmZlcmVudCBkYXRhdHlwZXMuYClcbiAgICAgICAgIH1cbiAgICAgICAgIGNvbnN0IGPOusyFMTogW3N0cmluZywgS11bXSA9IHppcChmaWVsZHMoz4MpLCDPgy5fX2NoaWxkcmVuIGFzIEtbXSksXG4gICAgICAgICAgICAgICBjzrrMhTI6IFtzdHJpbmcsIEtdW10gPSB6aXAoZmllbGRzKM+EKSwgz4QuX19jaGlsZHJlbiBhcyBLW10pXG4gICAgICAgICBhc3NlcnQoY866zIUxLmxlbmd0aCA9PT0gY866zIUyLmxlbmd0aClcbiAgICAgICAgIGNvbnN0IGPOusyFOiBbc3RyaW5nLCBLXVtdID0gemlwV2l0aCgoW2MxLCDOujFdOiBbc3RyaW5nLCBLXSwgW2MyLCDOujJdOiBbc3RyaW5nLCBLXSk6IFtzdHJpbmcsIEtdID0+IHtcbiAgICAgICAgICAgIGFzc2VydChjMSA9PT0gYzIpXG4gICAgICAgICAgICByZXR1cm4gW2MxLCDOujEgPT09IHVuZGVmaW5lZCA/IM66MiA6ICjOujIgPT09IHVuZGVmaW5lZCA/IM66MSA6IGpvaW4ozroxLCDOujIpKV1cbiAgICAgICAgIH1cbiAgICAgICAgICkoY866zIUxLCBjzrrMhTIpXG4gICAgICAgICByZXR1cm4gZGF0YUVsaW0oLi4uY866zIUpKGspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZChcIlVuZGVmaW5lZCBqb2luLlwiLCDPgywgz4QpXG4gICAgICB9XG4gICB9XG59XG5cbi8vIGPOusyFIG5vbi1lbXB0eSBhbmQgY29uc3RydWN0b3JzIGFsbCBvZiB0aGUgc2FtZSBkYXRhdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiBkYXRhRWxpbTxLIGV4dGVuZHMgQ29udD4gKC4uLmPOusyFOiBbc3RyaW5nLCBLXVtdKTogKGs6IElkKSA9PiBFbGltPEs+IHtcbiAgIGNvbnN0IGQ6IERhdGFUeXBlID0gX19ub25OdWxsKGN0clRvRGF0YVR5cGUuZ2V0KGPOusyFWzBdWzBdKSksXG4gICAgICAgICBjzIU6IHN0cmluZ1tdID0gY866zIUubWFwKCgoW2MsIF9dKSA9PiBjKSksXG4gICAgICAgICBjzIXKuTogc3RyaW5nW10gPSBbLi4uZC5jdHJzLmtleXMoKV0sIC8vIHNvcnRlZFxuICAgICAgICAgZsyFOiBDb250W10gPSBbXVxuICAgbGV0IG46IG51bWJlciA9IDBcbiAgIGZvciAobGV0IG7KuTogbnVtYmVyID0gMDsgbsq5IDwgY8yFyrkubGVuZ3RoOyArK27KuSkge1xuICAgICAgaWYgKGPMhS5pbmNsdWRlcyhjzIXKuVtuyrldKSkge1xuICAgICAgICAgZsyFLnB1c2goY866zIVbbisrXVsxXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBmzIUucHVzaCh1bmRlZmluZWQgYXMgYW55KVxuICAgICAgfVxuICAgfVxuICAgcmV0dXJuIGF0KGQuZWxpbUMgYXMgQ2xhc3M8RGF0YUVsaW08Sz4+LCAuLi5mzIUpXG59XG5cbmV4cG9ydCBjbGFzcyBWYXJFbGltPEsgZXh0ZW5kcyBDb250PiBleHRlbmRzIEVsaW08Sz4ge1xuICAgeDogU3RyID0gX1xuICAgzro6IEsgPSBfXG5cbiAgIHN0YXRpYyBpczxLIGV4dGVuZHMgQ29udD4gKM+DOiBFbGltPEs+KTogz4MgaXMgVmFyRWxpbTxLPiB7XG4gICAgICByZXR1cm4gz4MgaW5zdGFuY2VvZiBWYXJFbGltXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJFbGltPEsgZXh0ZW5kcyBDb250PiAoeDogU3RyLCDOujogSyk6IChrOiBJZCkgPT4gVmFyRWxpbTxLPiB7XG4gICByZXR1cm4gYXQ8VmFyRWxpbTxLPj4oVmFyRWxpbSwgeCwgzropXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseV9md2QgKM6+OiBNYXRjaDxFeHByPik6IEFubm90YXRpb24ge1xuICAgcmV0dXJuIM6+LnR2zIUudG9BcnJheSgpLnJlZHVjZSgozrE6IEFubm90YXRpb24sIHR2OiBFeHBsVmFsdWUpOiBBbm5vdGF0aW9uID0+IGJvb2xfLm1lZXQozrEsIGlzzrEodHYpKSwgYm9vbF8udG9wKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlfYndkICjOvjogTWF0Y2g8RXhwcj4sIM6xOiBBbm5vdGF0aW9uKTogdm9pZCB7XG4gICDOvi50dsyFLnRvQXJyYXkoKS5mb3JFYWNoKCh0djogRXhwbFZhbHVlKTogdm9pZCA9PiBzZXRqb2luzrEozrEsIHR2KSlcbn1cbiIsImltcG9ydCB7IEdyYW1tYXIsIFBhcnNlciB9IGZyb20gXCJuZWFybGV5XCJcbmltcG9ydCB7IF9fbm9uTnVsbCwgYXMsIHVzZXJFcnJvciB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBDb25zLCBMaXN0LCBOaWwsIFBhaXIgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgZXhwckNsYXNzIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRW52LCBFeHRlbmRFbnYsIGVtcHR5RW52LCBleHRlbmRFbnYgfSBmcm9tIFwiLi9FbnZcIlxuaW1wb3J0IHsgRXZhbCB9IGZyb20gXCIuL0V2YWxcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IFwiLi9HcmFwaGljc1wiIC8vIGZvciBkYXRhdHlwZXNcbmltcG9ydCBncmFtbWFyIGZyb20gXCIuL1BhcnNlXCJcbmltcG9ydCB7IFByaW1WYWx1ZSwgU3RyIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgzr0sIGF0LCBudW0sIHN0ciB9IGZyb20gXCIuL1ZlcnNpb25lZFwiXG5cbi8vIEtpbmRlcmdhcnRlbiBtb2R1bGVzLlxuXG5pbXBvcnQgbGliX3ByZWx1ZGUgZnJvbSBcIi4uL2ZsdWlkL2xpYi9wcmVsdWRlLmZsZFwiXG5pbXBvcnQgbGliX2dyYXBoaWNzIGZyb20gXCIuLi9mbHVpZC9saWIvZ3JhcGhpY3MuZmxkXCJcblxuLy8gRGVmaW5lIGFzIGNvbnN0YW50cyB0byBlbmZvcmNlIHNoYXJpbmc7IGNvdWxkIHVzZSBtZW1vaXNhdGlvbi5cbmV4cG9ydCBsZXQgbW9kdWxlX3ByZWx1ZGU6IEVudlxuZXhwb3J0IGxldCBtb2R1bGVfZ3JhcGhpY3M6IEVudlxuXG5leHBvcnQgbmFtZXNwYWNlIE1vZHVsZSB7XG4gICBleHBvcnQgZnVuY3Rpb24gaW5pdGlhbGlzZSAoKTogdm9pZCB7XG4gICAgICBtb2R1bGVfcHJlbHVkZSA9IGxvYWRNb2R1bGUoZW1wdHlFbnYoKSwgbGliX3ByZWx1ZGUpXG4gICAgICBtb2R1bGVfZ3JhcGhpY3MgPSBsb2FkTW9kdWxlKG1vZHVsZV9wcmVsdWRlLCBsaWJfZ3JhcGhpY3MpXG4gICB9XG59XG5cbmZ1bmN0aW9uIGltcG9ydF8gKC4uLm1vZHVsZXM6IEVudltdKTogRW52IHtcbiAgIGlmIChtb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5RW52KClcbiAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbSwgLi4ubXNdID0gbW9kdWxlc1xuICAgICAgcmV0dXJuIG0uY29uY2F0KGltcG9ydF8oLi4ubXMpKVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFRlc3RGaWxlIChmb2xkZXI6IHN0cmluZywgZmlsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgIGxldCB0ZXh0OiBzdHJpbmdcbiAgIGNvbnN0IHhtbGh0dHA6IFhNTEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0XG4gICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgXCIuL1wiICsgZm9sZGVyICsgXCIvXCIgKyBmaWxlICsgXCIuZmxkXCIsIGZhbHNlKVxuICAgeG1saHR0cC5zZW5kKClcbiAgIGlmICh4bWxodHRwLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICB0ZXh0ID0geG1saHR0cC5yZXNwb25zZVRleHRcbiAgIH1cbiAgIHJldHVybiBfX25vbk51bGwodGV4dCEpXG59XG5cbi8vIE5vdCBzdXJlIGlmIE5lYXJsZXkgY2FuIHBhcnNlIGFyYml0cmFyeSBub24tdGVybWluYWwsIGFzIG9wcG9zZWQgdG8gcm9vdC5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkTW9kdWxlICjPgTogRW52LCBzcmM6IHN0cmluZyk6IEVudiB7XG4gICBjb25zdCBzcmPKuTogc3RyaW5nID0gc3JjICsgXCIgaW4gMFwiLFxuICAgICAgICAgZTogRXhwci5EZWZzID0gYXMoc3VjY2Vzc2Z1bFBhcnNlKHNyY8q5KSwgRXhwci5EZWZzKVxuICAgcmV0dXJuIEV2YWwuZGVmcyjPgSwgZS5kZWbMhSwgZW1wdHlFbnYoKSlbMV1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wZW5XaXRoSW1wb3J0cyAoZmlsZTogc3RyaW5nLCAuLi5tb2R1bGVzOiBFbnZbXSk6IFtFbnYsIEV4cHJdIHtcbiAgIHJldHVybiBwYXJzZVdpdGhJbXBvcnRzKGxvYWRUZXN0RmlsZShcImZsdWlkL2V4YW1wbGVcIiwgZmlsZSksIC4uLm1vZHVsZXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVuRGF0YXNldEFzIChmaWxlOiBzdHJpbmcsIHg6IHN0cmluZyk6IEV4dGVuZEVudiB7XG4gICBjb25zdCBbz4EsIGVdOiBbRW52LCBFeHByXSA9IHBhcnNlV2l0aEltcG9ydHMobG9hZFRlc3RGaWxlKFwiZmx1aWQvZGF0YXNldFwiLCBmaWxlKSlcbiAgIHJldHVybiBFbnYuc2luZ2xldG9uKHN0cih4KSjOvSgpKSwgRXZhbC5ldmFsXyjPgSwgZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVdpdGhJbXBvcnRzIChzcmM6IHN0cmluZywgLi4ubW9kdWxlczogRW52W10pOiBbRW52LCBFeHByXSB7XG4gICByZXR1cm4gW2ltcG9ydF8oX19ub25OdWxsKG1vZHVsZV9wcmVsdWRlKSwgX19ub25OdWxsKG1vZHVsZV9ncmFwaGljcyksIC4uLm1vZHVsZXMpLCBzdWNjZXNzZnVsUGFyc2Uoc3JjKV1cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2thY2gvbmVhcmxleS9pc3N1ZXMvMjc2I2lzc3VlY29tbWVudC0zMjQxNjIyMzRcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZXNzZnVsUGFyc2UgKHN0cjogc3RyaW5nKTogRXhwciB7XG4gICBjb25zdCB7IHJlc3VsdHMgfTogUGFyc2VyID0gbmV3IFBhcnNlcihHcmFtbWFyLmZyb21Db21waWxlZChncmFtbWFyKSkuZmVlZChzdHIpXG4gICBpZiAocmVzdWx0cy5sZW5ndGggPiAxKSB7XG4gICAgICB1c2VyRXJyb3IoXCJBbWJpZ3VvdXMgcGFyc2UuXCIpXG4gICB9IGVsc2VcbiAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdXNlckVycm9yKFwiVW5zdWNjZXNzZnVsIHBhcnNlLlwiKVxuICAgfVxuICAgcmV0dXJuIHJlc3VsdHNbMF1cbn1cblxuZXhwb3J0IHR5cGUgUmVjb3JkID0gTGlzdDxQYWlyPFN0ciwgUHJpbVZhbHVlPj4gLy8gZW50cnkgaW4gZGF0YXNldFxuXG4vLyBjcmVhdGUgYW4gZXhwcmVzc2lvbiBhbmQgZXZhbHVhdGUgaXQsIHNvIHdlIGhhdmUgYW4gZXhwbGFpbmVkIHZhbHVlXG5leHBvcnQgZnVuY3Rpb24gYmluZERhdGFzZXQgKM+BOiBFbnYsIHZzOiBPYmplY3RbXSwgeDogc3RyaW5nKTogRXh0ZW5kRW52IHtcbiAgIHJldHVybiBleHRlbmRFbnYoz4EsIHN0cih4KSjOvSgpKSwgRXZhbC5ldmFsXyjPgSwgYXNMaXN0KHZzLm1hcChhc1JlY29yZCkpKSlcbn1cblxuZnVuY3Rpb24gYXNSZWNvcmQgKHY6IE9iamVjdCk6IEV4cHIge1xuICAgcmV0dXJuIGFzTGlzdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2KS5tYXAoayA9PiBhc1BhaXIoaywgKHYgYXMgYW55KVtrXSkpKVxufVxuXG5mdW5jdGlvbiBhc1BhaXIgKGs6IHN0cmluZywgdjogdW5rbm93bik6IEV4cHIge1xuICAgcmV0dXJuIGF0KGV4cHJDbGFzcyhQYWlyKSwgYXNQcmltVmFsdWUoayksIGFzUHJpbVZhbHVlKHYpKSjOvSgpKVxufVxuXG5mdW5jdGlvbiBhc0xpc3QgKGXMhTogRXhwcltdKTogRXhwciB7XG4gICBsZXQgZcyFyrk6IEV4cHIgPSBhdChleHByQ2xhc3MoTmlsKSkozr0oKSlcbiAgIGZvciAobGV0IGUgb2YgWy4uLmXMhV0ucmV2ZXJzZSgpKSB7XG4gICAgICBlzIXKuSA9IGF0KGV4cHJDbGFzcyhDb25zKSwgZSwgZcyFyrkpKM69KCkpXG4gICB9XG4gICByZXR1cm4gZcyFyrlcbn1cblxuZnVuY3Rpb24gYXNQcmltVmFsdWUgKHY6IHVua25vd24pOiBFeHByIHtcbiAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIEV4cHIuY29uc3ROdW0obnVtKHYpKM69KCkpKSjOvSgpKVxuICAgfSBlbHNlXG4gICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBFeHByLmNvbnN0U3RyKHN0cih2KSjOvSgpKSkozr0oKSlcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXNlckVycm9yKGBJbGwtZm9ybWVkIGRhdGE6IGV4cGVjdGVkIHN0cmluZyBvciBudW1iZXIsIGZvdW5kICR7dHlwZW9mIHZ9LmApXG4gICB9XG59XG4iLCIvLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBuZWFybGV5LCB2ZXJzaW9uIDIuMTkuMFxuLy8gaHR0cDovL2dpdGh1Yi5jb20vSGFyZG1hdGgxMjMvbmVhcmxleVxuLy8gQnlwYXNzZXMgVFM2MTMzLiBBbGxvdyBkZWNsYXJlZCBidXQgdW51c2VkIGZ1bmN0aW9ucy5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGlkKGQ6IGFueVtdKTogYW55IHsgcmV0dXJuIGRbMF07IH1cbmRlY2xhcmUgdmFyIHdoaXRlc3BhY2U6IGFueTtcbmRlY2xhcmUgdmFyIHNpbmdsZUxpbmVDb21tZW50OiBhbnk7XG5kZWNsYXJlIHZhciBpZGVudDogYW55O1xuZGVjbGFyZSB2YXIgc3RyaW5nOiBhbnk7XG5kZWNsYXJlIHZhciBudW1iZXI6IGFueTtcbmRlY2xhcmUgdmFyIGNvbXBhcmVPcDogYW55O1xuZGVjbGFyZSB2YXIgZXhwb25lbnRPcDogYW55O1xuZGVjbGFyZSB2YXIgcHJvZHVjdE9wOiBhbnk7XG5kZWNsYXJlIHZhciBzdW1PcDogYW55O1xuXG5jb25zdCBtb28gPSByZXF1aXJlKCdtb28nKVxuY29uc3QgbGV4ZXIgPSBtb28uY29tcGlsZSh7XG4gICBpZGVudDoge1xuICAgICAgbWF0Y2g6IC9bYS16QS1aX11bMC05YS16QS1aX10qJyovLCAvLyBncmVlZHlcbiAgICAgIHR5cGU6IG1vby5rZXl3b3Jkcyh7XG4gICAgICAgIGtleXdvcmQ6IFtcIl9cIiwgXCJhc1wiLCBcIm1hdGNoXCIsIFwiZnVuXCIsIFwiaW5cIiwgXCJsZXRcIiwgXCJsZXRyZWNcIiwgXCJwcmltaXRpdmVcIiwgXCJ0eXBlbWF0Y2hcIl0sXG4gICAgICB9KVxuICAgfSxcbiAgIHdoaXRlc3BhY2U6IHtcbiAgICAgIG1hdGNoOiAvWyBcXGZcXHRcXHJcXG5dKy8sXG4gICAgICBsaW5lQnJlYWtzOiB0cnVlXG4gICB9LFxuICAgc2luZ2xlTGluZUNvbW1lbnQ6IC9cXC9cXC8uKiQvLFxuICAgLy8gSlNPTiBncmFtbWFyIGZvciBudW1iZXJzLCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzE1OS5odG1sI3NlY3Rpb24tNi5cbiAgIC8vIFNlZW1zIE1vbyByZXF1aXJlcyB1cyB0byB1c2Ugbm9uLWNhcHR1cmluZyBncm91cHMgKD86KVxuICAgbnVtYmVyOiAvXFwtPyg/OjB8WzEtOV1bMC05XSopKD86XFwuWzAtOV0rKT8oPzpbZXxFXVstfCtdP1swLTldKyk/LyxcbiAgIHN0cmluZzogL1wiKD86XFxcXFtcIlxcXFxdfFteXFxuXCJcXFxcXSkqXCIvLFxuICAgLy8gbm90IHF1aXRlIHN1cmUgd2h5IEkgY2FuJ3QgdXNlIGxpdGVyYWxzIGhlcmU6XG4gICBzdW1PcDogL1xcLXxcXCtcXCt8XFwrLyxcbiAgIGV4cG9uZW50T3A6IC9cXCpcXCovLFxuICAgcHJvZHVjdE9wOiAvXFwqfFxcLy8sIC8vIG11c3QgY29tZSBhZnRlciBleHBvbmVudE9wXG4gICBjb21wYXJlT3A6IC89PXw8PXw8fD49fD4vLFxuICAgc3ltYm9sOiBbXCIoXCIsIFwiKVwiLCBcIj1cIiwgXCLihpJcIiwgXCI7XCIsIFwie1wiLCBcIn1cIiwgXCIsXCIsIFwiW1wiLCBcIl1cIiwgXCIuLi5cIl0sIC8vIG11c3QgY29tZSBhZnRlciBjb21wYXJlT3Bcbn0pXG5cblxuaW1wb3J0IHsgX19jaGVjaywgYXNzZXJ0LCB1c2VyRXJyb3IgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgQ29ucywgTGlzdCwgTmlsLCBQYWlyIH0gZnJvbSBcIi4vQmFzZVR5cGVzXCJcbmltcG9ydCB7IEN0ciwgY3RyRm9yLCBleHByQ2xhc3MsIHR5cGVzIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IHsgc2luZ2xldG9uLCB1bmlvbldpdGggfSBmcm9tIFwiLi9GaW5pdGVNYXBcIlxuaW1wb3J0IHsgRGF0YUVsaW0sIGRhdGFFbGltLCB2YXJFbGltIH0gZnJvbSBcIi4vTWF0Y2hcIlxuaW1wb3J0IHsgU3RyIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgzr0sIGF0LCBudW0sIHN0ciB9IGZyb20gXCIuL1ZlcnNpb25lZFwiXG5cbmltcG9ydCBDb250ID0gRXhwci5Db250XG5cbi8vIENvbnN0cnVjdG9ycyBtdXN0IHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGxldHRlciwgYSBsYSBIYXNrZWxsLiBXaWxsIGZpeCB0aGlzIGFzIHBhcnQgb2YgaXNzdWUgIzQ5LlxuZnVuY3Rpb24gaXNDdHIgKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICBjb25zdCBjaDogc3RyaW5nID0gc3RyLmNoYXJBdCgwKVxuICAgcmV0dXJuIGNoID09PSBjaC50b1VwcGVyQ2FzZSgpICYmIGNoICE9PSBjaC50b0xvd2VyQ2FzZSgpXG59XG5cbnR5cGUgTWtDb250ID0gKM66OiBDb250KSA9PiBDb250XG5cbmZ1bmN0aW9uIGNvbXBvc2UgKG1rX866MTogTWtDb250LCBta1/OujI6IE1rQ29udCk6IE1rQ29udCB7XG4gICByZXR1cm4gKM66OiBDb250KSA9PiBta1/OujEobWtfzroyKM66KSlcbn1cblxuaW50ZXJmYWNlIE5lYXJsZXlUb2tlbiB7ICB2YWx1ZTogYW55O1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59O1xuXG5pbnRlcmZhY2UgTmVhcmxleUxleGVyIHtcbiAgcmVzZXQ6IChjaHVuazogc3RyaW5nLCBpbmZvOiBhbnkpID0+IHZvaWQ7XG4gIG5leHQ6ICgpID0+IE5lYXJsZXlUb2tlbiB8IHVuZGVmaW5lZDtcbiAgc2F2ZTogKCkgPT4gYW55O1xuICBmb3JtYXRFcnJvcjogKHRva2VuOiBOZWFybGV5VG9rZW4pID0+IHN0cmluZztcbiAgaGFzOiAodG9rZW5UeXBlOiBzdHJpbmcpID0+IGJvb2xlYW47XG59O1xuXG5pbnRlcmZhY2UgTmVhcmxleVJ1bGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbHM6IE5lYXJsZXlTeW1ib2xbXTtcbiAgcG9zdHByb2Nlc3M/OiAoZDogYW55W10sIGxvYz86IG51bWJlciwgcmVqZWN0Pzoge30pID0+IGFueTtcbn07XG5cbnR5cGUgTmVhcmxleVN5bWJvbCA9IHN0cmluZyB8IHsgbGl0ZXJhbDogYW55IH0gfCB7IHRlc3Q6ICh0b2tlbjogYW55KSA9PiBib29sZWFuIH07XG5cbmludGVyZmFjZSBHcmFtbWFyIHtcbiAgTGV4ZXI6IE5lYXJsZXlMZXhlciB8IHVuZGVmaW5lZDtcbiAgUGFyc2VyUnVsZXM6IE5lYXJsZXlSdWxlW107XG4gIFBhcnNlclN0YXJ0OiBzdHJpbmc7XG59O1xuXG5jb25zdCBncmFtbWFyOiBHcmFtbWFyID0ge1xuICBMZXhlcjogbGV4ZXIsXG4gIFBhcnNlclJ1bGVzOiBbXG4gICAge1wibmFtZVwiOiBcInJvb3RFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJfXCIsIFwiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZV0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJyb290RXhwclwiLCBcInN5bWJvbHNcIjogW1wiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIl8kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJ3aGl0ZXNwYWNlXCIpID8ge3R5cGU6IFwid2hpdGVzcGFjZVwifSA6IHdoaXRlc3BhY2UpXX0sXG4gICAge1wibmFtZVwiOiBcIl8kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJzaW5nbGVMaW5lQ29tbWVudFwiKSA/IHt0eXBlOiBcInNpbmdsZUxpbmVDb21tZW50XCJ9IDogc2luZ2xlTGluZUNvbW1lbnQpXX0sXG4gICAge1wibmFtZVwiOiBcIl8kZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwid2hpdGVzcGFjZVwiKSA/IHt0eXBlOiBcIndoaXRlc3BhY2VcIn0gOiB3aGl0ZXNwYWNlKV19LFxuICAgIHtcIm5hbWVcIjogXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwic2luZ2xlTGluZUNvbW1lbnRcIikgPyB7dHlwZTogXCJzaW5nbGVMaW5lQ29tbWVudFwifSA6IHNpbmdsZUxpbmVDb21tZW50KV19LFxuICAgIHtcIm5hbWVcIjogXCJfJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiXyRlYm5mJDFcIiwgXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJfXCIsIFwic3ltYm9sc1wiOiBbXCJfJGVibmYkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcImV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVFeHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwclwiLCBcInN5bWJvbHNcIjogW1wiZGVmczFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJleHByXCIsIFwic3ltYm9sc1wiOiBbXCJmdW5cIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJleHByXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwclwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmczEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJpblwifV19LFxuICAgIHtcIm5hbWVcIjogXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1wiZGVmczEkbWFjcm9jYWxsJDJcIl19LFxuICAgIHtcIm5hbWVcIjogXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiZGVmczEkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiZGVmczEkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImRlZnMxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcImRlZnMxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0XCIsIFwiZGVmczEkbWFjcm9jYWxsJDFcIiwgXCJleHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbZGVmcywgLCBlXSkgPT4gRXhwci5kZWZzKGRlZnMsIGUpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiY29tcGFyZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVFeHByXCIsIFwiY29tcGFyZU9wXCIsIFwic3VtRXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBvcCwgZTJdKSA9PiBFeHByLmJpbmFyeUFwcChlMSwgc3RyKG9wKSjOvSgpKSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiY29tcGFyZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInN1bUV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzdW1FeHByXCIsIFwic3ltYm9sc1wiOiBbXCJzdW1FeHByXCIsIFwic3VtT3BcIiwgXCJwcm9kdWN0RXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBvcCwgZTJdKSA9PiBFeHByLmJpbmFyeUFwcChlMSwgc3RyKG9wKSjOvSgpKSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwic3VtRXhwclwiLCBcInN5bWJvbHNcIjogW1wicHJvZHVjdEV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwcm9kdWN0RXhwclwiLCBcInN5bWJvbHNcIjogW1wicHJvZHVjdEV4cHJcIiwgXCJwcm9kdWN0T3BcIiwgXCJleHBvbmVudEV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtlMSwgb3AsIGUyXSkgPT4gRXhwci5iaW5hcnlBcHAoZTEsIHN0cihvcCkozr0oKSksIGUyKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcInByb2R1Y3RFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJleHBvbmVudEV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJleHBvbmVudEV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImV4cG9uZW50RXhwclwiLCBcImV4cG9uZW50T3BcIiwgXCJhcHBDaGFpblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBvcCwgZTJdKSA9PiBFeHByLmJpbmFyeUFwcChlMSwgc3RyKG9wKSjOvSgpKSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwb25lbnRFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJhcHBDaGFpblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImFwcENoYWluXCIsIFwic3ltYm9sc1wiOiBbXCJzaW1wbGVFeHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiYXBwQ2hhaW5cIiwgXCJzeW1ib2xzXCI6IFtcImFwcENoYWluXCIsIFwic2ltcGxlRXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBlMl0pID0+IEV4cHIuYXBwKGUxLCBlMikozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJzaW1wbGVFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXJpYWJsZVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInN0cmluZ1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcIm51bWJlclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInBhcmVudGhFeHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwic2ltcGxlRXhwclwiLCBcInN5bWJvbHNcIjogW1wicGFpclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzaW1wbGVFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJjb25zdHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInN5bWJvbHNcIjogW1widmFyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeF0pID0+IEV4cHIudmFyXyh4KSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcInZhciRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJpZGVudFwiKSA/IHt0eXBlOiBcImlkZW50XCJ9IDogaWRlbnQpXX0sXG4gICAge1wibmFtZVwiOiBcInZhciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widmFyJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXIkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInZhclwiLCBcInN5bWJvbHNcIjogW1widmFyJG1hY3JvY2FsbCQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6ICAoW1t4XV0sIF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICBpZiAoaXNDdHIoeC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdFxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBzdHIoeC52YWx1ZSkozr0oKSkgXG4gICAgICAgIH0gfSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcInN0cmluZ1wiKSA/IHt0eXBlOiBcInN0cmluZ1wifSA6IHN0cmluZyldfSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJzdHJpbmckbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzdHJpbmckbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInN0cmluZyRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nXCIsIFwic3ltYm9sc1wiOiBbXCJzdHJpbmckbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbbGl0XV0pID0+IEV4cHIuY29uc3RTdHIoc3RyKChsaXQudmFsdWUgYXMgc3RyaW5nKS5zbGljZSgxLCAtMSkpKM69KCkpKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcIm51bWJlciRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJudW1iZXJcIikgPyB7dHlwZTogXCJudW1iZXJcIn0gOiBudW1iZXIpXX0sXG4gICAge1wibmFtZVwiOiBcIm51bWJlciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibnVtYmVyJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibnVtYmVyJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJudW1iZXIkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcIm51bWJlclwiLCBcInN5bWJvbHNcIjogW1wibnVtYmVyJG1hY3JvY2FsbCQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbW2xpdF1dKSA9PiBFeHByLmNvbnN0TnVtKG51bShuZXcgTnVtYmVyKGxpdC52YWx1ZSBhcyBzdHJpbmcpLnZhbHVlT2YoKSkozr0oKSkpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwicGFyZW50aEV4cHIkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFyZW50aEV4cHIkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIpXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFyZW50aEV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInBhcmVudGhFeHByJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlLF0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiKFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wicGFpciRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFpciRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIixcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpciRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wicGFpciRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhaXIkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXIkbWFjcm9jYWxsJDRcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInBhaXIkbWFjcm9jYWxsJDZcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIpXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhaXIkbWFjcm9jYWxsJDVcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXIkbWFjcm9jYWxsJDZcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyJG1hY3JvY2FsbCQ1XCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyJG1hY3JvY2FsbCQ2XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcInBhaXIkbWFjcm9jYWxsJDNcIiwgXCJleHByXCIsIFwicGFpciRtYWNyb2NhbGwkNVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZTEsICwgZTIsXSkgPT4gYXQoZXhwckNsYXNzKFBhaXIpLCBlMSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIltcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3QkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3QkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxpc3QkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJdXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImxpc3QkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3QkbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0JG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0JG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0XCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0JG1hY3JvY2FsbCQxXCIsIFwibGlzdE9wdFwiLCBcImxpc3QkbWFjcm9jYWxsJDNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIGUsIF0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJjb25zdHJcIiwgXCJzeW1ib2xzXCI6IFtcImN0clwiLCBcImFyZ3NcIl0sIFwicG9zdHByb2Nlc3NcIjogIChbYywgZcyFXSwgXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgIGFzc2VydChjIGluc3RhbmNlb2YgU3RyKVxuICAgICAgICAgICBjb25zdCBjdHI6IEN0ciA9IGN0ckZvcihjLnZhbClcbiAgICAgICAgICAgaWYgKGN0ci5hcml0eSAhPT0gZcyFLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIGF0KGV4cHJDbGFzcyhjdHIuQyksIC4uLmXMhSkozr0oKSlcbiAgICAgICAgfSB9LFxuICAgIHtcIm5hbWVcIjogXCJjdHIkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwiaWRlbnRcIikgPyB7dHlwZTogXCJpZGVudFwifSA6IGlkZW50KV19LFxuICAgIHtcIm5hbWVcIjogXCJjdHIkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImN0ciRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImN0ciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiY3RyJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJjdHJcIiwgXCJzeW1ib2xzXCI6IFtcImN0ciRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAgKFtbeF1dLCBfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgaWYgKCFpc0N0cih4LnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHN0cih4LnZhbHVlKSjOvSgpKVxuICAgICAgICB9IH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IFtdfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIihcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiYXJncyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3MkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIixcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3MkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJleHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlXSkgPT4gZX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJGVibmYkMVwiLCBcImFyZ3MkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIpXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3MkbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcImFyZ3MkZWJuZiQxXCIsIFwiYXJncyRtYWNyb2NhbGwkM1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZSwgZXMsXSkgPT4gW2UsIC4uLmVzXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcInR5cGVtYXRjaFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVtYXRjaCRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW1hdGNoJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW1hdGNoJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiYXNcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW1hdGNoJG1hY3JvY2FsbCQzJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDRcIl19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVtYXRjaCRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQzJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVtYXRjaCRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaFwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcInR5cGVtYXRjaCRtYWNyb2NhbGwkM1wiLCBcInR5cGVNYXRjaGVzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlLCAsIG1dKSA9PiBFeHByLnR5cGVtYXRjaChlLCBtKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3QkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3QkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjtcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmTGlzdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZWZMaXN0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImRlZkxpc3QkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmTGlzdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJkZWZcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIGRlZl0pID0+IGRlZn0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3QkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0JGVibmYkMVwiLCBcImRlZkxpc3QkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3RcIiwgXCJzeW1ib2xzXCI6IFtcImRlZlwiLCBcImRlZkxpc3QkZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbZGVmLCBkZWZzXSkgPT4gTGlzdC5mcm9tQXJyYXkoW2RlZiwgLi4uZGVmc10pfSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmXCIsIFwic3ltYm9sc1wiOiBbXCJsZXRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZWZcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlY1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImRlZlwiLCBcInN5bWJvbHNcIjogW1wicHJpbVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcImxldFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsZXQkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcImxldCRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0JG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0JG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsZXQkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0JG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0JG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiPVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsZXQkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImxldCRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibGV0JG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsZXRcIiwgXCJzeW1ib2xzXCI6IFtcImxldCRtYWNyb2NhbGwkMVwiLCBcInZhclwiLCBcImxldCRtYWNyb2NhbGwkM1wiLCBcImV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIHgsICwgZV0pID0+IEV4cHIubGV0Xyh4LCBlKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcImxldHJlY1wifV19LFxuICAgIHtcIm5hbWVcIjogXCJsZXRyZWMkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsZXRyZWMkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJsZXRyZWMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjtcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsZXRyZWMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJyZWNEZWZcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIHJlY0RlZl0pID0+IHJlY0RlZn0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRlYm5mJDFcIiwgXCJsZXRyZWMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImxldHJlY1wiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJG1hY3JvY2FsbCQxXCIsIFwicmVjRGVmXCIsIFwibGV0cmVjJGVibmYkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgcmVjRGVmLCDOtF0pID0+IEV4cHIubGV0UmVjKExpc3QuZnJvbUFycmF5KFtyZWNEZWYsIC4uLs60XSkpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwicHJpbSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcInByaW1pdGl2ZVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJwcmltJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbXCJwcmltJG1hY3JvY2FsbCQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwicHJpbSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wicHJpbSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInByaW0kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInByaW0kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInByaW0kbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInByaW0kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJwcmltXCIsIFwic3ltYm9sc1wiOiBbXCJwcmltJG1hY3JvY2FsbCQxXCIsIFwidmFyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCB4XSkgPT4gRXhwci5wcmltKHgpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwicmVjRGVmJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiZnVuXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInJlY0RlZiRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1wicmVjRGVmJG1hY3JvY2FsbCQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwicmVjRGVmJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJyZWNEZWYkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJyZWNEZWYkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInJlY0RlZiRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicmVjRGVmJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJyZWNEZWYkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJyZWNEZWZcIiwgXCJzeW1ib2xzXCI6IFtcInJlY0RlZiRtYWNyb2NhbGwkMVwiLCBcInZhclwiLCBcIm1hdGNoZXNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIGYsIM+DXSkgPT4gRXhwci5yZWNEZWYoZiwgz4MpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiZnVuJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiZnVuXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImZ1biRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1wiZnVuJG1hY3JvY2FsbCQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiZnVuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJmdW4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJmdW4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImZ1biRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiZnVuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJmdW4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJmdW5cIiwgXCJzeW1ib2xzXCI6IFtcImZ1biRtYWNyb2NhbGwkMVwiLCBcIm1hdGNoZXNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIM+DXSkgPT4gRXhwci5mdW4oz4MpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIm1hdGNoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoQXMkbWFjcm9jYWxsJDJcIl19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaEFzJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hBcyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hBcyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJhc1wifV19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaEFzJG1hY3JvY2FsbCQzJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzJG1hY3JvY2FsbCQ0XCJdfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hBcyRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoQXMkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoQXMkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaEFzXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcIm1hdGNoQXMkbWFjcm9jYWxsJDNcIiwgXCJtYXRjaGVzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlLCAsIM+DXSkgPT4gRXhwci5tYXRjaEFzKGUsIM+DKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXNcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIntcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXMkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoZXMkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjtcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoZXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJtYXRjaFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbV0pID0+IG19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRlYm5mJDFcIiwgXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwifVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaGVzJG1hY3JvY2FsbCQ0XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlc1wiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRtYWNyb2NhbGwkMVwiLCBcIm1hdGNoXCIsIFwibWF0Y2hlcyRlYm5mJDFcIiwgXCJtYXRjaGVzJG1hY3JvY2FsbCQzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBtLCBtcyxdKSA9PiBbbSwgLi4ubXNdLnJlZHVjZShEYXRhRWxpbS5qb2luKX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwi4oaSXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaCRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hcIiwgXCJzeW1ib2xzXCI6IFtcInBhdHRlcm5cIiwgXCJtYXRjaCRtYWNyb2NhbGwkMVwiLCBcImV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtta1/OuiwgLCBlXSkgPT4gbWtfzrooZSl9LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaFwiLCBcInN5bWJvbHNcIjogW1wicGF0dGVyblwiLCBcIm1hdGNoZXNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtta1/OujEsIM+DXSkgPT4gbWtfzroxKEV4cHIuZnVuKM+DKSjOvSgpKSl9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlc1wiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZU1hdGNoZXMkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJ7XCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZU1hdGNoZXMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCI7XCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVNYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwidHlwZU1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBtXSkgPT4gbX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoZXMkZWJuZiQxXCIsIFwidHlwZU1hdGNoZXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwifVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoZXMkbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoZXMkbWFjcm9jYWxsJDRcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkMVwiLCBcInR5cGVNYXRjaFwiLCBcInR5cGVNYXRjaGVzJGVibmYkMVwiLCBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBtLCBtcyxdKSA9PiBbbSwgLi4ubXNdLnJlZHVjZSgobTEsIG0yKSA9PiB1bmlvbldpdGgobTEsIG0yLCAoZTogRXhwciwgZcq5OiBFeHByKTogRXhwciA9PiB1c2VyRXJyb3IoXCJPdmVybGFwcGluZyB0eXBlY2FzZSBicmFuY2hlcy5cIikpKX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIuKGklwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2gkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVNYXRjaCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVuYW1lXCIsIFwidHlwZU1hdGNoJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAgKFt4LCAsIGVdKSA9PiB7XG4gICAgICAgICAgIGFzc2VydCh4IGluc3RhbmNlb2YgU3RyKVxuICAgICAgICAgICBpZiAoIXR5cGVzLmhhcyh4LnZhbCkpIHtcbiAgICAgICAgICAgICAgdXNlckVycm9yKGBUeXBlIG5hbWUgJHt4LnZhbH0gbm90IGZvdW5kLmApXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHNpbmdsZXRvbih4LCBlKVxuICAgICAgICB9IH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVuYW1lJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcImlkZW50XCIpID8ge3R5cGU6IFwiaWRlbnRcIn0gOiBpZGVudCldfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW5hbWUkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVuYW1lJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW5hbWUkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVuYW1lJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbmFtZVwiLCBcInN5bWJvbHNcIjogW1widHlwZW5hbWUkbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbeF1dKSA9PiBzdHIoeC52YWx1ZSkozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0XCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiBhdChleHByQ2xhc3MoTmlsKSkozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIsXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RPcHQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdE9wdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdE9wdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0T3B0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RPcHQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdE9wdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZV0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdE9wdCRlYm5mJDFcIiwgXCJsaXN0T3B0JGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0XCIsIFwic3ltYm9sc1wiOiBbXCJleHByXCIsIFwibGlzdE9wdCRlYm5mJDFcIiwgXCJsaXN0UmVzdE9wdFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UsIGVzLCBlyrldKSA9PiBbZSwgLi4uZXMsIGXKuV0ucmV2ZXJzZSgpLnJlZHVjZSgoZcyFLCBlKSA9PiBhdChleHByQ2xhc3MoQ29ucyksIGUsIGXMhSkozr0oKSkpfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IGF0KGV4cHJDbGFzcyhOaWwpKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHQkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHQkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLi4uXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQxXCIsIFwibGlzdFJlc3RPcHQkbWFjcm9jYWxsJDNcIiwgXCJleHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCAsIGVdKSA9PiBlfSxcbiAgICB7XCJuYW1lXCI6IFwicGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1widmFyaWFibGVfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcImNvbnN0cl9wYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIl9cIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1widmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcInZhcmlhYmxlX3BhdHRlcm4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInZhcmlhYmxlX3BhdHRlcm4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1widmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiAozro6IENvbnQpID0+IHZhckVsaW0oc3RyKFwiX1wiKSjOvSgpKSwgzropKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1widmFyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeF0pID0+ICjOujogQ29udCkgPT4gdmFyRWxpbSh4LCDOuikozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIixcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiKVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDVcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNVwiLCBcInN5bWJvbHNcIjogW1wicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInBhdHRlcm5cIiwgXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJwYXR0ZXJuXCIsIFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQ1XCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBta1/OujEsICwgbWtfzroyLCAsXSkgPT4gKM66OiBDb250KSA9PiBkYXRhRWxpbShbUGFpci5uYW1lLCBjb21wb3NlKG1rX866MSwgbWtfzroyKSjOuildKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIltcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdF9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0X3BhdHRlcm4kbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0X3BhdHRlcm4kbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdF9wYXR0ZXJuJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiXVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0X3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibGlzdF9wYXR0ZXJuJG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0X3BhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcImxpc3RPcHRfcGF0dGVyblwiLCBcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkM1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbWtfzrosIF0pID0+IG1rX866fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdE9wdF9wYXR0ZXJuXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiAozro6IENvbnQpID0+IGRhdGFFbGltKFtOaWwubmFtZSwgzrpdKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wibGlzdDFfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3QxX3BhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcInBhdHRlcm5cIiwgXCJsaXN0UmVzdE9wdF9wYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbbWtfzroxLCBta1/OujJdKSA9PiAozro6IENvbnQpID0+IGRhdGFFbGltKFtDb25zLm5hbWUsIGNvbXBvc2UobWtfzroxLCBta1/OujIpKM66KV0pKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gKM66OiBDb250KSA9PiBkYXRhRWxpbShbTmlsLm5hbWUsIM66XSkozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIi4uLlwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ0XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcImxpc3RSZXN0T3B0X3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJwYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCAsIG1rX866XSkgPT4gbWtfzrp9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ1XCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNVwiLCBcImxpc3QxX3BhdHRlcm5cIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIG1rX866XSkgPT4gbWtfzrp9LFxuICAgIHtcIm5hbWVcIjogXCJjb25zdHJfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wiY3RyXCIsIFwiYXJnc19wYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6ICAoW2MsIG1rX866c10sIF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICBhc3NlcnQoYyBpbnN0YW5jZW9mIFN0cilcbiAgICAgICAgICAgaWYgKGN0ckZvcihjLnZhbCkuYXJpdHkgIT09IG1rX866cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdFxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiAozro6IENvbnQpID0+IGRhdGFFbGltKFtjLnZhbCwgbWtfzrpzLnJlZHVjZShjb21wb3NlLCAozro6IENvbnQpID0+IM66KSjOuildKSjOvSgpKVxuICAgICAgICB9IH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gW119LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiYXJnc19wYXR0ZXJuJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIsXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3NfcGF0dGVybiRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwicGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbWtfzrpdKSA9PiBta1/Oun0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3NfcGF0dGVybiRlYm5mJDFcIiwgXCJhcmdzX3BhdHRlcm4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIilcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDFcIiwgXCJwYXR0ZXJuXCIsIFwiYXJnc19wYXR0ZXJuJGVibmYkMVwiLCBcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkM1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbWtfzrosIG1rX866cyxdKSA9PiBbbWtfzrosIC4uLm1rX866c119LFxuICAgIHtcIm5hbWVcIjogXCJjb21wYXJlT3AkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwiY29tcGFyZU9wXCIpID8ge3R5cGU6IFwiY29tcGFyZU9wXCJ9IDogY29tcGFyZU9wKV19LFxuICAgIHtcIm5hbWVcIjogXCJjb21wYXJlT3AkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVPcCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImNvbXBhcmVPcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiY29tcGFyZU9wJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJjb21wYXJlT3BcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVPcCRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW1t4XV0pID0+IHgudmFsdWV9LFxuICAgIHtcIm5hbWVcIjogXCJleHBvbmVudE9wJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcImV4cG9uZW50T3BcIikgPyB7dHlwZTogXCJleHBvbmVudE9wXCJ9IDogZXhwb25lbnRPcCldfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwb25lbnRPcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiZXhwb25lbnRPcCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImV4cG9uZW50T3AkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImV4cG9uZW50T3AkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImV4cG9uZW50T3BcIiwgXCJzeW1ib2xzXCI6IFtcImV4cG9uZW50T3AkbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbeF1dKSA9PiB4LnZhbHVlfSxcbiAgICB7XCJuYW1lXCI6IFwicHJvZHVjdE9wJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcInByb2R1Y3RPcFwiKSA/IHt0eXBlOiBcInByb2R1Y3RPcFwifSA6IHByb2R1Y3RPcCldfSxcbiAgICB7XCJuYW1lXCI6IFwicHJvZHVjdE9wJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwcm9kdWN0T3AkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwcm9kdWN0T3AkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInByb2R1Y3RPcCRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicHJvZHVjdE9wXCIsIFwic3ltYm9sc1wiOiBbXCJwcm9kdWN0T3AkbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbeF1dKSA9PiB4LnZhbHVlfSxcbiAgICB7XCJuYW1lXCI6IFwic3VtT3AkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwic3VtT3BcIikgPyB7dHlwZTogXCJzdW1PcFwifSA6IHN1bU9wKV19LFxuICAgIHtcIm5hbWVcIjogXCJzdW1PcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wic3VtT3AkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzdW1PcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wic3VtT3AkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInN1bU9wXCIsIFwic3ltYm9sc1wiOiBbXCJzdW1PcCRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW1t4XV0pID0+IHgudmFsdWV9XG4gIF0sXG4gIFBhcnNlclN0YXJ0OiBcInJvb3RFeHByXCIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBncmFtbWFyO1xuIiwiaW1wb3J0IHsgX19jaGVjaywgYXMsIGFzc2VydCwgdXNlckVycm9yIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IEJvb2wsIHRydWVfLCBmYWxzZV8gfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRXhwbFZhbHVlLCBleHBsVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuL0V4cGxcIlxuaW1wb3J0IHsgSWQsIE51bSwgUHJpbU9wVGFnLCBQcmltVmFsdWUsIFN0ciwgXywgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyDOvSwgYXQsIG51bSwgc3RyIH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuZXhwb3J0IHR5cGUgVW5hcnk8VCwgVj4gPSAoeDogVCkgPT4gKGs6IElkKSA9PiBWXG5leHBvcnQgdHlwZSBCaW5hcnk8VCwgVSwgVj4gPSAoeDogVCwgeTogVSkgPT4gKGs6IElkKSA9PiBWXG5cbi8vIEluIHRoZSBmb2xsb3dpbmcgdHdvIGNsYXNzZXMsIHdlIHN0b3JlIHRoZSBvcGVyYXRpb24gd2l0aG91dCBnZW5lcmljIHR5cGUgcGFyYW1ldGVycywgYXMgZmllbGRzIGNhbid0XG4vLyBoYXZlIHBvbHltb3JwaGljIHR5cGUuIFRoZW4gYWNjZXNzIHRoZSBvcGVyYXRpb24gdmlhIGEgbWV0aG9kIGFuZCByZWluc3RhdGUgdGhlIHBvbHltb3JwaGlzbSB2aWEgYSBjYXN0LlxuXG5leHBvcnQgY2xhc3MgUHJpbU9wPFRhZyBleHRlbmRzIFByaW1PcFRhZz4gZXh0ZW5kcyBWYWx1ZTxUYWc+IHtcbiAgIG5hbWU6IHN0cmluZyA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFVuYXJ5T3AgZXh0ZW5kcyBQcmltT3A8XCJVbmFyeU9wXCI+IHtcbiAgIG9wOiBVbmFyeTxQcmltVmFsdWUsIFZhbHVlPiA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIEJpbmFyeU9wIGV4dGVuZHMgUHJpbU9wPFwiQmluYXJ5T3BcIj4ge1xuICAgb3A6IEJpbmFyeTxQcmltVmFsdWUsIFByaW1WYWx1ZSwgVmFsdWU+ID0gX1xufVxuXG5jb25zdCBjZWlsaW5nOiBVbmFyeTxOdW0sIE51bT4gPSB4ID0+IG51bShNYXRoLmNlaWwoeC52YWwpKVxuXG4vLyBVc2VkIHRvIHRha2UgYXJiaXRyYXJ5IHZhbHVlIGFzIGFkZGl0aW9uYWwgYXJndW1lbnQsIGJ1dCBub3cgcHJpbWl0aXZlcyBoYXZlIHByaW1pdGl2ZSBhcmd1bWVudHMuXG5jb25zdCBkZWJ1Z0xvZzogVW5hcnk8TnVtIHwgU3RyLCBWYWx1ZT4gPSB2ID0+IChrOiBJZCkgPT4geyBcbiAgIGNvbnNvbGUubG9nKHYpOyBcbiAgIHJldHVybiB2IFxufVxuXG5jb25zdCBmbG9vcjogVW5hcnk8TnVtLCBOdW0+ID0geCA9PiBudW0oTWF0aC5mbG9vcih4LnZhbCkpXG5jb25zdCBsb2c6IFVuYXJ5PE51bSwgTnVtPiA9IHggPT4gbnVtKE1hdGgubG9nKGFzKHgsIE51bSkudmFsKSlcbmNvbnN0IG51bVRvU3RyOiBVbmFyeTxOdW0sIFN0cj4gPSB4ID0+IHN0cih4LnZhbC50b1N0cmluZygpKVxuXG4vLyBObyBsb25nZXIgc3VwcG9ydCBvdmVybG9hZGVkIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhdHRlcm4tbWF0Y2hpbmcgc2VtYW50aWNzIGlzIG5vbi10cml2aWFsOyBtaWdodCByZXF1aXJlIHR5cGVjYXNlLlxuLy8gSWYgd2Ugd2FudCBpbnRlZ2VyIGRpdmlzaW9uLCBhcHBhcmVudGx5IH5+KHggLyB5KSB3aWxsIHJvdW5kIGluIHRoZSByaWdodCBkaXJlY3Rpb24uXG5jb25zdCBkaXY6IEJpbmFyeTxOdW0sIE51bSwgTnVtPiA9ICh4LCB5KSA9PiAoazogSWQpID0+IHtcbiAgIGNvbnN0IG46IE51bSA9IG51bShhcyh4LCBOdW0pLnZhbCAvIGFzKHksIE51bSkudmFsKShrKVxuICAgaWYgKCFpc0Zpbml0ZShuLnZhbCkpIHtcbiAgICAgIHVzZXJFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIiwgeCwgeSlcbiAgIH1cbiAgIHJldHVybiBuXG59XG5cbmNvbnN0IGNvbmNhdDogQmluYXJ5PFN0ciwgU3RyLCBTdHI+ID0gKHgsIHkpID0+IHN0cihhcyh4LCBTdHIpLnZhbCArIGFzKHksIFN0cikudmFsKVxuXG5jb25zdCBlcXVhbDogQmluYXJ5PE51bSB8IFN0ciwgTnVtIHwgU3RyLCBCb29sPiA9ICh4LCB5KSA9PiB7XG4gICBpZiAoeCBpbnN0YW5jZW9mIE51bSAmJiB5IGluc3RhbmNlb2YgTnVtKSB7XG4gICAgICByZXR1cm4geC52YWwgPT09IHkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2VcbiAgIGlmICh4IGluc3RhbmNlb2YgU3RyICYmIHkgaW5zdGFuY2VvZiBTdHIpIHtcbiAgICAgIHJldHVybiB4LnZhbCA9PT0geS52YWwgPyB0cnVlXygpIDogZmFsc2VfKClcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXNlckVycm9yKGBFeHBlY3RlZCAke051bS5uYW1lfSBvciAke1N0ci5uYW1lfS5gKVxuICAgfVxufVxuXG5jb25zdCBlcnJvcjogVW5hcnk8U3RyLCBWYWx1ZT4gPSBtZXNzYWdlID0+IGFzc2VydChmYWxzZSwgXCJGbHVpZCBlcnJvcjpcXG5cIiArIG1lc3NhZ2UudmFsKVxuXG5jb25zdCBncmVhdGVyRXE6IEJpbmFyeTxOdW0gfCBTdHIsIE51bSB8IFN0ciwgQm9vbD4gPSAoeCwgeSkgPT4ge1xuICAgaWYgKHggaW5zdGFuY2VvZiBOdW0gJiYgeSBpbnN0YW5jZW9mIE51bSkge1xuICAgICAgcmV0dXJuIHgudmFsID49IHkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2VcbiAgIGlmICh4IGluc3RhbmNlb2YgU3RyICYmIHkgaW5zdGFuY2VvZiBTdHIpIHtcbiAgICAgIC8vIHN0cmluZyBjb21wYXJpc29uIGRlbGVnYXRlcyB0byBjZW50cmFsIGltcGxlbWVudGF0aW9uIGZvciBjb25zaXN0ZW5jeVxuICAgICAgcmV0dXJuIHguZ2VxKHkpID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVzZXJFcnJvcihgRXhwZWN0ZWQgJHtOdW0ubmFtZX0gb3IgJHtTdHIubmFtZX0uYClcbiAgIH1cbn1cblxuY29uc3QgZ3JlYXRlcjogQmluYXJ5PE51bSwgTnVtLCBCb29sPiA9ICh4LCB5KSA9PiBhcyh4LCBOdW0pLnZhbCA+IGFzKHksIE51bSkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG5cbmNvbnN0IGxlc3NFcTogQmluYXJ5PE51bSwgTnVtLCBCb29sPiA9ICh4LCB5KSA9PiB7XG4gICBpZiAoeCBpbnN0YW5jZW9mIE51bSAmJiB5IGluc3RhbmNlb2YgTnVtKSB7XG4gICAgICByZXR1cm4gYXMoeCwgTnVtKS52YWwgPD0gYXMoeSwgTnVtKS52YWwgPyB0cnVlXygpIDogZmFsc2VfKClcbiAgIH0gZWxzZVxuICAgaWYgKHggaW5zdGFuY2VvZiBTdHIgJiYgeSBpbnN0YW5jZW9mIFN0cikge1xuICAgICAgcmV0dXJuIHgubGVxKHkpID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVzZXJFcnJvcihgRXhwZWN0ZWQgJHtOdW0ubmFtZX0gb3IgJHtTdHIubmFtZX0uYClcbiAgIH1cbn1cblxuY29uc3QgbGVzczogQmluYXJ5PE51bSwgTnVtLCBCb29sPiA9ICh4LCB5KSA9PiBhcyh4LCBOdW0pLnZhbCA8IGFzKHksIE51bSkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG5jb25zdCBtaW51czogQmluYXJ5PE51bSwgTnVtLCBOdW0+ID0gKHgsIHkpID0+IG51bShhcyh4LCBOdW0pLnZhbCAtIGFzKHksIE51bSkudmFsKVxuY29uc3QgcGx1czogQmluYXJ5PE51bSwgTnVtLCBOdW0+ID0gKHgsIHkpID0+IG51bShhcyh4LCBOdW0pLnZhbCArIGFzKHksIE51bSkudmFsKVxuY29uc3QgcG93OiBCaW5hcnk8TnVtLCBOdW0sIE51bT4gPSAoeCwgeSkgPT4gbnVtKGFzKHgsIE51bSkudmFsICoqIGFzKHksIE51bSkudmFsKVxuY29uc3QgdGltZXM6IEJpbmFyeTxOdW0sIE51bSwgTnVtPiA9ICh4LCB5KSA9PiBudW0oYXMoeCwgTnVtKS52YWwgKiBhcyh5LCBOdW0pLnZhbClcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcyBmb3IgYnVpbGRpbmcgdGhlIG1hcHMuIEV4cG9ydCB0byBhbGxvdyBvdGhlciBtb2R1bGVzIHRvIHByb3ZpZGUgb3BlcmF0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiB1bmFyeV88VCBleHRlbmRzIFByaW1WYWx1ZSwgViBleHRlbmRzIFZhbHVlPiAob3A6IFVuYXJ5PFQsIFY+KTogRXhwbFZhbHVlPFVuYXJ5T3A+IHtcbiAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5jb25zdF8oKSjOvSgpKSwgYXQoVW5hcnlPcCwgb3AubmFtZSwgb3ApKM69KCkpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5XzxUIGV4dGVuZHMgUHJpbVZhbHVlLCBVIGV4dGVuZHMgUHJpbVZhbHVlLCBWIGV4dGVuZHMgVmFsdWU+IChvcDogQmluYXJ5PFQsIFUsIFY+KTogRXhwbFZhbHVlPEJpbmFyeU9wPiB7XG4gICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuY29uc3RfKCkozr0oKSksIGF0KEJpbmFyeU9wLCBvcC5uYW1lLCBvcCkozr0oKSkpXG59XG5cbi8vIFByaW1pdGl2ZXMgd2l0aCBpZGVudGlmaWVycyBhcyBuYW1lcyBhcmUgdW5hcnkgYW5kIGZpcnN0LWNsYXNzLlxuZXhwb3J0IGNvbnN0IHVuYXJ5T3BzOiBNYXA8c3RyaW5nLCBFeHBsVmFsdWU8VW5hcnlPcD4+ID0gbmV3IE1hcChbXG4gICBbY2VpbGluZy5uYW1lLCB1bmFyeV8oY2VpbGluZyldLFxuICAgW2RlYnVnTG9nLm5hbWUsIHVuYXJ5XyhkZWJ1Z0xvZyldLFxuICAgW2Vycm9yLm5hbWUsIHVuYXJ5XyhlcnJvcildLFxuICAgW2Zsb29yLm5hbWUsIHVuYXJ5XyhmbG9vcildLFxuICAgW2xvZy5uYW1lLCB1bmFyeV8obG9nKV0sXG4gICBbbnVtVG9TdHIubmFtZSwgdW5hcnlfKG51bVRvU3RyKV1cbl0pXG4gICBcbmV4cG9ydCBjb25zdCBiaW5hcnlPcHM6IE1hcDxzdHJpbmcsIEV4cGxWYWx1ZTxCaW5hcnlPcD4+ID0gbmV3IE1hcChbXG4gICBbXCItXCIsIGJpbmFyeV8obWludXMpXSxcbiAgIFtcIitcIiwgYmluYXJ5XyhwbHVzKV0sXG4gICBbXCIqXCIsIGJpbmFyeV8odGltZXMpXSxcbiAgIFtcIioqXCIsIGJpbmFyeV8ocG93KV0sXG4gICBbXCIvXCIsIGJpbmFyeV8oZGl2KV0sXG4gICBbXCI9PVwiLCBiaW5hcnlfKGVxdWFsKV0sXG4gICBbXCI+XCIsIGJpbmFyeV8oZ3JlYXRlcildLFxuICAgW1wiPj1cIiwgYmluYXJ5XyhncmVhdGVyRXEpXSxcbiAgIFtcIjxcIiwgYmluYXJ5XyhsZXNzKV0sXG4gICBbXCI8PVwiLCBiaW5hcnlfKGxlc3NFcSldLFxuICAgW1wiKytcIiwgYmluYXJ5Xyhjb25jYXQpXVxuXSlcbiIsImltcG9ydCB7IENsYXNzLCBfX25vbk51bGwsIGFic3VyZCwgYXNzZXJ0IH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IE9yZCB9IGZyb20gXCIuL3V0aWwvT3JkXCJcbmltcG9ydCB7IFZhbHVlRGVsdGEsIF9fZGVsdGFzIH0gZnJvbSBcIi4vRGVsdGFcIlxuXG4vLyBVc2UgdG8gaW5pdGlhbGlzZSBmaWVsZHMgZm9yIHJlZmxlY3Rpb24sIHdpdGhvdXQgcmVxdWlyaW5nIGNvbnN0cnVjdG9ycy5cbmV4cG9ydCBjb25zdCBfOiBhbnkgPSB1bmRlZmluZWQgXG5cbi8vIFNvbWV3aGF0IHBlcnZlcnNlIHRvIGRvIHRoaXMsIGJ1dCBuZWVkIHNvbWUgdHlwZSBzYWZldHkhXG5leHBvcnQgdHlwZSBEYXRhVmFsdWVUYWcgPVxuICAgXCJWaWV3cG9ydFwiIHwgXCJDaXJjbGVcIiB8IFwiR3JvdXBcIiB8IFwiTGluZVwiIHwgXCJNYXJrZXJcIiB8IFwiT3JpZW50XCIgfCBcIlBvbHlsaW5lXCIgfCBcIlBvbHltYXJrZXJzXCIgfCBcIlNjYWxlXCIgfCBcIlRyYW5zbGF0ZVwiIHwgXCJUZXh0XCIgfCBcIlRyYW5zZm9ybVwiIHwgXCJDaXJjbGVcIiB8IFwiQXJyb3doZWFkXCIgfFxuICAgXCJCb29sXCIgfCBcIkNsb3N1cmVcIiB8IFwiRGF0YUV4cGxcIiB8IFwiRWxpbVwiIHwgXCJNYXRjaFwiIHwgXCJFbnZcIiB8IFwiRXhwbFwiIHwgXCJFeHBsLkRlZlwiIHwgXCJFeHBsLlJlY0RlZlwiIHwgXCJFeHBsVmFsdWVcIiB8IFwiRXhwclwiIHwgXCJFeHByLkRlZlwiIHwgIFxuICAgXCJMaXN0XCIgfCBcIk9wdGlvblwiIHwgXCJPcmRlcmluZ1wiIHwgXCJQYWlyXCIgfCBcIlBsdWdcIiB8IFwiUG9pbnRcIiB8IFwiRXhwci5SZWNEZWZcIiB8IFwiUmVjdFwiIHwgXCJUcmVlXCIgfCBcIlRva2VuXCJcbmV4cG9ydCB0eXBlIExleGVtZVRhZyA9IFwiV2hpdGVzcGFjZVwiIHwgXCJTaW5nbGVMaW5lQ29tbWVudFwiIHwgXCJPcGVyYXRvclwiXG5leHBvcnQgdHlwZSBQcmltT3BUYWcgPSBcIlVuYXJ5T3BcIiB8IFwiQmluYXJ5T3BcIlxuZXhwb3J0IHR5cGUgVmFsdWVUYWcgPSBEYXRhVmFsdWVUYWcgfCBMZXhlbWVUYWcgfCBQcmltT3BUYWcgfCBcIklkXCIgfCBcIk51bVwiIHwgXCJTdHJcIlxuXG4vLyBWYWx1ZSBpbiB0aGUgbWV0YWxhbmd1YWdlLlxuZXhwb3J0IGNsYXNzIFZhbHVlPFRhZyBleHRlbmRzIFZhbHVlVGFnID0gVmFsdWVUYWc+IHtcbiAgIHJlYWRvbmx5IF9fdGFnITogVGFnXG5cbiAgIF9fY2hpbGQgKGs6IGtleW9mIHRoaXMpOiBQZXJzaXN0ZW50IHtcbiAgICAgIHJldHVybiB0aGlzW2tdIGFzIHVua25vd24gYXMgUGVyc2lzdGVudFxuICAgfVxuXG4gICAvLyBQcm9iYWJseSBjb25mdXNpbmdseSwgXCJjaGlsZHJlblwiIGlzbid0IGEgdXNlci1sZXZlbCBub3Rpb247IHNwZWNpZmljYWxseSwgd3JhcHBlcnNcbiAgIC8vIGxpa2UgTnVtIGFuZCBTdHIgaGF2ZSBjaGlsZHJlbiB3aGljaCBhcmUgbm90IG9ic2VydmFibGUgdGhyb3VnaCBwYXR0ZXJuLW1hdGNoaW5nLlxuICAgZ2V0IF9fY2hpbGRyZW4gKCk6IFBlcnNpc3RlbnRbXSB7XG4gICAgICByZXR1cm4gZmllbGRzKHRoaXMpLm1hcChrID0+IHRoaXMuX19jaGlsZChrKSlcbiAgIH1cbn1cblxuLy8gQWRkcmVzcyBvciBsb2NhdGlvbiBvZiBwZXJzaXN0ZW50IG9iamVjdC5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJZCBleHRlbmRzIFZhbHVlPFwiSWRcIj4ge1xuICAgdGFnPFRhZyBleHRlbmRzIHN0cmluZz4gKHRhZzogVGFnKTogVGFnZ2VkSWQ8VGFnPiB7XG4gICAgICByZXR1cm4gdGFnZ2VkSWQodGhpcywgdGFnKVxuICAgfVxufVxuXG5jbGFzcyBGdW5jdGlvbklkIGV4dGVuZHMgSWQge1xuICAgZjogRnVuY3Rpb24gPSBfXG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uSWQgKGY6IEZ1bmN0aW9uKTogRnVuY3Rpb25JZCB7XG4gICByZXR1cm4gbWFrZShGdW5jdGlvbklkLCBmKVxufVxuXG5leHBvcnQgY2xhc3MgQXBwbGljYXRpb25JZCBleHRlbmRzIElkIHtcbiAgIGs6IE1lbW9JZCA9IF9cbiAgIHY6IFBlcnNpc3RlbnQgPSBfXG59XG5cbmV4cG9ydCB0eXBlIE1lbW9JZCA9IEZ1bmN0aW9uSWQgfCBBcHBsaWNhdGlvbklkXG5cbmZ1bmN0aW9uIGFwcGxpY2F0aW9uSWQgKGs6IE1lbW9JZCwgdjogUGVyc2lzdGVudCk6IEFwcGxpY2F0aW9uSWQge1xuICAgcmV0dXJuIG1ha2UoQXBwbGljYXRpb25JZCwgaywgdilcbn1cblxuZXhwb3J0IGNsYXNzIFRhZ2dlZElkPFRhZyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBJZCB7XG4gICBrOiBJZCA9IF9cbiAgIHByb3A6IFRhZyA9IF9cbn1cblxuZnVuY3Rpb24gdGFnZ2VkSWQ8VGFnIGV4dGVuZHMgc3RyaW5nPiAoazogSWQsIHByb3A6IFRhZyk6IFRhZ2dlZElkPFRhZz4ge1xuICAgcmV0dXJuIG1ha2UoVGFnZ2VkSWQsIGssIHByb3ApIGFzIFRhZ2dlZElkPFRhZz5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9JZCAoZjogRnVuY3Rpb24sIHbMhTogSXRlcmFibGU8YW55Pik6IE1lbW9JZCB7XG4gICBjb25zdCBmyrk6IEZ1bmN0aW9uSWQgPSBmdW5jdGlvbklkKGYpXG4gICBsZXQgazogTWVtb0lkID0gZsq5XG4gICBmb3IgKGxldCB2IG9mIHbMhSkge1xuICAgICAgayA9IGFwcGxpY2F0aW9uSWQoaywgdilcbiAgIH1cbiAgIHJldHVybiBrXG59XG5cbi8vIEZ1bmN0aW9ucyBhcmUgcGVyc2lzdGVudCB0byBzdXBwb3J0IHByaW1pdGl2ZXMuIFByaW1pdGl2ZSBkYXRhdHlwZXMgbGlrZSBOdW0gYW5kIFN0ciBjb250YWluXG4vLyBFUzYgcHJpbWl0aXZlcyBsaWtlIG51bWJlciBhbmQgc3RyaW5nLCB3aGljaCBhcmUgKGN1cnJlbnRseSkgXCJwZXJzaXN0ZW50XCIgZm9yIGludGVybmluZyBwdXJwb3Nlc1xuLy8gYnV0IGFyZSBub3QgXCJ2YWx1ZXNcIiBiZWNhdXNlIHRoZXkgYXJlIG5vdCBvYnNlcnZhYmxlIHRvIHVzZXIgY29kZS4gQm9vbGVhbnMgYXJlIHBlcnNpc3RlbnRcbi8vIHRvIHN1cHBvcnQgYW5ub3RhdGlvbiBoZWxwZXJzLlxuZXhwb3J0IHR5cGUgUGVyc2lzdGVudCA9IFZhbHVlIHwgYm9vbGVhbiB8IHN0cmluZyB8IG51bWJlciB8IEZ1bmN0aW9uXG5cbmV4cG9ydCB0eXBlIFByaW1WYWx1ZSA9IE51bSB8IFN0clxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmltICh2OiBWYWx1ZSk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHYgaW5zdGFuY2VvZiBOdW0gfHwgdiBpbnN0YW5jZW9mIFN0clxufVxuXG5leHBvcnQgY2xhc3MgTnVtIGV4dGVuZHMgVmFsdWU8XCJOdW1cIj4ge1xuICAgdmFsOiBudW1iZXIgPSBfXG5cbiAgIHRvU3RyaW5nICgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMudmFsLnRvU3RyaW5nKClcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0ciBleHRlbmRzIFZhbHVlPFwiU3RyXCI+IGltcGxlbWVudHMgT3JkPFN0cj4ge1xuICAgdmFsOiBzdHJpbmcgPSBfXG5cbiAgIHRvU3RyaW5nICgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIGBcIiR7dGhpcy52YWx9XCJgXG4gICB9XG5cbiAgIGxlcSAoc3RyOiBTdHIpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbC5sb2NhbGVDb21wYXJlKHN0ci52YWwpIDw9IDBcbiAgIH1cblxuICAgZXEgKHN0cjogU3RyKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy52YWwubG9jYWxlQ29tcGFyZShzdHIudmFsKSA9PT0gMFxuICAgfVxuXG4gICBnZXEgKHN0cjogU3RyKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy52YWwubG9jYWxlQ29tcGFyZShzdHIudmFsKSA+PSAwXG4gICB9XG59XG5cbi8vIE1lcmdlYWJsZSBzdGF0ZSBkZWx0YXMgYXJlIGRpc2pvaW50LlxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50byAodGd0OiBWYWx1ZURlbHRhLCBzcmM6IFZhbHVlRGVsdGEpOiB2b2lkIHtcbiAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaCgocHJvcDogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIXRndC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgdGd0W3Byb3BdID0gc3JjW3Byb3BdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgYWJzdXJkKFxuICAgICAgICAgICAgYEluY29tcGF0aWJsZSB1cGRhdGUgb2YgZmllbGQgXCIke3Byb3B9XCIgYXQgcmV2aXNpb24uYCxcbiAgICAgICAgICAgIHRndFtwcm9wXSwgXG4gICAgICAgICAgICBzcmNbcHJvcF1cbiAgICAgICAgIClcbiAgICAgIH1cbiAgIH0pXG59XG5cbi8vIEN1cnJpZWQgbWFwIGZyb20gY29uc3RydWN0b3JzIGFuZCBhcmd1bWVudHMgdG8gY2FjaGVkIHZhbHVlczsgY3VycmllZCBiZWNhdXNlIGNvbXBvc2l0ZSBrZXlzIHdvdWxkIFxuLy8gcmVxdWlyZSBlaXRoZXIgY3VzdG9tIGVxdWFsaXR5LCB3aGljaCBpc24ndCBwb3NzaWJsZSB3aXRoIEVTNiBtYXBzLCBvciBpbnRlcm5pbmcsIHdoaWNoIHdvdWxkIGVzc2VudGlhbGx5XG4vLyBpbnZvbHZlIHRoZSBzYW1lIG1lbW9pc2F0aW9uIGxvZ2ljLlxuZXhwb3J0IHR5cGUgTWVtb1RhYmxlID0gTWFwPFBlcnNpc3RlbnQsIFBlcnNpc3RlbnQgfCBNYXA8UGVyc2lzdGVudCwgT2JqZWN0Pj4gLy8gYXBwcm94aW1hdGUgcmVjdXJzaXZlIHR5cGVcblxuLy8gSGFzaC1jb25zZWQgY29uc3RydWN0b3JzIGFyZSBpbnZhcmlhbnQgYWNyb3NzIHdvcmxkcy5cbmNvbnN0IF9fY3RyTWVtbzogTWVtb1RhYmxlID0gbmV3IE1hcFxuXG5mdW5jdGlvbiBsb29rdXBBcmc8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IChmOiBNZW1vaXNhYmxlPFQ+LCBtOiBNZW1vVGFibGUsIHbMhTogUGVyc2lzdGVudFtdLCBuOiBudW1iZXIpOiBQZXJzaXN0ZW50IHwgTWFwPFBlcnNpc3RlbnQsIE9iamVjdD4ge1xuICAgLy8gZm9yIG1lbW9pc2F0aW9uIHB1cnBvc2VzLCB0cmVhdCBmJ3Mga2V5IGFzIGFyZ3VtZW50IC0xXG4gICBjb25zdCBrOiBQZXJzaXN0ZW50ID0gbiA9PT0gLTEgPyBmLmtleSA6IHbMhVtuXVxuICAgbGV0IHY6IFBlcnNpc3RlbnQgfCBNYXA8UGVyc2lzdGVudCwgT2JqZWN0PiB8IHVuZGVmaW5lZCA9IG0uZ2V0KGspXG4gICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobiA9PT0gdsyFLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgIHYgPSBmLmNhbGwodsyFKVxuICAgICAgICAgdiA9IHYhIC8vIFRTIGNvbmZ1c2VkOyB0aGlua3MgdiBjYW4gYmUgdW5kZWZpbmVkIGhlcmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICB2ID0gbmV3IE1hcFxuICAgICAgfVxuICAgICAgbS5zZXQoaywgdilcbiAgIH1cbiAgIHJldHVybiB2XG59XG5cbi8vIFVuaWZ5IG1lbW8tZnVuY3Rpb25zIGFuZCBpbnRlcm5lZCBjbGFzc2VzLlxuZXhwb3J0IGludGVyZmFjZSBNZW1vaXNhYmxlPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiB7XG4gICBrZXk6IFBlcnNpc3RlbnRcbiAgIGNhbGwgKGFyZ3M6IFBlcnNpc3RlbnRbXSk6IFRcbn1cblxuY2xhc3MgTWVtb0N0cjxUIGV4dGVuZHMgVmFsdWU+IGltcGxlbWVudHMgTWVtb2lzYWJsZTxUPiB7XG4gICBDOiBDbGFzczxUPlxuXG4gICBjb25zdHJ1Y3RvciAoQzogQ2xhc3M8VD4pIHtcbiAgICAgIHRoaXMuQyA9IENcbiAgIH1cblxuICAgZ2V0IGtleSAoKTogUGVyc2lzdGVudCB7XG4gICAgICByZXR1cm4gdGhpcy5DXG4gICB9IFxuXG4gICBjYWxsICh2zIU6IFBlcnNpc3RlbnRbXSk6IFQge1xuICAgICAgY29uc3QgdjogVCA9IG5ldyB0aGlzLkNcbiAgICAgIGNvbnN0cnVjdChmYWxzZSwgdiwgdsyFKVxuICAgICAgT2JqZWN0LmZyZWV6ZSh2KVxuICAgICAgcmV0dXJuIHZcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9DYWxsPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAobWVtbzogTWVtb1RhYmxlLCBmOiBNZW1vaXNhYmxlPFQ+LCB2zIU6IFBlcnNpc3RlbnRbXSk6IFQge1xuICAgbGV0IHY6IFBlcnNpc3RlbnQgfCBNYXA8UGVyc2lzdGVudCwgT2JqZWN0PiA9IGxvb2t1cEFyZyhmLCBtZW1vLCB2zIUsIC0xKVxuICAgZm9yIChsZXQgbjogbnVtYmVyID0gMDsgbiA8IHbMhS5sZW5ndGg7ICsrbikge1xuICAgICAgLy8gc2luY2UgdGhlcmUgYXJlIG1vcmUgYXJndW1lbnRzLCB0aGUgbGFzdCB2IHdhcyBhIChwb3NzaWJseSBuZXN0ZWQpIG1hcFxuICAgICAgdiA9IGxvb2t1cEFyZyhmLCB2IGFzIE1lbW9UYWJsZSwgdsyFLCBuKVxuICAgfVxuICAgcmV0dXJuIHYgYXMgVFxufVxuXG4vLyBFeHBlcmltZW50ZWQgd2l0aCBkaWN0aW9uYXJ5LWJhc2VkIGNvbnN0cnVjdGlvbiBwYXR0ZXJuOyBlbGltaW5hdGVzIGZpZWxkIG9yZGVyIG1pc21hdGNoIGFzIGEgcG9zc2libGVcbi8vIHNvdXJjZSBvZiBlcnJvciwgYnV0IHRoZSBiZW5lZml0IGlzIHZlcnkgc21hbGwgYW5kIGRvZXNuJ3QgcmVhbGx5IHN1aXQgdGhlIG1lbW9pc2F0aW9uIHBhdHRlcm4uXG5leHBvcnQgZnVuY3Rpb24gbWFrZTxUIGV4dGVuZHMgVmFsdWU+IChDOiBDbGFzczxUPiwgLi4udsyFOiBQZXJzaXN0ZW50W10pOiBUIHtcbiAgIHJldHVybiBtZW1vQ2FsbChfX2N0ck1lbW8sIG5ldyBNZW1vQ3RyKEMpLCB2zIUpXG59XG5cbi8vIERlcGVuZHMgaGVhdmlseSBvbiAoMSkgZ2V0T3duUHJvcGVydHlOYW1lcygpIHJldHVybmluZyBmaWVsZHMgaW4gZGVmaW5pdGlvbi1vcmRlcjsgYW5kICgyKVxuLy8gY29uc3RydWN0b3IgZnVuY3Rpb25zIHN1cHBseWluZyBhcmd1bWVudHMgaW4gdGhlIHNhbWUgb3JkZXIuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0PFQgZXh0ZW5kcyBWYWx1ZT4gKGNvbXBhcmU6IGJvb2xlYW4sIHRndDogVCwgdsyFOiBQZXJzaXN0ZW50W10pOiBWYWx1ZURlbHRhIHwgbnVsbCB7XG4gICBjb25zdCBmzIU6IChrZXlvZiBUKVtdID0gZmllbGRzKHRndCksXG4gICAgICAgICDhup86IFZhbHVlRGVsdGEgfCBudWxsID0gY29tcGFyZSA/IHt9IDogbnVsbFxuICAgYXNzZXJ0KGbMhS5sZW5ndGggPT09IHbMhS5sZW5ndGgpXG4gICBsZXQgbjogbnVtYmVyID0gMFxuICAgZsyFLmZvckVhY2goKHByb3A6IGtleW9mIFQpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHNyYzogUGVyc2lzdGVudCA9IHbMhVtuKytdXG4gICAgICBpZiAoY29tcGFyZSAmJiB0Z3QuX19jaGlsZChwcm9wKSAhPT0gc3JjKSB7XG4gICAgICAgICDhup8hW3Byb3AgYXMgc3RyaW5nXSA9IHsgYmVmb3JlOiB0Z3QuX19jaGlsZChwcm9wKSwgYWZ0ZXI6IHNyYyB9XG4gICAgICB9XG4gICAgICAodGd0IGFzIGFueSlbcHJvcF0gPSBzcmNcbiAgIH0pXG4gICByZXR1cm4g4bqfXG59XG5cbi8vIEV4Y2x1ZGUgbWV0YWRhdGEgYWNjb3JkaW5nIHRvIG91ciBjb252ZW50aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIGlzRmllbGQgKHByb3A6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuICFwcm9wLnN0YXJ0c1dpdGgoXCJfX1wiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmllbGRzPFQ+ICh2OiBUKTogKGtleW9mIFQpW10ge1xuICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHYpLmZpbHRlcihpc0ZpZWxkKSBhcyAoa2V5b2YgVClbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWV0YWRhdGFGaWVsZHMgKHY6IFZhbHVlKTogc3RyaW5nW10ge1xuICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHYpLmZpbHRlcihmID0+ICFpc0ZpZWxkKGYpICYmIGYgIT09IFwiX19pZFwiKVxufVxuIiwiaW1wb3J0IHsgQ2xhc3MsIF9fbm9uTnVsbCwgYXNzZXJ0IH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IERlbHRhLCBDaGFuZ2UsIF9fZGVsdGFzIH0gZnJvbSBcIi4vRGVsdGFcIlxuaW1wb3J0IHsgSWQsIE1lbW9pc2FibGUsIE1lbW9UYWJsZSwgUGVyc2lzdGVudCwgTnVtLCBTdHIsIFZhbHVlLCBfLCBjb25zdHJ1Y3QsIGZpZWxkcywgbWFrZSwgbWVtb0NhbGwgfSBmcm9tIFwiLi9WYWx1ZVwiXG5cbi8vIFZlcnNpb25lZCBvYmplY3RzIGFyZSBwZXJzaXN0ZW50IG9iamVjdHMgdGhhdCBoYXZlIHN0YXRlIHRoYXQgdmFyaWVzIGFjcm9zcyB3b3JsZHMuIEludGVyZmFjZSBiZWNhdXNlIHRoZSBcbi8vIHNhbWUgZGF0YXR5cGUgY2FuIGJlIGludGVybmVkIGluIHNvbWUgY29udGV4dHMgYW5kIHZlcnNpb25lZCBpbiBvdGhlcnMuXG5leHBvcnQgdHlwZSBWZXJzaW9uZWQ8VD4gPSBWZXJzaW9uZWRfICYgVFxuXG4vLyBXaHkgZG8gdmVyc2lvbmVkIG9iamVjdHMgbmVlZCB0byBzdG9yZSB0aGVpciBpZD9cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvbmVkXyB7XG4gICBfX2lkOiBJZFxuICAgX1/hup86IERlbHRhIC8vIGRlbHRhcyBzaG91bGQgYmUgcmVzdHJpY3RlZCB0byBrZXlzIG9mIHR5cGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcnNpb25lZDxUIGV4dGVuZHMgVmFsdWU+ICh2OiBUKTogdiBpcyBWZXJzaW9uZWQ8VD4ge1xuICAgcmV0dXJuICh2IGFzIFZlcnNpb25lZDxUPikuX19pZCAhPT0gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1ZlcnNpb25lZDxUIGV4dGVuZHMgVmFsdWU+ICh2OiBUKTogVmVyc2lvbmVkPFQ+IHtcbiAgIGlmICh2ZXJzaW9uZWQodikpIHtcbiAgICAgIHJldHVybiB2XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydChmYWxzZSwgYCR7dn0gaXMgbm90IHZlcnNpb25lZC5gKVxuICAgfVxufVxuXG4vLyBGb3IgdmVyc2lvbmVkIG9iamVjdHMgdGhlIG1hcCBpcyBub3QgY3VycmllZCBidXQgdGFrZXMgYW4gKGludGVybmVkKSBjb21wb3NpdGUga2V5LiBUaGlzIHN0b3JlcyBvbmx5IFwiZGVyaXZlZFwiXG4vLyAoaW50ZXJuYWwpIHZlcnNpb25lZCBub2Rlcywgbm90IGV4dGVybmFsLlxudHlwZSBWZXJzaW9uZWRWYWx1ZXMgPSBNYXA8SWQsIFZlcnNpb25lZDxWYWx1ZT4+XG5jb25zdCBfX3ZlcnNpb25lZDogVmVyc2lvbmVkVmFsdWVzID0gbmV3IE1hcCgpXG5jb25zdCBfX3JlYWNoYWJsZTogU2V0PFZlcnNpb25lZDxWYWx1ZT4+ID0gbmV3IFNldCgpIC8vIHN1YnNldCBvZiBfX3ZlcnNpb25lZCByZWFjaGFibGUgYXQgY3VycmVudCByZXZpc2lvblxuXG4vLyBUaGUgKHBvc3NpYmx5IGFscmVhZHkgZXh0YW50KSB2ZXJzaW9uZWQgb2JqZWN0IHVuaXF1ZWx5IGlkZW50aWZpZWQgYnkgYSBtZW1vLWtleS4gQXMgYW4gaWRlbXBvdGVudCBzaWRlLWVmZmVjdCxcbi8vIHJlY29yZCBob3cgdGhlIG9iamVjdCBkaWZmZXJzIGZyb20gaXRzIHByZXZpb3VzIHZlcnNpb24uIEV4dGVybmFsIG5vZGVzIGFyZSBhbHdheXMgY3JlYXRlZCBmcmVzaC5cbmV4cG9ydCBmdW5jdGlvbiBhdDxUIGV4dGVuZHMgVmFsdWU+IChDOiBDbGFzczxUPiwgLi4udsyFOiBQZXJzaXN0ZW50W10pOiAoazogSWQpID0+IFZlcnNpb25lZDxUPiB7XG4gICByZXR1cm4gKGs6IElkKSA9PiB7XG4gICAgICBsZXQgdjogVmVyc2lvbmVkPFZhbHVlPiB8IHVuZGVmaW5lZCA9IF9fdmVyc2lvbmVkLmdldChrKVxuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgY29uc3QgdjogVmVyc2lvbmVkPFQ+ID0gY3JlYXRlKEMsIC4uLnbMhSkoaylcbiAgICAgICAgIGlmICghKGsgaW5zdGFuY2VvZiBFeHRlcm4pKSB7XG4gICAgICAgICAgICBfX3ZlcnNpb25lZC5zZXQoaywgdilcbiAgICAgICAgICAgIF9fcmVhY2hhYmxlLmFkZCh2KVxuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIHZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhc3NlcnQoIShrIGluc3RhbmNlb2YgRXh0ZXJuKSlcbiAgICAgICAgIF9fcmVhY2hhYmxlLmFkZCh2KVxuICAgICAgICAgcmVzZXQodiwgQywgLi4udsyFKVxuICAgICAgICAgcmV0dXJuIHYgYXMgVmVyc2lvbmVkPFQ+XG4gICAgICB9XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIFZhbHVlPiAoQzogQ2xhc3M8VD4sIC4uLnbMhTogUGVyc2lzdGVudFtdKTogKGs6IElkKSA9PiBWZXJzaW9uZWQ8VD4ge1xuICAgcmV0dXJuIChrOiBJZCkgPT4ge1xuICAgICAgY29uc3QgdjogVmVyc2lvbmVkPFQ+ID0gbmV3IEMgYXMgVmVyc2lvbmVkPFQ+XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJfX2lkXCIsIHtcbiAgICAgICAgIHZhbHVlOiBrLFxuICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJfX+G6n1wiLCB7XG4gICAgICAgICAvLyBUaGUgZGVsdGEgbWFwIGlzIHBhcnRpYWw7IHRoZSBhYnNlbmNlIG9mIGFuIGVudHJ5IGlzIGVxdWl2YWxlbnQgdG8gYW4gZW1wdHkgZGVsdGEuIFRoaXMgYWxsb3dzXG4gICAgICAgICAvLyBkZWx0YXMgdG8gYmUgY2xlYXJlZCBzaW1wbHkgYnkgcmVtb3ZpbmcgYWxsIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKTogRGVsdGEge1xuICAgICAgICAgICAgbGV0IOG6nzogRGVsdGEgfCB1bmRlZmluZWQgPSBfX2RlbHRhcy7hup/MhS5nZXQodGhpcylcbiAgICAgICAgICAgIGlmICjhup8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAg4bqfID0gbmV3IENoYW5nZSh7fSlcbiAgICAgICAgICAgICAgIF9fZGVsdGFzLuG6n8yFLnNldCh0aGlzLCDhup8pXG4gICAgICAgICAgICAgICByZXR1cm4g4bqfXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIOG6n1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSxcbiAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgICAgY29uc3RydWN0KGZhbHNlLCB2LCB2zIUpXG4gICAgICBfX2RlbHRhcy5jcmVhdGVkKHYpXG4gICAgICByZXR1cm4gdlxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQ8VCBleHRlbmRzIFZhbHVlPiAodjogVmFsdWUsIEM6IENsYXNzPFQ+LCAuLi52zIU6IFBlcnNpc3RlbnRbXSk6IHZvaWQge1xuICAgaWYgKHYgaW5zdGFuY2VvZiBDKSB7XG4gICAgICBfX2RlbHRhcy5jaGFuZ2VkKHYsIGNvbnN0cnVjdCh0cnVlLCB2LCB2zIUpISlcbiAgIH0gZWxzZSB7XG4gICAgICByZWNsYXNzaWZ5KHYsIEMpXG4gICAgICBjb25zdHJ1Y3QoZmFsc2UsIHYsIHbMhSlcbiAgICAgIF9fZGVsdGFzLnJlY2xhc3NpZmllZCh2KVxuICAgfVxufVxuXG4vLyBTaG91bGQgZW11bGF0ZSB0aGUgcG9zdC1zdGF0ZSBvZiBcIm5ldyBDXCIuIFByb2JhYmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgaG93IHRoaXMgd29ya3Mgd2l0aCBpbmhlcml0ZWQgcHJvcGVydGllcy5cbmZ1bmN0aW9uIHJlY2xhc3NpZnk8VCBleHRlbmRzIFZhbHVlPiAodjogVmFsdWUsIGN0cjogQ2xhc3M8VD4pOiB2b2lkIHtcbiAgIGNvbnN0IHByb3RvOiBPYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IGN0cilcbiAgIGFzc2VydCAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHYpICE9PSBwcm90bylcbiAgIGZvciAoY29uc3QgayBvZiBmaWVsZHModikpIHtcbiAgICAgIGFzc2VydChkZWxldGUgdltrIGFzIGtleW9mIE9iamVjdF0pXG4gICB9XG4gICBPYmplY3Quc2V0UHJvdG90eXBlT2YodiwgcHJvdG8pXG59XG5cbi8vIEEgbWVtbyBrZXkgd2hpY2ggaXMgc291cmNlZCBleHRlcm5hbGx5IHRvIHRoZSBzeXN0ZW0uIChUaGUgbmFtZSBcIkV4dGVybmFsXCIgaXMgYWxyZWFkeSB0YWtlbi4pXG5leHBvcnQgY2xhc3MgRXh0ZXJuIGV4dGVuZHMgSWQge1xuICAgaWQ6IG51bWJlciA9IF9cbn1cblxuZnVuY3Rpb24gZXh0ZXJuIChpZDogbnVtYmVyKTogRXh0ZXJuIHtcbiAgIHJldHVybiBtYWtlKEV4dGVybiwgaWQpXG59XG5cbi8vIEZyZXNoIGtleXMgcmVwcmVzZW50IGlucHV0cyB0byB0aGUgc3lzdGVtLCBlLmcuIGFkZHJlc3NlcyBvZiBzeW50YXggbm9kZXMgcHJvdmlkZWQgYnkgYW4gZXh0ZXJuYWwgc3RydWN0dXJlIGVkaXRvci5cbmV4cG9ydCBjb25zdCDOvTogKCkgPT4gRXh0ZXJuID1cbiAgICgoKSA9PiB7XG4gICAgICBsZXQgY291bnQ6IG51bWJlciA9IDBcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICByZXR1cm4gZXh0ZXJuKGNvdW50KyspXG4gICAgICB9XG4gICB9KSgpXG5cbmV4cG9ydCBmdW5jdGlvbiBudW0gKHZhbDogbnVtYmVyKTogKGs6IElkKSA9PiBWZXJzaW9uZWQ8TnVtPiB7XG4gICByZXR1cm4gYXQoTnVtLCB2YWwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIgKHZhbDogc3RyaW5nKTogKGs6IElkKSA9PiBWZXJzaW9uZWQ8U3RyPiB7XG4gICByZXR1cm4gYXQoU3RyLCB2YWwpXG59XG5cbmNvbnN0IF9fZnVuTWVtbzogTWVtb1RhYmxlID0gbmV3IE1hcFxuXG4vLyBTaG91bGQgY2xlYXIgbWVtbyB0YWJsZSBhdCBlYWNoIHJldmlzaW9uLCBidXQgdGhlcmUgYXJlIG5vIG1lbW8tZnVuY3Rpb25zIGF0IHRoZSBtb21lbnQuXG5leHBvcnQgZnVuY3Rpb24gbmV3UmV2aXNpb24gKCk6IHZvaWQge1xuICAgX19kZWx0YXMuY2xlYXIoKVxuICAgX192ZXJzaW9uZWQuZm9yRWFjaCgodjogVmVyc2lvbmVkPFZhbHVlPiwgazogSWQpOiB2b2lkID0+IHtcbiAgICAgIGlmICghX19yZWFjaGFibGUuaGFzKHYpKSB7XG4gICAgICAgICBfX3ZlcnNpb25lZC5kZWxldGUoaylcbiAgICAgIH1cbiAgIH0pXG4gICBfX3JlYWNoYWJsZS5jbGVhcigpXG59XG5cbmV4cG9ydCB0eXBlIE1lbW9GdW5UeXBlPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiA9ICguLi52zIU6IFBlcnNpc3RlbnRbXSkgPT4gVFxuXG5jbGFzcyBNZW1vRnVuPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiBpbXBsZW1lbnRzIE1lbW9pc2FibGU8VD4ge1xuICAgZjogTWVtb0Z1blR5cGU8VD5cblxuICAgY29uc3RydWN0b3IgKGY6IE1lbW9GdW5UeXBlPFQ+KSB7XG4gICAgICB0aGlzLmYgPSBmXG4gICB9XG5cbiAgIGdldCBrZXkgKCk6IFBlcnNpc3RlbnQge1xuICAgICAgcmV0dXJuIHRoaXMuZlxuICAgfVxuXG4gICBjYWxsICh2zIU6IFBlcnNpc3RlbnRbXSk6IFQge1xuICAgICAgcmV0dXJuIHRoaXMuZi5hcHBseShudWxsLCB2zIUpXG4gICAgICAvLyBmb3IgYW4gXCJpbnN0YW5jZVwiIHZlcnNpb24gd2hlcmUgdsyFWzBdIGlzIFwidGhpc1wiLCB1c2U6XG4gICAgICAvLyByZXR1cm4gdGhpcy5mLmFwcGx5KHbMhVswXSwgdsyFLnNsaWNlKDEpKVxuICAgfVxufVxuXG4vLyBNZW1vaXNhdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBtZW1vPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAoZjogTWVtb0Z1blR5cGU8VD4sIC4uLnbMhTogUGVyc2lzdGVudFtdKTogVCB7XG4gICByZXR1cm4gbWVtb0NhbGwoX19mdW5NZW1vLCBuZXcgTWVtb0Z1bihmKSwgdsyFKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6Zm9udC93b2ZmO2Jhc2U2NCxkMDlHUms5VVZFOEFBRUpFQUE0QUFBQUFZVlFBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkNRVk5GQUFBLzBBQUFBRFFBQUFBMFAySlB1a05HUmlBQUFBZThBQUF6a1FBQVJuV1ovMUYzUmtaVVRRQUFRQVFBQUFBYUFBQUFIRXhMK2VGSFJFVkdBQUE3VUFBQUFEMEFBQUJJQkNjRXpFZFFUMU1BQUQxQUFBQUNqd0FBQm43L3dobEpSMU5WUWdBQU81QUFBQUd3QUFBRHZsMHRhSUpQVXk4eUFBQUJvQUFBQUZjQUFBQmdlZ2tRUkdOdFlYQUFBQVdzQUFBQi9BQUFBb0lHT2lXd2FHVmhaQUFBQVVRQUFBQTBBQUFBTnRTcW5JOW9hR1ZoQUFBQmVBQUFBQ0FBQUFBa0J3QURTbWh0ZEhnQUFFQWdBQUFDSXdBQUEvSUt5aXNMYldGNGNBQUFBWmdBQUFBR0FBQUFCZ0Q5VUFCdVlXMWxBQUFCK0FBQUE3UUFBQWU4MmtnZzBIQnZjM1FBQUFlb0FBQUFFd0FBQUNEL2hnQXllSnhqWUdSZ1lHQmt6L2wrZGJaNFBML05Wd1p1NWhkQUVZYWRxaHFQWWZUL3lIOFBtRjh3endCeU9SaVlRS0lBalYwT0lYaWNZMkJrWUdENjhwK0g0UVR6aS8rUi95T1pYekFBUlZEQUh3QzQvZ2hPQUFCUUFBRDlBQUI0bkdOZ1poSm1qR05nWldCaDZtS0tZR0JnOEliUVFERWpSZ2tHQmladVZpWW1KbVltSnBZR0JvYjFEZ3dLWGd4UTRPamk1QXFrRkg0ek1YMzV6OE53Z25rR293S1F6d2lTWTd6Q2RJUkJBUWhaQUJYZURNd0FlSnlsVk10dUd6Y1V2WklzQ1VaUVYxa0VSVk9nNWFLclFobHBaS21Rb3FLQS9BNWd3SUZ0b04zT2d4NHhtb2ZBb1dScjFhOW9WMTBYeUxiOWhpNzdNZjJESHQ2aGJMaEJFeURWZ09UUjVYMGNYbDVlSW5wZSs1NXFWUDErcVhrTzEraFo3VytINjlTdWYrWndnNzZvLytEd0RuWHFQenZjcEdHajQzQ0xPbzNFNFRiOXV2Tzd3N3YwYWJOdytBbDkzdnpENFQzNnVyWDEzNkZQV2o4Ni9KVGFyVFVpMW5aMlFhakwwUzJ1MFRlMVB4MnUwMTY5N1hDRHZxMS81ZkFPaVhycGNKUG05ZDhjYnBGb0hEdmNybzBiZHc3djBwZk5DNGVmMEtENWs4TjdkTmI4eStFT1BXOTk1L0JUMm12ZDBDRVZ0S1FOYVZLVTBKd01DWHFMNGRPRXhoaGRoeWMwWWp5Z1ByNEIwSXhpMklZa2dhL2dvWVN0cEF5cm9GZVVVNFJkRGQ5MkRuZ3ZKZzk3MWpMRkoranlQbWJKL3lSV0NlMzF2ZTRERS84OVRNNmdyMkFoNFRWa0R3blBnbzR3cjhCa0FWNEJ2RWVJcHNCTllsZ2VweHhseTBjLzRxUGY0VU9IeFhLalZUSTM0cTN3SitOSkYvTmsxQldEZm44Z1puRVJTbkcxS1kzTVN2RXFqd3E5TEhSZ1pPd0pNVXRUY1drdFMzRXBTNm5YVnNwTy9FZE96cVNLWlJwS25VZ3RqdlFxV21SQkdjMVZMbk14Ty9YWWo2Nzg2SzBmd2dIV2ZDVEZoejZuYTc0U0E5S0Noa2lYb0FOY1E0RTAwR3d0YzZYRitiVzRNckVZanNSQlVVQnNrNThnVlNuU3BQRlhKcXMwQVBCeGJKdmtDVTBSNVFoK2poazl4TFBScWxndkhxTDRYbjh3bWM2T0RvNm5WY0R6YTRSN1VjWDZvUFc3SmhkUU8rSDdmNkR6R29hQ2E2Q1MyblhLOWF5NUppdXBSL3Y0cG56L0M4Z0xCTHVCTkVYNGtIV0dHRDZTTk1hZ2krc1RVWkYvZlNYNmZjQytQejBzdExSU2IzOS9tZ1VMV1pnYkwxV2g3dzA5ZnpRZWZkU0pIbCtaNG9vTE1BeS9scGhma3IyS0JXUUZHUCsvS3JmdlJkSWRkbEpvbHRoZHM1OE41RFlURWV1V1hPZVd3eHdlQzJqYTEyQUx5bnF6bWR2Z1BVc25DWm1wWmgrbmlCeUNZWmRQa2JNWHk4WHVWUjFDYzRFcDF5VzBpNlNZWWNRU0EvM3EveHRFMXF3Yk16ZUR1V0IrM24wQnExSUV3dWdnbGxtZ0Y2SzQrY0RUNlFwNUY2V3JVcTFsdWhHcGltUmV5bGlZdVM1V3lWeWNxN3d3bTZVRUNIV2dOK0kwQzgrNklzaGprUVViZ1lldFphTHd0RFdNVkM0aXFVMkE5YzFLcXpKV2tWRkZYdkpMakpsNndBYzU0WXN4M0Zic0VXa1dheFhrNGtTdmpBSk40bVpqa05TWDFNTjN5NS9IQlZDMVZvL2JhSWE5YmZKcGJzenlaYTkzZTN2ckJiYmxlRkdSOVN6M2ovSFd3L1hiaXdtd2VteWZBZjEzakY0cWt5RDE1aVpMMzlkMkhyY1orbmNUMnJhZGZ3QmlYb0RzZUp4allHQmdab0JnR1FaR0lNbkFXQVBrTVlMNUxJd0pRRHFFd1lHQmxVR0VvWTdoUDZNaG94TmpNR01pWXdWakhlTWtwdU5NSjVudU1xOWszc044UUVGRVFVcEJUa0ZKUVUzQlFNRkt3VVZoamFLd29wS2ltcUtlRXBNU214Sy9rcENTcUpLVWtweVN0cEtIVW9KU3F1cXAzMHovL3dOTlYyQllBRFRWa1RHSU1RRm9haTNRMUdOQVUyOUFUUlZXa0ZDUVVWQUFtMnFKeFZSQm9LbVNjRk5UZ0tZeS92Ly8vK0gvQS8vNy96ZjhML3lmK3QvL3YvZC9pMytzLzFqK2Z2dXIvVmZ5cjlpREl3OE9Qamp3WVArRFBRODJQMWo5WU5FRDYvdFg3eCsvZitUKzNudXY3ajIvZC8vZXZYdDM3dDI4ZCszZXFYdnI3azIvTitXMkFlc3ZTTWhRSHpDeU1SQTBtcEdKbVlXVmpaMkRrNHViaDVlUFgwQlFTRmhFVkV4Y1FsSktXa1pXVGw1QlVVbFpSVlZOWFVOVFMxdEhWMC9md05ESTJNVFV6TnpDMHNyYXh0Yk8zc0hSeWRuRjFjM2R3OVBMMjhmWHp6OGdNQ2c0SkRRc1BDSXlLam9tTmk2ZW9hVzF2WFBpdERrTEZ5eGFzbmpwOHBVclZxMWV1MmJkK28yYk4yM1p0blhYenQxNzdoY2tKYWMvTEp1ZmwvbXlKT043MjR3dmhUOStwcGErZWYvdTJ0ZXNxaXZMZHRRbjVudys5ZTF0ZHZXamhJYm1xWWVQWEw5eDUrN05XOXQvN1QvKzdQbVRwNy8vUENpL2ZlOXhVMWRqZDBkdlgzL1A1Q2tNazJiTm5ubmc5S1g4YytjdlZGeStlQVlBNHl6T2UzaWNZMkJtQUlQL3pReEdERmdBQUNoRUFiZ0FlSnlkZXd0QVRObi8rQjNUbmJrN0VicHUyR1ZtSkNrS2taU05FRXVKVm0vUkM3M28vWlJYMW12TFVXd2VlY3NqZVpkSFNrVkdHTko0RFN2djUyS3hGdXZyYzJmUDJQMmZPMU1lKzkzOWZyKy92Mm51dlhQUDU1enpPWi8zNTNNT0VXVmlRb2xFb3JaRE15SVRZbE84L0h6VHB0Z1BTMHljUm9sYVVDTEtqbTlEOGYxRXZHTUx2citZNTB6dzEvalE3N04rdDZNN21TeHEzWW1pMm5TU1pMZnRSTGwzY2x0aFRuMGw5R0NvMXBRRjFabXlvcXlwSGxRL3lwa2FTbmxSNDZnZ0tvS0tvUktwREdvT3RZajZnVnBEYmFIMlVlWGkyK0kzNGovVEUyTDc5Qm5heDNnYkx0ejZ1cnNJdDM1RGpiZGg3a214STlKVEVpT2lZbU9kSFBvNnUzakhSMFpIUkthbXhjWkhwRVZPU1lwSVNZdU5pSnNTR3hVMVBESXVMU0lwSlhGSyt1UzAxUFI0MGh5Ym1FREc2TnZYb2IveDVwSVNNU1YyY2tSY2JFSlViRUpzV2xac1FscGtkRXBFWEVRUzZUWTlNams5SWk0aE1jMXdqNHRNVFRVOFJLZEVrbmxTakM4VFowUW1SRWNxL1dJaWxWTmlvMlBUeUtzc1pXVEM1TVFwa1ZPVThSR1RZMklUSXBXa3c1U0lTWEdSeXRURXFMVE1pSlJJWlZSaWl0S0lXR3hDdERJdEpsS205TXRLaW95S21CeVpxb3lMblJ5WmtFcjZweVVxc3hMVGxiR3B5c21KU1ZrcHNkRXhaSDFLbThtMlNnY1haeGM3Y25YcGI2ZnMyNmRQWCtYUUtZbVRJcFcrV2FscGtmR3B2V1RLb1hGeFNoK2hRNnJTSnpJMU1pVWpja292Z2lVWjZnTU81SmxNTEtDUkZKbVNscVZNalBwOEZKblNnNndqSlNreFJTQ3JNaUpoaWpJMnJSbTd4SlJVTzhPcitJZ3NKU0dSY3BLd1RPT1NJcWZZS2ROVGhhdU1FQ1UxS1M0aVMvZ1JuMGg0RWlzOGtaZVQ0eEtGRlJJeXBLVkVKS1JHUmFha2tKK1pzV2t4aWVscEJyd2lweWVsRUpLVE1USlRZdFBTSWhPVUJxWmtSTVI5d0pTc1UvYS9rcDRNR3llOG1CS1JGdkh2NVArRStqS2hKU05XR0NRaVZTbElrekFmNFVPS01pNkNVSkkwQzFLUzhnOXNjZmlNTGFNaXlVQnhreUpUb2ttSDRTbnBrNmZGUjZRYU1FdFFEaDNaUzJsa1ZJcVJVU21mTThxQTZkOHc2VCtQS1JEOXYvTGwvOFlWMmQveTVlKzQ4dCtXYXpRc1NpOC9KVEV0U3NmK1NzRzZmUGFTSXY5RVZBdEtUSmxRTkNXaHBNUlFmRUhKS0ZPcUpkV0tNaU1HcFEzVmxqS25XS29keFJIajBwN3FRSFdrdnFTK29qb1JReU9uRkpTUzZrSlpVbDJKMGVsR3pFNTN5b2F5SmNhbkoyVkgyVk85cU41VUg4cUI2a3VNa1NQVm4zS2lCaENqNUVJTnBMNm1YS2xCMUdES2pScEN6YUtHVWU3VWNHb0U5UTAxa2hwRmVWQ2UxR2hpdU1aUVl5bHY2bHRpd0h3b1g4cVA4cWNDcUVCaXpNWlR3ZFFFYWlJVlFvVlNZYUx2cVhCaTNpWlIwZFFVcW9pS291WlR1eWhFVGFVS1JUbFVNVFdYMmt5dHA3WlJPNm5aMUdvcWxVcWhGbEtycUtYVWRHb2p0WTdhU3Mwa2huQTN0WWNxby9aU3BkUmlhajlWVGgyZ0RsS0hxQ1BVWWFxQ3FxVFdVbFhVTWFxYXFxRnFxYVBVRGlxUE9rbXBxQk5VSFhXSzJrQ3RwTTVSWjZpemxJYXFweHFvWmRSNTZqSjFnYnBJWGFKK3BMVFVGZW9xVlVKZG8yNVNqZFIxNmhaMWc5cEVMYWZ1VTNlb3U5UTk2Z0V4d3crSk9WNUNGVkQ1MUFycU9IV2JPazJwcVVkVUpESFVPYUpjNmp0cUhyV0ErcDdLcGhhSkZvdVFhQWt4NHJuRXFETlVPaFZMWlJLRG5rUWxVMmxVRmpXRG1rYkZVWk5GZWFKOGFvMW9xV2laNkFkUmdXaTVhQVcxWGJSU3RFcFVLRm90V2lOYUsxb25XaS9hSU5wSXhWTUoxSHZCWjR3aEJFNGxrMlBSQXRIVEZ0TmJMRzJoYnZHbjJGRWNJSTRSenhFdkZaZUovekJSbWlTWTNLWTcwTk5wRGYxU2tpNDVJM2tvK1ZQYVZUcE1HaW10WkZLWUZRei94ZWd2MEJkRlg1eVFXY284WkdHeXBUS1Y3SVlwYStwcUdtQzYzUFJOUzdlV3ZpMlRXaTVzdWF2bGI2MXNXN20yR3RzcXJoVnF0YlBWeFZZUFc3MHo2MnlXWmxiYnVsTnI1OVlUV2w5cFk5YW1kNXVNTnNWdHF0c3EyN3EzbmRpMjNMeWwrVGp6YVBQdDVuWG12N0lEMlhoMkNWdlVUdFRPb3QzMGRzZmIxYlY3ekEzamtJWEl3dHNpb1gyMzlxN3RWM1NRZEpCM2NPcmcxV0ZiaDZvT3YzVlVkdXpmY1h2SEl4MXZmaW45OHNzdnAzMlo4NlhxeThhdlhMNUs3R1RUYVdhbmtrN2FUbjkyN3RkNVN1ZjljcEY4cC95TS9JbENvdWl0R0t1SVZ5eFJIRksyVUE1V1RsSXVVdTVTOGwyNmRRbnVjcXNMdHZ6UzBzVXl6SEttWlczWFlWMVR1bTdwZXNlcWcxV2dWV0czM3QwMDNYNno3bUE5MmpyTGVwWDFRZXZiM2NYZGwzUS8wZjBuRzZuTkFKc3BOa3R0S20zNzJBYlpadHNlc0gzWW8xV1B5QjRyZXBUMHVOSFRwS2RmejhhZS83S3p0QnRwTjhrdXowNW4zOUYrb1AyMzlyUHQ4K3dyN0YvMmt2WHEwY3U5VjJTdm1sNlhlajNwcGUvOVZXLzczc043VCt5ZDJydXdkMFB2RjMzTSs4VDN5ZTlUMnFmT1lheURxbStidnJaOXkvcDE3eGZSNy90KzlmM3U5dnZOVWVJNDJQRklmNWYrTlU0dG5PeWRncHoyT2owYTBONFZIZVZmSEJXUnE5VlJNVExoYzNUZjZuTWtrSTlQY1hnd0xJZW5pTVpLZkp3RDhnUHBDMmk5Sk5Ud0RJUHhjdktEcitXRUp5ejhNc01xOHJjUUtQNU5wdms5b0J5MDdFVncxd1Z4N3ZyVldnbDdid08yNHBReU0yOCtIckpGNEtDK3B4YURBeC9QcVNIYld3TGRjTGJ4eWF3b0E2YXF3VWtOTVptaWZmd004VHVMTTJnblRJV09LQjVQTlR5K1FVaHRoemFEMDB2eTRJQjJRTXhZUkNmZ0dOelIrQ3c4Zm9HUU4xQW9IVHZoRnVUeE5hSWZRd3BIQmhIZWRFUzBXZFo1VHczL1ZtTitSZ3V0cXFHOWxwMEZCYnd0NTdIVmJ6ZTZnQzRlVlYxZXhsVGo1OXkxMUxxd3hTTVgyd3hLQ0VRTVd6TmhNUmV4MkhOMzJBbkdPNXcrNkhOOXd0TkZERHZMby9xQ0ZLUUZENjhoRUNPd3NLeTIzY2ZBSm1uMWt1TVpKUk9adW1vNnNpTHdrQjFpTGt3WUliVmRZT2VPTUlPdzJldmd4NG1NR1JSa3ErTXlZSjk2dHhwbXFPZG5tdTlYd3l6MWNlSENWaC9uditUTHVWOEdOOXJZREI1c2E5czQrS1g4WldQakx3cHZpeTR5UGxKdi9sbVQwQ0lYV3RqTTR5UDVJMXpRZG4zZys1bTFTYlFadE0zU0pHWG9iRFRtMWRlUkZzSzE3QjVkZDU3bEJxSWUyQlVQQUZmNnl2NDd4OUZUNXMzZ092dnVnOGQya1NQUFE3N2xvUXg3eUdteW15ZnFpakQ3MnhDUW9lZm83SkZUMXhnMjd0ZXVyeEh1Qjg0MFp2bnVIQnJtRnVzZmw3WXA2RFNxWnM1VkhUeXRxb2p5bFIvUTkrUFlReUhqSm9ZTVJvUFJ5QlBvSnJxeTcrRFRXc1lNYXdVcFFKbm12NnJab2wrYmhZQzh4bzYvdHhPcE5HS1lvRXZqN0xERmVPeU1jQytFbldxeDB5UGNoamwra0hZR2VlaGJCQzdrcndwTTdrRm5wcmtmS0RYaU05aVJld1lXUjhFWlFTOEVUb0hnMUJmYU1BR1Q2VHRZWG1tSnNBdjVtNGhObkxEUTd5dGRVS1lJL0lna0xpT0M2bzI3U3JDeU1zTVh1b1E2NEZiVjBVK2d6UlBjcHJyVUFWcEJsOHFNT3F3TXBjMGVRTEZhQkhXa3o1LzhDZEluSGFkN0E3bW9JUjNTMVRpZExFT0ZsVVRHRzhCR0RMSFBPRXVaR1Y0TWt6V2kvYkJTRE5WUXpPR1ZIckJTWXRRV0VWRVZNZmhYYzEwSldHUit4c0VNWFd5bStUTFFzMG04U0JmQStXekNkZTlqYWJiczFIVGFMRnZEdnlEamFPR1JWZ3k3ZEZNNEhCYUZJN0VEZGlqRGtSQUdZV1VRQ1E3Z0VBV1JPRXpoWVFLOTF1QnZzUWsybVUxdXZYQ3YyZkF0bUlESkduTHJwU0NhWmxqK0RqTFdLN0w4MFFpUHdqYVYvc0NDQ2RML29TVktnalQ4UFkySWQ5YUsrVVVhVHM4Z1NJVmsrdklsN1dWRWxBdk11cC9GRW9SRnlIbDBwaVZ6YlQ2OTlzS0p3NWZSTlhRbUJBMUNuaE9Ed3NNWXZBOGZSTTU4QUJLd2h6SU41R3ZNZWFVMlFNcytoWEI0ek8yU1BIMFFwWFFlNVROUTRZVEM5cVNlWjl6UzZBUGRiNGIvaHFBMWVuTUZRWHYweU8vcXdQVk1UaDdOdm1vb09uRU9OU0tRMld1d0dQVkhJNk1qM0pqNmFmU09vMVVscHhGenV5Yk16WDU0OUFCRmxNR1F1R3A0YTYySUtOUmlzZ0pIc3NiZUNCL1FoeUlYT0kwUWR0VWlCSzZ2RWRKMFE3UzdCVjZNSUllM3pqTmlla01EUVJyUm45U1V1ZFNmMUtpNUZPU1NJU0xKRVBnOVdxQVgwNVZiajYwOWhwaFhWMFoyN3pkaWhJTmlEQnBmbW5TQ0dSNUg3M2RwREh1RUdPajArbWZvREJaOVh1Q09pbWxvNnFMNGJHWXB4TUpoNC9pbk5iQXZVMVN0aFl0a1hJNk02NFN3THo1SHgvZ2srNkZCRExaNDBSYzZRc2NYajhBQzJGNVBjR3Y1TkJRK1AyMG1rNXRIdStQeDNFOE45VStmTm5nNU9IaDY5ZXJsV2YrVFhHQ25oVWFrNHAzRmZBSVpUKy9zQWI5SWNNVjdpMXNJOXVzc0RMTWVWZ3YwVjJsRHRMQ01YTmhuTUpZMzVkZzNyaGtCN3FnWGcxdS9IUVNtWVByMk9yU1dvNmNCV3RjaUprL0t2amhiVk5HQXRBelF2YlZkdXZSMng3U2NmWWJjS3p6UFpqRHNDMGdBTzI2WVgrRHc0WDYxVjY2Y3FMMHN2M3dpY0ppQ2ZWT003M0RPM21ONjkvWStlK2VPK3V3VCtSUDFHR2RCN0dDZnNQNm14WU9ieFQwRXZuQ08zbmV5K0FTNnpvQkZqMGU0SSs3WW95KzJ3T3pUM2dTVjNlanc4aTNybUx4Y1dndmp1ZVlsTjVOQWJ0UWtXUGRCbS9nQlJKMzBVaE5CcHd6S0NGdEkyODlDbTBFaEwvRjFncjQ5S09jM2lxN3pCV0wrSG4rRzB4ZmdlU2lFRjY1cS9WQUk0Y2xYVVBkZzlVOXFBOVIxM283ejVndlVVZ0xady9qMGNZanIvQktPSDRwRDlPU0xTQnZNUTBmMDVFcWI5UkI4WW8zR0hQeUE2cW45U2NzMndnNzRua05nRFU2ekVReEdRRHVmVlNJcjVEeDJsaVh6NHp5NnNLRzY0ank2aUtvbm9wRUl5N0JqZEM1dXdUaHJwZXpUclVZbkNzbFpxbGRxYUZDL1VZa09xKzlwZUcrMW1FZThQZWN5RWxzNCtrOCtXRWU0ZHhsTVh5eGx5ZytFK3lqMlhlZHlKUmxud29xQ0VZTzc5TUpXV043MzVOaDdpdE5vMy9aZHU1azh5YkpKMjdJT0l1WW5VSUlJaHNJbzNCdFlQQWFIRTg4K2dCaVlTT0xsQjBDNEFpeUkwamVjZ3hhTWw4VGZyWHVvRFJsdUNMWUVPeGhJUHNKOUNCbEIyUVgzeEdJWDVUZXo1NjFjcVVCcmwyNWN0cDY1Qy90OGllUy9JOXdmcStHWnU4VDRJOTB3UWdzbkdNdFp5WWcxS05TWmNOMWtac2VRQnJhcElVZGovbHdMNWRmRHI3TnZuMXRBbkFTbTc0UWVSeFRvelZpTnpYSkJLdmtiRzQ2b1VTTURYMkp4QmY1Q2pxTWxXZzhPNUJMb3RMWlBRcDhoVTc5UjRHNFNieFBvTG1IZmd2UnNhSzllTHBPNktyQmNZdkNIUEU4azhMcFlSMEV2THNERkxYVW9XWXNuRmtGWEdFQSt3dDFUOFNPNk1iRWtoS212b3NmY3NOdlRqMEJFNDc3RTNFN0QwNERjSVZvQlg2QmZUbFpkSVc3Y2lSakxLeHJSZlMwZmNsMTgzd0t5SlRBQ0FrRUdjMkV1Sm5jOFFvR3pEUmdxSlJEM0NsdGlhMnh0VFc1eENxeVVtSzBoeTk2c2dZVWEwWE9pRTY3d2tMT1dDYXJ5OExOM2NFZUQ3OEJDQUkzZTdYMlFscXhrUXBZR0RtcWdVRmdNUDFNcjF2WFhtWEplOVFOM1k1Ty9RZmMrZXJQdFJoVUR2K0tGSGpBSWZ5Y05pQitST2V4dlZ2NEFuWStyRGlMTDZtckVRWjFKY09BdHRPTG5GbHA0eUZ2Z2gxcGRrRHRXNnkxQTdVNWMyUVdqTXpIZ0tjUjhCdVI2WkdsME5zVEROR3JGYThDQ1c5ZmpVdEFMWWhqdHF1Q0xad3ArbGJ0K3V0UXhzNitsM0F0Rjc1OXptakU3VnBUQmkwcU5jMzBjaHhjVlN1Q1ZYdlF2cEcvRnR3Y2RYTFZDK0Q1V2YwZkV5UlZwZEJhZmdmUFdoRUtFTHVmSVdQeHpBZWxqcEhHU1lMaGJDSVB4ZVJKWW9lZjNJMWhCbmhIUzg4UUw2SUpJbElqbjY2K1FVR2xDVVFaeGJ2eWkxMFJDU2UreFduWTlqQ1hkSFlRbHNYdTZ5OWlKK2hlNVVqTlkzaXhEL0EwaVJ0dmhIV2NqRzJSaEt6TmJSRWgyV3dOSVlCdVJZQVBKYnNPWEVyQjZWRStjSzl2M0xMWlM0RWtHV1dBa3dGWDRqUndaNW9zNUJXWUk0c3VKSEQwMkRGdDNYUXptOENjSERtK0pWcm5Ec0xja0ZpZSszcExjaG1GM1MvTFNRYTRiaW85eWVDcFpsZlRNc1hjSVdBYWlzRDNZRTkyTndQYmtFNFdqeUM5N2lKRHp0a1RNUHNWTmRWMlFxdHNjdEVRUWdHOC9SRGdjSHRIQXJHejRFZjNDR0JHVjR3Umg0VG9MRTJqM0dhN3RKR1pHQWpSY2gvM1h4Znc4WFR1dWgySHhnaHVDcFlUcTEzUVdISHluMFIvMmdPL2VXeENCZUdjVWlMdGFYa2E4M2t0QzFaNHlzOTFHMGNuaDM0c2J5WnV2RVd3bU15TFlvUXNhaFBBc1FtekNhRjVFMlBLYVh5SndCZjArbkYxOTB3Z2ErVDdvTHFMWkhmQU4veVlQd1RmNk4zZkpTMTNRMStSbEVIYlZ2OGxGbURUMUoxZmhtUlprVEpqdEIvNFBNYlFtWS9SQU1COC93b1Y2NWljRThYQVY0dkRWWndpdjVobFlBSThjRUE3R3BiUmhWVUtzWkZnVm5PTHNaR1pHZGQ4aWVJK3RaQng3bVJDRzlsSHBpbFNpQmhMQVp1cVNPT3owUjB0d1V2WFVGVDJYL0NXNEt3TjFGc2NtbmRxSTYzU3hQcG4weDg3QWFjUjdjQjhPbkg1dmlaMzhuNzh2NmlreGU2QnJveVVydjhubnMrRTNvWVE3UzVaWFJKem1lL0RGNzg4aW5NV1BtQ0NvQTI1TGtqaytSNHpia2x6dUtFbmx6UEFUL2d4WWliNERYekdZRVMvWGk2UmcyZXFrREppdGdvNXFjK0tEbDJuWUduZ0NCN25lTW5aV0g1bS9TYXlVclhFZ2ZCSEFlR2MxN01nMDEycmdQVW1SdEJZYUNWdHpQVTk2MktzeDZTeFJaZXMzYjZFTGRMRjZpNjFKQkRRNEtkeUx5ZVZiZUVoNE4vMUd6bkxrUUN6Q2xPdXR0Mjl2M0NMK1dYUmhvS1hjckVlMm1tZlV4UG1MK1dpK0t4ZWlHbFBzdFFUYjU5a3BFZTVDL3A0cHdUNnZmc25aNGlNcXh2OFFuUjRibmhoSVlzemNVYmZRTy9UdS9DMFE1ZGFpdzRtYlk1blBNRHlvaGZka0lYeXBMb2Z6MExmSWxZVFhEOTQraGxnMmF5dEwzQVYzZVdNSjFvcXpxSEg3NFhyaTc5aFpnelJrbFhvM21NTzl2VURHQk9yR1FFdEwxNEdZa21QUnlGdHZGV2JaYW5CVlFROTFjNHkyRE9LNHZySThGZGVQY0xxVVdCYzdOU3hRTHlnd0IxcER2TmRoUG9aemxMR05oV3FhZmRxZlVBOHZVTU1vTmVqVjJaa0NsVjlyMkJlbnNUV25IcTJOZjBvb0YzVUlMRjhyMkZ2OEZBOFNZQTNLbGZwZkdiN2VsK0FyNzk0RmQ4S2RRV1FOWHlrdW9JWnQ1UVRoQVJMckNjNzRTL2tRNUxsM1NpMVRDQSs0WDY3ZC9nVmFuSGV4bFMvRmxKTjdUOFRZdXQzK1JRaXZqQlFSYVFXSElpWXNnd1VTY0lOMks5Yjhzc09ucXh3WGF1Q29GQmlmODloVVBnWjVSQ2NFTWJud3A0Y2dLcVJ2VENiWVBUZlhQaDhvTE1xZUxNcEp4cjVhcSt2RURTRExma0lXbFpDaEcvc1JKaTBPenlCSjN2b0Y2M00ya0ZVcDUwUEw3UXIrbEllK1NocTIwTjlUUGhmTnlaK2J6K1Fzb2RsSzhOR2RGWWJwWVp6bWpJQ2lHT1FDdzk3bmFHQ3hCTDdIaTBsYXVRb0tZRFpNdFVFNEdVZlRCclIwT1ptaUJ3VFl2Z21ZMk1saXcwS3pEYktaTC95MTY4VGUrckJhWnNXNng5c0Q3ZVM0V0FONTBnZDc3Lzd5NGVlSHhYdWgwVkZKM25FM1I2MFBRcjdJSzJHYVA1Tkx4UHZ5Y0dsZVRINHNpbUhNUHBsaXM0YXRQRS9JNFV4NDdDSmpLOUUydEMxbkcyTzJwbG1jNFY5RVNNcUpQQTJVdVZ0OGJWQWYwcERkckR1TldueUkwL0F0OGlUL1NYY2tiT1YxSWcrTnZCdWU4MWY5a1JzVVNQRnhZS1BJVi9LbEJDMFBDZHRJaE9nL0NiMitoVWFpZCtNMy9sWGdEZkpPWW1oRVZ0dFhrNTFabkdsK1E4T2V1VUZJdVY1U1gvbmdWL2tHVkppN1BJZGhWNjl1b05renM1Zk96SnVPWEZCdzhQVHhBc1k3SG5oSzgwYm1SYU1Ja2xIYkc4bHhWQXNoaEJ5dGVTWG5TdVFHWlF1S0lDS2FJZ2FCaVBncjZPQ0JPOWg0djhUVkVpdE4rbEg1SHJUN2g2MnJtSnd6ZE9iY2xBVnBpSm1VdE9hU2dnVEtYMG5OREZvZTA4eUY2WHlLeFNEQ2dNRXlkcnFiUVpqUVZWNmVhYjZHRDJiTCtCZ3kraEJpSEpPd3JWNU9iTDh0TDNkRjRLT1B1VXJNb3hETW9JZFFJd1NmYTNTZTdPbzFCQnBzREkzRWhiVGgyeEVYMGtiZjdpb0NHejVta01HRlVQbzJaSmkyZkJzU2lyYzFQRk44RzdwSmhvbXR6UkFqRStKeWVrSUVPT0NJbnhBT2dud1NSU1c0SU53R3UyTUxjSGNnTVQ1T0lGMkk4a3pMMEkzTE5GL0hqMmZMWGdxWXl0aWtCYU5KY2orVUVNa2VxZUdWbW5pVU5tSytNMmtjWnZRb2FuaW5ucC9CczJyelFzMFdEWHVyRUZaeDdKWEtpa2trbnZ4R2FuOHM3cVQ4bk5wWEVyeTRjcjhDaGtqWlEraUZSMGxhUG9tUXQrUnJTdEFMaHJ6Y3Y2U3lSbDZuSGkzeENZcXpGN3F4VjBhRVRRb2xUTmZoL045bmlXNnB4YmQwODdnL1pxbC9ueVg5eTZ4UERiUENFcmpNc1kyaFlZY0lWNzZSL2h5MHkwYysycnRPVXJNa05GS0J5YlNWcUljbWNVc09reXROeS9GSVJEMUlZaUNOWEJ3YUxQZjFQaWM1ZVd6WHowSTN0dkZTeGFGS09VbXFzdFhyMUtKSC9Dd3h2NXMzNGJLU1lrSkNVQlNLMmpGMUF4TzhmVTVlQlBKRWs0TGlJNWp5eWZTRzdmdU9IRUZscUN4aFR4WlRrN1E2dHh3MW9FUEhkcFl6eHBJam5wekJ2d0dxdWViNEJrL250UHhxZHdsN0x3dXNPSGVaMlZ3MUx5RVpuQmJrMVdJNGRJenJ2emJ3S3ZvWi9WeDc5ZjVhcGpxUHE4NDVrTHhwR3FNNlJJY2ZHMWZzbmMrY21lQWx4ZTFudTNaSG1DTi9ON3BEKzltTVYvVVpxVHIvVlBIaFk0SmJ5cHcySlhsQ0RtTkdlRmFpaGcxRXRzY1NlUi9NS3pqc2VrdHlZUTB3SkcwOWd2Wm5iSTlucW83Ums4dDlOb3dqZXVreUVZc3hxM0RzNmYwY2wzVHo1dDNVK0Fjb0FWZXAyVnMxYjZZVzdkTEFIeG94djVua3AyRVZBUUYwMk42QWpRR0lmS2FIeFRJQng4UENqZ2ZRTVdIVEE1ZjRMdmJkR0xndmpBa0lxQWc3ZnB5dWlEMCsvVGdpbjQwVmU1bmpBUlVWQWNmcGZSVWJheGZYTGFtYlhodFR3ZWhOc1IzMzI2MTdyMzY5NmRTMTY5ZE8zYTBIM3Z0TnFCbkFJTlVqRlR3anNjMGlyZmdHcEhMK01BQVAwc0lnR0tEQ0F4cWxCWVhRQnlFVmJvMGdISjQ1SVJ5SW41SjA1cWtUZ2dqOERMZEJ5SjhBRkdTandiUWdUZTY2eDBacEdzRGhOMnA0SS9YVzV6UTltV0dGV3BlcE5yK2hEZFZDc05aZnl6N2x4K3NrWEdhdFYzbGZ4TENOdlZ6OHJCVEkvV2o4OWl5R2ZmcHRjbWdFOGtCZSt5TnFVeGpvUElvdXp5aEpScFBRSUsvVUFPU0gvTGFsbjJVOHB0RzdCelZHUFVJdjBPTmpDRXpReWVsN3h1OWoyQ3UxSmZ2SzBSbDBjZEloM3gwTWJsRkhoMjZKM29KcTBPWjFGNTZnczJoUDVPcGtCdHRoUCs1a01uMGtveVlCalVPVEkyTmlaak1ldTRuN2p0ZzBaZ3M2aWNwTGkvZXZZNFFJNnVsclVkTHJuMTZMazNSZmNjTmw0R2N4M0ppRC82U0NYMVdQVmFKdDZuZHFmckphc1AvN3VMays0ME8vSWQ3WTgrNlRaNmV2dlZaY1JMVVJxM3laT3Nuc1YxOGZzeU5DME5uWkRuZkFGZzl0aVlOL2dxNm9OejluOUZjdmNTTmthb3R2aU00djRzZGxiTThvejN4WDNWQnR2a3NObmRYc1J1akV1M0pWYU8rNkRjWE1FbUtYUXZPalZZak9YWit6RlcwbXhKSHVTVDdaWFI2T0pzMlBtY3JzanFLM2J0eXhxaFF4aDdaa1Jpbm1wMHR4aC9ESU1RcmZZMGtxT1R2NENYekZ4Y3dQSEpFUVgxaGM4eFBhU3lLeVhieVRxSmFueFRDZmQrUkd5dUFvRENjM29xWEVIUEhiMUVKNXhJN1RGM2p6QVRoQkxmbUhhcVpBRDlpdkFybnFyVUFRR0s0R0h6VllxY1d3QmpweGFoalRLQ0ZKOEpnR1loZkJoejVYY0hRUHlkM3ZCKzhuR1VaZmlkcWZleW81Y215QjkwamZIRy9GVUFtdVNmdEFqeWY4QzVWb0Ztd1J3M0tkSlllMytNTVdnc05JZm1BMWhGYUxqZ2xYTWJ6bUwzRDN2ZXI3OS9meTZ0Ky8zdXYrL2ZyNisvSUpGcjZob2I2K29aVjFkWlhDTjlTWG1KNXFOY3czRm5Ddnc2OGNwT09lYW1LOWhjb3Q5UEhHZlhDNkJHTVR2a0N0THlDekpFQzVDcTZSb0h3ZFdjZE5lTTZOa2drdlMxVmdyUUpPWlE0V3J6ZXJKNnJadDJEQlozSTdKSTgyaHNURmhzVk1VZmlpNU0wekR6S0I4WFN4ZDIzeUJYUVRuYTlBMTFGdGJQbllsWWJpeFpFMXBmdFJGYm8wOXFBN0NUNGlac1NPWjZxbTBzV2xtMWZ1SjR6YmxSd2RHcEx1cjJEZnBuNEk0VThMSVh3K1NUVThDQTZUTXlEdU03ZDRTMHZzbnFlTXJSa3RZMjk1eWN5S2RKWUU3WlVhYUVQc3lVb2gvZjFPZ3BYOTNMQkYxd2N1WUtiUWo5WG9pcUROK3lJTlVVd1ZyUDVRTzRQemhsTDBFeHhmZnE5MG9kb2NCcXBKdHRMSFloSVJ1NHRqQm15WVFhLytZYzJ5alFUSjVZblpVNmRtSnloU1VQSVBhWVhNekdoNjU4eTk4L2NnUm5XbStHeDExUGJKaWxub3U1eTUzek81UzJpQmF2VWt1MWNUMXdzdXdvanB1bERPM3pBbW1TMkF5RHdzcVJZUmNROGpsSDRuY0hOVXZaMzlLSy8rQTg1Ny9menNmUDFkdWJlRmYwU285N2NSbGFvVDVVZE9xOHREL0pwRTk0d2d1dCtmNDhiSzhGRThuTnlFSkJwcy9GWGdsSEZORFZucVJabmJ5S3p1YWtnbDRxbG1VNC9yZ3ZsQm5MZU1QWGpjWGkxbDA0Ly9yRlo1Uy9WNWVCVEhCK2l5Z25iUnBFVWYrSDQ2VFdENWhXRERmU3ZUOTRQWEJueXpqbzh4VEtDQ0ZSa1BWWkRhTkhvUE5iOUJ6VDZCVWRNNDl2azRHZnZrZHRQNmZoc2o0Mi9qYkVGeW10SDZTbFdpUGlYSXoxelNVV0dRSUxBMG9EYXJUSmRnUkcxUG1ZRGExRElqYWxtZm9MYW56SWphN0NRKzJZaGFDY2lhWkUvQnhpY0o4aWR2a3IrZ2VIcmIzOHBmWE5sL0U4QnB3UVlCakM4akVraENGdzFmUTN4c0JSRTJhb0NXQkV1VDREdmlHNjJ4MHhxRUJ5Tk0zeG56RHIxQmQ4NnNmY3NNV1VGbmUwNElHNFcrUVJPcTBBVUVNbkFzellNV3pCMTNLZnNxMWVpVVB5a0VIZ01yUXkzd1ZuTXQ4RVZUTFJENjhET0ZoUFYvZ2kzVG1RcWE4VC9CQmhCWW44OWd6NnZtcXd6QVB6WURQMjRDM3NkL3ovbksyQnQrTXZaSC84LzYzSGx0RGtIRUxiQjNtdnU4Yk9wVHdKLy80Q2MrNlZCZUNySlNjMENsMExLVXZXRG9CSCtnNjNpc1VNSzRpOC9vZ2tZZ2ZNWlkwZmkxYVNnQ2w4OWY0Z0prMFJhQk1qTmVoRFRRUVhQWlVCVGtsNU9RNDZaUVk2blM2QjBsK29qM1FmY1F0SU5nT0lZUUR1Yk5FTkxnMHdqQlp0Z2hQTzVBTkw2Rk8zT1F5NXV0UWtodkptd01HdFM4VkRNNVE5ZGYyQjJFU2pYNzR2OVVFOFhSU0NneUlqeU5ZZThnSEFEdHNEVjRKREdCdy84L1RRWDdZazhGWFpCYmdBclFoK3JxaCtyb0xtSUlQeFpJb2IydXZ5QWcvOVJjcURzbHlNUS9OUThpelQ2Zk5OZS9Obit1elJJNCtyUUpoSDJYUlRMT29DWldObFU1anpXUDBsem9qTlZsQ2xqOFUvUFB2MHNOTnZzZm1wZVNacDhQelhkZWkyYTlYcUZkOGZvVENEeGFWLzhCQ2FIUURIdFZnZ0Q4NTFvelZnL3p2eUxSV3NBcUZVbXBGLzU5MmZuVGNxZEJCNHdsejhKUFNwNGwzV1Zzb0ZEeXhJOTE3UVZWV0VkVW9kQmYxbHdCWFUwVzlHOUZVRnpPY3dKTi9pTk1mNzVZSU14L2hGbEtZSHcrd093UVVEUUFzYmNNVURBTjl5V0pWL1JmSzkxeWlBYlNBTk1Vd2lqNlhud1hBZk1YQlBOYkh6R3ZmRTBtQkN2Q2NMRDZiRmE5SjhtL21oWDR3U3ZlUmdRZGVHc3hET1B6dUlnSTZJY2RjVC9jcnp3YytwRlBYOXp2OEdIY3ovRHNHRjVPOE9oSC83VTZYS0FieFVYdGRSdElqNjRkdUtQUEp6cUR1dTNyZThhVGNYTXBpNzEyaXo0YmREditDWUpvSk9DT1lCcDZIZk5vYkFNejNwK3I4TnZxam9ZZ1BBQ0xjRmZzaVFZanIyMFR5cG1ZTWk1TWxhcEYxMUN6ZnFKR1ZKOVNUVkp4WTYxVmtMYlB5cTE0Slo5b3NLbi8wTXp4ZnhyTTZEODBKNUptbitabUlxdDN0UWNKK1E1K0FORDM0RTk4b055aUR3TC9TZUcwU1J1RUl2bFFvUkFOZlRJL3FaTVBCVWNTSmo0NlM4eVlVSDZXS2JBajlIR1hhSEdLVUN1LzltSWVsbUJwajNsdWhscjVHdUhreExZTXZxdDZZUWJzVUp2ZjFjQjY3UXd0dTJvdTlPQ3J1RXQ3SDc2VHM0WFVoUk1oWHp0NFRoMm84SllLVFcwYUE3QVpGbi9qMlVVeEU4MWNNbk1wd3diTTlaR3krWE0zTHR5VXV4RkJGL1Q4S1FKTDlDYmdaeXd6ZU12ZTFQV1MvYlhvQmdNbUF4cVV1UC80TGxnbTF4OGlvZE1udGRTN3hOMFl5Nm5IbXN1cGM1cktxY2NjWkc1dzl5KzExLzhNWDB2WTVQRlgrT2pTcGg3VnpUMW1OdldvZHBCRmtoN2paV3pGSGFCb3RqcjRzNzYvR3ZURzBMV2l1V3RtVTljS0J4a2VUMEpib2gvVlJEOHEvRC9yQ2N4cjBuRUJZWEtNaGowMHQ3bHoydHltM29mbU9wQitGRTduKzM0d1VaOTAvOUhnOHFxMUZZTFBXNmRoYTRjMGo1QTlwR21FMmlGa2hOcmpHL2orelY0T2lqOHR2bTdTd0g2TldGY0pjZHhPS1lJT1ExOWgrWkpSYUVSTXZGLzZzYkVIM0pFYjhpUzVJbk5vQW4yZ3JIcmpDYlFQM1VuUHMyRVNzRmhxaVZ0bjRyWjlyb2ZjVWZ5QzZuZFczZGc3NUhMc0pYUUZhWGNlYTJBQ0Q5RUprNk9pdjBaTS82Q3I5eFFycEI0Vzg2Uzl4bmpZQmZoc1BWdC9kV09kSE1KVTNQMno1MjQ4clBOeUpOR213Vm1XcTJNeStDR0cwcm0zbW4zNU4xVnNneU0wdjJZRDVqTVlYN2YvWHpmNHNxeUdYckk0SCtXai82MGEza3l6dTRJZC9iZWFOZTREVllJQS9tZW9STjVUa0xwUGdJd2lkMUhMdnZ0c05Ca0JKTUwyMGlCczc0SS9kaUh5UXNaZFJlUmwxVjhRT01XMyt1aEptMHJORE1IQ1VOYzFGSnJqalBzVGY5LzRvaW56K2RoSVVIdndzVXBkUU5vSlJvMEdqSjRHZjRTMEVaTDNRazNoNithUjhDaVN4amRqWXF6ZnhtVEFZVU9aL2w5YUVpNjJiTm9WTUc1WkdNcXdja3dKdXdMd2tFL2pKdS9yRmtESGwwemRIbHZDZUVmUk96SjNKKzJkeG1ES3R6UWFXcHlrMlpvei9rY0NhMjJaM0Z5YXZUWGhZSmloOHRQdFEwVzJtd0w4MFFtd1hnSXQ4NkR2TURESFptRDJvZFlNSFFSVk5lWjArNW9LenVkZFpPeStwb0x6VnFBRVRmMlJhT3A1LzJiMG01ajVlUVVhRDRNN2h1RG9uMEZDK0FSRGZOUU1ZV1Eyb2NFTEE5QUU0emlkQ0JTaDdDMERaVjhFTjhNMzJ4U0JaSitDVjhPelQzMnRFZGdvRmp1SldPejRITWxydk1NSFhqeDRBTlIxOVhXU2lzSnVrb3UydThmZmcvdUd3a09CQkllQUgwbE1jYU53cU9Qem92dG9lTVZ0bmxZNEJZVWpBNjlRS0lwY2s3Q1ZpZC9McGUvTVBvZ3FrSUdacUJJZG1MMGpoUWpPWFc3YUxvK1JkUGdlLzQxakVPNkdyQ3lGcmFmUlJiNWw0WXpIeU4xeDV5L1FCNmVwTXVzUldLTTNid1dIMEpCK012b1EwMXlKRm9TdmlVV3pqTlhvbXNFeWRwYWJERnNZSmZpL3dlVWFaZmtUTUVKNUkyQ0dFZkF3QWN4d2svVTJDdlUrQStrUEIzL3NZdk9hd0F0V09VdkRaaG03SENGZDBna091dzFGS3JhSzBEUkk5ckhxYkVCR3FEeFhObFdlcHd1VjU4cWhNbWlyTTNqazNjYWlnc0FzNCs3UmU2MVlLQ3BvNFBUZmIxb0VvQkZaM3c1a2NublR6emI4Sk1QK3N1SDNBUU9DOU05Q2RGM1RoTUVzQVlPYW9USnN4OWQvQ0JxYTFQWVR6ZiszWFg2OW5jUmxCQnB4K3hMQ00zaHJJYlc1UTdJY2dqeU1SWmR3SEI3N041dEdlckZrb0FzYWRvdFk1a3NhaEhnTDhuUmw0QURhbUZJWlQxN1VYK2RiRTNsNjFKUlNlVWl3RHc3Q1Vqd1AyLytHUTZGTXdmdVNoSXFrVS9zMGVKL0VIVC9raGt2dzZna1FlaGQ4UVA0cmVDbE9rb2o2K2FmTzY2N1c0THorK014NU9hUEF5TEJSWVQ4TzJ1bEdMTU9YUnN2d3N5VjBWWnhHZDNmV1hpdHp2eGg3N1IrZGxQc0dydnU0L3BqcVFRd1NFZXdYUUozcTMxMnVMZjNFVVgySXB6L2JtLzhlS3JtSnN1WTltcnZFV2xtWkd6WnFpUDRhZDJySzRUZk9neVNmTDV3eGtiZGJJYzBoSEFuMFFObVVsUmlqdU05U0VzTld1SkJiZmJJYjNoMnlqWk1aZGpXZUd5YmJ3cmRoRzV2Mk51TGdrR0dxcDRhcEdzbFVXS0htdnlWNWpWcUUrTFZpL210K0FJY3B0Qm5hMGdYbDY2OXEwQ2EwYWNINjc1aTkxWFRpeHFrclkxRjNGRFZrbGd1VGhLMndxVkNGcHBBWGZrelBDNXJsTndiTlFKbExaeTFucGsyZ3Q4ell1V0NIY0ZweHo4MDFXdVk4dkFWVFJEZVYxSWpTSmNBeHRnZ2NqV29XYmxDeklvUHY0TThZVUJiYXcyR3pvSy9DbHJzQjJmQ1FmNnhLUHVHdnFLNW5pcElxeEpCSytzd0xERXNlajhhanNPSjV0VXlZWkptek92ZzJ1bzNVTmN2dUdPcktiMTZMTHI0V1g5UjE0d3lDejljSzBaSm9xeEFyaVNGT0orZFVZWWNDQThNbStmdFhUS3F0clRpa2todmlJNkU0cHhMdFZJdkJGM2ZoNXN6T25KK0ZrbERhSmxTQ0RwVHNxYWxoSmtnbVRaMFFqSHhSME9IWUtyUUg3VjJ6WmJOaHdrYkJaa2RBSXh1K2hMOGlXT2tpWXFYRC9XWE5OVVkzdnBNWUdJSjVIMlNOclU0akd1NkRsU0ZINjRwTzhLL3JSQTNuTDkrRjduZTA1OFVRZG9JTC9WOHFrWE9JUGtlZEVzRlhHaGluRWZPbGZCUlhjRXF2UUxRYm1qdzNaUmF6S3BRdVdsNnlyQUV0d29wNG5EZ0ZVMHlEWlArelhmRGREL0FsQStQd2RRa2FzSHpTaXBuTU9jbUM0dmxsNkI0RGw2Vm1ya0lSV2pqcndPZEFNYWZQOGVCekpHYThpK0h0NzdQRXY4OGliLytZNWZIN0xNbkg0OFoxWU1NVzFmSHhYSmpzODVmaEVFNFdQVkJnOFNpY2ZSNFp6bU1JaDNqcmhFTzg0WVpEdk1hVDY4L2d0dmlaWVlSZmNiWXd6c2ZYdkdDY0xBMlNMNEFiK2h2ZlAvdjRtdjlXRGVHWklzZ2xodW1jSUZZNEhJZDdRN2ordklZL0QrRnFIQzR4MDZqaGpocjhQb1B5dzRIZUVJanZHRzkrR3ZDRFFEVU9sTUFkdzEyZ3h3aDRKN29DNzhUa3k5bmVjUDNsbHhzM2Z2bkY5WWF0cmF1cnJaeVFSamh0RERTeHkrbkdyN2hkRWlRTEI0L2h2a1hUaFVCbHExSXlZTEVLR0JWTVZNM1BOTittZ21CVnRuQ3BFQzdzVnhUY0plWTZYT1p2RVVIazV6aTgwcnQrK05XSHQ3Rm9laDQrQkwva3ozOXlDQjJ2RjRxMXA4RmJETzFoQVFkU0dENXhEMWJpU0NEZnFqM05BQmNGQUM4Q1FBenY4S3Fwb0lSSVFzbklpVk5wTTMxdllvM0daNHJ3MS94aU1aWk80OGJKektwaHpBbG9Yd2VleFBqTUYvTUwrVCs0dUMwVDEva1M4ekJtYkNwdXhVQXBtdUdMU3hDZG03bzRoYWpKOUNVemxreG5ZQUhLOHNOeGlONkVHZFUzejlGeFZGT3lwWlNwaXFXanhyb251Q1BjRmJtL3lnQXJaZ2phZEtJRzBZczNMdDVJTE5DMkpkdnl0akRmb0UxMUp4RzlCMXhmTlFLSDZsREQ5RDBaakpudGd1TzZRY2RFMEtJZStsY1Jya00zTGlWa1FvQW4raFlGSEZrTXBzeHVLYlNGMW5lZ05ZSjJ6RTlUTHJ1NEQvTEZYbks4UjVxYW1wU1JrTUpzbmtKdlhGZTBmc05hWnJaMHFmV1J2aUJCMTlIWnc0ZHZNYmlNZCtPZ2M5V1JBNnFpMEZGeTFIVjROd2RiaHJETFVPYWZvb1pFTlZ4VmkvbHVRcVgvdGo5MHdyK3I0WGZvS09HM3FqZ0hoRGw4RVhOd3NSZEMrajVxNGl4ZjVpRlE0SmNIeUZWNFJ2aWwyckJCL2c5YURpZm5ib0tIRytIaFp0RmVrbHV2QWx1eDdpRzg0RlpLSVJSN2dqTk94Mm5ZRXp2alVPSW5QZkVBU0pORGV3U3l1aXYzbUc4bG80ZjFtbUNKZXFCKzVhTTFpd3B5bHFQbERFeVFMczFia2kvbmZ5am1jaGN2eXBIcjh5UTV1Y3Z5RkJBa1JTdnlWL3hRY0s3aFlmbHo5QUxkbjNUT3EyQkIvbncwanpHTG5sL0hXMldvTW1GN25landlYmpZSUg2dEc4YVZiRGxjZkJhOVFROXhLNFRIb2prb2MvRWNackZrNXE1eEYreUpmeFYzczhGOU1YTVdNOUFPM0I2QUoyVERHaEp6dDhLczRtc1VHRDh0bVlIKzc5MDUxL0ZYMzRENDh1TjdpcHZveE1pMUlYT3cwaE8zdFVXTTJYbENsUWMzUmZ4QnJYaTNCWCt6V29LWDZWemNFRjcrM29VK1g4Q0JJKzlFYjFEdHVibHlQN05Vc25waW1lTUdQd1o2NnJzUmduNmg2M0JHQkowYm9LSkJySFBRZGVET3ZHOC9Gc1R2c3hwMFdWQmh1RW5Oa252VTZ3YWRNdDl5dnorL1ZELy9LWHVSMzk2RHE1ZXk5L1F1K1JKWUQ4OXA5Z3pPaFhzb24yK1AwQ2w5R2tJVFlTM21hZlllM283Zm9lYi9sV0E4eXZ3aFpQNWJmZm1idlI0UzN0d1c3ZVYzaWZrRzNYVnVQTUkrNzYvVDM2Y3VUTXlkenVSS3Z0KzRZTWZDTFF4dXozTzRROURhaUtzbE1FQWZiNUNXRVBpcUFpd3lnQ2tYSGF2aWIxYUpkWEVreVh3MHJ0NVJQZ0FGamZIL051RHN1Tk1reEhId0dPWFEvOExJVzRyYnFPN01jZlZsMTVxSUJzVGN1SEwydVVLL0VVczR6L0FhOVpteUV3MktLNmg2YktWZlJGaVFweWRpZUFta2M2Y3JJdHo5bzN3OEZmNW84c0dSVjBwTFQxeTdTRGlDTTdIajhkOXRqNXFEOHN5RXMreEZlS1I3d0gzM1E5cnlUTVN3OTZhaXFka3B5WkdUWjN1UlZKbGhMeUxzc0JxVGRRMUFsck5DTXBPeloyWE5Kd0VDbXJGODNsSm1UakJkdUdEN3ZHMm9ESld1SzlxOWRXL1JhUVJpTWdnQ3A5a2tVUU1IOU11SzQ4VzcxcXd2S2xpSFZxTjFpNVl2Wk16bWdOWGh2WWVyeVZkVXhVOFQ4M040ZHk1aGZISnlCSXBDcWV0aU5pYXVqZDRlak1haDRPajRiNW1kYWZTMkF5V2xWV2d2MmpsajE0eWFwSktaaDFBOU9sQmVYTXNrWWlzdUlUZzVlUktLUkNucll6Y21ydm0wWXlxOTdlRDIwbXJTY2NlTTNaOTNKQ2k0Vm9CdHBhaVdueVRtcmZoOExucTlQLzRDcjBJb2xCaTNrZGdXRDBFb0RPelJoRzZsTTA2QUtXeEVxQUl2UWZSRnNJV1JDRlZpUjhMRE9TdU9pRTdWaVBrVkx6aWswdHRDRU1yamJTQ1FQSS9IbVdnaXpVL0VGN2dqK2traFVnTW9QN2xHZklwL3hpRi8zaFlIb1Z5OUxRNGt6OEdRaWFyb1BQeEhFK2o4MERvaTBLSTZQbFJNYk1WYkRvZndsdjRJaCtrdElVVGZSVVhDaWk3Q1NZbnV1SnhlTUdkK2FzNGM1bnRKYnVIQ2pmTTJNZGdXS3NFYUR0QXJOdjZ3WWRsYUprK3lkTTd5OUlJWmpGbUU4Y3hkaCtlRlRhZnV3RWM0Z1hhMStlaWRSamg2ZDdXL0RCelZ3cUcxZDAySDFpS2FqK3BsWjI0emRvdlFzSStiTzUwWE9qM3VUeEpxY0NScHBQRnNHWCs4SFgrTnk5cWdDOXFBVnhYQ2prSUpsUDRBWHhXODcxY28vZVF0WTNqN3cvdStoVitnbGpLMVROMnlwZFpVMjdKVko4cWRwWVlKLzYreUhXVk45YWFHVW9GVU9KVk9MYUoyVVBXaWpxSWhvZ21pZE5FYzBRclJhZEhWRm5TTDFpMjZ0SEJ0TWF5RmY0dkpMUmEyMk5TaVhHd3E3aWorV3V3dURoYW5pdlBFUmVJRDRpdmlkeWFNeVhDVE1TWVJKaWttODB5V21Xd3hLVFdwTWpsdDBtanltQmJUYldrcjJvbjJvSDNwWURxZC9wNWVRVCtsWDB0TUpCWWw2Y1hUcHFVbkp5WnVUdDR0MzcyNXVFUmg2aEVRN09VVlVLUFJISytwcno4ZTdDRTNIWWlNVVkvcHA5QUNzTnkwZVlQcXM5MHBVN0RYTTFndFBEelg0T2V3a0JkcjlLUGZCL0dCR24xcmlTbi9Kay9LRDlTLytVazRXZTB1UVAxRGxiNjVTQzgzYlM1cy8zVzdpWHlFOXdQa3ByN25SbS8rR21FcHdwTFJDSGRHdUJEK0JESENFNUh6d0pEaGFDankyUnRmeTNoT3BGVkQ3OFRkRnc2RFFLdHJpTGhuV0k3L3RFYmdpeDQxSHJpSzFPaEkycTRReHRSZFAwcENRcStPbWY3K3VPTW1DSmZ6bzl6MTMwcXhyQW83UXd6RVZJRXp5TWp5Ti9EZGlmdU14Zzl3TkR4d1FMQkIzeDNoVTFxeUtQMGlEOTVPb3UrcnZ5SDhmdytTaGVvSElONkJ2MEdibmtiZHdhb1BBY0VtZU9SMzJNNVFmL3dSMVJidlAwdmsyUlNsNUNVdVRTUFI3UGZidnE5QXBReEVTa0hpV3R0YjNnK05TZzBQWXc1T3BBK1dDb1ZNNXRhQnlRTVYyVkpUNTVDUlBZV2E1TS9RYzlsNXVhbVFTYlp6ZVlzdGx6QzQ0NGU2a2tMUmlDN3VPSEdKQ1Nxbmt5UDhwNHhBdmREd3EvTi9aa3dicjErNS8remsyTDZFekdKb0tibFFXSHRGdmg1dHlGbjNQV002ZmVuMC9PbUlzUnN6QWJkUjRIWTIzaS8xZGhyZURzUlNVdzk5akVaaVdwSzZLVFUxTlRNeGNXdm1Wdm5Xclp1SUFPWEY1b2VoRkVZdjBzQUNxZWwvTzFzcU1UWFdDejR0Z1JuckNITFRwaU9PeGt5MnVXSmdHbjltN0JaUDFBODVoWkdnb2UvRDVOM3ptWE96Nkpyc2d6UFJST1R2bStxUC9OQ2trcVJ5eG1jS1hlSFJrSElaUFVhUHk5RnJwQW11OGx6TGpGcEhqMTBUdHc1Vm9LUEhOaDFCMVdoUHlxWkl4alIzYjA0RjJzYndJZzlNc01adXVOMjgyYllKSjMrVFE2RUhQaXJGek1sUllDby9pelNsTzQ0WjJZUlM4bE1ZVTJjRWZ2cUVXQWM2TXlBMUxnUmxvUm41SkxVMDNiU3dhUEVtZEF2dFAxS2laV0FPLzRBSVoxZDllOEowM2h0V1M0aGoxcU1KZkJ1RTFMZ013WGJRMDZiTldpVm9tVnhRTTRWcGNsSEt6cDFGMjRxTE03YkZ4MmVrSkJNV1JZRWJkZ1NTa1JEQ09zSlVpTUxrTG1RSkJHVkhQSlhJNUdnU0ZIY0dkL0pSNHM1NEpORVpKWlpqZC9KUmdoeStrWnQrR2xkakVtY1RwRElSV01BWDlKSHlxc09vQVYzeExCdUtoaU9mNkRtZVROMDhldVd1dmR1SUpLS0RTV2dxbWhJWGw1VE1rTW1ja1E4Y0lWTGNCM1UzNUlLbUdzaVZiSjllOXQwUlJLaDBhRWVWUUNXM3kxSkMySDFvN3dmQ1NzZDRmdDB6N2doSUJjS1MzMS8wM1JGNSt6elNpd1I3OFdsQUR5VEFwMDJISWJLQ3pXZ00rQWtLSTBmUUNlTHp5S1B4dUlQaHFJTXBJYTBJVzJrUXljL3ZZRXBEV24vWXRucmJUbFNFdHN6ZGtzMllicDI3TFhzclVlMHR0U3RxbVhESndwUTVLZkhFd2FjVnBxNWlURk1MVTFhbEltK1VGamd2a0RIOU5LT1dDeW0xd25ScVV2TFVxVW5GZS9ac0Y3N0poTUtmY2tVdXNFWHhBUVhhdEFtRGZ4ZHF1VkdxaVlGRnpwaHlCc29ERWVObGRaTUFmL1lEMi9uQjNFT1NRY2NHUXhzRWRndzQvVVI0MHdWNlhDTzJzYU1jWVNjM0xIRU5ZQ2JCM0JQWVBsOTY4ZFFsWUJEMFlHQWtZV1p2UEFLNzR2YUU4YUVFdEdzREZsL3haRXh2b2ZPUVBZb01mbmZrSlNlbmtTTUdETGd3NHA3ODNvVkxkeFdtZm1HaGZuNWhsU2RPVkFqZlVEKzU2ZjhEaGxtRWN3QUFBSGljSGN2QkRZQWdGQVRSNFVlVWcwWFJsMFo3RmFvUUQwN0lacEozV1JLd1c3V2drTWkydW1EajBDZVh2bmwwYzBIbjFZTlBML1BIRDk5WkNQUUFBQUI0bkkxVHUwb0RRUlE5TXh1VEtKSnNIZ1lKSVlpRUZCWmlFY1JDTEN4VUJDR0lXa29XSmFLRUtFa3NGRTNoRjRoZjRFZFlXdmdWYXEyd1dOb3I2Sms3b3hDVGdNWGU1N2xuN3IwekN3VmdEQlZjUVRXQ1RoTnhlbXByZTNNS2VlRHJDeVBNSzJoRWpFVmZ3VU0wQ0JvZGxPdXRZQSt6amNPREFCV1JpOGV0L1NhVzI2Y25iYXl4VGt1dHJUZWVSeGJqV1dtWm96d3ZoeUxLbU1jU1ZyQ0RYZFRSZEhVMTFoaDlSUnhZY1kwSHZDbGZMVmdPVlhXNlp2UHFSTjJvTy9XbzNiazZiL1BhNGZXdGk5K3pteHhuZmNFWldtampDT2Z5S2NhU1NDT0RMS1l4aDJWVUdmTWw3dUVKejNpbnJaQ1F2aUxrS0tDRUdUZG5USElwbWRkSCtPc1phZkFlV2ZQa3RlajRRSFEvenJLbWUzQVQvOFJsaHVLeWYvaHNaVnh1NTRPWmRZbXY5c1EvR2Q5d2NVODJXSkR0UUpnVnQvWFRnWkVlNWFSWTl0eFJoOUV5WjE3NkdvU285aUEwZFVuNkhjWmkvT1JRWkxVUHFZbUk5ZDE3ck8vVzYrUWM1N3MwREZGTytjb04rR1JLaVJXS0ZlSHJUY3R1TDRqMnVVZWpRK3BMOFRPaVEyckRrVURYb2JvT1pmNm1GQm5NYlJSbHp4WVhGVnhLZFBqN2hqUlAwNjVmYmJyOEJydDVTREY0bktXVU8weFVRUlNHLzMxd2wxMVp3QVVSZkdCaVE2TkdZZ2lFMHFnWUN4K0lZdWdzRElYR3dsaUxMNnpkMWdRa3VpTGhvWkdZRzQxTGhNUWcyMWpZR0JiTFcxTmdSU0FadjVsZFJJMFNZTytYYysvTTNEbm4vSFBtM2xGSVVrS05PcVRRamF1M2I2cGNVVVprak95YjBQVnJ0K3lZQ2ozZWhYbUc4WmltTit6bWVxcFRsKzdvc1o1b1NGVWFNbk42aGozSE1pYlFDNTRqWmtLajJCanRjYndtektwZUVXR1N2bzlselZmTk1qZUJkNEIzZ0hkUTlBN3dEdkFPOEE3MDFuekRJeUJHeG8wdTBWdkNmd2xWdnZsQWE0NjQ4K1k3OTd5N2UycFJxOXJVcm5ubEZTN3J0S29qazlFamFEM0FTck5tMFh6QlZqRGZqS3FVSzJVV1MvS1h5WmsrMDdmSnVabWk1Y3lDR1RTRHBXVW1qbTk2VFc4Si9obFlMS0NVclFYay9qblZLMXExNnMyUGJXWkxGOHkxc3ladCtXM0V0dnNZVzBaVDJsbDZnMWkrOGJlY3Y3alQ2enUydGxiN1pEUW56eXpRV3RnNHVwdTV6Y3Q5c2Y0ZmF0eVR2UFcyVmR5TC8vdG43UGV6eVZ4L3FTUnp2eGtvUkZtUDVtcTlYSHh2KzF1dXEvUDl0VmVvRDZ0V1RSRFdZWWlvR2FJNkJ2YlBibEdNdjd0VmNmN3dOdTNnTDI5WFVoMFEwa1VvVXplVTZ3b2sxQU1WR29Da3BxQkNINkZDTXhEUlowaHlSdVJWcVJXdEVpR3NvNHdraVZzSnV6Z3hxcGk5MTdIUGNSQVNUa2ZJNllnNEhXVk9SMHpIb1U0bklLbVRVS2xUVU9YMHhYVWFxblVHZHVzczdOUTVTT2s4MU9nQzdGY24xTHFWMUhQS2RxbEJsNkJSbDJHUFcxdllyUzNxMXVicHJoNmh4NjR3cHFjUTUwd2VSc05MU0dwRVkyUWYxMnN5dm9HVUp1V1Q2eDNVNkwyeXhMUjE4VnhkUEU3NWFUUi9naHJOUW9PclVjelZxTnpWS002NmJSV2EySnRtOW1UdHJPMUFjVGU2ZWxCMFQvZjFRQS9WajZvcDRzNFFJMis5ZndLcHlrY3VBQUFCQUFBQUNBQUFBQVFBRGdBQ2FXUmxiM0p2Ylc0QUFXeGhkRzRBQ0FBR0FBQUFBQUFCQUFJQUNBQU1BQUgvVmdBQkFBQjRuR05nWUdCa0FJSmJqQ3VrUVBST1ZZM0hNQm9BTnk0RmNRQUFlSnh0azcxclUyRVV4cC96dnJHR0VpK2QxRGdrYllUWTBoZDZhVW9RZzlGWWlpbCtZQ0IrZE9xRk9PaW9nb09iVURvN0Y5ekZRUndjSEJ6Nk4zUndGRm9wdU5sbzZLYlg1NXplaEZnNi9EajMvVGlmejN0bEFNaFo0NzQ3amJjdTRDS1o5eTFVM1RaaXllRXhxWk84ZkVIWmJlRXU3N2JrRHFycUk4OXhpdmVyNUFtSnMrOXE5cTNVTTJLN1QxK05NVVQyc09Dbk1lOCtBTzRsRXMzcDl2SEFkZmdka1BoSnJuZVFTSjdzSWRJN011RCtLenRML0EyZU56Tjc1TFBJZGNSNFhkZEwvL2lQRm5mQ05kTmZQRHZIUGxwYU0rME04OTlqTE9BZ1BXVHZzZXVoelJ4cVo2M2VXY2JwV1E5dEhDanBMcy8xKzZIdllwbjd5OHhwZnVvanQzRkwzbU9HTmxJZnEzY0hFUzNJRk04MGZ3SGYwSkZjK3B2NTEwYXpENXhIWU0wQkpSZlN2M3FIMzAzbTNPZDhpdEpCbVRHV2JHYWN2ZTd4ckM5dlVMTzlwNmdvcksyaHVkMmpvM2x6SFhHL0xxL04veXJuZEoxY0lvSHJZSE0vQVp2YmRqYlRNYWlESXpjbG4vNGtmV3AxWnFqRGNWalhobG5WWWh6Vm9tbnh1amIzRStCOFk5TWkvSTlxcFQzU2Z0ZloyUHlIT2h4SDMxakh0R3lQbzFwa1drK3BsbndERWUwRWU3N210eXplb3VvNGVqUFVqUlpaVHFXdnVlbXpRczZURXRkZnlTZnFYYk04ZFV6cTIvSS9xRzhPbDRld3QvVVJBWE9XYTRCVjNudEdpdEpBZzZ6Z1hicG11WGRSNG41YjQvb1hxTGd5LzVWTlRMdlB1T0RtV0JkNzFMdjJocTZnNGd1b1NZSUM4eStRcFJFTjVpNnl6K2dmSTZiR1J3QT1cIiIsIi8vIEZpcnN0LWNsYXNzIG1vZHVsZS5cbmV4cG9ydCBjbGFzcyBTVkcge1xuICAgc3RhdGljIE5TOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgIHByaXZhdGUgaGlkZGVuTWV0cmljc0VsZW1lbnQ6IFNWR1NWR0VsZW1lbnRcblxuICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgdGhpcy5oaWRkZW5NZXRyaWNzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcuTlMsIFwic3ZnXCIpXG4gICAgICB0aGlzLmhpZGRlbk1ldHJpY3NFbGVtZW50LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMFwiKVxuICAgICAgdGhpcy5oaWRkZW5NZXRyaWNzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwXCIpXG4gICAgICB0aGlzLmhpZGRlbk1ldHJpY3NFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuTWV0cmljc0VsZW1lbnQpXG4gICB9XG5cbiAgIHRleHRXaWR0aCAodGV4dDogU1ZHVGV4dEVsZW1lbnQpOiBudW1iZXIge1xuICAgICAgdGhpcy5oaWRkZW5NZXRyaWNzRWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0KVxuICAgICAgY29uc3Qgd2lkdGg6IG51bWJlciA9IHRleHQuZ2V0QkJveCgpLndpZHRoXG4gICAgICB0ZXh0LnJlbW92ZSgpXG4gICAgICByZXR1cm4gd2lkdGhcbiAgIH1cblxuICAgdGV4dEhlaWdodCAodGV4dDogU1ZHVGV4dEVsZW1lbnQpOiBudW1iZXIge1xuICAgICAgdGhpcy5oaWRkZW5NZXRyaWNzRWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0KVxuICAgICAgY29uc3QgaGVpZ2h0OiBudW1iZXIgPSB0ZXh0LmdldEJCb3goKS5oZWlnaHRcbiAgICAgIHRleHQucmVtb3ZlKClcbiAgICAgIHJldHVybiBoZWlnaHRcbiAgIH1cbn1cbiIsImltcG9ydCB7IGxhc3QsIG50aCB9IGZyb20gXCIuLi8uLi9zcmMvdXRpbC9BcnJheVwiXG5pbXBvcnQgeyBBQ2xhc3MsIENsYXNzLCBfX2NoZWNrLCBfX25vbk51bGwsIGFic3VyZCwgYXMsIGFzc2VydCwgdXNlckVycm9yIH0gZnJvbSBcIi4uLy4uL3NyYy91dGlsL0NvcmVcIlxuaW1wb3J0IHsgYm9vbF8gfSBmcm9tIFwiLi4vLi4vc3JjL3V0aWwvTGF0dGljZVwiXG5pbXBvcnQgeyBfX3NsaWNlLCBhbm5vdGF0ZWQsIGlzzrEsIHNldM6xIH0gZnJvbSBcIi4uLy4uL3NyYy9Bbm5vdGF0aW9uXCJcbmltcG9ydCB7IENvbnMsIExpc3QsIE5vbkVtcHR5LCBQYWlyIH0gZnJvbSBcIi4uLy4uL3NyYy9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgZXhwckNsYXNzIH0gZnJvbSBcIi4uLy4uL3NyYy9EYXRhVHlwZVwiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSwgZXhwbFZhbHVlIH0gZnJvbSBcIi4uLy4uL3NyYy9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgQ2hhbmdlLCBOZXcsIFZhbHVlRGVsdGEgfSBmcm9tIFwiLi4vLi4vc3JjL0RlbHRhXCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi4vLi4vc3JjL0V4cGxcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuLi8uLi9zcmMvRXhwclwiXG5pbXBvcnQgeyBEYXRhRWxpbSwgVmFyRWxpbSB9IGZyb20gXCIuLi8uLi9zcmMvTWF0Y2hcIlxuaW1wb3J0IHsgTnVtLCBQZXJzaXN0ZW50LCBTdHIsIFZhbHVlLCBmaWVsZHMgfSBmcm9tIFwiLi4vLi4vc3JjL1ZhbHVlXCJcbmltcG9ydCB7IGFzVmVyc2lvbmVkLCByZXNldCB9IGZyb20gXCIuLi8uLi9zcmMvVmVyc2lvbmVkXCJcblxuaW1wb3J0IERhdGFFeHByID0gRXhwci5EYXRhRXhwclxuaW1wb3J0IERlZiA9IEV4cHIuRGVmXG5pbXBvcnQgTGV0ID0gRXhwci5MZXRcbmltcG9ydCBMZXRSZWMgPSBFeHByLkxldFJlY1xuaW1wb3J0IFByaW0gPSBFeHByLlByaW1cbmltcG9ydCBSZWNEZWYgPSBFeHByLlJlY0RlZlxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ3Vyc29yIHtcbiAgIGFic3RyYWN0IG9uOiBWYWx1ZVxuICAgYWJzdHJhY3QgdG88VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+LCBrOiBrZXlvZiBUKTogdGhpc1xuICAgYWJzdHJhY3QgYXQ8VCBleHRlbmRzIFZhbHVlPiAoQzogQUNsYXNzPFQ+LCBmOiAobzogVCkgPT4gdm9pZCk6IEN1cnNvclxuXG4gICBub3RBbm5vdGF0ZWQgKCk6IHRoaXMge1xuICAgICAgcmV0dXJuIHVzZXJFcnJvcihcIk5vdCBhbiBhbm5vdGF0ZWQgbm9kZS5cIiwgdGhpcy5vbilcbiAgIH1cblxuICAgYXNzZXJ0PFQgZXh0ZW5kcyBWYWx1ZT4gKEM6IEFDbGFzczxUPiwgcHJlZDogKHY6IFQpID0+IGJvb2xlYW4pOiBDdXJzb3Ige1xuICAgICAgcmV0dXJuIHRoaXMuYXQoQywgdiA9PiBhc3NlcnQocHJlZCh2KSkpXG4gICB9XG5cbiAgIM6xc2V0ICgpOiB0aGlzIHtcbiAgICAgIGlmIChhbm5vdGF0ZWQodGhpcy5vbikpIHtcbiAgICAgICAgIGFzc2VydChpc86xKHRoaXMub24pID09PSBib29sXy50b3ApXG4gICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB0aGlzLm5vdEFubm90YXRlZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIM6xY2xlYXIgKCk6IHRoaXMge1xuICAgICAgaWYgKGFubm90YXRlZCh0aGlzLm9uKSkge1xuICAgICAgICAgYXNzZXJ0KGlzzrEodGhpcy5vbikgPT09IGJvb2xfLmJvdClcbiAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHRoaXMubm90QW5ub3RhdGVkKClcbiAgICAgIH1cbiAgIH1cblxuICAgc2V0zrEgKCk6IHRoaXMge1xuICAgICAgaWYgKGFubm90YXRlZCh0aGlzLm9uKSkge1xuICAgICAgICAgc2V0zrEoYm9vbF8udG9wLCB0aGlzLm9uKVxuICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5ub3RBbm5vdGF0ZWQoKVxuICAgICAgfVxuICAgfVxuXG4gICBjbGVhcs6xICgpOiB0aGlzIHtcbiAgICAgIGlmIChhbm5vdGF0ZWQodGhpcy5vbikpIHtcbiAgICAgICAgIHNldM6xKGJvb2xfLmJvdCwgdGhpcy5vbilcbiAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHRoaXMubm90QW5ub3RhdGVkKClcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gSGVscGVycyBzcGVjaWZpYyB0byBjZXJ0YWluIGRhdGF0eXBlcy5cblxuICAgdHJlZU5vZGVWYWx1ZSAoKTogdGhpcyB7XG4gICAgICByZXR1cm4gdGhpcy50byhOb25FbXB0eSwgXCJ0XCIpXG4gICAgICAgICAgICAgICAgIC50byhQYWlyLCBcInNuZFwiKVxuICAgfVxuXG4gICBudGggKG46IG51bWJlcik6IHRoaXMge1xuICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnRvKENvbnMsIFwiaGVhZFwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnRvKENvbnMsIFwidGFpbFwiKS5udGgobiAtIDEpXG4gICAgICB9XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeHBsVmFsdWVDdXJzb3IgZXh0ZW5kcyBDdXJzb3Ige1xuICAgYW5jZXN0b3JzOiBFeHBsVmFsdWVbXVxuICAgcmVhZG9ubHkgdHY6IEV4cGxWYWx1ZVxuXG4gICBjb25zdHJ1Y3RvciAoYW5jZXN0b3JzOiBFeHBsVmFsdWVbXSwgdHY6IEV4cGxWYWx1ZSkge1xuICAgICAgc3VwZXIoKVxuICAgICAgdGhpcy5hbmNlc3RvcnMgPSBhbmNlc3RvcnNcbiAgICAgIHRoaXMudHYgPSB0dlxuICAgfVxuXG4gICBzdGF0aWMgZGVzY2VuZGFudCAocHJldjogRXhwbFZhbHVlQ3Vyc29yIHwgbnVsbCwgdHY6IEV4cGxWYWx1ZSk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICByZXR1cm4gbmV3IEV4cGxWYWx1ZUN1cnNvcihwcmV2ID09PSBudWxsID8gW10gOiBbLi4ucHJldi5hbmNlc3RvcnMsIHByZXYudHZdLCB0dilcbiAgIH1cblxuICAgc3RhdGljIHBhcmVudCAoY2hpbGQ6IEV4cGxWYWx1ZUN1cnNvcik6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICBhc3NlcnQoY2hpbGQuYW5jZXN0b3JzLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gbmV3IEV4cGxWYWx1ZUN1cnNvcihjaGlsZC5hbmNlc3RvcnMuc2xpY2UoMCwgY2hpbGQuYW5jZXN0b3JzLmxlbmd0aCAtIDEpLCBsYXN0KGNoaWxkLmFuY2VzdG9ycykpXG4gICB9XG5cbiAgIGdldCBvbiAoKTogVmFsdWUge1xuICAgICAgcmV0dXJuIHRoaXMudHZcbiAgIH1cblxuICAgdG88VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+LCBrOiBrZXlvZiBUKTogdGhpcyB7XG4gICAgICByZXR1cm4gRXhwbFZhbHVlQ3Vyc29yLmRlc2NlbmRhbnQodGhpcywgRXhwbC5leHBsQ2hpbGQodGhpcy50di50LCBhcyh0aGlzLnR2LnYsIEMpLCBrKSkgYXMgdGhpc1xuICAgfVxuXG4gICB0b0NoaWxkIChuOiBudW1iZXIpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIERhdGFWYWx1ZSkge1xuICAgICAgICAgY29uc3QgdHZzOiBFeHBsVmFsdWVbXSA9IEV4cGwuZXhwbENoaWxkcmVuKHRoaXMudHYudCwgdGhpcy50di52KVxuICAgICAgICAgaWYgKDAgPD0gbiAmJiBuIDwgdHZzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEV4cGxWYWx1ZUN1cnNvci5kZXNjZW5kYW50KHRoaXMsIG50aCh0dnMsIG4pKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihcIk5vdCBhIGRhdGEgdmFsdWVcIilcbiAgICAgIH1cbiAgIH1cblxuICAgdG9DaGlsZE9mZnNldCAodHY6IEV4cGxWYWx1ZSwgb2Zmc2V0OiBudW1iZXIpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIERhdGFWYWx1ZSkge1xuICAgICAgICAgY29uc3QgdHZzOiBFeHBsVmFsdWVbXSA9IEV4cGwuZXhwbENoaWxkcmVuKHRoaXMudHYudCwgdGhpcy50di52KVxuICAgICAgICAgY29uc3QgbjogbnVtYmVyID0gdHZzLmZpbmRJbmRleCh0dl8gPT4gdHZfID09PSB0dilcbiAgICAgICAgIGlmIChuID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihcIk5vdCBhIGNoaWxkXCIpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9DaGlsZChuICsgb2Zmc2V0KVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoXCJOb3QgYSBkYXRhIHZhbHVlXCIpXG4gICAgICB9XG4gICB9XG5cbiAgIG5leHRTaWJsaW5nICgpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KCkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnVwKCkudG9DaGlsZE9mZnNldCh0aGlzLnR2LCAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICB9XG5cbiAgIHByZXZTaWJsaW5nICgpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KCkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnVwKCkudG9DaGlsZE9mZnNldCh0aGlzLnR2LCAtMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgfVxuXG4gICBoYXNQYXJlbnQgKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA+IDBcbiAgIH1cblxuICAgdXAgKCk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICByZXR1cm4gRXhwbFZhbHVlQ3Vyc29yLnBhcmVudCh0aGlzKVxuICAgfVxuXG4gICB0b0JpbmFyeUFyZzEgKG9wTmFtZTogc3RyaW5nKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGNvbnN0IHQ6IEV4cGwuQmluYXJ5QXBwID0gYXModGhpcy50di50LCBFeHBsLkJpbmFyeUFwcClcbiAgICAgIGFzc2VydCh0Lm9wTmFtZS52YWwgPT09IG9wTmFtZSlcbiAgICAgIHJldHVybiBFeHBsVmFsdWVDdXJzb3IuZGVzY2VuZGFudCh0aGlzLCB0LnR2MSlcbiAgIH1cblxuICAgdG9CaW5hcnlBcmcyIChvcE5hbWU6IHN0cmluZyk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICBjb25zdCB0OiBFeHBsLkJpbmFyeUFwcCA9IGFzKHRoaXMudHYudCwgRXhwbC5CaW5hcnlBcHApXG4gICAgICBhc3NlcnQodC5vcE5hbWUudmFsID09PSBvcE5hbWUpXG4gICAgICByZXR1cm4gRXhwbFZhbHVlQ3Vyc29yLmRlc2NlbmRhbnQodGhpcywgdC50djIpXG4gICB9XG5cbiAgIGF0PFQgZXh0ZW5kcyBWYWx1ZT4gKEM6IEFDbGFzczxUPiwgZjogKG86IFQpID0+IHZvaWQpOiB0aGlzIHtcbiAgICAgIGYoYXM8VmFsdWUsIFQ+KHRoaXMudHYudiwgQykpXG4gICAgICByZXR1cm4gdGhpc1xuICAgfVxuXG4gICBpc0NoYW5nZWQgKHNf4bqfOiBWYWx1ZURlbHRhKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGFzc2VydChhc1ZlcnNpb25lZCh0aGlzLnR2LnYpLl9f4bqfLmVxKG5ldyBDaGFuZ2Uoc1/hup8pKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICB9XG5cbiAgIGlzVW5jaGFuZ2VkICgpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgYXNzZXJ0KGFzVmVyc2lvbmVkKHRoaXMudHYudikuX1/hup8uZXEobmV3IENoYW5nZSh7fSkpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgIH1cblxuICAgaXNOZXcgKCk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICBhc3NlcnQoYXNWZXJzaW9uZWQodGhpcy50di52KS5fX+G6nyBpbnN0YW5jZW9mIE5ldylcbiAgICAgIHJldHVybiB0aGlzXG4gICB9XG5cbiAgIHRvVGVybWluYWwgKCk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICBsZXQgdDogRXhwbCA9IHRoaXMudHYudFxuICAgICAgd2hpbGUgKHQgaW5zdGFuY2VvZiBFeHBsLk5vblRlcm1pbmFsKSB7XG4gICAgICAgICB0ID0gdC50XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwbFZhbHVlQ3Vyc29yLmRlc2NlbmRhbnQodGhpcywgZXhwbFZhbHVlKHQsIHRoaXMudHYudikpICAgICAgXG4gICB9ICAgXG59XG5cbmV4cG9ydCBjbGFzcyBFeHByQ3Vyc29yIGV4dGVuZHMgQ3Vyc29yIHtcbiAgIHJlYWRvbmx5IHY6IFZhbHVlIC8vIHdvdWxkIHByZWZlciBTeW50YXhOb2RlLCBidXQgd2UgYWxzbyB0cmF2ZXJzZSBcImFkbWluc3RyYXRpdmVcIiBub2RlcyBsaWtlIGNvbnMgY2VsbHMuXG5cbiAgIGNvbnN0cnVjdG9yICh2OiBWYWx1ZSkge1xuICAgICAgc3VwZXIoKVxuICAgICAgdGhpcy52ID0gdlxuICAgfVxuXG4gICBnZXQgb24gKCk6IFZhbHVlIHtcbiAgICAgIHJldHVybiB0aGlzLnZcbiAgIH1cblxuICAgLy8gTm8gd2F5IHRvIHNwZWNpZnkgb25seSBcIm93blwiIHByb3BlcnRpZXMgc3RhdGljYWxseS5cbiAgIHRvPFQgZXh0ZW5kcyBEYXRhVmFsdWU+IChDOiBDbGFzczxUPiwgcHJvcDoga2V5b2YgVCk6IHRoaXMge1xuICAgICAgY29uc3Qgdsq5OiBUW2tleW9mIFRdID0gYXM8UGVyc2lzdGVudCwgVD4odGhpcy52LCBDKVtwcm9wXSAvLyBUeXBlU2NyaXB0IG5vbnNlbnNlXG4gICAgICByZXR1cm4gbmV3IEV4cHJDdXJzb3Iodsq5IGFzIGFueSkgYXMgdGhpc1xuICAgfVxuXG4gICAvLyBBbGxvdyB0aGUgZGF0YSB2YWx1ZSBjbGFzcyB0byBiZSB1c2VkIHRvIG5hdmlnYXRlIHRoZSBkYXRhIGV4cHJlc3Npb24gZm9ybS5cbiAgIGNvbnN0cl90bzxUIGV4dGVuZHMgRGF0YVZhbHVlPiAoQzogQ2xhc3M8VD4sIHByb3A6IGtleW9mIFQpOiBFeHByQ3Vyc29yIHtcbiAgICAgIHJldHVybiB0aGlzLnRvPERhdGFFeHByPihleHByQ2xhc3MoQyksIHByb3AgYXMga2V5b2YgRGF0YUV4cHIpXG4gICB9XG5cbiAgIHRvQ2FzZTxUIGV4dGVuZHMgRGF0YVZhbHVlPiAoQzogQ2xhc3M8VD4pOiBFeHByQ3Vyc29yIHtcbiAgICAgIGNvbnN0IHbKuTogVmFsdWUgPSBfX25vbk51bGwoKGFzKHRoaXMudiwgRGF0YUVsaW0pIGFzIGFueSlbQy5uYW1lXSlcbiAgICAgIHJldHVybiBuZXcgRXhwckN1cnNvcih2yrkpXG4gICB9XG5cbiAgIHN0YXRpYyBkZWZzIChkZWZzOiBMaXN0PERlZj4pOiBNYXA8c3RyaW5nLCBMZXQgfCBQcmltIHwgUmVjRGVmPiB7XG4gICAgICBjb25zdCBkZWZzyrk6IE1hcDxzdHJpbmcsIExldCB8IFByaW0gfCBSZWNEZWY+ID0gbmV3IE1hcFxuICAgICAgZm9yICg7IENvbnMuaXMoZGVmcyk7IGRlZnMgPSBkZWZzLnRhaWwpIHtcbiAgICAgICAgIGNvbnN0IGRlZjogRGVmID0gZGVmcy5oZWFkXG4gICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgTGV0IHx8IGRlZiBpbnN0YW5jZW9mIFByaW0pIHtcbiAgICAgICAgICAgIGRlZnPKuS5zZXQoZGVmLngudmFsLCBkZWYpXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBMZXRSZWMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlY0RlZnM6IExpc3Q8UmVjRGVmPiA9IGRlZi7OtDsgQ29ucy5pcyhyZWNEZWZzKTsgcmVjRGVmcyA9IHJlY0RlZnMudGFpbCkge1xuICAgICAgICAgICAgICAgY29uc3QgcmVjRGVmOiBSZWNEZWYgPSByZWNEZWZzLmhlYWRcbiAgICAgICAgICAgICAgIGRlZnPKuS5zZXQocmVjRGVmLngudmFsLCByZWNEZWYpXG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWJzdXJkKClcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZzyrlcbiAgIH1cblxuICAgdG9EZWYgKHg6IHN0cmluZyk6IEV4cHJDdXJzb3Ige1xuICAgICAgY29uc3QgaGVyZTogRXhwckN1cnNvciA9IHRoaXMudG8oRXhwci5EZWZzLCBcImRlZsyFXCIpLFxuICAgICAgICAgICAgZGVmczogTWFwPHN0cmluZywgTGV0IHwgUHJpbSB8IFJlY0RlZj4gPSBFeHByQ3Vyc29yLmRlZnMoaGVyZS52IGFzIExpc3Q8RGVmPilcbiAgICAgIGFzc2VydChkZWZzLmhhcyh4KSwgYE5vIGRlZmluaXRpb24gb2YgXCIke3h9XCIgZm91bmQuYClcbiAgICAgIHJldHVybiBuZXcgRXhwckN1cnNvcihkZWZzLmdldCh4KSEpXG4gICB9XG5cbiAgIGF0PFQgZXh0ZW5kcyBWYWx1ZT4gKEM6IEFDbGFzczxUPiwgZjogKG86IFQpID0+IHZvaWQpOiBFeHByQ3Vyc29yIHtcbiAgICAgIGYoYXM8VmFsdWUsIFQ+KHRoaXMudiwgQykpXG4gICAgICByZXR1cm4gdGhpc1xuICAgfVxuXG4gICB2YXJfICh4OiBzdHJpbmcpOiB0aGlzIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFZhckVsaW0sIM+DID0+IM+DLngudmFsID09PSB4KVxuICAgICAgcmV0dXJuIHRoaXMudG8oVmFyRWxpbSwgXCLOulwiKSAgICAgIFxuICAgfVxuXG4gICAvLyBFZGl0aW5nIEFQSS5cblxuICAgc2V0TnVtIChuOiBudW1iZXIpOiBFeHByQ3Vyc29yIHtcbiAgICAgIHJlc2V0KHRoaXMudiwgTnVtLCBuKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgIH1cblxuICAgc2V0U3RyIChzdHJfOiBzdHJpbmcpOiBFeHByQ3Vyc29yIHtcbiAgICAgIHJlc2V0KHRoaXMudiwgU3RyLCBzdHJfKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgIH1cblxuICAgY29uc3RyX3NwbGljZTxUIGV4dGVuZHMgRGF0YVZhbHVlPiAoQzogQ2xhc3M8VD4sIHByb3BzOiAoa2V5b2YgVClbXSwgbWFrZU5vZGU6IChlzIU6IEV4cHJbXSkgPT4gRXhwcltdKTogRXhwckN1cnNvciB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2U8RGF0YVZhbHVlPihcbiAgICAgICAgIGV4cHJDbGFzcyhDKSwgXG4gICAgICAgICBwcm9wcyBhcyAoa2V5b2YgRGF0YVZhbHVlKVtdLCBcbiAgICAgICAgIChlzIU6IFBlcnNpc3RlbnRbXSk6IEV4cHJbXSA9PiBtYWtlTm9kZShlzIUubWFwKGUgPT4gYXMoZSwgRXhwci5FeHByKSkpXG4gICAgICApXG4gICB9IFxuXG4gICBzcGxpY2U8VCBleHRlbmRzIFZhbHVlPiAoQzogQ2xhc3M8VD4sIHByb3BzOiAoa2V5b2YgVClbXSwgbWFrZU5vZGU6ICh2zIU6IFBlcnNpc3RlbnRbXSkgPT4gUGVyc2lzdGVudFtdKTogRXhwckN1cnNvciB7XG4gICAgICBjb25zdCB2OiBUID0gYXM8UGVyc2lzdGVudCwgVD4odGhpcy52LCBDKSwgXG4gICAgICAgICAgICB2zIU6IFBlcnNpc3RlbnRbXSA9IHYuX19jaGlsZHJlbixcbiAgICAgICAgICAgIG7MhTogbnVtYmVyW10gPSBwcm9wcy5tYXAocHJvcCA9PiBfX2NoZWNrKGZpZWxkcyh2KS5pbmRleE9mKHByb3ApLCBuID0+IG4gIT0gLTEpKSxcbiAgICAgICAgICAgIHbMhcq5OiBQZXJzaXN0ZW50W10gPSBtYWtlTm9kZShuzIUubWFwKChuOiBudW1iZXIpOiBQZXJzaXN0ZW50ID0+IHbMhVtuXSkpXG4gICAgICBuzIUuZm9yRWFjaCgobjogbnVtYmVyLCBtOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgIHbMhVtuXSA9IHbMhcq5W21dXG4gICAgICB9KVxuICAgICAgcmVzZXQodiwgQywgLi4udsyFKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgIH0gXG59XG4iLCJpbXBvcnQgeyBsYXN0IH0gZnJvbSBcIi4uL3V0aWwvQXJyYXlcIlxuaW1wb3J0IHsgQ2xhc3MsIF9fbG9nLCBfX25vbk51bGwsIGFic3VyZCwgYXMsIGFzc2VydCwgaWQsIHVzZXJFcnJvciB9IGZyb20gXCIuLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgQ29ucywgTGlzdCB9IGZyb20gXCIuLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRXhwbFZhbHVlIH0gZnJvbSBcIi4uL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBDaXJjbGUsIEdyb3VwLCBHcmFwaGljc0VsZW1lbnQsIExpbmUsIE1hcmtlciwgUG9seWxpbmUsIFBvbHltYXJrZXJzLCBQb2ludCwgUmVjdCwgU2NhbGUsIFRleHQsIFRyYW5zZm9ybSwgVHJhbnNsYXRlLCBWaWV3cG9ydCB9IGZyb20gXCIuLi9HcmFwaGljc1wiXG5pbXBvcnQgeyBVbmFyeSwgdW5hcnlfLCB1bmFyeU9wcyB9IGZyb20gXCIuLi9QcmltaXRpdmVcIlxuaW1wb3J0IHsgSWQsIE51bSwgU3RyIH0gZnJvbSBcIi4uL1ZhbHVlXCJcbmltcG9ydCB7IG51bSB9IGZyb20gXCIuLi9WZXJzaW9uZWRcIlxuaW1wb3J0IHsgU1ZHIH0gZnJvbSBcIi4vQ29yZVwiXG5pbXBvcnQgeyBFeHBsVmFsdWVDdXJzb3IgfSBmcm9tIFwiLi9DdXJzb3JcIlxuaW1wb3J0IHsgUG9pbnRJbnRlcmFjdG9yLCBSZWN0SW50ZXJhY3RvciB9IGZyb20gXCIuL0ludGVyYWN0b3JcIlxuaW1wb3J0IHsgUGFuZSB9IGZyb20gXCIuL1BhbmVcIlxuaW1wb3J0IHsgYm9yZGVyLCBjaXJjbGUsIGdyb3VwLCBsaW5lUm91bmRlZCwgbWFya2VyRW5zdXJlRGVmaW5lZCwgcG9seWxpbmUsIHJlY3QsIHN2Z0VsZW1lbnQsIHRleHRFbGVtZW50X2dyYXBoaWNhbCB9IGZyb20gXCIuL1JlbmRlcmVyXCJcblxuY29uc3QgZm9udFNpemU6IG51bWJlciA9IDEyXG5leHBvcnQgY29uc3Qgc3ZnOiBTVkcgPSBuZXcgU1ZHKClcblxudHlwZSBUcmFuc2Zvcm1GdW4gPSAoW3gsIHldOiBbbnVtYmVyLCBudW1iZXJdKSA9PiBbbnVtYmVyLCBudW1iZXJdXG5cbmZ1bmN0aW9uIHNjYWxlICh4X3NjYWxlOiBudW1iZXIsIHlfc2NhbGU6IG51bWJlcik6IFRyYW5zZm9ybUZ1biB7XG4gICByZXR1cm4gKFt4LCB5XSk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICAgICAgcmV0dXJuIFt4ICogeF9zY2FsZSwgeSAqIHlfc2NhbGVdXG4gICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSAoeF9pbmM6IG51bWJlciwgeV9pbmM6IG51bWJlcik6IFRyYW5zZm9ybUZ1biB7XG4gICByZXR1cm4gKFt4LCB5XSk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICAgICAgcmV0dXJuIFt4ICsgeF9pbmMsIHkgKyB5X2luY11cbiAgIH1cbn1cblxuZnVuY3Rpb24gaW52ZXJ0U2NhbGUgKHNjYWxlOiBUcmFuc2Zvcm1GdW4pOiBUcmFuc2Zvcm1GdW4ge1xuICAgcmV0dXJuIChbeCwgeV0pOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgIGNvbnN0IFt4X3NjYWxlLCB5X3NjYWxlXTogW251bWJlciwgbnVtYmVyXSA9IHNjYWxlKFsxLCAxXSlcbiAgICAgIHJldHVybiBbeCAvIHhfc2NhbGUsIHkgLyB5X3NjYWxlXVxuICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1GdW4gKHQ6IFRyYW5zZm9ybSk6IFRyYW5zZm9ybUZ1biB7XG4gICBpZiAodCBpbnN0YW5jZW9mIFNjYWxlKSB7XG4gICAgICBhc3NlcnQodC54LnZhbCA+PSAwICYmIHQueS52YWwgPj0gMClcbiAgICAgIHJldHVybiBzY2FsZSh0LngudmFsLCB0LnkudmFsKVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIFRyYW5zbGF0ZSkge1xuICAgICAgYXNzZXJ0KGlzRmluaXRlKHQueC52YWwpICYmIGlzRmluaXRlKHQueS52YWwpKVxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZSh0LngudmFsLCB0LnkudmFsKVxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgfVxufVxuXG5mdW5jdGlvbiBwb3N0Y29tcG9zZSAoZjE6IFRyYW5zZm9ybUZ1biwgZjI6IFRyYW5zZm9ybUZ1bik6IFRyYW5zZm9ybUZ1biB7XG4gICByZXR1cm4gKFt4LCB5XSk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICAgICAgcmV0dXJuIGYxKGYyKFt4LCB5XSkpXG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHcmFwaGljc1JlbmRlcmVyIHtcbiAgIGVkaXRvcjogUGFuZS5QYW5lXG4gICByb290OiBTVkdTVkdFbGVtZW50XG4gICBhbmNlc3RvcnM6IFNWR0VsZW1lbnRbXSAvLyBzdGFjayBvZiBlbmNsb3NpbmcgU1ZHIGVsZW1lbnRzXG4gICB0cmFuc2xhdGlvbnM6IFRyYW5zZm9ybUZ1bltdIC8vIHN0YWNrIG9mICh1bmNvbXBvc2VkKSBhY3RpdmUgdHJhbnNsYXRpb25zLCBlYWNoIHJlbGF0aXZlIHRvIHBhcmVudCBTVkdcbiAgIHNjYWxpbmdzOiBUcmFuc2Zvcm1GdW5bXSAvLyBzdGFjayBvZiBzdWNjZXNzaXZlbHkgY29tcG9zZWQgc2NhbGluZ3MsIGVhY2ggcmVsYXRpdmUgdG8gcm9vdCBTVkdcbiAgIHNob3dJbnZpc2libGU6IGJvb2xlYW4gPSBmYWxzZVxuXG4gICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIGlzbid0IHN1cHBvcnRlZCBvbiBTVkdFbGVtZW50LCBzbyBpdCBjb250YWlucyBhIGdyb3VwIGVsZW1lbnQgd2l0aCB0aGUgaW52ZXJzaW9uIHRyYW5zZm9ybS5cbiAgIGNvbnN0cnVjdG9yIChlZGl0b3I6IFBhbmUuUGFuZSwgcm9vdDogU1ZHU1ZHRWxlbWVudCwgaW5pdGlhbEFuY2VzdG9yOiBTVkdFbGVtZW50KSB7XG4gICAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgICAgdGhpcy5yb290ID0gcm9vdFxuICAgICAgdGhpcy5hbmNlc3RvcnMgPSBbaW5pdGlhbEFuY2VzdG9yXVxuICAgICAgdGhpcy50cmFuc2xhdGlvbnMgPSBbaWRdXG4gICAgICB0aGlzLnNjYWxpbmdzID0gW2lkXVxuICAgfVxuXG4gICBnZXQgY3VycmVudCAoKTogU1ZHRWxlbWVudCB7XG4gICAgICByZXR1cm4gdGhpcy5hbmNlc3RvcnNbdGhpcy5hbmNlc3RvcnMubGVuZ3RoIC0gMV1cbiAgIH1cblxuICAgLy8gc2NhbGluZyBhcHBsaWVzIHRvIHRyYW5zbGF0ZWQgY29vcmRpbmF0ZXNcbiAgIGdldCB0cmFuc2Zvcm0gKCk6IFRyYW5zZm9ybUZ1biB7XG4gICAgICByZXR1cm4gcG9zdGNvbXBvc2UodGhpcy5zY2FsZSwgbGFzdCh0aGlzLnRyYW5zbGF0aW9ucykpXG4gICB9XG5cbiAgIGdldCBzY2FsZSAoKTogVHJhbnNmb3JtRnVuIHtcbiAgICAgIHJldHVybiBsYXN0KHRoaXMuc2NhbGluZ3MpXG4gICB9XG5cbiAgIHJlbmRlciAodGc6IEV4cGxWYWx1ZTxHcmFwaGljc0VsZW1lbnQ+LCBbdywgaF06IFtudW1iZXIsIG51bWJlcl0pOiB2b2lkIHtcbiAgICAgIGFzc2VydCh0aGlzLmFuY2VzdG9ycy5sZW5ndGggPT09IDEpXG4gICAgICBjb25zdCByb290OiBTVkdFbGVtZW50ID0gdGhpcy5jdXJyZW50XG4gICAgICB3aGlsZSAocm9vdC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICByb290LnJlbW92ZUNoaWxkKHJvb3QuZmlyc3RDaGlsZClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoOiBudW1iZXIgPSBwYXJzZUZsb2F0KF9fbm9uTnVsbChyb290LmdldEF0dHJpYnV0ZShcIndpZHRoXCIpKSlcbiAgICAgIGNvbnN0IGhlaWdodDogbnVtYmVyID0gcGFyc2VGbG9hdChfX25vbk51bGwocm9vdC5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIikpKVxuICAgICAgdGhpcy53aXRoTG9jYWxGcmFtZShcbiAgICAgICAgIHNjYWxlKHdpZHRoIC8gdywgaGVpZ2h0IC8gaCksXG4gICAgICAgICBpZCxcbiAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRWxlbWVudChFeHBsVmFsdWVDdXJzb3IuZGVzY2VuZGFudChudWxsLCB0ZykpXG4gICAgICAgICB9XG4gICAgICApXG4gICB9XG5cbiAgIHJlbmRlckVsZW1lbnQgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxHcmFwaGljc0VsZW1lbnQ+Ki8pOiBTVkdFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IEdyYXBoaWNzRWxlbWVudCA9IGFzKHRnLnR2LnYsIEdyYXBoaWNzRWxlbWVudClcbiAgICAgIGlmIChnIGluc3RhbmNlb2YgQ2lyY2xlKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5jaXJjbGUodGcpXG4gICAgICB9IGVsc2UgXG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5ncm91cCh0ZylcbiAgICAgIH0gZWxzZSBcbiAgICAgIGlmIChnIGluc3RhbmNlb2YgTGluZSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMubGluZSh0ZylcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBQb2x5bGluZSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMucG9seWxpbmUodGcpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChnIGluc3RhbmNlb2YgUG9seW1hcmtlcnMpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnBvbHltYXJrZXJzKHRnKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIFJlY3QpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnJlY3QodGcpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChnIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCh0ZylcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBWaWV3cG9ydCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQodGcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIC8vIFNjYWxpbmdzIGFjY3VtdWxhdGUgYXMgd2UgZ28gZG93bi4gVHJhbnNsYXRpb25zIGRvbid0LCBiZWNhdXNlIHdlIHVzZSBuZXN0ZWQgU1ZHcy5cbiAgIHdpdGhMb2NhbEZyYW1lPFQ+IChzY2FsZTogVHJhbnNmb3JtRnVuLCB0cmFuc2xhdGU6IFRyYW5zZm9ybUZ1biwgbG9jYWxSZW5kZXI6ICgpID0+IFQpOiBUIHtcbiAgICAgIGxldCByZXN1bHQ6IFRcbiAgICAgIHRoaXMuc2NhbGluZ3MucHVzaChwb3N0Y29tcG9zZShsYXN0KHRoaXMuc2NhbGluZ3MpLCBzY2FsZSkpXG4gICAgICB0aGlzLnRyYW5zbGF0aW9ucy5wdXNoKHRyYW5zbGF0ZSlcbiAgICAgIHJlc3VsdCA9IGxvY2FsUmVuZGVyKClcbiAgICAgIHRoaXMudHJhbnNsYXRpb25zLnBvcCgpXG4gICAgICB0aGlzLnNjYWxpbmdzLnBvcCgpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICB9XG5cbiAgIC8vIFNjYWxlIGNpcmNsZSBieSBwcm9kdWN0IG9mIHgsIHkgc2NhbGluZyBmYWN0b3JzIHRvIG1haW50YWluIHJhdGlvIG9mIGFyZWEgdG8gZml4ZWQgcmVjdGFuZ2xlIGFzIGFuIGludmFyaWFudC5cbiAgIGNpcmNsZSAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPFJlY3Q+Ki8pOiBTVkdDaXJjbGVFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IENpcmNsZSA9IGFzKHRnLnR2LnYsIENpcmNsZSlcbiAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMudHJhbnNmb3JtKFtnLngudmFsLCBnLnkudmFsXSlcbiAgICAgIGNvbnN0IFt4X3NjYWxlLCB5X3NjYWxlXSA9IHRoaXMuc2NhbGUoWzEsIDFdKVxuICAgICAgY29uc3QgcjogU1ZHQ2lyY2xlRWxlbWVudCA9IGNpcmNsZSh4LCB5LCBnLnJhZGl1cy52YWwgKiB4X3NjYWxlICogeV9zY2FsZSwgXCJub25lXCIsIGcuZmlsbC52YWwsIHRoaXMuY2lyY2xlKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKHIpXG4gICAgICByZXR1cm4gclxuICAgfVxuXG4gICBncm91cCAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPEdyb3VwPiovKTogU1ZHR0VsZW1lbnQge1xuICAgICAgY29uc3QgZzogU1ZHR0VsZW1lbnQgPSBncm91cCgpXG4gICAgICB0aGlzLmN1cnJlbnQuYXBwZW5kQ2hpbGQoZylcbiAgICAgIHRoaXMuYW5jZXN0b3JzLnB1c2goZylcbiAgICAgIGZvciAobGV0IHRnzIU6IEV4cGxWYWx1ZUN1cnNvci8qPExpc3Q8R3JhcGhpY3NFbGVtZW50Pj4qLyA9IHRnLnRvKEdyb3VwLCBcImdzXCIpOyBcbiAgICAgICAgICAgQ29ucy5pcyhhcyh0Z8yFLnR2LnYsIExpc3QpKTsgdGfMhSA9IHRnzIUudG8oQ29ucywgXCJ0YWlsXCIpKSB7XG4gICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnQodGfMhS50byhDb25zLCBcImhlYWRcIikpXG4gICAgICB9XG4gICAgICB0aGlzLmFuY2VzdG9ycy5wb3AoKVxuICAgICAgcmV0dXJuIGdcbiAgIH1cblxuICAgLy8gRm9yIGxpbmUvcG9seWxpbmUsIGVhY2ggcG9pbnQgaXMgY29uc2lkZXJlZCBhIFwiY2hpbGRcIiwgYW5kIHRoZXJlZm9yZSBzdWJqZWN0IHRvIG15IGxvY2FsIHNjYWxpbmcuXG4gICBsaW5lICh0ZzogRXhwbFZhbHVlQ3Vyc29yLyo8UG9seWxpbmU+Ki8pOiBTVkdMaW5lRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBMaW5lID0gYXModGcudHYudiwgTGluZSlcbiAgICAgIGNvbnN0IFtbeDEsIHkxXSwgW3gyLCB5Ml1dID0gW1xuICAgICAgICAgdGhpcy50cmFuc2Zvcm0oW2cucDEueC52YWwsIGcucDEueS52YWxdKSwgXG4gICAgICAgICB0aGlzLnRyYW5zZm9ybShbZy5wMi54LnZhbCwgZy5wMi55LnZhbF0pXG4gICAgICBdXG4gICAgICBjb25zdCBsOiBTVkdMaW5lRWxlbWVudCA9IGxpbmVSb3VuZGVkKHgxLCB5MSwgeDIsIHkyLCBnLnN0cm9rZS52YWwsIGcuc3Ryb2tlV2lkdGgudmFsKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKGwpXG4gICAgICByZXR1cm4gbFxuICAgfVxuXG4gICBwb2x5bGluZSAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPFBvbHlsaW5lPiovKTogU1ZHUG9seWxpbmVFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IFBvbHlsaW5lID0gYXModGcudHYudiwgUG9seWxpbmUpXG4gICAgICBjb25zdCBwczogW251bWJlciwgbnVtYmVyXVtdID0gZy5wb2ludHMudG9BcnJheSgpLm1hcCgocDogUG9pbnQpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShbcC54LnZhbCwgcC55LnZhbF0pXG4gICAgICB9KVxuICAgICAgY29uc3QgbDogU1ZHUG9seWxpbmVFbGVtZW50ID0gcG9seWxpbmUocHMsIGcuc3Ryb2tlLnZhbCwgZy5zdHJva2VXaWR0aC52YWwpXG4gICAgICB0aGlzLmN1cnJlbnQuYXBwZW5kQ2hpbGQobClcbiAgICAgIHJldHVybiBsXG4gICB9XG5cbiAgIC8vIFBvbHltYXJrZXJzIGhhdmUgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHBvaW50cywgaW4gdGhlICpwYXJlbnQqIHNjYWxpbmcuXG4gICBwb2x5bWFya2VycyAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPFBvbHltYXJrZXJzPiovKTogU1ZHR0VsZW1lbnQge1xuICAgICAgY29uc3QgZzogU1ZHR0VsZW1lbnQgPSBncm91cCgpXG4gICAgICB0aGlzLmN1cnJlbnQuYXBwZW5kQ2hpbGQoZylcbiAgICAgIHRoaXMuYW5jZXN0b3JzLnB1c2goZylcbiAgICAgIGNvbnN0IGludlNjYWxlOiBUcmFuc2Zvcm1GdW4gPSBpbnZlcnRTY2FsZSh0aGlzLnNjYWxlKVxuICAgICAgZm9yIChsZXQgdGfMhTogRXhwbFZhbHVlQ3Vyc29yLyo8TGlzdDxHcmFwaGljc0VsZW1lbnQ+PiovID0gdGcudG8oUG9seW1hcmtlcnMsIFwibWFya2Vyc1wiKSxcbiAgICAgICAgICAgICAgIHRwczogRXhwbFZhbHVlQ3Vyc29yLyo8TGlzdDxQb2ludD4qLyA9IHRnLnRvKFBvbHltYXJrZXJzLCBcInBvaW50c1wiKTsgXG4gICAgICAgICAgIENvbnMuaXMoYXModGfMhS50di52LCBMaXN0KSkgfHwgQ29ucy5pcyhhcyh0cHMudHYudiwgTGlzdCkpOyBcbiAgICAgICAgICAgdGfMhSA9IHRnzIUudG8oQ29ucywgXCJ0YWlsXCIpLCB0cHMgPSB0cHMudG8oQ29ucywgXCJ0YWlsXCIpKSB7XG4gICAgICAgICBpZiAoIUNvbnMuaXMoYXModGfMhS50di52LCBMaXN0KSkgfHwgIUNvbnMuaXMoYXModHBzLnR2LnYsIExpc3QpKSkge1xuICAgICAgICAgICAgdXNlckVycm9yKGAke1BvbHltYXJrZXJzLm5hbWV9OiBtb3JlIG1hcmtlcnMgdGhhbiBwb2ludHMuYClcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0cDogRXhwbFZhbHVlQ3Vyc29yLyo8UG9pbnQ+Ki8gPSB0cHMudG8oQ29ucywgXCJoZWFkXCIpXG4gICAgICAgICAgICBjb25zdCBwOiBQb2ludCA9IGFzKHRwLnR2LnYsIFBvaW50KVxuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy50cmFuc2Zvcm0oW3AueC52YWwsIHAueS52YWxdKVxuICAgICAgICAgICAgY29uc3QgbWFya2VyVmlld3BvcnQ6IFNWR1NWR0VsZW1lbnQgPSBzdmdFbGVtZW50KHRydWUsIHgsIHksIDEwLCAxMCwgZmFsc2UsIHRoaXMucG9seW1hcmtlcnMpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYXBwZW5kQ2hpbGQobWFya2VyVmlld3BvcnQpXG4gICAgICAgICAgICB0aGlzLmFuY2VzdG9ycy5wdXNoKG1hcmtlclZpZXdwb3J0KVxuICAgICAgICAgICAgdGhpcy53aXRoTG9jYWxGcmFtZShcbiAgICAgICAgICAgICAgIGludlNjYWxlLFxuICAgICAgICAgICAgICAgaWQsIFxuICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWFya2VyOiBTVkdFbGVtZW50ID0gdGhpcy5yZW5kZXJFbGVtZW50KHRnzIUudG8oQ29ucywgXCJoZWFkXCIpKVxuICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlciBpbnN0YW5jZW9mIFNWR0NpcmNsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBQb2ludEludGVyYWN0b3IodGhpcy5lZGl0b3IsIHRwLCBtYXJrZXIpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLmFuY2VzdG9ycy5wb3AoKVxuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbmNlc3RvcnMucG9wKClcbiAgICAgIHJldHVybiBnXG4gICB9XG5cbiAgIHJlY3QgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxSZWN0PiovKTogU1ZHUmVjdEVsZW1lbnQge1xuICAgICAgY29uc3QgZzogUmVjdCA9IGFzKHRnLnR2LnYsIFJlY3QpXG4gICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLnRyYW5zZm9ybShbZy54LnZhbCwgZy55LnZhbF0pXG4gICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnNjYWxlKFtnLndpZHRoLnZhbCwgZy5oZWlnaHQudmFsXSlcbiAgICAgIGFzc2VydCh3aWR0aCA+PSAwICYmIGhlaWdodCA+PSAwKVxuICAgICAgY29uc3QgcjogU1ZHUmVjdEVsZW1lbnQgPSByZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIFwibm9uZVwiLCBnLmZpbGwudmFsLCB0aGlzLnJlY3QpXG4gICAgICBuZXcgUmVjdEludGVyYWN0b3IodGhpcy5lZGl0b3IsIHRnLCByKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKHIpXG4gICAgICByZXR1cm4gclxuICAgfVxuXG4gICB0ZXh0ICh0ZzogRXhwbFZhbHVlQ3Vyc29yLyo8VGV4dD4qLyk6IFNWR1RleHRFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IFRleHQgPSBhcyh0Zy50di52LCBUZXh0KSxcbiAgICAgICAgICAgIFt4LCB5XTogW251bWJlciwgbnVtYmVyXSA9IHRoaXMudHJhbnNmb3JtKFtnLngudmFsLCBnLnkudmFsXSksXG4gICAgICAgICAgICB0OiBTVkdUZXh0RWxlbWVudCA9IHRleHRFbGVtZW50X2dyYXBoaWNhbCh4LCB5LCBmb250U2l6ZSwgZy5zdHIudmFsKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKHQpXG4gICAgICB0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJibGFja1wiKVxuICAgICAgdC5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLCBgJHtnLmFuY2hvci52YWx9YClcbiAgICAgIHQuc2V0QXR0cmlidXRlKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIGAke2cuYmFzZWxpbmUudmFsfWApXG4gICAgICByZXR1cm4gdFxuICAgfVxuXG4gICB2aWV3cG9ydCAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPFZpZXdwb3J0PiovKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBWaWV3cG9ydCA9IGFzKHRnLnR2LnYsIFZpZXdwb3J0KVxuICAgICAgLy8gZGltZW5zaW9ucyBhcmUgcmVsYXRpdmUgdG8gcGFyZW50IGNvb3JkaW5hdGUgc3BhY2UsIHNvIG5vdCB0cmFuc2Zvcm1lZCBieSBnJ3Mgc2NhbGluZ1xuICAgICAgY29uc3QgW3gsIHldID0gdGhpcy50cmFuc2Zvcm0oW2cueC52YWwsIGcueS52YWxdKVxuICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5zY2FsZShbZy53aWR0aC52YWwsIGcuaGVpZ2h0LnZhbF0pXG4gICAgICBhc3NlcnQod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMClcbiAgICAgIGNvbnN0IG91dGVyU3ZnOiBTVkdTVkdFbGVtZW50ID0gc3ZnRWxlbWVudChmYWxzZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmFsc2UsIHRoaXMudmlld3BvcnQpXG4gICAgICBpZiAoZy5maWxsLnZhbCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgIG91dGVyU3ZnLmFwcGVuZENoaWxkKHJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCwgXCJub25lXCIsIGcuZmlsbC52YWwsIHRoaXMudmlld3BvcnQpKVxuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKG91dGVyU3ZnKVxuICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZSkge1xuICAgICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKGJvcmRlcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBcImdyYXlcIiwgdHJ1ZSkpXG4gICAgICB9XG4gICAgICB0aGlzLmFuY2VzdG9ycy5wdXNoKG91dGVyU3ZnKVxuICAgICAgY29uc3QgbWFyZ2luOiBudW1iZXIgPSBnLm1hcmdpbi52YWxcbiAgICAgIGNvbnN0IFt3aWR0aMq5LCBoZWlnaHTKuV06IFtudW1iZXIsIG51bWJlcl0gPSBbTWF0aC5tYXgod2lkdGggLSBtYXJnaW4gKiAyKSwgaGVpZ2h0IC0gbWFyZ2luICogMl1cbiAgICAgIGNvbnN0IGlubmVyU2NhbGU6IFRyYW5zZm9ybUZ1biA9IChbeCwgeV06IFtudW1iZXIsIG51bWJlcl0pID0+IHtcbiAgICAgICAgIHJldHVybiBbeCAqIHdpZHRoyrkgLyB3aWR0aCwgeSAqIGhlaWdodMq5IC8gaGVpZ2h0XVxuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJWaWV3cG9ydDogU1ZHU1ZHRWxlbWVudCA9IHN2Z0VsZW1lbnQodHJ1ZSwgbWFyZ2luLCBtYXJnaW4sIHdpZHRoyrksIGhlaWdodMq5LCBmYWxzZSwgdGhpcy52aWV3cG9ydClcbiAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZChpbm5lclZpZXdwb3J0KVxuICAgICAgdGhpcy5hbmNlc3RvcnMucHVzaChpbm5lclZpZXdwb3J0KVxuICAgICAgdGhpcy53aXRoTG9jYWxGcmFtZShcbiAgICAgICAgIHBvc3Rjb21wb3NlKGlubmVyU2NhbGUsIHRyYW5zZm9ybUZ1bihnLnNjYWxlKSksXG4gICAgICAgICB0cmFuc2Zvcm1GdW4oZy50cmFuc2xhdGUpLFxuICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50KHRnLnRvKFZpZXdwb3J0LCBcImdcIikpXG4gICAgICAgICB9XG4gICAgICApXG4gICAgICB0aGlzLmFuY2VzdG9ycy5wb3AoKVxuICAgICAgdGhpcy5hbmNlc3RvcnMucG9wKClcbiAgICAgIHJldHVybiBvdXRlclN2Z1xuICAgfVxuXG4gICBzZXRNYXJrZXJNaWQgKGVsOiBTVkdFbGVtZW50LCBDOiBDbGFzczxNYXJrZXI+LCBjb2xvdXI6IHN0cmluZyk6IHZvaWQge1xuICAgICAgY29uc3QgbWFya2VySWQ6IHN0cmluZyA9IG1hcmtlckVuc3VyZURlZmluZWQodGhpcy5yb290LCBDLCBjb2xvdXIpIC8vIHJldmlzaXQgY2FzdFxuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibWFya2VyLW1pZFwiLCBgdXJsKCMke21hcmtlcklkfSlgKVxuICAgfVxufVxuXG57XG4gICAvLyBBZGRpdGlvbmFsIHByaW1pdGl2ZXMgdGhhdCByZWx5IG9uIG9mZmxpbmUgcmVuZGVyaW5nIHRvIGNvbXB1dGUgdGV4dCBtZXRyaWNzLiBDb21iaW5pbmcgdGhlc2Ugd291bGQgXG4gICAvLyByZXF1aXJlIG1vcmUgZ2VuZXJhbCBwcmltaXRpdmVzIHRoYXQgY2FuIHJldHVybiB0dXBsZXMuXG4gICBjb25zdCB0ZXh0V2lkdGg6IFVuYXJ5PFN0ciwgTnVtPiA9IChzdHI6IFN0cik6IChrOiBJZCkgPT4gTnVtID0+IHtcbiAgICAgIHJldHVybiBudW0oc3ZnLnRleHRXaWR0aCh0ZXh0RWxlbWVudF9ncmFwaGljYWwoMCwgMCwgZm9udFNpemUsIHN0ci52YWwpKSlcbiAgIH1cbiAgIFxuICAgY29uc3QgdGV4dEhlaWdodDogVW5hcnk8U3RyLCBOdW0+ID0gKHN0cjogU3RyKTogKGs6IElkKSA9PiBOdW0gPT4ge1xuICAgICAgcmV0dXJuIG51bShzdmcudGV4dEhlaWdodCh0ZXh0RWxlbWVudF9ncmFwaGljYWwoMCwgMCwgZm9udFNpemUsIHN0ci52YWwpKSlcbiAgIH1cbiAgIFxuICAgdW5hcnlPcHMuc2V0KHRleHRXaWR0aC5uYW1lLCB1bmFyeV8odGV4dFdpZHRoKSlcbiAgIHVuYXJ5T3BzLnNldCh0ZXh0SGVpZ2h0Lm5hbWUsIHVuYXJ5Xyh0ZXh0SGVpZ2h0KSlcbn1cbiIsImltcG9ydCB0aXBweSBmcm9tIFwidGlwcHkuanNcIlxuaW1wb3J0IHsgSW5zdGFuY2UgYXMgVG9vbHRpcCwgUGxhY2VtZW50IH0gZnJvbSBcInRpcHB5LmpzXCJcbmltcG9ydCBcInRpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzXCJcbmltcG9ydCBcInRpcHB5LmpzL3RoZW1lcy9saWdodC1ib3JkZXIuY3NzXCJcbmltcG9ydCB7IENsYXNzLCBfX2xvZywgX19ub25OdWxsLCBhcyB9IGZyb20gXCIuLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgYm9vbF8gfSBmcm9tIFwiLi4vdXRpbC9MYXR0aWNlXCJcbmltcG9ydCB7IERpcmVjdGlvbiwgaXPOsSwgc2V0zrEgfSBmcm9tIFwiLi4vQW5ub3RhdGlvblwiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSB9IGZyb20gXCIuLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuLi9FeHBsXCJcbmltcG9ydCB7IFBvaW50LCBSZWN0IH0gZnJvbSBcIi4uL0dyYXBoaWNzXCJcbmltcG9ydCB7IE51bSwgUGVyc2lzdGVudCwgU3RyLCBmaWVsZHMgfSBmcm9tIFwiLi4vVmFsdWVcIlxuaW1wb3J0IHsgRXhwbFZhbHVlQ3Vyc29yIH0gZnJvbSBcIi4vQ3Vyc29yXCJcbmltcG9ydCB7IFBhbmUgfSBmcm9tIFwiLi9QYW5lXCJcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4vUmVuZGVyZXJcIlxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwIChlbGVtZW50OiBTVkdFbGVtZW50LCBwbGFjZW1lbnQ6IFBsYWNlbWVudCk6IFRvb2x0aXAge1xuICAgcmV0dXJuIHRpcHB5KGVsZW1lbnQsIHsgdGhlbWU6IFwibGlnaHQtYm9yZGVyXCIsIHBsYWNlbWVudCB9KVxufVxuXG5hYnN0cmFjdCBjbGFzcyBJbnRlcmFjdG9yPFQgZXh0ZW5kcyBEYXRhVmFsdWUsIFUgZXh0ZW5kcyBTVkdFbGVtZW50PiB7XG4gICBlZGl0b3I6IFBhbmUuUGFuZVxuICAgQzogQ2xhc3M8VD5cbiAgIHRvb2x0aXA6IFRvb2x0aXBcbiAgIGN1cnNvcjogRXhwbFZhbHVlQ3Vyc29yLyo8UGFpcjxOdW0sIE51bT4+Ki9cbiAgIGVsZW1lbnQ6IFVcbiAgIHByb3BGb2N1czoga2V5b2YgVCB8IG51bGwgPSBudWxsXG5cbiAgIGNvbnN0cnVjdG9yIChlZGl0b3I6IFBhbmUuUGFuZSwgQzogQ2xhc3M8VD4sIGN1cnNvcjogRXhwbFZhbHVlQ3Vyc29yLyo8UGFpcjxOdW0sIE51bT4+Ki8sIGVsZW1lbnQ6IFUpIHtcbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgICB0aGlzLkMgPSBDXG4gICAgICB0aGlzLnRvb2x0aXAgPSBjcmVhdGVUb29sdGlwKGVsZW1lbnQsIGVkaXRvci50b29sdGlwUGxhY2VtZW50KVxuICAgICAgdGhpcy5lZGl0b3IudG9vbHRpcHMuYWRkKHRoaXMudG9vbHRpcClcbiAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgICBjb25zdCBwOiBUID0gYXMoY3Vyc29yLnR2LnYsIEMpXG4gICAgICBjb25zdCBwcm9wc0ZvY3VzOiAoa2V5b2YgVClbXSA9IHRoaXMuZm9jdXNlZFByb3BzKGN1cnNvci50diBhcyBFeHBsVmFsdWU8VD4pXG4gICAgICBpZiAocHJvcHNGb2N1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICB0aGlzLnRvb2x0aXAuc2V0Q29udGVudCh0aGlzLnByb3BWYWx1ZXMocCwgcHJvcHNGb2N1cykpXG4gICAgICAgICB0aGlzLnRvb2x0aXAuc2hvdygpXG4gICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJmb2N1c1wiKVxuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIChlOiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpXG4gICAgICB9KVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKGU6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgIHRoaXMub25Nb3VzZU91dChlKVxuICAgICAgfSlcbiAgIH1cblxuICAgLy8gTm9uLXByaW1pdGl2ZSBkZXBlbmRlbmNpZXMgcmVuZGVyIGFzIGEgYnVsbGV0LlxuICAgcHJvcFZhbHVlcyAoZzogVCwgcHJvcHM6IChrZXlvZiBUKVtdKTogc3RyaW5nIHtcbiAgICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IHByb3BzLm1hcCgocHJvcDoga2V5b2YgVCk6IHN0cmluZyA9PiB7XG4gICAgICAgICBjb25zdCBwcm9wVmFsOiBQZXJzaXN0ZW50ID0gZy5fX2NoaWxkKHByb3ApXG4gICAgICAgICBjb25zdCBwcm9wU3RyOiBzdHJpbmcgPSBwcm9wVmFsIGluc3RhbmNlb2YgTnVtID8gXG4gICAgICAgICAgICAgICByb3VuZChwcm9wVmFsLnZhbCkgOlxuICAgICAgICAgICAgICAgcHJvcFZhbCBpbnN0YW5jZW9mIFN0ciA/IFxuICAgICAgICAgICAgICAgICAgcHJvcFZhbC52YWwgOiBcIuKAolwiXG4gICAgICAgICByZXR1cm4gYCR7cHJvcH06ICR7cHJvcFN0cn1gXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCI8L2JyPlwiKVxuICAgfVxuXG4gICBmb2N1c2VkUHJvcHM8VCBleHRlbmRzIERhdGFWYWx1ZT4gKHR2OiBFeHBsVmFsdWU8VD4pOiAoa2V5b2YgVClbXSB7XG4gICAgICByZXR1cm4gZmllbGRzKHR2LnYpLmZpbHRlcigocHJvcDoga2V5b2YgVCkgPT4ge1xuICAgICAgICAgY29uc3QgdHZfOiBFeHBsVmFsdWUgPSBFeHBsLmV4cGxDaGlsZCh0di50LCB0di52LCBwcm9wKVxuICAgICAgICAgcmV0dXJuIF9fbm9uTnVsbCh0aGlzLmVkaXRvci5kaXJlY3Rpb24pID09PSBEaXJlY3Rpb24uRndkID8gYm9vbF8ubmVnYXRlKGlzzrEodHZfKSkgOiBpc86xKHR2XylcbiAgICAgIH0pXG4gICB9XG5cbiAgIGFic3RyYWN0IHByb3BGb3IgKHhfcHJvcDogbnVtYmVyLCB5X3Byb3A6IG51bWJlcik6IGtleW9mIFRcblxuICAgb25Nb3VzZU1vdmUgKGU6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHY6IFQgPSBhcyh0aGlzLmN1cnNvci50di52LCB0aGlzLkMpXG4gICAgICBjb25zdCByZWN0OiBDbGllbnRSZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAvLyBpbnZlcnQgc2lnbiBvbiB5IGF4aXMgYmVjYXVzZSBvZiBnbG9iYWwgaW52ZXJzaW9uIGZvciBTVkcgZ3JhcGhpY3NcbiAgICAgIGNvbnN0IHhfcHJvcDogbnVtYmVyID0gTWF0aC5tYXgoZS5jbGllbnRYIC0gcmVjdC5sZWZ0LCAwKSAvIHJlY3Qud2lkdGhcbiAgICAgIGNvbnN0IHlfcHJvcDogbnVtYmVyID0gTWF0aC5taW4ocmVjdC5ib3R0b20gLSBlLmNsaWVudFksIHJlY3QuaGVpZ2h0KSAvIHJlY3QuaGVpZ2h0XG4gICAgICBjb25zdCBwcm9wRm9jdXM6IGtleW9mIFQgPSB0aGlzLnByb3BGb3IoeF9wcm9wLCB5X3Byb3ApXG4gICAgICBpZiAodGhpcy5wcm9wRm9jdXMgIT09IHByb3BGb2N1cykge1xuICAgICAgICAgdGhpcy5wcm9wRm9jdXMgPSBwcm9wRm9jdXNcbiAgICAgICAgIHRoaXMuZWRpdG9yLmJ3ZFNsaWNlKCgpID0+IHtcbiAgICAgICAgICAgIHNldM6xKGJvb2xfLnRvcCwgdGhpcy5jdXJzb3IudG8odGhpcy5DLCBwcm9wRm9jdXMpLnR2KVxuICAgICAgICAgfSlcbiAgICAgICAgIHRoaXMudG9vbHRpcC5zZXRDb250ZW50KHRoaXMucHJvcFZhbHVlcyh2LCBbcHJvcEZvY3VzXSkpXG4gICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZvY3VzXCIpXG4gICAgICB9XG4gICB9XG5cbiAgIG9uTW91c2VPdXQgKGU6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgIHRoaXMucHJvcEZvY3VzID0gbnVsbFxuICAgICAgdGhpcy5lZGl0b3IuYndkU2xpY2UoKCkgPT4ge30pXG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImZvY3VzXCIpXG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb2ludEludGVyYWN0b3IgZXh0ZW5kcyBJbnRlcmFjdG9yPFBvaW50LCBTVkdFbGVtZW50PiB7XG4gICBjb25zdHJ1Y3RvciAoZWRpdG9yOiBQYW5lLlBhbmUsIHRwOiBFeHBsVmFsdWVDdXJzb3IvKjxQb2ludD4qLywgbWFya2VyOiBTVkdFbGVtZW50KSB7XG4gICAgICBzdXBlcihlZGl0b3IsIFBvaW50LCB0cCwgbWFya2VyKVxuICAgfVxuXG4gICBwcm9wRm9yICh4X3Byb3A6IG51bWJlciwgeV9wcm9wOiBudW1iZXIpOiBrZXlvZiBQb2ludCB7XG4gICAgICByZXR1cm4gXCJ5XCJcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlY3RJbnRlcmFjdG9yIGV4dGVuZHMgSW50ZXJhY3RvcjxSZWN0LCBTVkdSZWN0RWxlbWVudD4ge1xuICAgY29uc3RydWN0b3IgKGVkaXRvcjogUGFuZS5QYW5lLCB0ZzogRXhwbFZhbHVlQ3Vyc29yLyo8UmVjdD4qLywgcjogU1ZHUmVjdEVsZW1lbnQpIHtcbiAgICAgIHN1cGVyKGVkaXRvciwgUmVjdCwgdGcsIHIpXG4gICB9XG5cbiAgIC8vIERldGVybWluZSB3aGljaCBcImRpYWdvbmFsIHF1YWRyYW50XCIgb2YgdGhlIHVuaXQgc3F1YXJlIFsxLCAxXSBjb250YWlucyBbeCwgeV0sIGFuZFxuICAgLy8gdGhlbiBtYXAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIG9mIHRoZSByZWN0YW5nbGUuXG4gICBwcm9wRm9yICh4OiBudW1iZXIsIHk6IG51bWJlcik6IGtleW9mIFJlY3Qge1xuICAgICAgY29uc3QgY29ybmVyOiBba2V5b2YgUmVjdCwga2V5b2YgUmVjdF0gPSB5ID4geCA/IFtcInhcIiwgXCJoZWlnaHRcIl0gOiBbXCJ5XCIsIFwid2lkdGhcIl1cbiAgICAgIHJldHVybiB5IDwgMSAtIHggPyBjb3JuZXJbMF0gOiBjb3JuZXJbMV1cbiAgIH1cbn1cbiIsImltcG9ydCB7IEluc3RhbmNlIGFzIFRvb2x0aXAsIFBsYWNlbWVudCB9IGZyb20gXCJ0aXBweS5qc1wiXG5pbXBvcnQgeyBfX25vbk51bGwsIGFzIH0gZnJvbSBcIi4uL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBEaXJlY3Rpb24sIFNsaWNlLCBfX3NsaWNlIH0gZnJvbSBcIi4uL0Fubm90YXRpb25cIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUsIGV4cGxWYWx1ZSB9IGZyb20gXCIuLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgX19kZWx0YXMgfSBmcm9tIFwiLi4vRGVsdGFcIlxuaW1wb3J0IHsgRW52IH0gZnJvbSBcIi4uL0VudlwiXG5pbXBvcnQgeyBFdmFsIH0gZnJvbSBcIi4uL0V2YWxcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuLi9FeHBsXCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi4vRXhwclwiXG5pbXBvcnQgeyBBcnJvd2hlYWQgfSBmcm9tIFwiLi4vR3JhcGhpY3NcIlxuaW1wb3J0IHsgbmV3UmV2aXNpb24gfSBmcm9tIFwiLi4vVmVyc2lvbmVkXCJcbmltcG9ydCB7IEV4cGxWYWx1ZUN1cnNvciB9IGZyb20gXCIuL0N1cnNvclwiXG5pbXBvcnQgeyBtYXJrZXJFbnN1cmVEZWZpbmVkLCBzdmdSb290RWxlbWVudCB9IGZyb20gXCIuL1JlbmRlcmVyXCJcbmltcG9ydCB7IFZpZXcgfSBmcm9tIFwiLi9WaWV3XCJcbmltcG9ydCBcIi4vc3R5bGVzLmNzc1wiXG5cbi8vIFByZXZpb3VzbHkgRWRpdG9yLCBidXQgY2xhc2hlcyBhIGJpdCB3aXRoIHRoZSBXcmF0dGxlciBjbGFzcyBvZiB0aGUgc2FtZSBuYW1lLlxuZXhwb3J0IG1vZHVsZSBQYW5lIHtcbiAgIGV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXNlICgpOiB2b2lkIHtcbiAgICAgIFZpZXcuaW5pdGlhbGlzZSgpXG4gICB9XG5cbiAgIGV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAgICAgb25Cd2RTbGljZSAoZWRpdG9yOiBQYW5lLCBleHRlcm5EZXBzOiBTbGljZSk6IHZvaWRcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFBhbmUge1xuICAgICAgbGlzdGVuZXI6IExpc3RlbmVyXG4gICAgICByb290UGFuZTogU1ZHU1ZHRWxlbWVudFxuICAgICAgdG9vbHRpcHM6IFNldDxUb29sdGlwPlxuICAgICAgdG9vbHRpcFBsYWNlbWVudDogUGxhY2VtZW50IC8vIG1ha2UgZm9yIG5pY2VyIGV4YW1wbGVzXG4gICAgICDPgV9leHRlcm5hbDogRW52XG4gICAgICDPgV9pbXBvcnRzOiBFbnZcbiAgICAgIGU6IEV4cHJcbiAgICAgIHR2OiBFeHBsVmFsdWVcbiAgICAgIGhlcmUhOiBFeHBsVmFsdWVDdXJzb3JcbiAgICAgIGRpcmVjdGlvbjogRGlyZWN0aW9uXG4gICAgICBzbGljZTogU2xpY2UgPSBuZXcgU2V0KClcbiAgIFxuICAgICAgY29uc3RydWN0b3IgKFxuICAgICAgICAgbGlzdGVuZXI6IExpc3RlbmVyLCBcbiAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XTogW251bWJlciwgbnVtYmVyXSwgXG4gICAgICAgICB0b29sdGlwUGxhY2VtZW50OiBQbGFjZW1lbnQsIFxuICAgICAgICAgz4FfZXh0ZXJuYWw6IEVudiwgXG4gICAgICAgICDPgV9pbXBvcnRzOiBFbnYsXG4gICAgICAgICBlOiBFeHByXG4gICAgICApIHtcbiAgICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lclxuICAgICAgICAgdGhpcy5yb290UGFuZSA9IHN2Z1Jvb3RFbGVtZW50KHdpZHRoLCBoZWlnaHQpXG4gICAgICAgICB0aGlzLnRvb2x0aXBzID0gbmV3IFNldCgpXG4gICAgICAgICB0aGlzLnRvb2x0aXBQbGFjZW1lbnQgPSB0b29sdGlwUGxhY2VtZW50XG4gICAgICAgICBtYXJrZXJFbnN1cmVEZWZpbmVkKHRoaXMucm9vdFBhbmUsIEFycm93aGVhZCwgXCJibHVlXCIpXG4gICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucm9vdFBhbmUpXG4gICAgICAgICB0aGlzLs+BX2V4dGVybmFsID0gz4FfZXh0ZXJuYWxcbiAgICAgICAgIHRoaXMuz4FfaW1wb3J0cyA9IM+BX2ltcG9ydHNcbiAgICAgICAgIHRoaXMuZSA9IGVcbiAgICAgICAgIC8vIGV2YWx1YXRlIHR3aWNlIHNvIHdlIGNhbiBzdGFydCB3aXRoIGFuIGVtcHR5IGRlbHRhXG4gICAgICAgICB0aGlzLnR2ID0gRXZhbC5ldmFsXyh0aGlzLs+BLCB0aGlzLmUpXG4gICAgICAgICB0aGlzLmhlcmUgPSBFeHBsVmFsdWVDdXJzb3IuZGVzY2VuZGFudChudWxsLCB0aGlzLnR2KVxuICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uRndkXG4gICAgICAgICBuZXdSZXZpc2lvbigpXG4gICAgICAgICBFdmFsLmV2YWxfKHRoaXMuz4EsIHRoaXMuZSkgLy8gcmVlc3RhYmxpc2ggcmVhY2hhYmxlIG5vZGVzXG4gICAgICB9XG5cbiAgICAgIGdldCDPgSAoKTogRW52IHtcbiAgICAgICAgIHJldHVybiB0aGlzLs+BX2V4dGVybmFsLmNvbmNhdCh0aGlzLs+BX2ltcG9ydHMpXG4gICAgICB9XG5cbiAgICAgIHZpc2libGVUb29sdGlwcyAoKTogVG9vbHRpcFtdIHtcbiAgICAgICAgIHJldHVybiBbLi4udGhpcy50b29sdGlwc10uZmlsdGVyKHRvb2x0aXAgPT4gdG9vbHRpcC5zdGF0ZS5pc1Zpc2libGUpXG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2UgKCk6IHZvaWQge1xuICAgICAgICAgdGhpcy5yZW5kZXIoKVxuICAgICAgICAgY29uc3QgdGhpc186IHRoaXMgPSB0aGlzXG4gICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTk3MDYwXG4gICAgICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSBmdW5jdGlvbiAoZXY6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMzcpIHsgLy8gbGVmdFxuICAgICAgICAgICAgICAgICAgdGhpc18uaGVyZSA9IHRoaXNfLmhlcmUucHJldlNpYmxpbmcoKVxuICAgICAgICAgICAgICAgICAgdGhpc18ucmVuZGVyKClcbiAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMzgpIHsgLy8gdXBcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzXy5oZXJlLmhhc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICB0aGlzXy5oZXJlID0gdGhpc18uaGVyZS51cCgpXG4gICAgICAgICAgICAgICAgICAgICB0aGlzXy5yZW5kZXIoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PSAzOSkgeyAvLyByaWdodFxuICAgICAgICAgICAgICAgICAgdGhpc18uaGVyZSA9IHRoaXNfLmhlcmUubmV4dFNpYmxpbmcoKVxuICAgICAgICAgICAgICAgICAgdGhpc18ucmVuZGVyKClcbiAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gNDApIHsgLy8gZG93blxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfLmhlcmUudHYudiBpbnN0YW5jZW9mIERhdGFWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgdGhpc18uaGVyZSA9IHRoaXNfLmhlcmUudG9DaGlsZCgwKVxuICAgICAgICAgICAgICAgICAgICAgdGhpc18ucmVuZGVyKClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGRvY3VtZW50Lm9ua2V5cHJlc3MgPSBmdW5jdGlvbiAoZXY6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gXCJWXCIpIHtcbiAgICAgICAgICAgICAgICAgIFZpZXcuZXhpc3RpbmdWaWV3KHRoaXNfLmhlcmUudHYpLnRvZ2dsZVZhbHVlKClcbiAgICAgICAgICAgICAgICAgIHRoaXNfLnJlbmRlcigpXG4gICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgIGlmIChldi5rZXkgPT09IFwiRVwiKSB7XG4gICAgICAgICAgICAgICAgICBWaWV3LmV4aXN0aW5nVmlldyh0aGlzXy5oZXJlLnR2KS50b2dnbGVFeHBsKClcbiAgICAgICAgICAgICAgICAgIHRoaXNfLnJlbmRlcigpXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJ3ZFNsaWNlIChzZXROZWVkZWQ6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgIF9fc2xpY2UucmVzZXQoRGlyZWN0aW9uLkJ3ZClcbiAgICAgICAgIHNldE5lZWRlZCgpXG4gICAgICAgICBFdmFsLmV2YWxfYndkKHRoaXMuZSwgdGhpcy50dilcbiAgICAgICAgIF9fc2xpY2UuYW5uID0gX19zbGljZS5yZXN0cmljdFRvKHRoaXMuz4FfZXh0ZXJuYWwudmFsdWVzKCkpXG4gICAgICAgICB0aGlzLmxpc3RlbmVyLm9uQndkU2xpY2UodGhpcywgX19zbGljZS5hbm4pXG4gICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5Cd2RcbiAgICAgICAgIHRoaXMuc2xpY2UgPSBfX3NsaWNlLmFublxuICAgICAgfVxuXG4gICAgICAvLyBGb3J3YXJkLXNsaWNlIHdpdGggcmVzcGVjdCB0byBzdXBwbGllZCBzbGljZSBvZiDPgV9leHRlcm5hbC5cbiAgICAgIGZ3ZFNsaWNlIChleHRlcm5EZXBzOiBTbGljZSk6IHZvaWQge1xuICAgICAgICAgX19zbGljZS5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uRndkXG4gICAgICAgICBfX3NsaWNlLmFubiA9IGV4dGVybkRlcHNcbiAgICAgICAgIEV2YWwuZXZhbF9md2QodGhpcy5lLCB0aGlzLnR2KVxuICAgICAgICAgX19zbGljZS5hbm4gPSBfX3NsaWNlLnJlc3RyaWN0VG8oW3RoaXMudHZdKVxuICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uRndkXG4gICAgICAgICB0aGlzLnNsaWNlID0gX19zbGljZS5hbm5cbiAgICAgIH1cblxuICAgICAgcmVuZGVyICgpOiB2b2lkIHtcbiAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MzEwNjQzXG4gICAgICAgICBjb25zdCBjaGlsZHJlbjogQ2hpbGROb2RlW10gPSBBcnJheS5mcm9tKHRoaXMucm9vdFBhbmUuY2hpbGROb2RlcylcbiAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBDaGlsZE5vZGUpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgU1ZHRGVmc0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJvb3RQYW5lLnJlbW92ZUNoaWxkKGNoaWxkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgfSlcbiAgICAgICAgIHRoaXMudG9vbHRpcHMuZm9yRWFjaCh0b29sdGlwID0+IHRvb2x0aXAuZGVzdHJveSgpKVxuICAgICAgICAgdGhpcy50b29sdGlwcy5jbGVhcigpXG4gICAgICAgICBWaWV3LnJlbmRlcih0aGlzKVxuICAgICAgfVxuICAgXG4gICAgICBvbkVkaXQgKCk6IHZvaWQge1xuICAgICAgICAgdGhpcy50diA9IEV2YWwuZXZhbF8odGhpcy7PgSwgdGhpcy5lKVxuICAgICAgICAgdGhpcy5oZXJlID0gRXhwbFZhbHVlQ3Vyc29yLmRlc2NlbmRhbnQobnVsbCwgZXhwbFZhbHVlKGFzKHRoaXMudHYudCwgRXhwbC5EZWZzKS50LCB0aGlzLnR2LnYpKVxuICAgICAgICAgLy8gY3Vyc29yIG1heSBubyBsb25nZXIgYmUgdmFsaWQsIGhvdyB0byBkZWFsIHdpdGggdGhhdD9cbiAgICAgICAgIHRoaXMucmVuZGVyKClcbiAgICAgIH1cbiAgIFxuICAgICAgb25WaWV3Q2hhbmdlICgpOiB2b2lkIHtcbiAgICAgICAgIHRoaXMucmVuZGVyKClcbiAgICAgIH1cbiAgIH1cbn1cbiIsImltcG9ydCB7IFBsYWNlbWVudCB9IGZyb20gXCJ0aXBweS5qc1wiXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IERpcmVjdGlvbiwgU2xpY2UsIF9fc2xpY2UgfSBmcm9tIFwiLi4vQW5ub3RhdGlvblwiXG5pbXBvcnQgeyBFbnYgfSBmcm9tIFwiLi4vRW52XCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi4vRXhwclwiXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSBcIi4vUGFuZVwiXG5pbXBvcnQgeyBWaWV3IH0gZnJvbSBcIi4vVmlld1wiXG5cbmV4cG9ydCBjbGFzcyBQYW5lQ29vcmRpbmF0b3IgaW1wbGVtZW50cyBQYW5lLkxpc3RlbmVyIHtcbiAgIM+BX2V4dGVybmFsOiBFbnZcbiAgIHBhbmVzOiBTZXQ8UGFuZS5QYW5lPiA9IG5ldyBTZXQoKVxuXG4gICBjb25zdHJ1Y3RvciAoz4FfZXh0ZXJuYWw6IEVudikge1xuICAgICAgdGhpcy7PgV9leHRlcm5hbCA9IM+BX2V4dGVybmFsXG4gICB9XG5cbiAgIGFkZFBhbmUgKM+BOiBFbnYsIGU6IEV4cHIsIHRvb2x0aXBQbGFjZW1lbnQ6IFBsYWNlbWVudCA9IFwidG9wXCIpOiBQYW5lLlBhbmUge1xuICAgICAgY29uc3QgcGFuZTogUGFuZS5QYW5lID0gbmV3IFBhbmUuUGFuZSh0aGlzLCBWaWV3LmRlZmF1bHREaW1zLCB0b29sdGlwUGxhY2VtZW50LCB0aGlzLs+BX2V4dGVybmFsLCDPgSwgZSlcbiAgICAgIHBhbmUuaW5pdGlhbGlzZSgpXG4gICAgICB0aGlzLnBhbmVzLmFkZChwYW5lKVxuICAgICAgcmV0dXJuIHBhbmVcbiAgIH1cblxuICAgcmVtb3ZlUGFuZSAocGFuZTogUGFuZS5QYW5lKTogdm9pZCB7XG4gICAgICBhc3NlcnQodGhpcy5wYW5lcy5oYXMocGFuZSkpXG4gICAgICB0aGlzLnBhbmVzLmRlbGV0ZShwYW5lKVxuICAgfVxuXG4gICBvbkJ3ZFNsaWNlIChlZGl0b3I6IFBhbmUuUGFuZSwgZXh0ZXJuRGVwczogU2xpY2UpOiB2b2lkIHtcbiAgICAgIC8vIGNvbnNpZGVyIGF2YWlsYWJpbGl0eSBvZiDPgV9leHRlcm5hbCBvbmx5OyB0cmVhdCDPgSBhbmQgZSBhcyB1bmxpbWl0ZWQgcmVzb3VyY2VzXG4gICAgICBbLi4udGhpcy5wYW5lc11cbiAgICAgICAgIC5maWx0ZXIoZWRpdG9yXyA9PiBlZGl0b3JfICE9PSBlZGl0b3IpXG4gICAgICAgICAuZm9yRWFjaCgoZWRpdG9yXzogUGFuZS5QYW5lKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBlZGl0b3JfLmZ3ZFNsaWNlKGV4dGVybkRlcHMpXG4gICAgICAgICAgICBlZGl0b3JfLnJlbmRlcigpIC8vIFRPRE86IGp1c3QgcmVkbyBzZWxlY3Rpb24gcmVuZGVyaW5nXG4gICAgICAgICB9KVxuICAgICAgX19zbGljZS5yZXNldChEaXJlY3Rpb24uRndkKVxuICAgfVxufVxuIiwiaW1wb3J0IHsgQ2xhc3MsIF9fbm9uTnVsbCwgYWJzdXJkLCBhcywgYXNzZXJ0LCBjbGFzc05hbWUgfSBmcm9tIFwiLi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IENoYW5nZSwgTmV3LCBSZWNsYXNzaWZ5IH0gZnJvbSBcIi4uL0RlbHRhXCJcbmltcG9ydCB7IHN0cmluZ3MgfSBmcm9tIFwiLi4vRXhwclwiXG5pbXBvcnQgeyBBcnJvd2hlYWQsIE1hcmtlciB9IGZyb20gXCIuLi9HcmFwaGljc1wiXG5pbXBvcnQgeyBWYWx1ZSwgaXNQcmltIH0gZnJvbSBcIi4uL1ZhbHVlXCJcbmltcG9ydCB7IHZlcnNpb25lZCB9IGZyb20gXCIuLi9WZXJzaW9uZWRcIlxuaW1wb3J0IHsgU1ZHIH0gZnJvbSBcIi4vQ29yZVwiXG5pbXBvcnQgXCIuL3N0eWxlcy5jc3NcIlxuXG4vLyBNYXliZSB0aGVyZSBhcmUgc29tZSBidWlsdC1pbiB0eXBlcyBmb3IgdGhpcywgYnV0IGRvbid0IGNhcmUgeWV0XG50eXBlIFBvaW50ID0geyB4OiBudW1iZXIsIHk6IG51bWJlciB9XG50eXBlIERpbXMgPSBQb2ludCAmIHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfVxuXG5leHBvcnQgY29uc3Qgc3ZnOiBTVkcgPSBuZXcgU1ZHKClcbmNvbnN0IGZvbnRTaXplOiBudW1iZXIgPSAxOFxuY29uc3QgY2xhc3Nlczogc3RyaW5nID0gXCJjb2RlXCJcbi8vIGJpemFycmVseSwgaWYgSSBkbyB0aGlzIGxhdGVyLCBmb250IG1ldHJpY3MgYXJlIGJvcmtlZDpcbmNvbnN0IGxpbmVIZWlnaHQgPSBzdmcudGV4dEhlaWdodCh0ZXh0RWxlbWVudChmb250U2l6ZSwgY2xhc3NlcywgXCJtXCIpKSAvLyByZXByZXNlbnRhdGl2ZSBjaGFyYWN0ZXIgXG4vLyBBU0NJSSBzcGFjZXMgc2VlbSB0byBiZSB0cmltbWVkOyBvbmx5IFVuaWNvZGUgc3BhY2UgdGhhdCBzZWVtcyB0byByZW5kZXIgbW9ub3NwYWNlZCBpcyB0aGlzOiBcbmNvbnN0IHNwYWNlX2NoYXI6IHN0cmluZyA9IFwiXFx1MDBhMFwiXG5jb25zdCBzaGFwZVJlbmRlcmluZzogc3RyaW5nID0gXCJnZW9tZXRyaWNQcmVjaXNpb25cIlxuXG4vLyBQb3B1bGF0ZSBleHBsaWNpdHksIHJhdGhlciB0aGFuIHVzaW5nIGEgbWVtb2lzZWQgZnVuY3Rpb24uXG50eXBlIERpbWVuc2lvbnMgPSB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH1cbmV4cG9ydCBjb25zdCBfX2RpbWVuc2lvbnM6IE1hcDxTVkdFbGVtZW50LCBEaW1lbnNpb25zPiA9IG5ldyBNYXAoKVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyb3cgKOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR0VsZW1lbnQge1xuICAgcmV0dXJuIGtleXdvcmQoXCJhcnJvd1wiLCDhup9fc3R5bGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3JkZXIgKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgc3Ryb2tlOiBzdHJpbmcsIGRhc2hlZDogYm9vbGVhbik6IFNWR1JlY3RFbGVtZW50IHtcbiAgIGNvbnN0IGI6IFNWR1JlY3RFbGVtZW50ID0gcmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHJva2UsIFwibm9uZVwiLCBib3JkZXIpXG4gICBiLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjAuNVwiKVxuICAgaWYgKGRhc2hlZCkge1xuICAgICAgYi5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMSwxXCIpXG4gICB9XG4gICByZXR1cm4gYlxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQm9yZGVyX2NoYW5nZWQgKGc6IFNWR1NWR0VsZW1lbnQpOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19ub25OdWxsKF9fZGltZW5zaW9ucy5nZXQoZykpXG4gICBjb25zdCBiOiBTVkdSZWN0RWxlbWVudCA9IGJvcmRlcihnLnguYmFzZVZhbC52YWx1ZSwgZy55LmJhc2VWYWwudmFsdWUsIHdpZHRoLCBoZWlnaHQsIFwiYmx1ZVwiLCB0cnVlKVxuICAgZy5hcHBlbmRDaGlsZChiKVxuICAgcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJvcmRlcl9mb2N1cyAoZzogU1ZHU1ZHRWxlbWVudCk6IFNWR1NWR0VsZW1lbnQge1xuICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH06IERpbWVuc2lvbnMgPSBfX25vbk51bGwoX19kaW1lbnNpb25zLmdldChnKSlcbiAgIGNvbnN0IGI6IFNWR1JlY3RFbGVtZW50ID0gYm9yZGVyKGcueC5iYXNlVmFsLnZhbHVlLCBnLnkuYmFzZVZhbC52YWx1ZSwgd2lkdGgsIGhlaWdodCwgXCJncmF5XCIsIGZhbHNlKVxuICAgZy5hcHBlbmRDaGlsZChiKVxuICAgcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYWNrZXQgKGdzOiBTVkdFbGVtZW50W10sIOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR1NWR0VsZW1lbnQge1xuICAgcmV0dXJuIGhvcml6KGtleXdvcmQoXCJicmFja2V0TFwiLCDhup9fc3R5bGUpLCAuLi5ncywga2V5d29yZChcImJyYWNrZXRSXCIsIOG6n19zdHlsZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjZW50cmVEb3QgKOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR0VsZW1lbnQge1xuICAgcmV0dXJuIHRleHQoXCLigKJcIiwg4bqfX3N0eWxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbWEgKOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR0VsZW1lbnQge1xuICAgcmV0dXJuIGtleXdvcmQoXCJjb21tYVwiLCDhup9fc3R5bGUpXG59XG5cbi8vIFdoZXRoZXIgdGhlIGNlbnRyZSBvZiByMSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgY2VudHJlIG9mIHIyLlxuZnVuY3Rpb24gbGVmdE9mIChyMTogRGltcywgcjI6IERpbXMpOiBib29sZWFuIHtcbiAgIHJldHVybiByMS54ICsgcjEud2lkdGggLyAyIDw9IHIyLnggKyByMi53aWR0aFxufVxuXG4vLyBUT0RPOiByZW1lbWJlciB3aGF0IHRoaXMgaXMgZm9yLlxuZnVuY3Rpb24gYmxhaCAoeDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgcHJvcG9ydGlvbjogbnVtYmVyKTogIG51bWJlciB7XG4gICByZXR1cm4geCArIHByb3BvcnRpb24gKiBsZW5ndGhcbn1cblxuLy8gT2Zmc2V0IG1pZ2h0IGJlIGJldHRlciBjb21wdXRlZCBhcyBhIGZ1bmN0aW9uIG9mIGRpc3RhbmNlIGJldHdlZW4gcDEgYW5kIHAyLlxuZnVuY3Rpb24gY3VydmVkTGluZSAocDE6IFBvaW50LCBwMjogUG9pbnQsIG9mZnNldDogbnVtYmVyKTogc3RyaW5nIHtcbiAgIGNvbnN0IG1wOiBQb2ludCA9IHsgeDogKHAyLnggKyBwMS54KSAqIDAuNSwgeTogKHAyLnkgKyBwMS55KSAqIDAuNSB9XG4gICAvLyBhbmdsZSBvZiBwZXJwZW5kaWN1bGFyIHRvIGxpbmVcbiAgIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihwMi55IC0gcDEueSwgcDIueCAtIHAxLngpIC0gTWF0aC5QSSAvIDJcbiAgIGNvbnN0IGNvbnRyb2w6IFBvaW50ID0geyB4OiBtcC54ICsgb2Zmc2V0ICogTWF0aC5jb3ModGhldGEpLCB5OiBtcC55ICsgb2Zmc2V0ICogTWF0aC5zaW4odGhldGEpIH1cbiAgIHJldHVybiBgTSAke3AxLnh9ICR7cDEueX0gUSAke2NvbnRyb2wueH0gJHtjb250cm9sLnl9ICR7cDIueH0gJHtwMi55fWBcbn1cblxuLy8gRmFjdG9yIGFsbCBlbGVtZW50IGNyZWF0aW9uIHRocm91Z2ggdGhpcyBzbyB3ZSBjYW4gdGFnIHdpdGggZXh0cmEgbWV0YWRhdGEuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50PEsgZXh0ZW5kcyBrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcD4obmFtZTogSywgY3JlYXRlZEJ5OiBGdW5jdGlvbik6IFNWR0VsZW1lbnRUYWdOYW1lTWFwW0tdIHtcbiAgIGNvbnN0IGU6IFNWR0VsZW1lbnRUYWdOYW1lTWFwW0tdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRy5OUywgbmFtZSlcbiAgIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1jcmVhdGVkLWJ5XCIsIGNyZWF0ZWRCeS5uYW1lKVxuICAgcmV0dXJuIGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RvciAoZzE6IFNWR1NWR0VsZW1lbnQsIGcyOiBTVkdTVkdFbGVtZW50KTogU1ZHRWxlbWVudCB7XG4gICBjb25zdCBnMV86IERpbXMgPSBkaW1zKGcxKVxuICAgY29uc3QgZzJfOiBEaW1zID0gZGltcyhnMilcbiAgIGNvbnN0IFtmcm9tQm90dG9tLCBmcm9tVG9wXTogW251bWJlciwgbnVtYmVyXSA9IFswLjEsIDAuOV1cbiAgIGNvbnN0IGNvbm5lY3Rvcl86IFNWR1BhdGhFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInBhdGhcIiwgY29ubmVjdG9yKVxuICAgY29uc3QgY3VydmVPZmZzZXQ6IG51bWJlciA9IDUgLy8gc29tZXdoYXQgYXJiaXRyYXJ5XG4gICBpZiAobGVmdE9mKGcxXywgZzJfKSkge1xuICAgICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJkXCIsIFxuICAgICAgICAgY3VydmVkTGluZShcbiAgICAgICAgICAgIHsgeDogZzFfLnggKyBnMV8ud2lkdGgsIHk6IGJsYWgoZzFfLnksIGcxXy5oZWlnaHQsIGZyb21Cb3R0b20pIH0sXG4gICAgICAgICAgICB7IHg6IGcyXy54LCB5OiBibGFoKGcyXy55LCBnMl8uaGVpZ2h0LCBmcm9tQm90dG9tKSB9LFxuICAgICAgICAgICAgY3VydmVPZmZzZXRcbiAgICAgICAgIClcbiAgICAgIClcbiAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0b3JfLnNldEF0dHJpYnV0ZShcImRcIiwgXG4gICAgICAgICBjdXJ2ZWRMaW5lKFxuICAgICAgICAgICAgeyB4OiBnMV8ueCwgeTogYmxhaChnMV8ueSwgZzFfLmhlaWdodCwgZnJvbVRvcCkgfSxcbiAgICAgICAgICAgIHsgeDogZzJfLnggKyBnMl8ud2lkdGgsIHk6IGJsYWgoZzJfLnksIGcyXy5oZWlnaHQsIGZyb21Ub3ApIH0sXG4gICAgICAgICAgICBjdXJ2ZU9mZnNldFxuICAgICAgICAgKVxuICAgICAgKVxuICAgfVxuICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgc2hhcGVSZW5kZXJpbmcpXG4gICBjb25uZWN0b3JfLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpXG4gICBjb25uZWN0b3JfLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcImJsdWVcIikgLy8gaGFyZGNvZGVkXG4gICBjb25uZWN0b3JfLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjFcIilcbiAgIGNvbm5lY3Rvcl8uc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjEsMVwiKVxuICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNBcnJvd2hlYWQtYmx1ZSlcIikgLy8gZXh0cmFjdCB0byBoZWxwZXIgZnVuY3Rpb25cbiAgIHJldHVybiBjb25uZWN0b3JfXG59XG5cbi8vIENvdWxkbid0IGdldCBnZXRTY3JlZW5DVE0gb3IgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRvIHdvcmsgcHJvcGVybHkgKHBlcmhhcHMgYmVjYXVzZSBvZiBuZXN0ZWQgU1ZHcz8pIHNvIGp1c3QgdXNlIHRoaXMgdG8gY29tcHV0ZSBcbi8vIGNvb3JkaW5hdGVzIG9mIGcgcmVsYXRpdmUgdG8gcm9vdCBTVkcuXG5mdW5jdGlvbiBjb29yZGluYXRlcyAoZzogU1ZHU1ZHRWxlbWVudCk6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSB7XG4gICBpZiAoZyBpbnN0YW5jZW9mIFNWR1NWR0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZy5wYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgU1ZHU1ZHRWxlbWVudCA/IGNvb3JkaW5hdGVzKGcucGFyZW50RWxlbWVudCk6IHsgeDogMCwgeTogMH1cbiAgICAgIHJldHVybiB7IHg6IHggKyBnLnguYmFzZVZhbC52YWx1ZSwgeTogeSArIGcueS5iYXNlVmFsLnZhbHVlIH1cbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH1cbiAgIH1cbn0gXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxpbWl0IChkZWxpbWl0ZXI6ICgpID0+IFNWR0VsZW1lbnQsIC4uLmdzOiBTVkdFbGVtZW50W10pOiBTVkdFbGVtZW50W10ge1xuICAgY29uc3QgZ3PKuTogU1ZHRWxlbWVudFtdID0gW11cbiAgIGdzLmZvckVhY2goKGc6IFNWR0VsZW1lbnQsIG46IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgZ3PKuS5wdXNoKGcpXG4gICAgICBpZiAobiA8IGdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgIGdzyrkucHVzaChkZWxpbWl0ZXIoKSlcbiAgICAgIH1cbiAgIH0pXG4gICByZXR1cm4gZ3PKuVxufVxuXG5mdW5jdGlvbiBkaW1zIChnOiBTVkdTVkdFbGVtZW50KTogRGltcyB7XG4gICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfTogRGltZW5zaW9ucyA9IF9fbm9uTnVsbChfX2RpbWVuc2lvbnMuZ2V0KGcpKVxuICAgY29uc3QgeyB4LCB5IH0gPSBjb29yZGluYXRlcyhnKVxuICAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGdlX2xlZnQgKGc6IFNWR1NWR0VsZW1lbnQpOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHsgaGVpZ2h0IH06IERpbWVuc2lvbnMgPSBfX2RpbWVuc2lvbnMuZ2V0KGcpIVxuICAgY29uc3QgZWRnZTogU1ZHTGluZUVsZW1lbnQgPSBsaW5lKFxuICAgICAgZy54LmJhc2VWYWwudmFsdWUsIFxuICAgICAgZy55LmJhc2VWYWwudmFsdWUsIFxuICAgICAgZy54LmJhc2VWYWwudmFsdWUsIFxuICAgICAgZy55LmJhc2VWYWwudmFsdWUgKyBoZWlnaHQsIFxuICAgICAgXCJncmF5XCIsXG4gICAgICAxXG4gICApXG4gICBlZGdlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjRcIilcbi8vICAgZWRnZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMiwyXCIpXG4gICBnLmFwcGVuZENoaWxkKGVkZ2UpXG4gICByZXR1cm4gZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZV9ib3R0b20gKGc6IFNWR1NWR0VsZW1lbnQpOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19kaW1lbnNpb25zLmdldChnKSFcbiAgIGNvbnN0IGVkZ2U6IFNWR0xpbmVFbGVtZW50ID0gbGluZShcbiAgICAgIGcueC5iYXNlVmFsLnZhbHVlLCBcbiAgICAgIGcueS5iYXNlVmFsLnZhbHVlICsgaGVpZ2h0LCBcbiAgICAgIGcueS5iYXNlVmFsLnZhbHVlICsgd2lkdGgsIFxuICAgICAgZy55LmJhc2VWYWwudmFsdWUgKyBoZWlnaHQsIFxuICAgICAgXCJncmF5XCIsXG4gICAgICAxXG4gICApXG4gICBlZGdlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjJcIilcbi8vICAgZWRnZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMiwyXCIpXG4gICBnLmFwcGVuZENoaWxkKGVkZ2UpXG4gICByZXR1cm4gZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzaXMgKOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR0VsZW1lbnQge1xuICAgcmV0dXJuIHRleHQoXCLigKZcIiwg4bqfX3N0eWxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXAgKCk6IFNWR0dFbGVtZW50IHtcbiAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZ1wiLCBncm91cClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvcml6ICguLi5nczogU1ZHRWxlbWVudFtdKTogU1ZHU1ZHRWxlbWVudCB7XG4gICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInN2Z1wiLCBob3JpeilcbiAgIGxldCB3aWR0aF9zdW06IG51bWJlciA9IDAsXG4gICAgICAgaGVpZ2h0X21heDogbnVtYmVyID0gMFxuICAgZ3MuZm9yRWFjaCgoZ8q5OiBTVkdFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICBnyrkuc2V0QXR0cmlidXRlKFwieFwiLCBgJHt3aWR0aF9zdW19YClcbiAgICAgIGfKuS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGAwYClcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19kaW1lbnNpb25zLmdldChnyrkpIVxuICAgICAgd2lkdGhfc3VtICs9IHdpZHRoXG4gICAgICBoZWlnaHRfbWF4ID0gTWF0aC5tYXgoaGVpZ2h0X21heCwgaGVpZ2h0KVxuICAgICAgZy5hcHBlbmRDaGlsZChnyrkpXG4gICB9KVxuICAgX19kaW1lbnNpb25zLnNldChnLCB7IHdpZHRoOiB3aWR0aF9zdW0sIGhlaWdodDogaGVpZ2h0X21heCB9KVxuICAgcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvcml6U3BhY2UgKC4uLmdzOiBTVkdFbGVtZW50W10pOiBTVkdTVkdFbGVtZW50IHtcbiAgIHJldHVybiBob3JpeiguLi5kZWxpbWl0KHNwYWNlLCAuLi5ncykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBrZXl3b3JkIChzdHI6IGtleW9mIHR5cGVvZiBzdHJpbmdzLCDhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdFbGVtZW50IHtcbiAgIHJldHVybiB0ZXh0KHN0cmluZ3Nbc3RyXSwg4bqfX3N0eWxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZSAoeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlciwgc3Ryb2tlOiBzdHJpbmcsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiBTVkdMaW5lRWxlbWVudCB7XG4gICBjb25zdCBsOiBTVkdMaW5lRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIGxpbmUpXG4gICBsLnNldEF0dHJpYnV0ZShcInNoYXBlLXJlbmRlcmluZ1wiLCBzaGFwZVJlbmRlcmluZylcbiAgIGwuc2V0QXR0cmlidXRlKFwieDFcIiwgYCR7cm91bmQoeDEpfWApXG4gICBsLnNldEF0dHJpYnV0ZShcInkxXCIsIGAke3JvdW5kKHkxKX1gKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBgJHtyb3VuZCh4Mil9YClcbiAgIGwuc2V0QXR0cmlidXRlKFwieTJcIiwgYCR7cm91bmQoeTIpfWApXG4gICBsLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBzdHJva2UpXG4gICBsLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBgJHtyb3VuZChzdHJva2VXaWR0aCl9YClcbiAgIHJldHVybiBsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lUm91bmRlZCAoeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlciwgc3Ryb2tlOiBzdHJpbmcsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiBTVkdMaW5lRWxlbWVudCB7XG4gICBjb25zdCBsOiBTVkdMaW5lRWxlbWVudCA9IGxpbmUoeDEsIHkxLCB4MiwgeTIsIHN0cm9rZSwgc3Ryb2tlV2lkdGgpXG4gICBsLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIilcbiAgIHJldHVybiBsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXIgKEM6IENsYXNzPE1hcmtlcj4sIGNvbG91cjogc3RyaW5nKTogU1ZHTWFya2VyRWxlbWVudCB7XG4gICBjb25zdCBtOiBTVkdNYXJrZXJFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcIm1hcmtlclwiLCBtYXJrZXIpXG4gICBtLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hcmtlcklkKEMsIGNvbG91cikpXG4gICBtLnNldEF0dHJpYnV0ZShcIm9yaWVudFwiLCBcImF1dG9cIilcbiAgIG0uc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBjb2xvdXIpXG4gICBtLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBjb2xvdXIpXG4gICByZXR1cm4gbVxufVxuXG5mdW5jdGlvbiBtYXJrZXJJZCAoQzogQ2xhc3M8TWFya2VyPiwgY29sb3VyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgcmV0dXJuIGAke0MubmFtZX0tJHtjb2xvdXJ9YFxufVxuXG5leHBvcnQgdHlwZSBNYXJrZXJGYWN0b3J5ID0gKGNvbG91cjogc3RyaW5nKSA9PiBTVkdNYXJrZXJFbGVtZW50XG5cbmxldCBtYXJrZXJGYWN0b3J5OiBNYXA8c3RyaW5nLCBNYXJrZXJGYWN0b3J5PlxuXG57XG4gICBtYXJrZXJGYWN0b3J5ID0gbmV3IE1hcCgpXG4gICBtYXJrZXJGYWN0b3J5LnNldChBcnJvd2hlYWQubmFtZSwgbWFya2VyX2Fycm93aGVhZClcbn1cblxuLy8gQXNzdW1lIHJvb3QgaGFzIGEgdW5pcXVlIGRlZnMgZWxlbWVudCBjYWxsZWQgXCJkZWZzXCIuIFJldHVybiBjb21wb3NpdGUgbWFya2VyIGlkLlxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlckVuc3VyZURlZmluZWQgKHJvb3Q6IFNWR1NWR0VsZW1lbnQsIEM6IENsYXNzPE1hcmtlcj4sIGNvbG91cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgIGNvbnN0IGlkOiBzdHJpbmcgPSBtYXJrZXJJZChDLCBjb2xvdXIpXG4gICBsZXQgbWFya2VyOiBFbGVtZW50IHwgbnVsbCA9IHJvb3QuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICBpZiAobWFya2VyID09PSBudWxsKSB7XG4gICAgICBtYXJrZXIgPSBfX25vbk51bGwobWFya2VyRmFjdG9yeS5nZXQoQy5uYW1lKSkoY29sb3VyKVxuICAgICAgY29uc3QgZGVmczogU1ZHRGVmc0VsZW1lbnQgPSBhcyhyb290LmdldEVsZW1lbnRCeUlkKFwiZGVmc1wiKSwgU1ZHRGVmc0VsZW1lbnQpXG4gICAgICBkZWZzLmFwcGVuZENoaWxkKG1hcmtlcilcbiAgICAgIGFzc2VydChyb290LmdldEVsZW1lbnRCeUlkKGlkKSA9PT0gbWFya2VyKVxuICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtYXJrZXIgaW5zdGFuY2VvZiBTVkdNYXJrZXJFbGVtZW50KVxuICAgfVxuICAgcmV0dXJuIGlkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXJfYXJyb3doZWFkIChjb2xvdXI6IHN0cmluZyk6IFNWR01hcmtlckVsZW1lbnQge1xuICAgY29uc3QgbTogU1ZHTWFya2VyRWxlbWVudCA9IG1hcmtlcihBcnJvd2hlYWQsIGNvbG91cilcbiAgIGNvbnN0IGxlbmd0aDogbnVtYmVyID0gNixcbiAgICAgICAgIHdpZHRoOiBudW1iZXIgPSA0XG4gICBtLnNldEF0dHJpYnV0ZShcInJlZlhcIiwgYCR7bGVuZ3RofWApXG4gICBtLnNldEF0dHJpYnV0ZShcInJlZllcIiwgYCR7d2lkdGggLyAyfWApXG4gICBtLnNldEF0dHJpYnV0ZShcIm1hcmtlcldpZHRoXCIsIFwiMTZcIilcbiAgIG0uc2V0QXR0cmlidXRlKFwibWFya2VySGVpZ2h0XCIsIFwiMTZcIilcbiAgIGNvbnN0IHBhdGg6IFNWR1BhdGhFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInBhdGhcIiwgbWFya2VyX2Fycm93aGVhZClcbiAgIG0uYXBwZW5kQ2hpbGQocGF0aClcbiAgIHBhdGguc2V0QXR0cmlidXRlKFwic2hhcGUtcmVuZGVyaW5nXCIsIHNoYXBlUmVuZGVyaW5nKVxuICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGBNICR7bGVuZ3RofSAke3dpZHRoIC8gMn0gTCAwICR7d2lkdGh9IEwgMCAwIFpgKVxuICAgcmV0dXJuIG1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZSAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1czogbnVtYmVyLCBzdHJva2U6IHN0cmluZywgZmlsbDogc3RyaW5nLCBjcmVhdGVkQnk6IEZ1bmN0aW9uKTogU1ZHQ2lyY2xlRWxlbWVudCB7XG4gICBjb25zdCByOiBTVkdDaXJjbGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCBjcmVhdGVkQnkpXG4gICByLnNldEF0dHJpYnV0ZShcInNoYXBlLXJlbmRlcmluZ1wiLCBzaGFwZVJlbmRlcmluZylcbiAgIHIuc2V0QXR0cmlidXRlKFwiY3hcIiwgYCR7cm91bmQoeCl9YClcbiAgIHIuc2V0QXR0cmlidXRlKFwiY3lcIiwgYCR7cm91bmQoeSl9YClcbiAgIHIuc2V0QXR0cmlidXRlKFwiclwiLCBgJHtyb3VuZChyYWRpdXMpfWApXG4gICByLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBzdHJva2UpXG4gICByLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgZmlsbClcbiAgIHJldHVybiByXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJlbnRoZXNpc2UgKGc6IFNWR0VsZW1lbnQsIOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR1NWR0VsZW1lbnQge1xuICAgcmV0dXJuIGhvcml6KGtleXdvcmQoXCJwYXJlbkxcIiwg4bqfX3N0eWxlKSwgZywga2V5d29yZChcInBhcmVuUlwiLCDhup9fc3R5bGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50aGVzaXNlSWYgKHBhcmVuczogYm9vbGVhbiwgZzogU1ZHU1ZHRWxlbWVudCwg4bqfX3N0eWxlOiBEZWx0YVN0eWxlKTogU1ZHU1ZHRWxlbWVudCB7XG4gICByZXR1cm4gcGFyZW5zID8gcGFyZW50aGVzaXNlKGcsIOG6n19zdHlsZSkgOiBnXG59XG5cbi8vIFRPRE86IHVzZSBQb2ludCBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZT9cbmZ1bmN0aW9uIHBvaW50c1RvU3RyaW5nIChwzIU6IFtudW1iZXIsIG51bWJlcl1bXSk6IHN0cmluZyB7XG4gICByZXR1cm4gcMyFLm1hcCgoW3gsIHldOiBbbnVtYmVyLCBudW1iZXJdKSA9PiBgJHtyb3VuZCh4KX0sJHtyb3VuZCh5KX1gKS5qb2luKFwiIFwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUgKHDMhTogW251bWJlciwgbnVtYmVyXVtdLCBzdHJva2U6IHN0cmluZywgc3Ryb2tlV2lkdGg6IG51bWJlcik6IFNWR1BvbHlsaW5lRWxlbWVudCB7XG4gICBjb25zdCBsOiBTVkdQb2x5bGluZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgcG9seWxpbmUpXG4gICBsLnNldEF0dHJpYnV0ZShcInNoYXBlLXJlbmRlcmluZ1wiLCBzaGFwZVJlbmRlcmluZylcbiAgIGwuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50c1RvU3RyaW5nKHDMhSkpXG4gICBsLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBzdHJva2UpXG4gICBsLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBgJHtyb3VuZChzdHJva2VXaWR0aCl9YClcbiAgIGwuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgcmV0dXJuIGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3QgKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgc3Ryb2tlOiBzdHJpbmcsIGZpbGw6IHN0cmluZywgY3JlYXRlZEJ5OiBGdW5jdGlvbik6IFNWR1JlY3RFbGVtZW50IHtcbiAgIGNvbnN0IHI6IFNWR1JlY3RFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInJlY3RcIiwgY3JlYXRlZEJ5KVxuICAgci5zZXRBdHRyaWJ1dGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgc2hhcGVSZW5kZXJpbmcpXG4gICByLnNldEF0dHJpYnV0ZShcInhcIiwgYCR7cm91bmQoeCl9YClcbiAgIHIuc2V0QXR0cmlidXRlKFwieVwiLCBgJHtyb3VuZCh5KX1gKVxuICAgci5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHtyb3VuZCh3aWR0aCl9YClcbiAgIHIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGAke3JvdW5kKGhlaWdodCl9YClcbiAgIHIuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIHN0cm9rZSlcbiAgIHIuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBmaWxsKVxuICAgcmV0dXJuIHJcbn1cblxuLy8gUm91bmRpbmcgdG8gcGl4ZWwgYm91bmRhcmllcyAoYWx0aG91Z2ggb2Z0ZW4gZGVzaXJhYmxlIGZvciBTVkcsIGUuZy4gdG8gZ2V0IHNoYXJwIGxpbmVzKSBkb2Vzbid0IHdvcmsgd2VsbCBcbi8vIGZvciBzbWFsbCBzaGFwZXMsIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIG1haW50YWluIHRoZSBmdWxsIG1vbnN0cm9zaXR5IHRoYXQgYXJlIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuIFJvdW5kIFxuLy8gdG8gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLCBjYXN0IHRvIG51bWJlciB0byBzdHJpcCB0cmFpbGluZyB6ZXJvcywgYW5kIHRoZW4gY2FzdCBiYWNrIHRvIHN0cmluZy5cbi8vIFRoaXMgc2VlbXMgdG8gYmUgc3VmZmljaWVudCBwcmVjaXNpb24gZm9yIFNWRyBidXQgaXMgYWxzbyBodW1hbi1mcmllbmRseS5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZCAobjogbnVtYmVyKTogc3RyaW5nIHtcbiAgIHJldHVybiAoK24udG9GaXhlZCgzKSkudG9TdHJpbmcoKVxufVxuXG4vLyBOZWVkcyB0byBiZSBhdCB0aGUgYm90dG9tIGluIHRoZSB6LW9yZGVyLCBhbmQgb3BhcXVlLlxuZXhwb3J0IGZ1bmN0aW9uIHNoYWRpbmcgKGc6IFNWR1NWR0VsZW1lbnQsIGZpbGw6IHN0cmluZyk6IFNWR1NWR0VsZW1lbnQge1xuICAgY29uc3Qgc3ZnOiBTVkdTVkdFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInN2Z1wiLCBzaGFkaW5nKVxuICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH06IERpbWVuc2lvbnMgPSBfX2RpbWVuc2lvbnMuZ2V0KGcpIVxuICAgY29uc3QgYmFja2dyb3VuZDogU1ZHUmVjdEVsZW1lbnQgPSByZWN0KGcueC5iYXNlVmFsLnZhbHVlLCBnLnkuYmFzZVZhbC52YWx1ZSwgd2lkdGgsIGhlaWdodCwgXCJub25lXCIsIGZpbGwsIHNoYWRpbmcpXG4gICBiYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuICAgc3ZnLmFwcGVuZENoaWxkKGJhY2tncm91bmQpXG4gICBzdmcuYXBwZW5kQ2hpbGQoZylcbiAgIF9fZGltZW5zaW9ucy5zZXQoc3ZnLCB7IHdpZHRoLCBoZWlnaHQgfSlcbiAgIHJldHVybiBzdmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwYWNlICgpOiBTVkdFbGVtZW50IHtcbiAgIHJldHVybiB0ZXh0KGAke3NwYWNlX2NoYXJ9YCwgRGVsdGFTdHlsZS5VbmNoYW5nZWQpXG59XG5cbi8vIENvbnRlbnQgYmVsb3cgb3IgdG8gdGhlIGxlZnQgaXMgY2xpcHBlZCBhdXRvbWF0aWNhbGx5OyBjb250ZW50IHRvIGFib3ZlIG9yIHRvIHRoZSByaWdodCBpcyBjbGlwcGVkIFxuLy8gaWYgd2Ugc2V0IHdpZHRoIGFuZCBoZWlnaHQuXG5leHBvcnQgZnVuY3Rpb24gc3ZnRWxlbWVudCAob3ZlcmZsb3c6IGJvb2xlYW4sIHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZGVmczogYm9vbGVhbiwgY3JlYXRlZEJ5OiBGdW5jdGlvbik6IFNWR1NWR0VsZW1lbnQge1xuICAgY29uc3Qgc3ZnOiBTVkdTVkdFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInN2Z1wiLCBjcmVhdGVkQnkpXG4gICBzdmcuc2V0QXR0cmlidXRlKFwieFwiLCBgJHtyb3VuZCh4KX1gKVxuICAgc3ZnLnNldEF0dHJpYnV0ZShcInlcIiwgYCR7cm91bmQoeSl9YClcbiAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHtyb3VuZCh3aWR0aCl9YClcbiAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7cm91bmQoaGVpZ2h0KX1gKVxuICAgLy8gdXNlIGlubGluZSBzdHlsZSByYXRoZXIgdGhhbiBhbiBhdHRyaWJ1dGUsIG90aGVyd2lzZSBhbnkgYWN0aXZlIHN0eWxpbmcgd2lsbCBvdmVycmlkZVxuICAgc3ZnLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBvdmVyZmxvdzogJHtvdmVyZmxvdyA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIn1gKVxuICAgaWYgKGRlZnMpIHtcbiAgICAgIGNvbnN0IGQ6IFNWR0RlZnNFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRlZnNcIiwgY3JlYXRlZEJ5KVxuICAgICAgZC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImRlZnNcIilcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChkKVxuICAgfVxuICAgcmV0dXJuIHN2Z1xufVxuXG4vLyBDaHJvbWUgZG9lc24ndCBhcHBlYXIgdG8gZnVsbHkgc3VwcG9ydCBTVkcgMi4wIHlldDsgaW4gcGFydGljdWxhciwgdHJhbnNmb3JtIGF0dHJpYnV0ZXMgb24gc3ZnIGVsZW1lbnRzIGFyZSBcbi8vIGlnbm9yZWQgKGV4Y2VwdCBhdCB0aGUgcm9vdCkuIFRvIGludmVydCB0aGUgeS1heGlzLCB3ZSBoYXZlIHRvIGFkZCBhIG5lc3RlZCBnIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdHJhbnNmb3JtLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0VsZW1lbnRfaW52ZXJ0ZWQgKHc6IG51bWJlciwgaDogbnVtYmVyKTogW1NWR1NWR0VsZW1lbnQsIFNWR0dFbGVtZW50XSB7XG4gICBjb25zdCBzdmc6IFNWR1NWR0VsZW1lbnQgPSBzdmdFbGVtZW50KGZhbHNlLCAwLCAwLCB3LCBoLCB0cnVlLCBzdmdFbGVtZW50X2ludmVydGVkKVxuICAgY29uc3QgZzogU1ZHR0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZ1wiLCBzdmdFbGVtZW50X2ludmVydGVkKVxuICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYHNjYWxlKDEsLTEpIHRyYW5zbGF0ZSgwLCR7LWh9KWApXG4gICBnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGAke3d9YClcbiAgIGcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGAke2h9YClcbiAgIHN2Zy5hcHBlbmRDaGlsZChnKVxuICAgcmV0dXJuIFtzdmcsIGddXG59XG5cbi8vIFRvcC1sZXZlbCBTVkcgbm9kZSB3aXRoIGEgXCJkZWZzXCIgZWxlbWVudCB3aXRoIGlkIFwiZGVmc1wiLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z1Jvb3RFbGVtZW50ICh3OiBudW1iZXIsIGg6IG51bWJlcik6IFNWR1NWR0VsZW1lbnQge1xuICAgY29uc3Qgc3ZnOiBTVkdTVkdFbGVtZW50ID0gc3ZnRWxlbWVudChmYWxzZSwgMCwgMCwgdywgaCwgdHJ1ZSwgc3ZnUm9vdEVsZW1lbnQpXG4gICAvLyBTZWUgaHR0cHM6Ly92ZWN0YS5pby9ibG9nL2d1aWRlLXRvLWdldHRpbmctc2hhcnAtYW5kLWNyaXNwLXN2Zy1pbWFnZXNcbiAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAtMC41IC0wLjUgJHt3LnRvU3RyaW5nKCl9ICR7aC50b1N0cmluZygpfWApXG4gICBzdmcuc3R5bGUudmVydGljYWxBbGlnbiA9IFwidG9wXCJcbiAgIHN2Zy5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxuICAgcmV0dXJuIHN2Z1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGV4dCAoc3RyOiBzdHJpbmcsIOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR1RleHRFbGVtZW50IHtcbiAgIGNvbnN0IHRleHQ6IFNWR1RleHRFbGVtZW50ID0gdGV4dEVsZW1lbnQoZm9udFNpemUsIFtjbGFzc2VzLCDhup9fc3R5bGVdLmpvaW4oXCIgXCIpLCBzdHIpXG4gICB0ZXh0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7MH0sJHtsaW5lSGVpZ2h0IC8gMn0pYClcbiAgIHRleHQuc2V0QXR0cmlidXRlKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwiY2VudHJhbFwiKVxuICAgY29uc3Qgd2lkdGg6IG51bWJlciA9IHN2Zy50ZXh0V2lkdGgodGV4dClcbiAgIF9fZGltZW5zaW9ucy5zZXQodGV4dCwgeyB3aWR0aCwgaGVpZ2h0OiBsaW5lSGVpZ2h0IH0pXG4gICB0ZXh0LnJlbW92ZSgpXG4gICByZXR1cm4gdGV4dFxufVxuXG5mdW5jdGlvbiB0ZXh0RWxlbWVudCAoZm9udFNpemU6IG51bWJlciwgY2xhc3NfOiBzdHJpbmcsIHN0cjogc3RyaW5nKTogU1ZHVGV4dEVsZW1lbnQge1xuICAgY29uc3QgdGV4dDogU1ZHVGV4dEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwidGV4dFwiLCB0ZXh0RWxlbWVudClcbiAgIHRleHQuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKVxuICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJmb250LXNpemVcIiwgZm9udFNpemUudG9TdHJpbmcoKSkgLy8gd2Fzbid0IGFibGUgdG8gc2V0IHRoaXMgdGhyb3VnaCBDU1MgZm9yIHNvbWUgcmVhc29uXG4gICB0ZXh0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzXykgLy8gc2V0IHN0eWxpbmcgYmVmb3JlIGNyZWF0aW5nIHRleHQgbm9kZSwgZm9yIGZvbnQgbWV0cmljcyB0byBiZSBjb3JyZWN0XG4gICB0ZXh0LnNldEF0dHJpYnV0ZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuICAgdGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpKVxuICAgcmV0dXJuIHRleHRcbn1cblxuLy8gRmxpcCB0ZXh0IHZlcnRpY2FsbHkgdG8gY2FuY2VsIG91dCB0aGUgZ2xvYmFsIHZlcnRpY2FsIGZsaXAuIERvbid0IHNldCB4IGFuZCB5IGJ1dCBleHByZXNzXG4vLyBwb3NpdGlvbiB0aHJvdWdoIGEgdHJhbnNsYXRpb24gc28gdGhhdCB0aGUgc2NhbGluZyBkb2Vzbid0IGFmZmVjdCB0aGUgcG9zaXRpb24uXG5leHBvcnQgZnVuY3Rpb24gdGV4dEVsZW1lbnRfZ3JhcGhpY2FsICh4OiBudW1iZXIsIHk6IG51bWJlciwgZm9udFNpemU6IG51bWJlciwgc3RyOiBzdHJpbmcpOiBTVkdUZXh0RWxlbWVudCB7XG4gICBjb25zdCB0ZXh0OiBTVkdUZXh0RWxlbWVudCA9IHRleHRFbGVtZW50KGZvbnRTaXplLCBcImxhYmVsXCIsIHN0cilcbiAgIGxldCB0cmFuc2Zvcm06IHN0cmluZyA9IGB0cmFuc2xhdGUoJHtyb3VuZCh4KX0sJHtyb3VuZCh5KX0pYFxuICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtICsgXCIgc2NhbGUoMSwtMSlcIilcbiAgIHJldHVybiB0ZXh0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmltcGxlbWVudGVkICh2OiBWYWx1ZSk6IFNWR1NWR0VsZW1lbnQge1xuICAgcmV0dXJuIGhvcml6KHRleHQoYFRPRE86ICR7Y2xhc3NOYW1lKHYpfWAsIERlbHRhU3R5bGUuVW5jaGFuZ2VkKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcnQgKC4uLmdzOiBTVkdFbGVtZW50W10pOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwic3ZnXCIsIHZlcnQpXG4gICBsZXQgaGVpZ2h0X3N1bTogbnVtYmVyID0gMCxcbiAgICAgICB3aWR0aF9tYXg6IG51bWJlciA9IDBcbiAgIGdzLmZvckVhY2goKGfKuTogU1ZHRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgZ8q5LnNldEF0dHJpYnV0ZShcInlcIiwgYCR7aGVpZ2h0X3N1bX1gKVxuICAgICAgZ8q5LnNldEF0dHJpYnV0ZShcInhcIiwgYDBgKVxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH06IERpbWVuc2lvbnMgPSBfX2RpbWVuc2lvbnMuZ2V0KGfKuSkhXG4gICAgICBoZWlnaHRfc3VtICs9IGhlaWdodFxuICAgICAgd2lkdGhfbWF4ID0gTWF0aC5tYXgod2lkdGhfbWF4LCB3aWR0aClcbiAgICAgIGcuYXBwZW5kQ2hpbGQoZ8q5KVxuICAgfSlcbiAgIF9fZGltZW5zaW9ucy5zZXQoZywgeyB3aWR0aDogd2lkdGhfbWF4LCBoZWlnaHQ6IGhlaWdodF9zdW0gfSlcbiAgIHJldHVybiBnXG59XG5cbmV4cG9ydCBlbnVtIERlbHRhU3R5bGUge1xuICAgTmV3ID0gXCJuZXdcIixcbiAgIENoYW5nZWQgPSBcImNoYW5nZWRcIixcbiAgIFVuY2hhbmdlZCA9IFwidW5jaGFuZ2VkXCJcbn1cblxuLy8gRGVsdGEtc3R5bGluZyBmb3IgdGhlIGNvbnN0cnVjdG9yIGNvbXBvbmVudCBvZiBhIHZhbHVlIChub3QgaXRzIGNoaWxkIHBvaW50ZXJzKS4gSW4gcGFydGljdWxhciwgcHJpbWl0aXZlcyBhcHBlYXIgY2hhbmdlZFxuLy8gaWZmIHRoZWlyIHZhbHVlIGhhcyBjaGFuZ2VkLCB3aGVyZWFzIG5vbi1wcmltaXRpdmVzIGFwcGVhciBjaGFuZ2VkIGlmZiByZWNsYXNzaWZpZWQuIENoYW5nZXMgdG8gY2hpbGQgcG9pbnRlcnMgbXVzdCBiZVxuLy8gdmlzdWFsaXNlZCBzZXBhcmF0ZWx5LlxuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhU3R5bGUgKHY6IFZhbHVlKTogRGVsdGFTdHlsZSB7XG4gICBpZiAodmVyc2lvbmVkKHYpKSB7XG4gICAgICBpZiAodi5fX+G6nyBpbnN0YW5jZW9mIE5ldykge1xuICAgICAgICAgcmV0dXJuIERlbHRhU3R5bGUuTmV3XG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh2Ll9f4bqfIGluc3RhbmNlb2YgQ2hhbmdlKSB7XG4gICAgICAgICBpZiAoT2JqZWN0LmtleXModi5fX+G6ny5jaGFuZ2VkKS5sZW5ndGggPiAwICYmIGlzUHJpbSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIERlbHRhU3R5bGUuQ2hhbmdlZFxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZWx0YVN0eWxlLlVuY2hhbmdlZFxuICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodi5fX+G6nyBpbnN0YW5jZW9mIFJlY2xhc3NpZnkpIHtcbiAgICAgICAgIHJldHVybiBEZWx0YVN0eWxlLkNoYW5nZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn0gXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTpmb250L3dvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFGM1lBQklBQUFBQXc4QUFBUUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUJkdkFBQUFCd0FBQUFjY3EvajBrZEVSVVlBQUZoa0FBQUFIUUFBQUI0QUpnR3pSMUJQVXdBQVd2d0FBQUsrQUFBRnlrVVVzUXBIVTFWQ0FBQlloQUFBQW5VQUFBUVFpcG12dGs5VEx6SUFBQUlRQUFBQVdRQUFBR0JxK0dRclkyMWhjQUFBQkxBQUFBSk9BQUFEVGxNbWJWMWpkblFnQUFBSVFBQUFBQ0lBQUFBaUFKZ0lLbVp3WjIwQUFBY0FBQUFBOXdBQUFXR1NRZHI2WjJGemNBQUFXRlFBQUFBUUFBQUFFQUFiQUFsbmJIbG1BQUFMdUFBQVEvUUFBSmRJaEsrdCttaGxZV1FBQUFHVUFBQUFOZ0FBQURZQkV4VWhhR2hsWVFBQUFjd0FBQUFoQUFBQUpBWWJCUk5vYlhSNEFBQUNiQUFBQWtJQUFBYXl1NnJnVW14dlkyRUFBQWhrQUFBRFVRQUFBMXpKUk83aWJXRjRjQUFBQWZBQUFBQWdBQUFBSUFQSEFmbHVZVzFsQUFCUHJBQUFBdklBQUFhb1ZuSUxOSEJ2YzNRQUFGS2dBQUFGc2dBQUNtbG52cFREY0hKbGNBQUFCL2dBQUFCSEFBQUFUTkttVGhvQUFRQUFBQUVGSG5XWmxieGZEenoxQUI4RERBQUFBQURPNldtSEFBQUFBTSt1WkRuK3JQOU1CSndDN2dBQUFBZ0FBZ0FBQUFBQUFIaWNZMkJrWUdDNjhGK0FnWUhsemI4MS83Tlk1akFBUlpBQjR4b0FvMkFITkFBQUFBQUJBQUFCclFCTkFBUUFWZ0FIQUFFQUFBQUFBQW9BQUFJQUFWUUFCQUFCZUp4allHYmN3emlCZ1pXQmdhbWZ5Wk9CZ1dFYWxON0NZTVJ3Q1NqS3hzck16TXJLeE1LeWdJRWgzNEdCd1pzQkNrSThnL3daSEJoNGY3TXdYZmd2QUZSNWdlR0RBZ1BEWkpBYzR4SW1HU0Nsd01BQ0FNRVVEdVVBQUFCNG5JMVZzWW9iUVF6VnJLOXlEbkxGRXM1d21EUkhYQXhwazhKMVNKRVB5Q2ZNaCtRVC9BbGJYcEhpT0VLcUs5eGRZMGdJV3hvVFVvUXRVaTBCQjAvZVNKbzVlZTJZR0I3YWtVWWp6Wk5HZGczSjc5YklYelJ6bmk3ZG1zZzFjVHY2UUhYMW5tcllMcUYvQlpBTDhYZXlZMjhOWkIrQ2p0ZXVvVEZBaWpycCtUdkpCOTd6aG4zV2JDTUcvS3RWMHNWbFdsZFhOQUVvMjVIREJDQ0pGOXRzZzAreXNiM3N1NUxjZFUzcHpORjVYSXFQbkk5NGMrZGpxL2ZwY09aSG5EM09maVp2dVpQbXF2RzcvSjNpYTQ1MWtaNzlwOEpKN0hGbVd5MFFTemh0WFpEN3duK3VlelAzTHpUdVRNNktQZTlKM1BuWWo4NXh4NEQ4aEV1T3p6cVB2TDNtRVFTd1RiR2U2NzRaOEV4cnc3V29GcEk3L05QWlcrSGxFTldLZVp1VU9xMXo3TVNaMUFMWUpHNXpIWWF3OWJNb3RWaVRZOTZQQUx4dE5lYzltUGlibE1NZS80ZFFQV3BoMFppYXBGd2E1Y0ZJdmp2aW5aQ3BWMnZ0eDlyMHprbXB2SnlTdWU4ejN4dEZwL2dPL05EM1YyRHEwOUlYcWN1amJsK1dudkhGcHgvR1BTS1A1anQ2aS9xdWxBZlBuT3hKcVNkNjhsL1M1aFBNVEpBKzZmOVg4anRmbEhxMnBjZkM0T3lnZFIvRUIyY2Q1eUU0dzd0OEN2bWN2aFhkbEdoM1R4UXZJTzhVV084K1ErY2did0RzM24wVlczeEM4N2pFOXgvZ0o5YXZjNDVEV1hKdTVGM3lUTGpWdDV4ekNweHJyWFBtR3ZlZW5YVmxEaE5pdmVRK0M4ejlHUE5iYXB2MDV2M3kzRndkOWdYUGhIdEIvcll5KzJacHVMaFJXRTQrQWZHUmovaU9aMXlhTi9tL3hPc005R1Vta3M0cDRjQ3NpZjRDVDd2anhnQUFlSnl0azFkUGxFRVVocCt6SDY2SWlFcFJCRnlIVlJHc29DS0NEWkhlRlJWN0Y1SGVqS0JDaklxOUVtdXNzUmZFRW51Tm1PaU5QOEFiaFkvNEN5eFhKdnM1N25wQnZQREtrOHlaTTVPWmQyYWVjd1l3OExRd1JIc2tXWS9FUGZhU1NOMm5ra2dQN0RycVE1UEVTYm8wU1lzdDFCWm5lMi83WkhnWjNvYXY0VzhFR1pHT1pzYzNGYWhDbEVNNVZZU0tWZ2txV1ZXcE90VWE3blQ2TzROK2Vsblc3eE8wanVLQ3hFdW0xZ25XT3U5c0h3ME11K0hqMW9sd2JIVjhWUUVxV0lVcDVkYUovMHNIcldOWVA2d3YxbHVyM1hwanRWbFJscDlycTZ2S2xldktjV1c3MGx3cHJ0aXV6MTAxWm9HWmIrYVp1V2FXbVdRbW1ER20zVFE2UDNRV2RoUjNGTm0zZU43N0g4eHU4M0dUODNEc2JvTHRUMlRqMythNWk1ZWJkRSs4NllVUHZmSFZyUHpvU3ovNjQwOEFnUVF4Z0lFRU00Z1FRbldPQnVOZ2lPWVpqcE9oREdNNEVZd2draWhHTW9yUmpHRXM0NGdtaHZGTVlDS3hUQ0tPeWNTVHdCU21NbzNwek5BWm5ra1NzMGdtUmVjN2pYUXl5Q1NMYkhMSUpZOThaak9IQXVZeWova1Vzb0NGTEdJeFMxaktNcGF6Z3BXczB2ZmZ4Vzcyc3Aram5PSThsN25FRmE1eGxldmNwSlZiM0thTnU5emhIdmQ1d0NNZThwaW5QT0VsTDNqRmE2bWdsclVVVVNKVk5IQ1Jhc3FrZ1kyVWF1MDluTmErenMycG1QcHU3TXBwMVA0R3o5bkdHaW8xekVUM2ZJV3UxMnBXczUyZG5KUUFDWlFpV1NlbFVpYkZzcDVuZWtXN3JzSU5VaSsxVWllTnVxNHIyU1FsVWk0MU5IT0FIUnhrSDRjNVFndUhPTTRKdmVNWVp6bkhHYjVMcW1SVG8zOURobVN5V1hJa1M5SitBWDIybHNFQUFIaWNYWkE5VHNRd0VJVmpFaFp5QXlRTHlTTnJLVmEyNktsU09KRlFtckNoOERUOFNMc1MyVHNncGFGeHdWbmVkaWx6TVFUZUJGWkE0L0Y3by9uMFpwQ1lHbm5qOTBLODh5QSszK0F1OTNuNitHQWhqRkpsNXlDZUxFNE14SW9zVXFNcXBNdHE3VFdyb01MdEpxaEt2VHh2a0MybkdodmJ3TmNLU2V1NytONTdRc0h5K04weTMxaGtCMHcyWVFKSHdPNGJzSnNBY2Y3RDR0VFVDdWxWNCs4OGVpZFJPSlpFcXNUWWVJeE9FclBGNHBneDF0ZnVZazU3WnJCWVdaelBoTmFqa0VnNGhGbHBRaCtDREhHREh6MysxWU5JL2h2RmJ5TmVvQnhFMzB5ZFhwTThHSm8weFlUc0xISlR0NzZNRVludEYrVmdhMXdBZUp6YndLRE5zSW1Sa1VtYmNSTVRpTnpPNUdGbm9Dekt3S0hOc0ozUkQ4YmN4TXpPcnIyQlFjRzFObFBDWlpNQk8yUHhwZ0pPSU1IUEN5UVMrSUdFUHBBQUFFUWdFTllBQUJBQU53QThBQUFBQ3Y5TUFBb0F0QUFLQVo4QUR3SGdBQW9DSEFBS0FsZ0FDZ0FBZUp3OXdtOUlHZ3NBQUhCVE16TnphdVpNTGUzdXZEdlA4ODd1djZkenpsZW1kekZrU01RWUlVUGlFZkdRUjRRTVB6eEVJdlpCWWtnTWlaREhpSWg0aklpUUVURWlIaVAyUWNZai9CQVI4UmdTajVDUWlCangzcWZINzZkUUtDci8rMHR4MFRYZDlhV3JxU3dwcThvRDVibktxbUpVY2RXMGFrVzFvYnBWVzlXejZnTjFxeHZ1cm5SLzBrUTFWYzE5ajlDVDdsbnNXZFhxdEZ2YW05NTA3OGZlYXgyankrdk8rOGI3RnZ1MjlGcTlxUDlkZjlNLzFiL2EvOTJRTW53eFBEeWFmbFF4S28wTHhycXhaVEtZSUZQQ2xEVVZUTXVtdHZtbGVYOEFHbGdadUxjVUxmOE00b09sd2FaVmJTMWJyeDdISHUvYlVGdk8xaG9hSDNvLzFMUkg3UjhjZW9mb0tEbHFqaXNuK3AvWHp2b3dNRHczZkRHaUhpbVB2SGZwWEl1dTMxenZYRlUzNDQ2NGkrNXRkMmQwYmpRMzJoaTlBOHlBRStDQU44QXlzQVpzQXZ1Z0JYU0RPQ2lBNDJBS2ZBWCtDWDREejhFcjhCWlNRZ2JJRHNFUUJZbFFISG9CelVMejBCSlVoR29leUJQd2hEMEpUOXFUOGRUaE5KeUJGK0E4WElKWDRYVWtqcnhBWnBGNVpBa3BJbVdraW13aXV5aURSdEVwZEFiTm9qbTBnTzU2R1cvVU8rV2Q4V2E5T1cvYit3UFRZaGJNamVGWURkdkI2dGd4MXNET3NCYlc4U2w4ZXAvTkIvbnl2bHRjaVJ0d093N2pGQjdCSmZ3U3Y4YnYvUnEvMlQvaXgveWNQK1ovN24vcG4vUC9TdWlJSWxFbXFzUW1zVXNjRWlmRUtYRkpYSk4yRWlZcE1rSks1RFQ1bXZ5RmZFTXVrKy9JRFhLYnZBbFFnVUxnSkhBYXVBeGNCKzdITkdQbXNhV3hCMHBIV1NtQUlpaVJpbE43OUJROVEyZnBIRjJnVitnS1hhTjM2RHA5VERmb003cEZkeGdGbzJkc1RJbHBzQWsyeldiWUJUYlBsdGhWZHAzZFl2Zll6OXdNbCtWeVhJRmI0U3BjamR2aDZ0d3gxK0RPdUJZdjhPTjhpbi9GLzh6L3dkZjVJLzRyZjhwZjhGZDhoMzhRbklJb3pBcHJ3a2ZoZTFBWkZJSnp3YlhnY2ZBODJCR05Za3BjRjdmRVBmR3orRlZzaW4rTGJmRkh5QkJ5aDRUUTgxQW10QkRLaDBxaGc3QTJUSVhYd3R2aHcvQzNjUHVKOUdRcG9vNnNSM1lpZTA4elR5K2o4OC93WjUyWU5tYU1RYkh5VDRGeDg0UnpBcDFnNG9iNHcrVHU1T0hrU1NLYnRDU0paQ0k1bjN5YlBFcmVTUWFKa2RMU2huUWtOYVVMcVNXMXBUdFpJV3RsbzJ5VFlabVJZM0pLenNnNSthMzg0VjhCZkJUOEFBQUFlSnpGdlF0NEc5ZDFJRHgzQUJBRVNSQ0Q5NU1BU0pBQStDWUJBZ09TNEZNVVNZbDZVQytUbGt4SmxtU0xjbXpMbG1VTGR1TEVVVzJMY2VWSFlzV2lFMitxYlpTSEhEY0dJVVFOOHplUDNXWmJOMS8rRmszZE5IOVgyeXJkSk4yMlNhdmRPUDNhSkFiMzNETVB6RUNnek9SdmQyMlI0TDI0TTNQdnVlZWU5em5EYUJqNGp5eXlQcWFXNldXR21BOHdXV2J6ZkxheDI3dlNhQmkrRXh2VjBLZzJpZzBXR3F4bStNNnJYV1JRMjU2dDVsWnM1SjM4RmR1cWpWMFl0VmZiWExhb0xXV2J0czNiRm0wWjI1SnQyVmF6a0dXNWxRUjVaOVN1VHpnVGtRU2ZtRXJNSlk0bnppVE9KUzRtYWhieW4wMWNTN0FMUGIwdHRsQmpVOExjRjIrTTJUWERKTkhYeFlhYXF2UlZkcHNqSHVPSFNUem1zTnVxOVBXa2dkQ2VaRUl2ZlBTRllSaFo5QmIveE9janZkNTgzNFE1Mk4zWW10YlgxdGZvOUZVdERWMU5YU0didFo2cjU2YWNGb3ZMWmJFNHZWNHYrWkhYVy95ZlZSTXhSN3ZmYXRNYmpMVVdscTBQdVlKQkRXdXNIemZWMVprZU1MdGNacmlBWVprb0FPcDVnSk9HTVRHVEFwUVlnQVVqQWNZSURTTUFaa1ZQM3JsMlJuOU9mMUd2V2JpMlUzOUlmeEwrR0RYbzlVNTlSTS9ydGJCZS9UVTlYYTgxcmducCs1TENza0pONGRpc0tlYjJ1cHhlbjh2cFlYM0ZGeDUzK2J4T2w5ZkxySzB4TG5LSytSNGI1c0t3VXd4WHhkUm02TmF4dUg5dmtodU1sd2t3SHhIbVpZZXAyR3ZGZWJtaDRaWWFlbWpvTldLakZocTFkQ3UxUkFkYjZlYXk1UG9LUTk3SjZybXM1bnBXeDJVTkJmcmJXTWhxdUt5cGtPVUtXY0psellXc3BaQmx1S3dWZnp1aG44djZDdGtHNk9leS9rSTJVT2pwSmZxUVBnNC9JUjUvK0RqK3hQWHdZeUxRSUcvcUR0VHQxKzAzSm8wWitLRi93VTk5b2o1VG42ei9lcVl1UXc3R01yR3o4Si80OFhxRzBhejlZdTJ6NUFIMk1hYVJDVFB0ekNGaHRTWlloa25hQlFzMExGS0RRSU5JcXcxQ0kwZ2JoRnVwaGtWYXVCVTNlU2ZYVEV4bVN6L2djYmFsa0dzVkdnQ0pObGlETXhHT0pPSjJoelBSQmJpWTVQRnZld2g2N1g1Q0VkSE85MFhzU1kzTm1hajY2TmFwZEtScjY3YXQyL2lac1hSeng5eU9PM1llTzNiczVyNTkrL2V6RFE5TUdjblhIWk9EQTlzTSsvZHJHdTZmcW1QL0gvY1VQekd0My8ramNjOUtEZGsxNm42akJuWVM5dG5HTUpvKzFzZUZ5V093enhIeUtMa01uM3J5R0xteHRoMndENzVuZllDSFVUaXZhZVoxeFhtVmxtMkdobGxhdGdNYURtR1ROYkRKc0pGVmhheVpXNm5EODFqbnJJdlU4WFZUZFhOMXgrdk8xSjJydTFoSHoyUGR0VHAySVZ0ZnlOWjNaeHZ4N09hdkpGWVRlTUlUcmtRMGtVcE1KK1lUaTRsTVlpbXhERWM0MStwSVVNalZjOW11UW02d3F4RWFPVy9ySVAySTRBZWM3aVFmQWhDR3F2UitPTW04bldKOGhQNUs5UEVJWVBGNE95TGlnUS96ZUxDaDRVeVNURE9idkJUWDlRTHdqZlZtV3lnV25UaXgrL2lwOXNEc2VIcnJRSHJ2Ui9aTzhqUDhMbnRIS05UbGJkLy9VcktmNTNkc0N0blllRld3ZVdMbitGeTZQUkZJVEF3azJzZWJkaVhiUnJvUzNadC80VzhNQmh4dDBSNDRRbmkrRHJOaGdMQzE3SFN6MStsUjFZZGMwMXlVRGVkaExMKzJqYm5KempNR3BvRXBuU3VUa2tUcWh1L3M2ZVZ0emhCZFhyd3FrMGsvK1dRNjgvWVBMdWUrODJkZnVnejNZT0FlcThwNzRHVW01VUVWN3RFWGlRTmM5S0drZEk4Ymw3LzBaOS9Kd1QzVy9vWDVWeEtIT2RjemZXVnpycnFlSTFVTUJiOWUrS2pSRTdwQk5WeFdpNmZZQ0FodTFmTk9wRW9SUHNJN0kxK3VmOVQyb1R0VEkyUEp1US9hejNCcytLbkV1T05JOUpGSG9rZGNvNG1uNkp3Wkc3bE1yZ0lGc2pOWENXRUFvZUJXT3FRRGVyamhFSW5ERHNNZXd5bkpwL1A1OUZ0OFBnLy9LSHh0YTU5bG5tZU9BWHlybVJ6UmFOcmhnQUZCc0VWM2plMy8ydGVRak1IUEtwTm5ic0lZQTcwL3E0VkJGR1h5K1pzOC9SNXBNSE1QUEw5ZldLOEIxbXVnUkZkRGlhN21uT2FpaGhKZHpTSE5TUTBTWFkxVEU5SHdHa3AwTmRjMGxPanlDb0libFlodHIwUm82YjU4bHJoZ1h6UU1wNENwaVc0RnBkZlgwOWZUN1B5N081RDJ3bGtrTHdIdHJXV2N6TDNDYUEyTTFramtWcDZlQ1UrYnlXbUttSGpUbEduT2ROeDB4blRPZE5GRVQ1dnBtZ2xPbTRaYnNkTnpabCsxNHptenUreFJlOG8rYlorM0w5b3o5aVg3c3IybWJQcThndjNaN3J0eno3MG41dTY0ZDJ4OE1EMDJOSklldi9uZzJRL2VmL0xjMHlmbmo5MDd0L2Z1Z3doZmhzbkFmSFZNYzRYWjRrSXAzWUNwRVBKT1QyL2NEQWZXbkU1bnlCVytHSVRyZ1VTUnZYQzlnOW1xb0wyM1hHOUNDcHUvVXIxYWpVdXBkbFZIcTFQVjA5WHoxWXZWbWVxbDZ1VnFFQW9ZWEhCUGJ5dEpVRjRQaTlBRDJraFVJRTcyRnE4OW1XbVBkN1VNVE8zWXZQdXhlMjkySDM1NW9MSEQwai9YUHRZLy90b3UzS3NsbkUrWTJTWE14d1ZUY01GOHJyS2tHWkRUeGEyWTZVVE1xMmFjaU5sbGpwcFQ1bW56dkhuUm5ERXZtWmZOUUx1cW04MENDd0JDL0U3T1gxMkQ1TW91d3JhZEpDUWdsK2FuRnpoQXFDa3lPajQrdldrODVPZ2Y2dW5xamd4czNyRmw3dTZoVFdjT2pnKzFPMFlHKzFPSkZOL1paVTNOdFc4YnZhdU5tR1pTczBkdEF0OWUreWI1QU15OUJ1U0pKdlZ1WEszRG8xV25QRnBBTzYxeE14NnRTRHdSMHQrOCtZdmUyZG4wNy93Tys0V3hIbkt5dU13L21YLzNGM2pPQkppNG1VNm14T1lGbURpMTdWZk5wRnJibnVPcXlVSzJsbHN4d29vNU13SEVjc3E0cERjM3dtTmtOSXZZVWoyYloyYTJoMXFKNjN0bTYrSEZ4Ky91aTNWWnQwMXQzbHhGYXZoWDJjTjNIWHpJVkRvUGNIWWN3S0VmRnA1dWc2ZmJURXBtSkRYcW9WRlBPVk0xQ2NKcUhSektIbXdoVjFWdm94VHJFSjFpUGJmaXdiUGpjWG9pSHQ0ejVabnpIUGVjOFp6elhQVFFzK081NW1FWGNvZUNkQVdFbmdPOXMzUStrS2M0Q1dVM3dzcklZclBuK0gwNlRYcnY5TjFIOXgwNGNlRTNmSTNGZjlTTnArT2JocE16YklQMmc0K1RrY1BUTzA0OWYvYlZySzc0Vzd0UFRBd21ONHUwQ2VDNkNIRGxZSldsd3cxd1hkRlJMSFlPYTNoSzlocnQ5UnI5L1d4TGNqVHdULzFrTVRnYWF5U1o2UXN2bkUzTW5PM2luM3BoV2VUaENDY243SHduOHd4VEVsMGs0RlJCbzRxZUpSQlR3aFNGdzZ0aFJPR3dLeHdOcDhMVDRmbndZamdUWGdvdmh3R0ZHNnZDRklXcnVCVXZRc3ZyOUVhOHZIZktPK2M5N2ozalBlZTk2S1hROGw3ekFyUTZ2SFJ3am1uc29CKzErQUhRRXpHYThxdEVpUitiaUVSa0lsVktmbXdaSFg3d2pyM0hIay94SjNadlAzejZxeU9ENllueDNmZitkQ3pSTno0OWZvU2tBak85RTNmdUc3dG5rRzJZN0JqWnZXMW8vK0NscmtReTBqNFk3djJ2MGU3T1VPdGdvSnZpRE1EMUphUXBqY3dNVThJTUFXTnRnTEZCaXJHZ1EyUVpPQTNkSWtya3IzaFdQUWdSajhzVDlhUTgwNTU1ejZJbjQxbnlMSHRxSkh6bUl6SWVpTWhNdW9pd2huZ3MzZVMvZDFHbkdkaTc5ZkRSdlF1TEwzL1kzMFFzMmsxRHlaRjBhbHRhOThUN3lkRGRNenNmK01qWlQ3MVpSUTdOSDl1Y1RFMEpNdmNrL1A0Q3lHV1U3aitpb0lTR2NycS9VYlpFU1NhbC9wVEtzd3NTRXpCSVRFQUxmNC9hWisySDdRL0IzMm9tWUZiOFBTbnhzM0srUnZaSkRBN25Id1ZlTE16ZnhJd3JhQS9NUDJjMGFhaVl1R0lBUkRJc0dqS0dKY095QVNaNnhiQnF3RGtaWElhb0lVVzdSZzJ6QnRSakZGUFFBRStYcCtFSDVrNGVFaDlkM0Fac0h1Z1Q0d2NaNGdxamwvaXJEcDZzTTZDb283TzNKRnJzdWxtZy9RK1JsNHB2ZlA5Yyt2WGtGOUpMZ3A3ekpGeTNGVTZQSG1qYlZSM1JBbXFnREpJYlpjaENicFJRR21DR0E2aURIM0s1ZUJjTXQvTDhLend2eWhaK3dEUEZjMUhld3VkMmtvUU9ybXFCeDc0QmozMkk3UDNoVXZvTHlkZlQ1d1Q5aXZrWnlOdGVKc0k4S1Z6SndaV2NKRzIzUUtPRm5sU09XNm1sZUZtN1dvdDRXZXVxamRhbWFxZHI1MnNYYXpPMVM3WEx0WEJTalMwY3lzYjRrVzNoVmdJVVJRTG5BaGNERkVVQ2h3SW5BNGdpQVdjZ0V1QURGRVVDMXdJb3VWQkU1aVZlS1hQS2VqaTNUcVVhT1ZZVDh2b2J1enM2T21NOVk3dWJRdzBoM1l5MEk2ODczQTFkRGxkSFF5aGlTVnJIQmxyN1BZNU9iNTM1OFRMOFdHTHZoelBaeFF3d3J6SWxJMEJ0R2VuR2hoVWFWa3JITzZqQWR0Vk5lbUZMelBYVmRKbWNXNkRoUWFSS1FXY3dFdVNEVThHNTRQSGdtZUM1NE1VZ3BVckJhMEU0QWRVYkluUmNMOXd3eUdWNVlJbTY4ck1kS2hGOWFqU1FaU05CbmRESWZ5WjU4czYrM1I5NTdUTWZlZjhuNzlnMG85ZEVOM1hHRG16dkdERG93cUg0bWFNUFBQUEVZenQyMzk5ZzdlV2R6dENBL3BENzViUFBmdlhWMC9QdlAzQmd5OWlCVTVaVGd3MFR1eWFQbmJud3lJa24zR1NpYXRkRVc4ZUpDWVRkMmpjQjJXNEF2cGhBajVoVllIaEZwVlFpRkZldHhJakNOUEpBVFlFSzZmcEN0cnFRclMxazY2Z1d2c0pSTHNNRGg0bGI0WC82R1FucHJhQmxaL0w4bHpmbGsvbmhucmU3UDZuZCt3YlA4K1NIUlMvUG56MUxmdXRITUNmQnh2TVN6TW5LK0pnV1pxOHdxenA0ZHAyeGpOOWNiU0FlMkw1dUQ1eW83Z2I0eFhnYVJNNUNsZVk2bEpHb3Rtd3JVSjBmMUlsUUlkdGNrTmdIRlphbzBJZzdZaUtpQUdXM1NuK1EwRUQ4dmdkVzArbmZQWEZYdFBmZUxWdEdwbWNuUmtZSGRneVNnR2x6YkdZSFQ3N0lEMCsyRDNMLzBCM3ZTYjdGckxYM2RMZThTYyt2RzM1OUc5YmdaQjVTWUdTNVdZcWlrWW1pa1duVmhHaGtjcG1pcHBScDJqUnZXalJsVEV1bVpaTmdrTElqU3RxZDlvaWR0MC9aNSt6SDdXZnM1K3dYN1JRbDdkZUEvdWFjYkxXZ3VaYndpcXIvTWthUmI4L3ZQLzM4aTQvT3phY1RteGJ1WGx5WVhZakhQL2IrRDcvUTl0d3g5OGxqOXo3YUo5cG4vaERtWFFjNjA0QXdjeTFNVm1zc3M4TGd6bXU1RlJZK0dEUzZnUDdOSXFEdEJhb0d5WEJ0Sjd3a21xYlRYM242STY5OE9Kc1pQbmIvMGZ0SEtQUSsvTUVYWCtCUFByUjRYSkQzY2QrZHpCUlRRajVqK2NHdFZpSWZpSnhWaFZ4M05VVUFJeHcyS3dJVTVwQjFGQVQ2R2txRTdGVFBrejRiWVc3a3BmVDFZK24wc2V2cDRrTnA4a1ArMG9rMzAvbXh0MDVjZ2lsSnVwMHdGN3VrT3lES0djdDBoNnRHWU1IdFZEZWdjQUNzMDhKSERUMEdPSnRjdDRVc0tLQVNEeUZjeXVZRWltZGFtbENhd2tTY0RTUGlFZHBQR3BoSGI0TkhWejNFTFpnMy82MndpVnFWZklYMWtTbUJ4aEZ5NDhEQkp5Njg4c1NCdTlLcDZhUEhUeDVMamFUejZmWjJKVmJabjBXV0pzQVUxK0psUGxUaFRLUG9YWDdBc2VHQmhvZXUwa3hKTmdVejNYa0NNR1lCdkVCN2RFaDdEQVhwd0FNcW11QmJVQlNvN2M5S2NZRWEvZ3hjMWxYSXV1bXE0ckFKU0pYTXVBNUFDdnlrR2d0WlRCZmZobFhBUDlLQm4veGJiL0YwWC9nMzMrVDU0bTVlWEF1VFJ6czBYK0dVMUVDanB1eVVWQ0dOaExPQ1U1V09pUERNdFBBYytnemgvbXZmVzF2Qys1dVpEdlcrZzVScFVzcVhzT2RWRXRMMTlPcFIraFZ2akZ3bWF1UWlRYmc5UDJVMWpaTDJYdkl0ZU1iZ3RtMmFrajJXMG44allOcXBDaGkydm9VU2xWZlJRbGxpQThycHdNcUZyUURWalZwanpRWGhJSUQ0S093SWJBUnlCc0hTcG5jMktrQkNidVRiLy95dit2TEovKzh2aS90RStQRDg5NzdMODMvNjMwcHd3dmxmeHZsWDJnZEVzQTN2QXlVTzlFazMwOFc3eEwwNGNVbkUyd3VJdCsrdlFKZlFZaTAxVkJacnljYXVJbDhVWEJxMFdsTk5qQ0p0VFNGWGgrYXVIQ2RZdlFTVE5aSXdhZ0VGekhWUlVGbEZ5TkFKYStCL3M0ekFWckx6Mm90MDV0clY5aTlyS2F3dTV1OGh2MHRoeEpPbDRoajVlakdER0Z6Y29qeUhkbWEvUXJhc3VPT3FjeWhCazFJUUJDaWVQT1daby9aMzNHamdzQUpRUTBReFR4SW5sK25zaXQvRFNXWklWQXZFbHk5NnladkZKV0dDdXdFbktjM1Q0TmxTMjZtTTVmckt2NTJkeXJxT25jcTlkT3JraDVkT1B2ak0yT0c5K3c0ZG1KODdTRXlQWDNnaDg5UXJMejkxTEpNNWR1aVJrNlZ6ZEFYbXpNSHNoeFFhdHpSblhBQ2xZVzQwbGdnMks0RjdBVjJpWGhocG4va1NZUkpteEV2aVNJWUM3ZWJkODhjUGFVWTJwY2NldWJtS01KdWUzREhMZDhkNk83NUdZUWV5Y0EvdWJhT2tLeUV4TXFMVUpraThIRXlnQmtYNS9KWEFhZ0RoRW5BRm9vRlVZRG93SDFnTVpBSkxnZVVBaFFzVldpTktjN2NkSlFrRmhOaWUxbzVQTHR6MUlBWFV5WVhoOTdXRmkyMFNyTjVuZk1MMDRzbk14MTg4ODhoSGpicDBMWm00QldhVTlnU1pWbWJoTmpCVGV3WmExd05nam1OYUJlRlBKRE42TGhzcFpLTzN3cFRhd3dJRXVycElOK25TbEVQNHlOeUw1cUJqZE9RK283TzJ5ZUwxK0t6OHlLYkJjUm5lMHg5d2FRekI4RW5lMVdwTk40WnRPcjRyVHFGUDZmWXY0TmNEc0taTzVyU3dJaWZNMjFrdU45RHBBdWFLUHJZcC9aeit1RjV3d3RWSS9yYXNrMXZ4MHgzeXIvcHhoL3d1ZjlTZjhrLzc1LzJML294L3liL3NCdzNEeFBncDVRanJuU2o3eFp2UUI0UzcwOFZHdWpSbHJOdlBPdjBhMk1kUDdkeVo3aG9lMld3S3hrTCtvWGpnZlhmdTNwUU9ENlpIekUyeEp2OVFyLy9CeGcvdE4vVTAyM3dPVzIyTnF5bmVQRGJiOU1FN3VkNG1SNFBUQ2oyTnZhSEo3UXI2YTVMb3IwcE9ralF2SkJkVkF2MFZXQVBRWDFBVXFGbWZoMjJ4aTBJUkpSV1pkQ1lOWkNLRC9QREVwVXNua05JcjZaWmJvZ29xYkVFRWtScW84NG9tRFFDMGFNQ1kwc3hwam1zRUMwZU5iTXdRajUrZ3VnaVlJNG9KSWlWUXNOT3cyTWpNVGt6dEFtUjUrT2loaCtIai85MHl1MmVhT0lDVS9mamdJL2NmSWg0UWVZaEN0NXBhanpkSkRlUzVGUm1WQUM2a3JoUldWbnc4SmYvMDh6dmFpMlA1L211YmNxbjg4Q1Q1TFNTbFA1U2VyYW1EWi9za1dVdWwxZUcrVkFTY2lzVkxnaGRWNkpCbm9aeEYwTnBDdFNyY1FaR3pnM0FseUZwbVRnMUVJazBXRk1GSWlCZitrRlpCamoyMjZVMlkvTWUxbWRBQW14OStUZnN5TENpMzZURXlWUHg5NUExM2s3R0QrQ0dzYmtqRXVSdklqNStwd0w5VVNDSGhRZWtvbHZPdlhCWEhVcXFoMEY5ek51ektHVzFWOUJ1T1c2bW5IbGhjbmNDVjNZV3NwNUR6NHZmQVBIQTFUa21LRWJSZFBYN3cvZjM1eE9sSDAvbitqMzhjL25yME5QeDFnYTdyOWRkNS9pLytndWV2WE9INTd5cHd4YzdzcWNEeDBFZGFMbHlxYVdDTnFQTGlsbFJKRG5BcnhXaVlvVEEzalVBR0U4SitPTC83WW44K0xmN2Y5Unh4L2pGQStKY3dyOCtUS3A3L1k3VWVaR1RhSytDUkxCSG9oS25VNFNSQXBpS05lS1JKSTVXcHlIVHhIZEJ3aWw4bWRhQnY5Wkw4aVV1OXhXMGdXc0g5MDZKdlVpL2RYL0pmbFlpSmpqYVVHaFoxYllseWN6NlR5YlB6L0x0SGVKU1pQNHYzMHFoc1p1Z0xjNFkwOFp2cDYrbjliRTZ5ajI4RCtabytONnFnV3lZbG5ZYm5xaDdxRkRsSW5qNDB6N09mb3MvOE1YT1RqQUo4WkR1ZGRNWXBXdWdSMVMreUowYlBwOCtQa3NJTjBsRjhHNSsvbGwxN2pXalgvaGptNmhSOWgzbUdjSVJkeURNc3gxTDdtYjdSM2toTmkyL0VZbXRyVEEyNXdiekN6b09FdUlOc1pRVGJEZVUxcDhobG9JZE5rdjlDc2hLcWlJcEtHTDFxb1NZVFVVN1AxVllqOHNPQmNGSmU0MXgxSXE5eHVweFJaOG81N1p4M0xqb3p6aVhuc2hONGpWc1lETWhGWXlhc1ZDUm9vRnhVc21RTmlyWStaNU9vSTlwbWRreHNUcC9XYXBKYjA2Ti8zdGJhT2I0ajkxeExhRFJKUGh3YTN2ejMvTkRRVVBMWnR1WndhR2ttR0J6YUlja0UxTmRRdzNpWUR6TWxBVnZsaHBFV2lDcWpSdGdtb1BLc2s0MndQRHZGenJISDJUUHNPZllpUzZrOGU0MWwwYXozM2w2K1hCMGFBa0g1cGZBQWVsdnlNaVhpSmNzZHhZSk1jL09XeWFGa3Nvc2t4N2JNblRnNk5KUE9ERlhQN3BqYTA5clhjZXFPdTk5dlpldEZ2a1g5SjR1d1QycGJrTFNJL3p1Mm9NV1JMUWNlUHJPd2FTamQwTDU1NjlicHNkRmc4UDY3NzMzWWN6QlZzMzE2ZGpZaytzY3V3MTdZbUlERVJaQTltSlRFVlZvRzBnVk5PWW1TckRUSVAzTFZPbzFJVURlQWJWYU9palJVQVdxZzJKWkFkNkxTYUJwUDJFc0x1cGtCUEdON2hyY2NPckducTROdDdSNFpIVW9OUnRoRy90Mi81dVB4VS9OSHoxaGYrZ1BMOXUzYlpyc2wzeC9kRXd2alloNVRlQjdMbHdOQ00xVzNkYmdPZ0Rwc1lnUkVuU2xtampuT25HSE9NUmNaQ25YbUdnTlFaM1cxZE1xMUcvU05pMUVsZ25EZFFCcjloRWVmNEYrTmpZeE43Vjg4dm5mTGJQRW5tckdYZFlkaXZKNXZIV3g1K01DOXA0N09CemJ2K05iOS9mRVNmZTZBUGZJeUwxYzRMU3BFdzlOaUdGWkxacmtBSWRUWVEwbGMvb3AyVllzejFycTBVVzFLTzYyZDF5NXFNOW9sN2JLV3lwcDZhbUdsZnM1cVVlZkR3QnhSQUtnUkJZQWNZNE5oSmdmNk9BV2NReXBSVWdORlIyY0hiM08yUjQ0ZG96SjNlbVk4M2tOdURGYjFkQWI1NHJkQXprN3lqdGtkZHNGUHU3Wk5QRDlOek9jVU9vMUJpWWM2c1lIMGw5S0U5emJpNTFodGtQSjVLMWNqb3VVRzdHSTFHL1BudFNRVW1DcFlZaEtVbUpnVlo3QUQ4WFh4OFBDT093NmxCL25SY2I2MVkzeDBPSlZxTlRkMG5abzdtbkVXbno1eGwzbkExazgrVjdOOXgvWWQ3YVU5L3lMc3VRL1FyN1JtazFMK2tVQ0RmajdwVkhxaDRWVUxtVG05U1V2WExwdHdCZHNEaU1RT3VrakhxZ01YNlhBNW9vNlVZOW94NzFoMFpCeExqbVVIa0NJTEp3aENzZzBsTHJNRXVza1lnb0RHclF6cG4wbjN3ejVIR3pmRnFGei93L1JQK2lmU1ArSDVIM1dHaHYrRkYvMVdlWGFZTVpUWm5jdDUyVlVqc1Fyc1MyMkFSbUZabWdoRk5hVkduNmJhUk5SdHM3bnBEOFd0NHNzOGEzUjZQRGFIeDRPODlNY2dENXlGNTV2Z0pDMHd0N0lhRk1kMFN1S2dRK0xnRm5UUmFrU2NhbWQxcEpxdm5xcWVxejVlZmFiNlhQWEZhb280MWRlcUJRWlVoMkpFQ1JsUW1ZZ29KcHJoazV5cHVxN1psYzdNU3RQMTdkbXNTWkRPSHZJOGYwS2FNU3ZxWGZOTUhlTmc3bVpLUXFKSk9VV0RVcHlSc0FERExXOFI2aG5oUkl0SUlCalI2emxKZm15TWlBWmZLdDIyeURBbTAzOXdZU0RmOTlKcjZlSmRDT1B2UDhmeS9MTlpPTDUvVCttdWJDZWxjV085RlhDMWt0cFRhVFBUZ2pvbzNGVFdCVDhGTktHVCtROFZzRVYxQmlxS0ROaVFneXhwb3dNYUhlV253MFpQUjY3T0poMFNwVG1aNWJKZStFTU1JczAyRmFoenlZczJoeEFOeWN5MnkydHd4cEZoVlR3ZTZxTUNUQ3l4ZGFkUGs5clpQd2dISmh3YTZaVS9LT0wyOTQrUGp3NzhsT2YvZTBkazlKK2xEd1ZkQUpqNGdEVzlCMHgrVGJyQW91RzIvTnl2czdCMCtsRk4rY0ZQOG9PRDBzRVg1eTNGcFYyK3hkNTNTM3pDLzRHNHRBZjM3YjNuZlhmc1BUNDJQanc0TWpMYVAxNDRjdXA5aDQ4OSt0Q0oyZDFBZ2JkUFlTelVOcHd2alFGNVJoRlJLYzBYdFNLcGdSS1RSRGpRdG5xTHpWd3dCZWRxOURvS2NpSFNGOWJwZHJvamJ0NDk1WjV6SDNlZmNaOXpYM1RUZGJxdnVZRjEyUzF1T2xnbnlPSk9pYlU2RlZLcTNwNG9pYS9VeVhSYXErMGJudDUvWW5kM0I5dlNNend4bEV4MFA0bG50YWZuNFR2dmZ0eEtYdnd2NWkyek03dmpqTXgzTDhNNnpZQlJ6MVdnaWFxbHljcEd1VHRnQXdGUlZkVWVJUngzQTlINVBiMDZSRE1sZTlVb21PcmxmRnBtcTJtSm44SXF2eUJ3MUhmL21kd281NlZhV0tPTjJjbVU5Q1NEY3I4cXlrK1NvYjlreE04YU1hSWl4K21OUW9SUzZZQ1hTQURSMm0wVGdUUnVCaHVaTUhIa2tIYmtKeWp1REExcFlENStqRm04RE5yd21Rb25RVGJJYUpCYzU2L1VyTllncUdwY05kR2FWTTEwelh6TllrMm1acWxtdVFZWXRJZGJhVVRvTnpvYkk0MTg0MVRqWE9QeHhqT041eG92TmxMb04xNXJCT2hiR2pVWStPd1JJZ210bFMyR0lZVmxNUnpwMHZnUGJCbmVuQTYxUnBOR0VJRGNzYWo3NFBiTlkrbVd0cmJCUkk4NzN1WWh2WHphY2FUZjRQRnlkbE45ZGJYRkUybElqWGdYK2czZWhvQ3ZYbS94UmtYKzhITzBlenhXd2FhSFNybTBlSlhNSjdNMFFUdlB6UnBBTEJXTUh3eUdVY0txelU1enhNeWJwOHh6NXVQbU0rWno1b3RtdW1yek5UT3Myc29ZUkl1cFlOTkxvSTNZakVoa3IvcWQzbEVRU3MrZWJmWTBobHA2WXFTV2Y2QTJ3eGZYZkc1TGdwS3J0WCttL0JmMnljVWNxS0I1SXlzMktCZFJuc1VnMmFERTZSdXFXSkhjQ25ZYkxZZitheEpTcWoxRDJCUmx4N1NnOE13TWphWXpIYUdKZHZJQUZXb0dCb1lIZnNZWC82WTdtQkxzRE4rRFh4K0FlWm9rUDdhS0o2Z29sUXhTcGYweFoyQ1FFYWpNa1BHU1JROC92elZ5dHZkU3p6MmErenZPUjJFZWZQSDdKQ0RFTWRIbnMvY2pUenFqanArNmxaeWdIVkpGVzI1cmg4elZFS1NYQ2lOa3ppcDBxZXlQTFhwNXRueEVOVzFOS0VMYWp3d0xjejlxaWwzcXZRdVg4TnpRN005L0xxempmM1ZLcXltKy9IUFozd2pyYVpBaTZWVG5FNVV2RmI1cXlpbi91a2E3bktsRzBJNFZqdElxMGZ0SEJRM3FqUjhoS2h0alNEUXlDc3R5L3NXQnJrdkpEMlFHOGgyNzJmMnhTOTBmZkl6UDkrejYxOU04LzRuWGVQNnh4M2orazUvaytkUEN2Z0J0cDNqaFYwVytTbFAzUWNOWGNTdFVCbFhaUE9lVGtka2dXTkxWb2xMT1hVVmpaRUZrZ0lWUWkzQzlSaFNCaDFsZWpVdGs3Mjl5d1hCZms4dnRjbG05WHA5Wkw2TVdlYUQ0VXZ1bURtZFZVcWQzOTNZb0VVM1VnMkU5YWp1bENzOHIyU210Z3V0Qmc3N2Z2L3J0Tk9tQVg4VzNPOG5vek5uTzRqZG16a3EyUW1wWERFa3lyRXJIUm9LbFE4T2FHWlFCMFp2Z3h0aFdFRFQ4bVA0MVNPeDRnSUVYSjJKSitFeGlEMmpHdGlyOVNEamlkM2JIa3FuMmxwYjJnV1JQajhzWENSY01pWjdYL1U0KzJmOTZSNlF2MG5tbEh6VGl3SlhldmhwR3NwdG0wTmJaVU1GdVdzcnBzQUx6QVVyR3p2L3lIYWJpV25ENkppWCs2akRTd2xKaExWMkVyZ0JEekIyWTFHWVhWaUFFbmROVjhTdVYxdkwyN2RmQ01LK0FmbC9QdUprSWM5VkEzWk5YTmNTaGJjK1pOS0lsSVZmblFCN2w1Z1NpbmNEc09pZUdTdlAyZWtKemN6QlNWdStKdXh2YXpPWkdteTloOWZSNkdscmhiNGMzYWYxdkhxZmRhTFMyZURaN0hEYjhRNUJ4SW10THpIbkFHNW9uTjZDV0FPamE4MHY2WlQwTmNkV3Y2akdjVk8vU1IvVXBQWWE0Nm1mMWgvVVA2V21JcTVOU2wxSVV0K09zTWpjdVEwNHBBaGFwWFBWWldHOFI1RWN2czdzQ3RxcXNOcXJUSit0dTFXS1lFd2JhNVN4MnRGb0NrZkIyWXlJWURZcVcwNy9NQUtJcXZWMER6Tnk1K3BuUDhNTURhVS9UNE5EQU1IL3MyUDREOXE5Y2F6aXduM1VkVEZXenhUOWlRK2tHelg3eUIrYW5uemN6WWc0TDJ2OWJtQWNxK1BmODBQQUxWakliN0ZlUEZTT3dza3doUi94VllpQ2VrY29weGxVanlpbEdsekZxVEJtbmpmUEdSV1BHdUdSY050WXM1SHBzY0owZlJjV3NqY01BUFd1ODNHeEphUjc2Ym9VZ0xoQkRJcUhvRUhkMFp1dW0vcmFlV01MODByT2FzUi8wRjVkbk5OT2thU2d5dmNQLzRLU3BxOE0vRTdQWTl2UHN2dk94eElMYmlycXpCV2o0bHhnUEU0WmR2K29udFlCeExwcUNBYlRKcWFjUGNlb2pLRUpIK0hBZnpUYkNJRTFsK3VZVGJkczhubTF0MnlLSlpIaWIvSGNpOG8xRWQxY3kyZFdkSUY4U09tYmFaandlK0JXNUw0TGpudTBlSE96dVRhVWtHUUpnMjhSOHNrTGtqU3BSc0FFYURSVFFMbXB4dUtwRGg0SEpGWENCeXVPaUFBZmxKOEIyczVxRmF5WmRRTmV0MHl5b1FuRnlkUTJJSWtwbFRvZnFQYWgwOWtMZTVBNkFWcEZ0d0pOT3RkbGdnVWFBTmFMUE1ZRzhSdW5qb2lGVDRnOFZ4YVBuejU5OE1QNTYzNGw3a3BlNlR6eDAvdno1MGQ4YlBaOVB4MzZmNTcvK2RaNy8vVmc2TnNQek13RDdORUEvZzNtcGVvRCtyUjZsRXJwalNxZjJPa2FSRHJGeGV5YWR2bjc5K3JIcjE0WFlnYlVsY2lmY3A1Zlp4TXdMOSttQ1M3dG9uSU9QMklGNGRhR3NrTCtpV2RVZzZtbGNtcWdtcFpuV3pHc1dOUm5Oa21aWkE2aG44SFZSd3RKa1IvclNMN1RHc1FYSUlGbk1VUVRXT3lxSXdYRFNKRVRWQzlLeXd5bjQzc1BFRUlsMERJd2tYWDJ0bnJIT0E3TWdIV05Id2hPWE92NHFiUEczT3BzYjhLT052RFJUNHc4MU5kc01Ebis3ZjFPb0tUa3c0WHgwZXpYdHM5YlF2dkdXSUQ4dzRUcDl5TmR1ODlyTWh2cTZoamFyRC83Z21MVzFOVkJ0UUpidTUvUmtuK2dqMGpEdXRXK3l2d2YwbnVyVzNjeGRDcGtGYVA1VkV6RUFOblZTajlEVklJa0l0cXozMXA4eGd5WEgwRitISXZTdkNMbE5EQTFaeHdmaC91cUZqMy8xcXgrLzhGVisrVGZPTGkrZi9ZMWxjbmx3MitFSEhqMDhPc0kzUjZaMnprNU9ESlA2bDc3eWxaZGUrTDNmZStHSlQzM3FpU2MvOFluaWpaYjc3eno4UHMrcG5iVXowOU83b3VnSHk2TVBydHdQcG5LdTY1VitNUDJ0ZnJDcWYwOC8yUEJRUDJwOGJYMjk2VGNhL2VINDBQUDNOTG1qcmFUb0grUy9HWXRFK3JvZkRnY2FncWVHdko3QUhwcFh5ekJwNEJHTFhKZzhndm0wanpCNWtWZmFnRnV0TVRvaDU1Q2hOR3NJdmEza2N2b3QvaC95ZUMzbUpWcXFHRXJEdFNvY1NESWprbCt0REF2Y0loWUU0RGRQRWh2RkJTRlFOSGNvUUpSb3dmRHdLNXJneGZ6a2pnTG9vdG11UWpiQVpZY0s2Nk9LVlIzNkpNZnBoTHRKRjJrbmNweE9PZW84ODhyMTZQbG85UEtlTFowRHRUWmp2RzJmeVJnMWUxeE5mYW0rcnNUUXJVajBrMWlNZE1TU3ljaFFIYXUxT1BmRWdvNEp2Nlc3cVNua2Z3YnptcW0vOVVlc0JTQy9XL0szVWdrVFpDY2hMaTJ0OXRJTE1OeW85Y204enZJM0pSS2I2QThmOHZ0RDlJZGNwaDE5RXhOOWdVZ2tFQXlIeGJncHY1alhTcTNWVjQya1Rzb3RVZWUzbWhPbC9GWTlTTG1ZNDVxSFM3VjhKZ1AvZmlUbm11U0pDOWFsenBOVXhTelIwL09yNVVtMk5GYk9rM1FWLzhmZEQ0ZWpiZjdZd0ZSNjZ0Z2QzOHgzaml4MmVMM0cvdmxnWDN2aVJEK2ptbE9MbE1XQzRhYlNuRUxRQ05GRFhJdnBnVXpJUlJFdHhHM0VFYnl4TEV0L2RhMGdhZDQrcjFKa0NiR1Juc0crQWI4OTBkVVVqdnBpL0VScWFuVHZ3UzFqUGIrdysveHVUNmZmNTNRYjI3WUVlOXI2WFN3MzNqMWdvemptQnh4N0hYMzZPMEg2WlNTNUh2Vkx1eXJXdEtKa0tBVXBxRFVjMmZ3Z0dxY0FIRHFuTHFMamRWTzZPZDF4M1JuZE9kMUZIUVdIN3BxTytyTlFQREF4R0lCcXd3OFFJYzF4TTZWYzVwTDFJUkt5cDlPdW9hRW1Tc2cwelh5L2w4Mno4OFczeDRaSmQvRmxmbWlJL3djcDcxQ0lCL01vTEtPd2I2Z1pvdmhCYjQ4aGhWUUZNdFAvODNNTCt3LytPRTBkUll2c2pxMFRPL2gzUDgwdXZQdHBnRkdVdWNROFQzUldQV01CK0Z4aWdreE9ZOUMwNTdzMUk4RFdjeWRCUThoM0cwWU05RzhENVVKd2pRTjBuRXRNRGNEMUxqaXhNajZoM0tHVDhpR2xreXZrRHZOUzduQ2VKR1BGWmNrdS9SclorMjl4M3RjamQ3YURrNU4zN0orZW1odUxkM1gyOVBTMHg4bisvWXRINWcrODc5N0RXMmFtSjZlbXh0Uzg0RFR5Z3RPVUYyQS93ODdUMmd2TUI4VGFDL1g0L1JuU3NiWmQvUDRwMWZkYStqM3pLRm1VdnkvZzkxTHRobWZGNnkrdmJhZDhGWFNqbTRDTE5KZHNXbGcvcG84WjhPQ0JtcFk3MUFLQ3U1QVZscWNobzFSVEVpSktEVkpFS1dwS2dkbkE0Y0JEQVV3R2xMUEFIUEdTQXh6enhDSktEZXJOMjZTRi9mdzkwc0pBRmhMaXFRcVdNRkFRdXFhUDByb1VGZm8vdGs3L3k2citWYm4vNDZyK0Zibi9sWFh1OHduYUwrUlowYjBBYmIxUnl1UllQODlLQ2xTNzJraThRTnJyMExDZ3NxdnIwTktTNjY0RCtIdlJhR2pxRmhJZXRLTFRUbkRSMExBOHNjYUprSXhWTVI4bUlhZG0vVXlWR1hOMTdKMkdKeTVpaGxZcFErYnNXZkxGbnlIK3VZRldmWnYxd1ZvanVOYTdnSjZKZUFrNkk0VkJxeEwydC9SL2JKMytsMVg5SzNLL0JPTWZvMCtSanU4VTc5OGhqV2ZlVXZSL1RPaW5Oa2ptdXFML1piSC9iNkQvTzNqL1R2SCs4bjNJRDJGZFZjeWZ5ZWZNaHpnUUUzRkFXS2NRcDA3dkd4Zm5VYm4vWSt2MHY2enFYNVg3MWZkZmtmdGZvZjFJeXdUOXRaYldwbUMwR2tGdGxTdGpnRzc2K2M5TC8wQU4vZnpuMmo0SC82Q0Irc0IxdU9jb1k0VlRIV0krcXFiUktoS240aVFsMFpuR2pEak1laUUwaDNxcThsZmNxMjZrZm02WE8rcE91YWZkOCs1RmQ4YTk1RjUyZzBCZzVGWjh5SVo4VGwvRXgvdW1mSE8rNDc0enZuTytpejdLaG56WGZFQzhHL0dXa3ZlQmQwcktGdFhBZVp2VGl0SWhwWnNSamNPOWRHb3IzOVhhdTJYcDVBemZFNDF2Ryt2K3UramczTUg4dmtNZC85QktBL1FiTjN1MlRIL29xVmRDVSs2WnJSKzVaNERNZVU0Vy8xUG0yS0ZVOFlwUHNhZDBML3BWZTFmZS83RjErbDlXOWEvSS9hOEkvUW82TUZUQ2RkRnYvM0dnQXphZ0JBY3JSQVdyT0x5YzhtYkhJQ1FyZDB0NGNDNWdJbFRtRWxUNlhNQXVCT2VndVU1T2JwTHk4S2dvS0l2UU5GM2tHTTBsbUV2bnYwUFRDUTVoeXN2WTlPU09tVWsrM3hicjdWZ0ZYQ05pbk1FNHM2U3dqcW5pTTljWFRqUktjVTFUQ3VPc0ZoTGxkSVZjbURFS2VsYzJpZzYwRVlwUEk2c2ppRThqcnBIb1NHcGtlbVIrWkhFa003STBzanhDdVdsY0RpTWFabkZwOWF6QVQwcU9LcVYrUHN6eXcvQkIxYzdNbWNIQlFWZnJRR2hxeXVqd0dHMmVTTVRTN0xmc25XNXJhKy9xQ2JlR3pTR3Z1ZGJzcUt1emM0WTlRREpKa3RmMmJHcXpqdlc3V2p4V2c5RnI4M2l0QnF1M3laVWNOZmFiL0M1L2c3bmE0bTV5V1J2czV1cHF6dXF4YkVrTTB2M0gyRXgySHZaL00rNy9EbktLcWRTL2M1MytXVlgvbU55L1M5WGZML2Z2VS9VL0xQZmZRZnRwTFNvcUt3QU90akRkVElMNXFzS09iVkRhOG00YnpYZTFoelQ5Q3JGdzFFR2RxOGFQYkEveUtQZEdITHc1aDNDbFQ3aXlpY3VHVWFOcEwxRGJZSXg2ZEFTNW9WemRUaWhpTEJyOUpDSnEzK0ZFQzBiVmtUK2FHQnVmUGgxbnArOUtqLzU1ZDN2UCtJNlpIZmU0Mkw2RFczWVZmNkNkK05wekxhRXRRN1hFcWozYzIxOUZ3KzNtNXNUd1ZENDBQbjUwUGpLOC9UZG5nc0daSmo5L2VtQ0ExcjRTNHRJQTFsTWkvN3NzMWNRQ09aYnU1Ulp4N3l2MzcxeW5mMWJWM3kvMzcxUHhQenIrSGZIK1N2NVg2dCtwNG5PbC9sa1ZYK3lYKy9laHRGeXFpK0tCN1YycUVJMnVNZ0dyNG5sVWhhWGtpaWsyS3NYa1NEM0cwbUIwSU9PRlgwNnZUZlQ2djdlVG1vYXdoK0ZjbHppRGFGR0NYcjFUU3BRSDdoRCt5T1RnL0psdFU0R1IrNDdldFcveHdmM3hidGJhdDZ0bmZHeHlZR2hJeTVOdkpZSXNyNGtudzkxSDNqajFHdy9zbXJ2SFFYWjJEQjBjR3grZDJYVlBZd1AxQzRneXdCZngzTzBXejExcFQxNUNXTzY1WlcrVi9Udlg2WjlWOVkvSi9lcjc5OHY5dU9lWUUyOVQ2UHgyNXFvR2pUWVlnQ1pZQU5SQkxSSFE5MXNVN2QvMk9CMGVyOVBoL20xeXVWaVVHdU11cjhmaDlIZyt3Zk5mRnYrazlWN1cvb2E4UlA1ekJSbEJGUTFuK0w4bEkvQ1ZaUVFNbm5VaUZ1Z2R0Z2YzcGFMaDVranlmWGVrV2lQTlVYN004L21HdHY3eHB3WkgzSjl2S0J3NTVlWmQvY2tqeHg3MXBGeUQvQVBUMForYXAvNXB4L2JONFhjc2VEWUUyenpkdHp2RmZmNUV4ZjZkNi9UUHF2cjc1ZjU5WWovNlgzSDhnbmlmWjBXNzlqYTVKdEduS25qMlZPNTdWZUNyN0c3V1lnR0wvSlhnYWhCQkhuUUZvOEZVY0RvNEgxd01ab0pMd2VWZ2pSVDdxazV1WVpBK2l5R3U3eEcwQXlmU3JnbzJra3gzVnJ1czRHYUUySGdhYjRUNW5rTFFVWktkdjlGeGF1NElqVGZpYVJwRjhjZS9ORy9adFdWUENTNzlNbHoyVWJqSTh0UnpzbDUxVWFTRkFyK3p5UHh1dDhnSHkvV3daZFg0RXAvZGcvd1I5RE40N2czTWx3b3lUMWZRejlBOXJxdWtyTWxGTVlKb1VLNVFGTVBHYlNCeUxXZTI2WVNJcnBXR3N0b1pWU3BkbVZjWDBqZ3liT2ZzRGsrZ3FmZStQblZGamRaT203VTJib3BHWnphOUtOVFdvT3VIZFo1Q25pV3NmNEVXUEJCMERkRGxDckl1SjhtOUpkNDBwYUpyNWVOZlhtZjhyR3I4TlhuOHE2cnh3L0w0dmV2Yy84STY5NTlYNklwL2lPT2o0dmdTUGYxWGRwNExNOVBZdng5MUtGYlM4UmdPNVBBN0tuZzI1WFFaRGRiczZhWTFlN28xSUYyTFJSNk1nZ05XOEtScHhjSUNORm5CZzhLS1Q2aUJocTR6VWZwT0RMS1M3STNCa2VuME4xNzYrS2VmLzFJNnZmbGs1c0hNWkNiek0zNjFWQTlqbFpkNThXWGt4UzBTSlZiUkExV0VtaXI3dkdRUnBQVlJVZTYrSmRDd2dkS0podFVHcEJNTnJvWm9RNnBodW1HK1liRWgwN0RVc054UVF3TU5HOFEwRERucTFZVyt3eENONUxDTGdmM3F2QXk2Y0dXZysySTZyY3JPeUdUay9JejV5Vmh4am8vSEg1NjcrekhyM3Roa3NXalp0bTNyenU2Uy92K2NyUDlmVk1sRkZsa3UycjJPSFdGNUhmbHFqMnI4TlhuOHE2cnh3L0o0Q1NjRjJ1eVR4eStRYnpQSy9JUW13TDNmVlZpclZZRkE1U0dnVjBQRUorUmh2N2VSTnFldmNZazd0b0dzQnM2Q1dRMU53alV1YnFXRjduTExhZ3Z1Y291ckpkcVNhcGx1bVc5WmJNbTBMTFVzdDJDK1FqbVJLY3RNZ2E4aWdoaDljRllpT0VQRUU3aFRUbFBaUERZU3cweVZsdEZCZ2ZBMDl5ZllhamxucGZVL1l0SktoWDI2c000K3paZG9nYWg3dDR1MDVoMWhQSVU3anA4cHB6V3E4Y3Zyak4rakduOU5IditxYXZ5d1BGNm1UV3ZiYUI2eVBQNkFhdndSZWZ5ZEpUd1Q1OU5SYmpzQUdmTUgwTDlON1A4TXdJQVZ4L3RBOW9vd2Y4aVVZdU5VVVJmR1NnUUFBK1drUmhNMG1neEt1YUdjTkZ4dHhscDFUYmZhRmZKTU5WY051TlJEczMwVXNYK1VtQWdCYWc1QlZoRG9ubEJQT1ZqSU5oWnlQYzFrSWM4MGM4M3NBczBGYmltQS9rWWpHWVg4SDJYZGxZU3E5b285VG4xVXJJOGFKb1FDTEtVU0xKbmkyK1FCbWhhMHVvcXhzbU04UDBaL25weWNWT1RETkRHdlZNZ3hVQVgweWxVNGFDTUFqWUFnTVdXWjZ4aFpXRldxREpLcnRXTGtveFg5UldMaXIzRWoyVDhBR3dvT1B3Vkh0cWtnSkFpTG5yajFjZ0RvYWpObGVUSnBjaU0yT1JsN29uOGkvVDk0L3Z1ZG9lR2Y4cnlvei8wcDJnczdSWHRoU2MvN1U5UXAzaEYxaWc1Wlgzd0w2V2luU0VlVi9SWjUvRzZ4L3dmUVgxRFlTNWZGZmxxZDY0OFZldVFlU2UvRVhGcWZQSDZCdWFub3ArZG51N29mOWRkcjh2aFhTU2NqMTlTQk02UE9GU25QQU5wZ3Jnam0rSWk2bk9DVDRzVG5NVjJsK1lFc09NeUo4Mk4yQ1AxWWUwZXdGM2VwN2NXd0h0U2ppV1Nqa2RkUFpVY1kzeTNTZy84czl3czZ3VTZ4djhSM0x1UDllNVIyYWxGLy8wZm9uNVg3L2ZKOWZQTDRBeVYrSk5vQlpzWCtEc1g5UytOZlU5QWJBOHBDd3ZqOWRMMXlMaEgxYzdtWjBRbzFBNlZLUDRMT1NUa0tadjBwTlljNnVjWVZVU2lkT2xWcEhlTDJPcHhlSDZpZXhiK1Z5dXlRUHBmUFozZjZmSDhuMTlzUjV0T0FPVVBxWExEeXJLRmZQeGZzOTB1NVlKaFRSRHBLdVdDbG1oWnlMcjRxTGt0T09vYUg1bGdiRmc3VTRFZFp4Slh3bFZINGlwRUw0OEM1MXlmRWRDbzdieGZqMlFScWQvNDgxaDc2STY2UFcrSDVUNGY3d245QjArU0ZXREhtYXdBVE0zTWs1NmtsQ3hWU1ZuR1dxdHhjZVphY1VONlFCU0ZXSS82dElWS0VXSzZHazZZb3huY0QxS1Fwd2dUeFVFMU9walB3QXdlcjFoUDN2TUgvaVRmdUxYNmZMK052c1hLYk9hWExzZzFsWndsdlJmNFpFL0gyaG54ZXZvaTZ5ZTd5ODZLNi80VjE3by95Z3VDRFJ2NFpaSTRwTXVPay9WTVZaS2tZbXc5NDdnZThxdVZLUG1zeEpTNW5xOExpeTRvcUVEMjlPa2NNaXpTcUNoMHBTM0NSVVgxOWRiQlpveWg3QkorcFNWcVFxNkZaVWZ1SW5JRXowRFVpMU9ZaUFuMUN1ZkozS2xSdFZRVnNZd3FYSkdKaXNLQ3VURDJsV3VoNzUvaXFpNkZveGV5dm5NV0xieHJ3YmtUK0JJQ1lGWXhOa1pXa1NJTWxTWkhGU1RsaVV1SmprQXhoWnBpVUtsYjhocEQrV1BLSFBTZjd3eTRxZE1LWGtJL3RVZWtENWY2MlpkWDRrazF1enpyalA3bk8rRG5SbDBQSC93dmdtUi9rMk1VSzc5akFLSHBqbWR4ZkV1Y29wdW1wNVk3YVhXZ1NTRGZOcjBhWHJrT2dyYVpDenVhb3A1QVA0R1pnNWNwS0h0eVM4cVdKOFpMbVJTNlR2Ykl6OTQzeDNZODh2WFJtKzhqSDdraW45OTUxOEJEcmsxMjZ2YjBYM3YvK2o3VVhKOU5rSUhYeTZOSEh4ZmMyWE1EOGdGYmdhcGNyUkNtcjBuSGswaXJ5dXVucTJrZzk2TTdWVGxRM25keUtCWkhINHJSRUxMeGx5akpuT1c0NVl6bG51V2loeUdPNVpnR0IwNGFEY3g3aG1pYjBkRWNvMmtaV0k0aTJFVmNrR2tsRnBpUHprY1ZJSnJJVVdZNEEyblpRZlJ2OVFRb1BRRnpwSjVEaUxnQTJPbFJrYkw3WTVyYWp2V3o4NlBUTzRrM042T2JSNGRHcCsvdlk1SkU5UjhhRzA2bkJ4L2toVnFOYkFISmQ2TjNCKzNmdUZOU1l3Wlk5ZTA3ZXQydlg5aDJmbkF3TGVmZ2lMUkxzVGNsYmZOdGF4SjA3UkJxNHRVeG1TSmJ6ZEpxUEpvOVg4blRsL1Mrc2MvOTU0ZjVpSFNvNm5oZm5nM1kwSWI4TXg4K1Y3STRWeHIrOHp2aFphVHpNOHdHY1B5LzZQajRnaklmK3ZUai9PV1gvTGZlL3NNNzk1OFgra3N5VFV2bFdxTXp6Yyt5ZkYvc1h5MlNxVkFrK29peXhHWG01VzhwaFhMOXExTDk3dWhsVjkxMzRyb0tLV1dmMHRSMlllVFp5OXpITVBPc2VDOFhLczgvZzRDcGtGS2RrdlpLcXZLbnBDd2FLaThYcWN6MlUvL2ZvQ0JZeHFDcXIyY2R5NG50eVJEbE9DUHRPeUtXNXBIanZES2dwUW9HdURKV3p2OGF2MGhwZHEvQ0hMTVBmeERpWFN3cC9zYkVTVEZYSlgzSkZWVDJ0bEowL3FmMFFjS25jVGkzTWVDZVF4ZnhKL1lmMFF2V0ZhZ3ArV3VwVjBFUDFuR2lCcytGV2JDQjExc3NZcGN3L3pLaEx5UHVBUCtKZWZLNXJLQzBvWlpsTW95c1FEUFhFM3NlZndJMDR3ZDh0NUFHcVlrUDZsYkVib3QxL1RMYjc3eExzL3VMNDUrVHhGMVhqTGZMNDNhcnhwYmlEWmRYNGtyOWh6enJqUDZFYS83QTgvbzUxeG45eW5mdlAwZkdDVElLeVZidGs2VktkcGlnMG9sSURqUkdTR0NMcjJySmw0dGVwenViWldQRWJEejFydVdBVDV0UFZvUU01VXBBeThzdUx1dWtyV3I3VVpkNm1rak9TMFd1TVZGZVgxM3piZXR5YzZCRnRYb01kTEJFcndDRWNoWGhPR1k0THBmZ1FUUjNDZlZDZ3QyeFk4c215OXlQY0Q0ajA5cDB5ZjhhUVNKOHZWL1FqemFyOEpTdnkrRmR1c1pFT2kzeEJ4Z05hUndiNkQ0cDhZVkV4L3BvOC9sWFYrR0Y1L0Y3VitOTDlMNnh6LzNrNlhxaHppekdXQVdha2dxZFpjc0ZjZFZGTkQvUzllaUgrZ0JLdjZnSXRVT0dqTnBtc254cFphRTZZRTBzQ21haDlSVS9Ud2dScEU5TW1QNlNmM2VHMXU4MnBtRTczMk9QRzZoM1RQaHZuaVhYcDYvdlRaSEZ1UWN0clUxdFNzVS9kYzFLWDFHN2IvUjlpRmZuY2dYWDRuTlJmenJjT3JNTzNEb2pycDNWSE1waWZPN2ZScWlQL1ArdU5LR3FNS0VxTDRCd0JOMjlpUFBLc0VQT3U2cHVYKzdUUTkyUHMyeVAzbWFEdkJEdU1tRkF2OWdXaHI4QStqTlJHdmgrczl6ekc1aTR3YnltZThVL3NHRkpKYVp5ZjNDQk4rSXc1TWY2ZUZMOUJiZ0Qxb1RtUFRlcjZicmxaV2dpYXVaNWpxSnVHd1ZjcmFFS1JlRDYyZjVMY3lGQTRjM0R0YThwckpTOUticGFoTmJyaFdzb2RHUTFlQzN6NDljbjlNWGFlWGx1OEJ0ZCtGbXZGaGRTWkU3bFpxa1dUNi9oSUlhVVhMdGFIK0xnekZIbDdJTDNRZDJob2tPM2VtY25zbE83ekdYYU1zWUpFZmJXS1N2NjUyU3AwS1ZGZXhuVUxzVkVGVU9SenMxUUxxRVBXWnVrR29aK0s5cFJJeFZHZ3BkcFZxSGpOMTlib2RBTU5NOEVmTHBlOW1UT3h2aGFucTNPQS9oTGg5UnByZ1RXN3hCcHp1VmxDTXlycFNpbkk0TVp3VUlyZnVINmR0Y1FFR0g4RnJ2bHRXS3RjVC9uV2Vud20xSkJyNk4wb3VDa01jQjI1MlJxOHBaQ1ZHUmV5TW90L3AydnlCeHAxM2JwMFBENEVrbXBUYzB0amFuU1U1cjhSZU5ZQmRwaXBwYmtzYUZzQzZDbE1OV3VTbFVaWnFvZGhpMi9BZFZtMkgrT3lBK0tWNGpTb1dDYTgvYy9BM1dLT1VzWkhGTjl3MlcwdXQ5M3Erb0xMYm5XNzdUWW5XMmR6dStnVHJlSW5mZFozNFZuUHNnL2pzMHlNbUNxam9RbG1aZmRXaEhVWHZ4dHJqWFQxdGtVN1l6YUx6V0t4V3V4c0ZIWXQyTmpXR2pUYkhaelpacUgzZmh2dS9UM0VTVDF3Z1hWOC9US0tnbWdtWW1sV1U4ak5haW5pQ0lZdWlxNFIrTGx2Zkg4c05yYVBvbTBtbzhMYlpJWHFiVWhPOE80VWVRbDFFaUw2bzZnNHE4Tnp3T09kblFVSmxRMENLc1BlMWNLOUQ3TkhFTGNxbmtWNkF2bDRIZ1JZY3VNczRoWjlneFRqeHR5L1N1K3NvNnVJd25DVWI0dS9YTnUydGd1NG9RWjJ1SFIvb0g1b3hjclBzb2RwTGdkOURIMXg0MDI0TG5xZTR1L2Z3M1dubVJwNFFscGgrNkVwelFiMGRaZzNraU5DYlRyaWJnSUVwSGRuRmYvZWFyUFkvUjVmTCtmenBsb2QxdmZyamZVV3kvYXVxaFpYYzJ1MXNNWVVQUCtiOEh3emMxZ2hsK3ZLMVFqWm1rTWJHL1VCMGpmajBkcnAzSFUwSkpiSEJTVGlhZGsxTjV2dWJCVUZrblJiWFFWNTQ2UHJ5QnM3U3ZLR2F2ekgxaG0vVXpWK1JSNy9pbXA4dnp4KzN6cnl6RWZYa1dkMllGd012bXNQT0diWnUvWWE3WTFrc2JoOFU2NS90TW9XS294aEMrLzJ5R1BJS2Vaa3hmY21FdnJlUktEZEo2TlRZMnlZdmdXdzR2aFM3WGNZYndiMGdPSGtWSjYrWjlHL2xxMzB6a0EvakpqRit5R3ZPOFg4TFgwdkt1WC9YQlZaekpUM244RCtFMkkvM0pQb21HUFFmeC8yMzVjUjVvWHZvY0tjdmtrRm5xbnFsNWJINWVZT0NXUkVHVDFNMzV0QjMxd21sbFFOb1U0YXYzbnBVaHIra2N0Q1BlRzg0bmxXQ2E5VjF1YUtpck1ZT2hHb29jK29FYlJPTWV6M0VHVVhnU3BaaDlhZzZSbHQ1S1c0Q2NsalJ2UFg4cGN1NFp6Z1Y1ci9PWDFOSS95aWNHaGh2c1o4RzJCWnk0U0Z6S0RjSVN3YVFILzEwRjhQWWROQTUyQW96MUp0Nll5MmRIWkd3eDJFYSszdWFtbnQ2bUpvckIzTmVmOW5mRytqRXpqK1hRbzk1NVk4Zk5yQXQ1blNoZ0V6anBYdnk1SmZvaVcvVmt0K2c1WlFDb05maHoxVmZPMWozdWR5K09BUDc1ZUVIb2RYZW1HV28reVRrZXlXMnRkdWVUZHJSSGczSzV5dHh6VFRhMElON3pTVEJ4anFLTjZ5bUUrUUFMeDFoaDZjZlBEQnllKzg4c29yMHZsU2pOTXlkQndmNG9FL1ROSnhENmFGZ1dTTlF2RTdTT2NiS2xoRnBlQXAyQW9TSXQ4cFhod2s5N0crZDM4QUYyQzhTMTdPdVZxMzlyLysvMGp0Zjl2K3JWdjIwT3lzZEY5UGR5SkdxeG9mMzNmNDhNNDdqaDdkazU2ZVRnOXUzc1NJTnFZODZEYStXOTZOYUt6OGJrUnJDS0JybDk2TkdOSG44MStMcGRQcHh4NWpIeVgxbmQrL0h0dC8vano1VGZIOWxmUWRRcTNNNXhYdW52STNlVjMxa1FhUVNhcnhyY2crTEw3UXJhTTRqNy93eFRqaTJ4TXRGQmlXVlFzQ3crS3lSQzBweTdSbDNySm95VmlXTE11V21nWHhWVWs2RFBacDJWQzBTVk1MMWp4dDRJUkMrN1JzQTMxNXNxQ01ZYm8zWmRCWXYwRWZrdGtWelNZa1pIUHRtQ1Z6YlBOWWY2ajlSZi8vclAweENJUTFmOUowZm5ocTA4UTlqM1BiYnhwTkhCZmJkOEp6TUZsN0xtWTBXcmpZT1UvS2ZkOWVBZWFhWWN3emJHZXVWb2pmUWgrSVVYbENWYlhQcFd4d2xBNmtCaHF4cFVZRUdoSGFxT2ZXcjE2ZnM5VlhsZm1ENkx0T3NGcFBMaWg4aDIrY291blBHQW1SYlMzZzI1ckxxOTVqbFhTaG5JOVZEdndUWDV5VlRvL3hwSU1mUytmWjU4KzBQcVNwamwwYXFCbFllcEE5L2NGWVRleVZqdW9mRWUxa0pqTlovR1dNT0l0L1I4eC9IWXNSYmF6NFUyS01RVi9zaDNoMjM4SzhjVTFaM2ppNS9CYkdGSWhuMWxKRkhwWHNlS3dQNkgyYytUT21CRU9KM3ZkQ283ZGlrVmxWNVNBc3FWaGVjVlpsb016MmJxank3SHNXblMyck9rK0xrR0N4b1J6akUzTGlvb1djcVowcWVCM3IxYVV0cjA5cmw4Y0liZFpYcWxlYngvQ1VMZU90VWQ1UTI5Nld2N1Y2YmFtR2JmMTlJMnhiUElqVmJDVzc3VHpUS0oxcFZkVk9WVDB1RlNoVmprcTVicVh3S2lSaGtUN1ovNjE4SXhMTGllNW9obXFVWmpRLzU2KzRWbDBJYlpmTEZYV2xYTk91ZWRlaUsrTmFjaTI3YUoxZkwxbFFKZzdlRmpqMG01c2lRUGJlc1hrbzdXOGI2cjZKRVJnbEdGanZRZGhnUklZU0JqbW14RTRsR0dDMHdmcmh6aFdyYTBrZUoxb1FoNkVMWkZZWlhDQm9KMUVteFV3ejg4d2lrMkdXbUdXbVJwUU9HQzFpaHVDeEx5dWVMN3hBaXVFSURVMFhNRW1DaG5XZGNzWjhYT3dKLzJXOFd5eHF2SGRMVzJ1c0J2NXNZUnZWaFkwTmhuZi9HdjcrdmtFNmF4Y0FIdjNNUDFXb0w5VUtqVmFwb1hMNk5rT2pXV3IwUWFPdklyYW9EbDRLR2lrbDZ2VEJHdnR1aXpvVUZaUnZlcWhWRm5xbU9UMGJpRFkzaFNqRW0yRjhENTdWWkFIZmlkaWlRSzMzT245cWxDTTNwRGNYcUE1aVJReXNkQmFWR0tuZWcxOVcwTVREMEFoTGpTUTBraFdqeTVCR0dwUTBVbVhJdStWVlVMTG4vcGJDY0VtTVBaRGVZbXFYM21JNmJaaVhYM0pLeWFJUkVSUWprYXM0MVh1alRGTGxPSWRZckZXTVNITnhRbldmSE5Nb0hQSk9JSXc5ZEhONmtUQktTUHlyVWtlZW5hZDQzaW5pL2kzN1FrOENPeThpL2UzSnBNRWd4bXg5bVMySU1Wc1JJV1lMWkZlTWxVSjlWTTdqeEJpektockRKZHBmdjR3eFR1L2crTTNpZFR2RjYzYlM2NlM2bjFnMy9lbGZxMjc2Qmt1bWI2eGErbnNVU3RmeVZUWE5qU0pOR1U4M2g4bU5VUUt3VXRDVE90SFh5VDRGYTRvd01hQi90Mkl4U293VkMwU3Jsb2pjUldySTlTcGxqdzV0dEdEZHNmd1ZicFhEeFhNdUxzcWx1R2x1bmx2a010d1N0OHpSUTIrbGVFV0poQTNyaVZQM0RiQWZNVnJVSVRJWUxCaEQ1Y2Mya0l5NjBTU3BmTlhDdW1DeGxvcmJrb00xOGxzWVpCUVV5RzlhZWswREpwM2dheGwwaGpKYS9PNC9DdTl0RUdHb2VRaGdPTUpzSlJwRkxMY0VOdlJ3U1kxMmFMUlgxTG54aUVzTlRIK1ZHajNRNkttWVpxbDZYUndTR1pwSHhZaEtPNUZmb3lCbWxSaVFQSVBBTHJqR2hMcWhOVkltTUVOTHNiazI4cEt2bkttSmJoTVE2T3dnM0lQTGpoZXk0OTIweVBNMFJ2aHZuQVJVMmpqbExuMTdYY3FnM3I2YjhxczFMdCtXVEtnMnRQaXF1SWw0dGpVdndCNXVJM3NybklKK2FQUkxqUzNRMkZKUjJGQ2RBaFZ6bllER1JFVXhSSlpxWlo0aE5iQTJHZDFPVnJEaXFRUU83VVlxMGxCQlJDbmhic0dVdWZ3VjM2b1BML0s1ZkZGZnlqZnRtL2N0K2pLK0pkK3lyMFlveGtUNXJWQ2MzRTFEaUtnZUVrVTlSS3BTbm0zRkNrMmRCY3FjZTZHSHB0bG00d1ZCT0FDVmNoUjR4Q2FLSkJOSXE5WU5ZdjYxMkVaWnpQTjdzUkRWaXdNMndreGt2eFBsNzVZdytaRGdoMlVMVXI5bU4rVVhRait6Zy9hTGZ1NTVTZ2VJK0Y0ZlBNUVNwc1NoRVpjYXFzUnAzR2lwTVF5TjRkdjc4bVM1VnNJVStiV2FHL0x5NVpoaDJLTGgyMFRrVWxWSXlOd1J4Rmc3SjlEZkhPT0hLMFBjU2h2Rm9yYlZOc1NpTmxkYnRDM1ZOdDAyMzdiWWxtbGJhbHR1b3hTaWsyNStGNHdmb1BHT0tvZmlyeTYrc2ZPU0IvTDJFbHpKTy9tZVlweGtoMkUwVCtNN0VTWkplNFZxQmFwZDJ3U05UUldab1NxSll2MzlWTm55VlZ1b2VxMEFNb3oxWHJjZ0JPQUlHN1pwSSsvY3lERWVGQ2hFSG1wVnYzeWdRVHJmSVZYTUE3QnI0WHdMZXdpTWR3QU85QkFSc0tmczdRNi92Z1NvaWNwdmczajdQUSt5OUthSURjdUUwanNmWUgvN21MLys5ZlZHTkF4VnBONmxLaFhRNklaRzk3K0xScG56MXRpeEZDY25wSWVJZGlHZ3ZsMUlmV08zVlRKdlEzdkw5YzV5d25xckRub0xMV1VVTVF5VVZqNnBqRmxCbW5nRWFlV1RBcTJVNnRFSWVWVWdkLzRSVTlKcFRFcW1hRkF5eFYrQkltNlFDSVlCOE9IYkVNRWM0OEJDU1N0TmRDdWJWcHR3SzV0Y1RkR21WTk4wMDN6VFlsT21hYWxwdVlsdVpRczlFNVdKM0syNFR4YVZ4RXhwQWlrblh3bzdpQ2lyWDBBYlNKZUV6U29wQlpsS1JTVlRWYlFEclpUdnJXUktBVmRxSmRPL0lTWFRWRWMycEdubUdEZU1pWEFyWVJqVGh2STlFcDNiS0pVeVdsdFZGR2hSU1QxRWJQNUxpYlpVSUJpaVFlWHpFazNCV0JGMkhyQzFVUEpQeTc1dnpYVThyYVVJRVl6eXdCZ1J1T1kxNVRXU1Q1dUdscGdZVldSSVFiaW0rQVpjazRWcjlJeS84bk9Fa295S3NKRHg0Y1hZZmFQajdLZG5NcG1ac250NDFmRWxOTFRFSklTV0tKengwZzJlRVc1QWl0Zmcrcyt3cTR3VmRPV1NHUkd1UjBwVUZscnk2MFNWWENoRmxkQzRCZnE4ejdJcjZ2Z0xrK1JuMjJEOHhUVXAvdUtpSEgveDlDM3hGOEkrdnNZK2gvNVhNWWJGSk1Xd0tNSlhub3ZCV05ENzF5NERISTFTalQvSkowb1o3eTJCS1grcmEvWUhRcnB1M1hBOFBxSmxDM0pnQ3U3Skd0enJBSHNOMW1pOVpZWHFWUlhYUERhYmgvNnd6OGp2WnlwK2x4MVpleGJtUW1FMHBjamVFSUpuN0RTbG5DS0hTWFVFVGVyRHAxL0kwek1KQks3Ylh2N1U5NG8zT1ZjcDNnVFc5RDNFYnozUW5Zb1lUZzJBTENmRU1ZbFJKU2ZHeEtpU0FvMHFvZWRrRy9uQTJuKzhiUnpISlNHT0EzaEdCSzQ0ajdYVWpqRVpJUTZjeGdkRCt5eHRNenl0TWNoZWdIWWRreGJzUHN3cXRvM1lUc3ZmajhqZjU3RTlKcmVGN3crVnRlOFcyc3dha3lkSks2MkZPMG45bG9jUWNVVGIwVzIvSTR2ME8zSnZwZS9ZQW41M3ZNSjNHWnJEQ044OXdxUmhEVGxPSndaZHd3RFY5NmZGNzJrTVZRK2orSjdta21QZDM3UlpxUHViQmh6S2NUUVV1b2YrNG1ycFg3WENJOVhYbk1aclRzdlhTUGZPY2RUaDNsTWxYdk8vQWJndEkvcDRuS1dVeTI3VFFCU0dmeWU5M3lSb0JSSmlNVUtpYWxFN3VaU0NsRjFiS1dxcmlGSVNWV3hON0NSV1hkdllrNXErQlUrQXhJSVhZSWZZcytBQnVvTlg0QTBRLzB5R05pMEZSU0tXNVcvRzV6Yi9PUTZBKzg0UkhBeCtUeEJaZGpDRHo1WUxtTVM1NVNJZU9vOHNqMkhHNlZnZXgxM252ZVVKM0hLK1daN0VXbUhQOGhRV0MrOHNUMk8yOE5YeUxQZC9XcDdEWXJGbWVSNXZ4eExMQzdnMy9wVFpuYkZwcmtKVGlXWUhTL2hndVVDckw1YUwyTWQzeTJOWWNwNWJIb2QwWGx1ZXdBUG5rK1ZKdkhSK1dKN0NjdUhVOGpUdUZENWFudVgrdWVVNUxCZHZXNTUzUlBHWjVRVThIbmV3Z3hnSnpwQWlRQmM5S0Fpc29JMVZQcXNvbzRJTnJKRmJmSi9TVnRNWlBYemtYS1U0UnNhOUJ2MDg0NW1iUzNJOXNKZU1GZU9FOFNTd0V5ZG5hZER0S2JIU1hoWFZjbVZqVGJTQ05CYXRzOFRQNC9RNEV3M2xpWlU4ejZYaXZtekhKNnYwYTFKR0Y2OU1lbDFRZ2pmY0ROMVhzYWhzSk9RWHJLZUx2akZMdWZTNy9kQWxqRksxUkkxOFU0cmFrQWI0czA1WkU1YzExTXh4UmlqMWlFV2tUQi9RSkRKR2tpbXFwRzBlSUtDN0ZyTE1hNU9CY09TbldSQkhvaUxMVmJIZEQwSlBsTXViN25DaTMybldyOHRnMHVxczZ4ZUNESmNYR0JGYzNvcldMdlA2YkpScjVCRzA2SXpZZHFsYk96aGlrQWxYcU5UMS9CTTNQUlp4NTRiMlNqbHFYMjdTSFB4YVlzNnBsbTZYUi9Yb29ZWEVmdHlMeEc3ZnkySXU5QndyeHEyaHhPdHZNNG1lVWttdFZCb2V0Ly96YmRGN0lHdmRWS1hNWkdrcEZhTm9hZjBMNFVNKzIxeEhYUG1tNlgyeVo4WkR0NlJuYkp2WW94NENCMGFsNkVya3hwVUkraXU5YWJqMExZWXF1NXIzY2d4T2VRZDJQRUx6SnVkYTF6RVlranEyY0doWW1TL2pxazRaWStyL2tJUjdHVE5tSnBZMFhlM3kvUUg5R3hTb3h4R3B4NUVTemJpamNqZjE5Y3lFUWR1UE10OFQvY2p6VTZGNnZtanVOY1JCNGtjRDQ4YkFZRTFjZmc0VktVd3c2MnRHNzlRTk9JYWhML0pBOVRpSjlhMUQ0YXFhc0wzSzJtbVFxRXhtUVNqanRGczZxRGV1dDN2RVkvd2o0Qys3b1VZTkFBQjRuRzJWQjNSVFZSakgvLzgyVFdqVHNzVXR3d0dJMUNTZHVLQWpsQTViTEEwVkZQRTFlVTFlKy9KU2t2Y294UUhLVXR4N0s4T3RMSEVEN3IwOTdyMzNua2M5cnVUZGEvSTR4M2ZPdTcvL2Q5ODM3bmZ2ZXdueVlGLy9YSWtBL3VmaWhzeUFQT1loSHk0VXdBMFBCcUVRUmZDaUdDVVlqQ0VZaW1FWWpoRVlpVjB3Q3J0aU4reU9QYkFuOXNMZTJBZWpNUVpqTVE3N1lqL3Nqd013SGhNd0VRZGlFZzdDWkpUaVlQamdUMWN2UXprcVVJa3FWR01LRHNHaE9BeUg0d2hNeFRUVW9CWjFxRWNRMDlHQUdXaEVFNXJSZ2lQUmlqYk14RkZveHl4MElJVFo2TVRSbUlPNU9BYkhZaDZPdzN3Y0Q0WDVXSS9sV0lFZHVCaWZZeVhPeGhtNENqZmhXcnF3R205aUdTN0FqL2dKWjdFQXArRmh2SXNmY0RWdXhpLzRHYjlpSFRiZ1NUeU9qZWhDR09jaWdxZWg0Z2s4aGVmeERKN0ZjL2dDM1hnSkwrQkZiRUlVMytNOHZJcVg4UXBpK0FyZjRIVDBRRU12NHRCaFlBMFNXSUErSkpHQ0JSTUwwWTh2c1FpTE1ZQVRjQkpPeE4xWWl5VTRHVXR4Q3I3R3Q3aVhibm80aUlVc29oZC80VzhXczRTRE9RVC9FQnpLWVJ4T2NnUkhjaGVPNHE3Y2pidHpEKzdKdmJnMzk4RnYrSjJqT1laak9ZNzdjai91endNNG5oTTRrUWR5RWcvaVpKYmlEN3pHZyttam53R1dzWndWckdRVnF6bUZoL0JRSG9ZUDhSRVA1eEdjeW1tc1lTM3JXTThncDdPQk05aklKbXpHRmphemhVZXlsVzJjeWFQWXpsbnNZQWgvNG1OOHd0bnM1TkdjdzdrOGhzZHlIby9qZkI1UGhWME1NMEtWM1l3eVJvMDk3TVUyNm96VFlBS2Y0alAyY1FHVFROR2toZGZ4QWQ3QzIzZ0g3K01Odk1lRjdPY2lEbkF4VCtDSlBJa25jd21YOGhTZXltVmN6aFZjeVZVOGphZHpOYy9nbVR3THQyRXI3c1JkZUFTMzR3NDhpbFB4RUZiaEZqeUcrM0EvdHZOc25zTnpjU2ErNDNrOG54ZndRbDdFaTNrSkwrVmx2SnhYOEVwZXhhdDVEZGR3TGRkeFBhL2xkYnllTi9CRzNzU2JlUXR2NVFadTVDWnU1aGJleHEyOG5YZndUdDdGdTNrUDcrVTJidWNPM3NmNytRQWY1RU91MWxCTGk4Y3lOSit2eGlkWkwxaGI0YW1KSytGa3d2QW9ndTZhcnFTNlVIVXJOancxaVdqQ1VIczlpcUMzTHF3bHcxYThXMWNYZWNNNVhWUVhTWmhLT0t3YVpsRTRLOTMxWVNXVE1pSlFuODZ2bUo2Z0xLaktna0ZSVUxWUkZNd2xVclBTRTVUTFVBWGRRWkZSdGVGdGNDd3E2bGhVUXk1WE5DdUxHOEtKZUZ5UlJ0UmhlR2M0OHNSeTJqV2pTMG02WXVuQjNXaHFla1IxYXpZOGpiSVRUWGJTS0RyUnhOWTF5alZyZ25tTlRYbGFqN2ZKVWFNbnA0dWJuYXZxZFJqdUZpVnNtYXBidDFIYzR2VFRkL0lUZTZMYmNMV2tHM2JwNmNIZEt1SU5FZC9xakRlYzhhMGkzckNSSHpTaSthb1I5YlRKSGhPeXh6YlJZOEpHU1Z2TU1xSkswb3JyaW1XV0pKeVd1MTNVVFlxNjdjNjZTV2ZkZGxFM0tUQkxSS1ZzZUdjNWRpdVYwL2JMNjY4SUNsWUdCcGxoTmFMcHV1THVFRmxNc1FrZG1ZTXpNd2NYRWdkbmlZTUx5YVlzMlZSSU5HWFpLQWdsTlNOYVlHWEdrdEJPRFZwT3l4T1NCMnpKYjZQVHNkaCtoNTdqMEFNNTdaNHJXbDFzbzJodTdtVmRuSHZ4N1FhbkJHd0cvTlhGS2VjMmRqZ04wMkVJOTdJcW0yVStuNlJmTWlCWkpsa3VXU241WDF5MVpJMWtyV1Nkb0YvbThWY0lCbVI4UU1ZSHF0MmQwYVNTM3RoK2dVN1JjTCtOd3M2SXBpYlZsSllxN1A5UHVlY0l4d0VibVN3Qlg1VlBzdHdWdEpJSjJ3ajRLL0s3NTNlbmJ5MTk2d1ZwUFYrelI5MXI3MWhaSU5OdWdWYmEwZDRzWjhveUcxSFFYYXJvWmpxbXkvWVdZOHhyeDh1ZkZsdjMyQS9FMkp0Mmp4Vm1IVnlaeCttcHpOM3JsUnRjR2xiNnBQWTdkTUNoNnh5NnpLR3JIYnJjb1NzZHVzcWhheHk2TnFmOUZSazlSRjBVMXBWNEpORnZwTTJVT215QnBhWk1MV0ZrWndiM0tVblYwTlZ1MHphSDJHWlNpOGFFUGJRci9iMzJxbWJXWVppY3lMa016c3lvdVF5Mm1YdnNqUTMweFZSUnJGaisyWWdIcWhGUlVqR3A0MWs5UEdwcGVpcjlzZW5abkNPeVU3bTh0cHV1eGhQbXptNzJWTTd0WDVuZ0lDa0FBQUFBQUFNQUNBQUNBQlFBQWYvL0FBTjRuR05nWkdCZzRBRmlNU0JtWWdEeUdOY0FTUll3andFQUN3RUEyd0FBQUhpY1ZWTFpTOVJSR0Qzbk55NWppNmh0MG9NTktUM1ZQRVJGaUdqbUlESE5oa2lFUkRXTXVkUm80aGE0amFQbFZwa1AwbHViN1F1MC9BZTk5VmYwMEZORVJBZ05FWkdkM3pjL1NoL3VPZDl5NzNmUC9lNEhBdGlFRVh3RTA4bkJYdml4RjRWTmphMEJCS1B4U0FCMXNVZ29nSEJMUENxN3RlVmtBRzNBMmhwOE91ZERnZGxDY0lQbjJvWG1DZUdZWDdRaFd3eC9Lamx3QVFkVHFaNCtIRFdzNytoUHBoQktkM2NtRVU1ZlRxWFJZbmphOEt6ZFV1emQ1V0wrWHIvZFVPaldsMGRER0RwNjJVNVVZUitDT0lKNk5DT0dVNnFUUDVmdzl2WjZQT25GcjNxODdIRk9sZjBnYitmM09WWDV1SFBlN3FielFWeGxkMjAzVFQ5a0I4M0t5WXFaamdPSUNrdFJ3RVllWnhORGJwNTdHR0ExYTJRWDhiQnBqMnBWNU9zcTcrak1pTVZkclczU1VRSDlDMnIxa29UdHlHckZFZFJ5dlduellwNlhWWmYrWjN6cjRzNi9hTjRxTW4xTGVDUHRPZmtycHFBY05kaVBRNmhEQ0JHMDRnemFjUkY5R01ZWXBqQ0hSU3h6VW5YRFNQQzZjWndMeGpIT0crYzRaN3pLakhHVXM4WVJ6aGczYzBrdmpQT1cyeWN1Q25POEtWemx1RERLRzhJSUo0UUpqZ25EdkNac3RvNkV2Umx3dTFWcFAxUGl4YW4rdU5OUWdzM1lxcDVYNHhnYWtVUVBoa3o3T0RMNjY2eGUrVm92Zm90M2VLL3AvNFRQK0lLditJYnY2c0ZQL01Kdi9GRkJod1hjelFaMnNadVhtR1kvaDNtRkdVNXlpdE9jNFN6bk9NOEZkY0RSbkpYeEh1L3pNUjl3aFEvNWlIZjRray80aW5mNWxNLzRuQytrcmd4YnBLc2NEVkoxVHJyYU5ZRjltTUFVTzlqSkFRNXFUNWZOMHdtOW9uVGRCTHZkM2laZnpDR1BSOFVaaTFlNnJIaWVSOFUrL1dLWk9PdmxzMTQrNitYZHlkeUJYVFovdGZudS9RVkFmWkVBQUFBQWVKeTExTXRMVkdFWXgvSGY4ODRvNHNBd0RiWVRFY1ZOUkxWSXZMZFF4TlIySWtJWE1URlFIQUlqZFJhekNMeHYrd05DMEN5dGpQSlM0dEx4Z29pSWlJaUlpSWlyaUZiUmJ2ck9HWTJnY0JFMFB6NlBaOTd6bm5QZTg1dzV5aVJsS2tkWFpaR0hUeDhyUTM1R2xFZ291Y2M2SHoxSmppbjFqWDJPYjA2WnZuR1pMK0xOdmF5YnBOV2UyWFBiSU4vZHJEdDJzN2JCMzFsdkpMbDE3UFA3YmltZzlNU3dBdWhPeE5XRFdDSnU3WWxoNjBBbkltRGNlcGxUbzB4bWhOZ0tvNER0YXRUZ05tcFJqd1kwb2duMzBZZCtER0FRUXhqR0NNWXdqcGVZd0N1OHhpU204QVp2OFE3VG1NRWM1dkVKbjdHQVJTd2hqbVdzWUJWcldNY0dOckdGYmV4Z0Yzdll4d0VPY1lSam5PQ1V1dzRpaERDeWtJMGM1Q0lQbGVpaVE4bTErMVZNTFVVWktoQ2tWM0Y2RmZkNmRWRWZsczdXdmVxZEw4NHZJRi9sNmtZUFl2aUFqL2lDci9pR0g3aCtZZi92NGg0ZS9FTS8vM2Zma2owTC9IR2Y3eSs0MXd5bFVZT0tjbFNVbzZJY0ZlV29xSEcwOVhyN2tqUFNFZkMrbFovTi9IVithMGNIT2hIQitaRUJGVkQ3MEk4QkRHSUl3eGpCRXBheEN1TXRDeW1zSzdyQnUxYXFNc1lxVktkUks3UWlLN0ZtYTdGV2E3T1k5ZHNMT2R2MDNzdzdtbWQ5NmZyN0orcTk1L0dVODA5cU94RlBoVTJuU3lvbXpydXFqNnRXY080Nllob2xmc3UzZks1WVlBWFVRaXVVanhVVk1WNWlKZFFxcTJLODJab1piN0VXYXF1MVV0dXNqYjB4aThsWWN6OW5jN3JHV3ROWmNZQ2tjYjhocmhRbWZsVVQ0LzlCTGJQcWlWTURjV29rVGszRXB6Rk5NbWRLMDR6TUVLYzVMVkFYaVJQdktudFhpR21ObU5hSjB3WngyaVJPVzhScG16anRFS2RkNHJSSG5QYUowd0Z4T2lST1I4VHBtRGlkRUtkVDRpeG9RV3JJUXRTd2hhbFpsa1hOdG16dVBNZHlxTG1XUzgyelBHcWxWVkxiK1oya1dTZS9ralRyc2k2Nk0yRVRuTlBvUUxIWC9kUVR6NmZYcWFkZTlmdHovd24yNXVET0FBQUFBQUFCQUFBQUFOUVlGaEVBQUFBQXp1bHBod0FBQUFEUHJtUTVcIiIsImltcG9ydCB7IENsYXNzLCBfX25vbk51bGwsIGFic3VyZCwgYXMsIGFzc2VydCwgY2xhc3NOYW1lLCBjbGFzc09mIH0gZnJvbSBcIi4uL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBmbGF0dGVuLCBudGgsIHppcCB9IGZyb20gXCIuLi91dGlsL0FycmF5XCJcbmltcG9ydCB7IENvbnMsIExpc3QsIE5pbCwgUGFpciB9IGZyb20gXCIuLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgQ3RyLCBjdHJGb3IsIGV4cHJDbGFzcyB9IGZyb20gXCIuLi9EYXRhVHlwZVwiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSwgZXhwbFZhbHVlIH0gZnJvbSBcIi4uL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBDaGFuZ2UgfSBmcm9tIFwiLi4vRGVsdGFcIlxuaW1wb3J0IHsgRW52IH0gZnJvbSBcIi4uL0VudlwiXG5pbXBvcnQgeyBFdmFsIH0gZnJvbSBcIi4uL0V2YWxcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuLi9FeHBsXCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi4vRXhwclwiXG5pbXBvcnQgeyBHcmFwaGljc0VsZW1lbnQsIFBvaW50IH0gZnJvbSBcIi4uL0dyYXBoaWNzXCJcbmltcG9ydCB7IERhdGFFbGltLCBFbGltLCBNYXRjaCwgVmFyRWxpbSB9IGZyb20gXCIuLi9NYXRjaFwiXG5pbXBvcnQgeyBNb2R1bGUsIHBhcnNlV2l0aEltcG9ydHMgfSBmcm9tIFwiLi4vTW9kdWxlXCJcbmltcG9ydCB7IEFwcGxpY2F0aW9uSWQsIE51bSwgU3RyLCBUYWdnZWRJZCwgVmFsdWUsIGZpZWxkcyB9IGZyb20gXCIuLi9WYWx1ZVwiXG5pbXBvcnQgeyDOvSwgYXQsIG5ld1JldmlzaW9uLCBudW0sIHN0ciwgdmVyc2lvbmVkIH0gZnJvbSBcIi4uL1ZlcnNpb25lZFwiXG5pbXBvcnQgeyBFeHByQ3Vyc29yIH0gZnJvbSBcIi4vQ3Vyc29yXCJcbmltcG9ydCB7IEdyYXBoaWNzUmVuZGVyZXIgfSBmcm9tIFwiLi9HcmFwaGljc1JlbmRlcmVyXCJcbmltcG9ydCB7IFBhbmUgfSBmcm9tIFwiLi9QYW5lXCJcbmltcG9ydCB7IFxuICAgRGVsdGFTdHlsZSwgYXJyb3csIGFkZEJvcmRlcl9jaGFuZ2VkLCBhZGRCb3JkZXJfZm9jdXMsIGNlbnRyZURvdCwgY29tbWEsIGNvbm5lY3RvciwgZGVsdGFTdHlsZSwgX19kaW1lbnNpb25zLCBlbGxpcHNpcywgaG9yaXosIFxuICAgaG9yaXpTcGFjZSwga2V5d29yZCwgZWRnZV9sZWZ0LCBwYXJlbnRoZXNpc2UsIHBhcmVudGhlc2lzZUlmLCBzaGFkaW5nLCBzcGFjZSwgc3ZnRWxlbWVudF9pbnZlcnRlZCwgdGV4dCwgdW5pbXBsZW1lbnRlZCwgdmVydCBcbn0gZnJvbSBcIi4vUmVuZGVyZXJcIlxuXG5pbXBvcnQgQ2xvc3VyZSA9IEV2YWwuQ2xvc3VyZVxuaW1wb3J0IENvbnQgPSBFeHByLkNvbnRcblxuZXhwb3J0IG1vZHVsZSBWaWV3IHtcbiAgIGV4cG9ydCBsZXQgZGltZW5zaW9uczogKHRnOiBFeHBsVmFsdWU8R3JhcGhpY3NFbGVtZW50PikgPT4gW251bWJlciwgbnVtYmVyXVxuICAgZXhwb3J0IGxldCBkZWZhdWx0RGltczogW251bWJlciwgbnVtYmVyXSA9IFszMjAsIDM2MF1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpc2UgKCk6IHZvaWQge1xuICAgICAgTW9kdWxlLmluaXRpYWxpc2UoKVxuXG4gICAgICAvLyBTaGVuYW5pZ2FucyB0byBjYWxsIGFuIGludGVybmFsIGZ1bmN0aW9uLiBXaWxsIGV4dHJhY3QgdGhpcyBpbnRvIGEgKHJldmVyc2UpIEZGSS5cbiAgICAgIGNvbnN0IHg6IHN0cmluZyA9IFwiZ1wiXG4gICAgICBjb25zdCBbz4EsIGRpbXNFeHByXTogW0VudiwgRXhwcl0gPSBwYXJzZVdpdGhJbXBvcnRzKGBkaW1lbnNpb25zICR7eH1gKVxuICAgICAgZGltZW5zaW9ucyA9IGZ1bmN0aW9uICh0ZzogRXhwbFZhbHVlPEdyYXBoaWNzRWxlbWVudD4pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgIGNvbnN0IHR2OiBFeHBsVmFsdWUgPSBFdmFsLmV2YWxfKM+BLmNvbmNhdChFbnYuc2luZ2xldG9uKHN0cih4KSjOvSgpKSwgdGcpKSwgZGltc0V4cHIpXG4gICAgICAgICBpZiAodHYudiBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3R2LnYueC52YWwsIHR2LnYueS52YWxdXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIC8vIFByZWZlciBnbG9iYWxzIHRvIHRocmVhZGluZyBwYXJhbWV0ZXJzIGV2ZXJ5d2hlcmUuXG4gICBsZXQgX19jdXJyZW50RWRpdG9yOiBQYW5lLlBhbmUgfCBudWxsID0gbnVsbFxuXG4gICB0eXBlIExpbmsgPSB7XG4gICAgICBmcm9tOiBWaWV3LCBcbiAgICAgIHRvOiBWaWV3XG4gICB9XG5cbiAgIGNvbnN0IF9fbGlua3M6IFNldDxMaW5rPiA9IG5ldyBTZXQoKVxuICAgY29uc3QgX19zdmdzOiBNYXA8VmlldywgU1ZHU1ZHRWxlbWVudD4gPSBuZXcgTWFwKCkgLy8gbWVtb2lzZWQgcmVuZGVyIHdpdGhpbiBhIHNpbmdsZSB1cGRhdGUgXG5cbiAgIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIgKGVkaXRvcjogUGFuZS5QYW5lKTogdm9pZCB7XG4gICAgICBfX3N2Z3MuY2xlYXIoKVxuICAgICAgX19saW5rcy5jbGVhcigpXG4gICAgICBhc3NlcnQoX19jdXJyZW50RWRpdG9yID09PSBudWxsKVxuICAgICAgX19jdXJyZW50RWRpdG9yID0gZWRpdG9yXG4gICAgICBjb25zdCBnOiBTVkdFbGVtZW50ID0gdmlldyhlZGl0b3IudHYsIHRydWUsIGZhbHNlKS5yZW5kZXIoKVxuICAgICAgZWRpdG9yLnJvb3RQYW5lLmFwcGVuZENoaWxkKGcpIC8vIG5lZWQgdG8gcmVuZGVyIG1haW4gdmlldyBzbyBsaW5rcyBjYW4gbWFrZSB1c2Ugb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICByZW5kZXJMaW5rcyhfX2xpbmtzKS5mb3JFYWNoKChsaW5rOiBTVkdFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgICBlZGl0b3Iucm9vdFBhbmUuYXBwZW5kQ2hpbGQobGluaylcbiAgICAgIH0pXG4gICAgICBfX2N1cnJlbnRFZGl0b3IgPSBudWxsXG4gICB9XG5cbiAgIGNvbnN0IHZpZXdzOiBNYXA8VmFsdWUsIFZpZXc+ID0gbmV3IE1hcCgpIC8vIHBlcnNpc3RzIGFjcm9zcyBlZGl0c1xuXG4gICBleHBvcnQgZnVuY3Rpb24gZXhpc3RpbmdWaWV3ICh0djogRXhwbFZhbHVlKTogRXhwbFZhbHVlVmlldyB7XG4gICAgICByZXR1cm4gX19ub25OdWxsKHZpZXdzLmdldCh0dikpIGFzIEV4cGxWYWx1ZVZpZXdcbiAgIH1cblxuICAgZnVuY3Rpb24gaXNFeHByRm9yIChlOiBFeHByLCBDOiBDbGFzczxEYXRhVmFsdWU+KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gY2xhc3NPZihlKSA9PT0gZXhwckNsYXNzKEMpXG4gICB9XG5cbiAgIC8vIFVucGFjayBldmFsdWF0aW9uIG1lbW8ta2V5IHRvIHJlY292ZXIgb3JpZ2luYWwgZXhwcmVzc2lvbi4gVE9ETzogbWFrZSBnZW5lcmljXG4gICAvLyBhbmQgbW92ZSBuZWFyIHRvIG1lbW8gY29kZS5cbiAgIGZ1bmN0aW9uIGV4cHJGb3IgKHQ6IEV4cGwpOiBFeHByIHtcbiAgICAgIGlmICh2ZXJzaW9uZWQodCkpIHtcbiAgICAgICAgIHJldHVybiBhcyhhcyhhcyh0Ll9faWQsIFRhZ2dlZElkKS5rLCBBcHBsaWNhdGlvbklkKS52LCBFeHByLkV4cHIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlbmRlckxpbmtzIChsaW5rczogU2V0PExpbms+KTogU1ZHRWxlbWVudFtdIHtcbiAgICAgIHJldHVybiBbLi4ubGlua3NdLm1hcCgoKGxpbms6IExpbmspOiBTVkdFbGVtZW50ID0+IHtcbiAgICAgICAgIHJldHVybiBjb25uZWN0b3IoX19ub25OdWxsKF9fc3Zncy5nZXQobGluay5mcm9tKSksIF9fbm9uTnVsbChfX3N2Z3MuZ2V0KGxpbmsudG8pKSlcbiAgICAgIH0pKVxuICAgfVxuXG4gICBhYnN0cmFjdCBjbGFzcyBWaWV3IHtcbiAgICAgIHJlbmRlciAoKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gdGhpcy5yZW5kZXJfKClcbiAgICAgICAgIF9fc3Zncy5zZXQodGhpcywgZylcbiAgICAgICAgIHJldHVybiBnXG4gICAgICB9XG4gICAgICBhYnN0cmFjdCByZW5kZXJfICgpOiBTVkdTVkdFbGVtZW50XG4gICB9XG5cbiAgIGNsYXNzIEV4cHJWaWV3IGV4dGVuZHMgVmlldyB7XG4gICAgICBwYXJlbnM6IGJvb2xlYW5cbiAgICAgIGU6IEV4cHJcblxuICAgICAgY29uc3RydWN0b3IgKHBhcmVuczogYm9vbGVhbiwgZTogRXhwcikge1xuICAgICAgICAgc3VwZXIoKVxuICAgICAgICAgdGhpcy5wYXJlbnMgPSBwYXJlbnNcbiAgICAgICAgIHRoaXMuZSA9IGVcbiAgICAgIH1cblxuICAgICAgcmVuZGVyXyAoKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICAgICBjb25zdCBwYXJlbnM6IGJvb2xlYW4gPSB0aGlzLnBhcmVuc1xuICAgICAgICAgY29uc3QgZTogRXhwciA9IHRoaXMuZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkNvbnN0TnVtKSB7XG4gICAgICAgICAgICAvLyBvdWNoOiBkaXNyZWdhcmQgZGVsdGEtaW5mbyBvbiBleHByZXNzaW9uIGl0c2VsZlxuICAgICAgICAgICAgcmV0dXJuIGhvcml6KG51bV8oZS52YWwsIGUudmFsKSlcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkNvbnN0U3RyKSB7XG4gICAgICAgICAgICAvLyBvdWNoOiBkaXNyZWdhcmQgZGVsdGEtaW5mbyBvbiBleHByZXNzaW9uIGl0c2VsZlxuICAgICAgICAgICAgcmV0dXJuIGhvcml6KHN0cl8oZS52YWwpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuRnVuKSB7XG4gICAgICAgICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gaG9yaXpTcGFjZShrZXl3b3JkKFwiZnVuXCIsIGRlbHRhU3R5bGUoZSkpLCBlbGltKGUuz4MpKVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZUlmKHBhcmVucywgZywgZGVsdGFTdHlsZShlKSlcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkRhdGFFeHByKSB7XG4gICAgICAgICAgICBpZiAoaXNFeHByRm9yKGUsIFBhaXIpKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gcGFpcl9leHByKGUpXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmIChpc0V4cHJGb3IoZSwgTmlsKSB8fCBpc0V4cHJGb3IoZSwgQ29ucykpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBsaXN0X2V4cHIocGFyZW5zLCBlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ29uc3RyX2V4cHIocGFyZW5zLCBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuUXVvdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKGUpXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5WYXIpIHtcbiAgICAgICAgICAgIC8vIG91Y2g6IGRpc3JlZ2FyZCBkZWx0YS1pbmZvIG9uIFZhci54XG4gICAgICAgICAgICByZXR1cm4gaG9yaXoodGV4dChlLngudmFsLCBkZWx0YVN0eWxlKGUpKSlcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkFwcCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZUlmKFxuICAgICAgICAgICAgICAgcGFyZW5zLCBcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2UoZXhwcighKGUuZiBpbnN0YW5jZW9mIEV4cHIuQXBwKSwgZS5mKSwgZXhwcih0cnVlLCBlLmUpKSxcbiAgICAgICAgICAgICAgIGRlbHRhU3R5bGUoZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkJpbmFyeUFwcCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIG9wZXJhdG9yIHByZWNlZGVuY2UsIGJ1dCBhbGxvdyBmdW5jdGlvbiBhcHBsaWNhdGlvbiB0byB0YWtlIHByaW9yaXR5IG92ZXIgYW55IGJpbmFyeSBvcGVyYXRpb25cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpc2VJZihcbiAgICAgICAgICAgICAgIHBhcmVucywgXG4gICAgICAgICAgICAgICBob3JpelNwYWNlKFxuICAgICAgICAgICAgICAgICAgZXhwcighKGUuZTEgaW5zdGFuY2VvZiBFeHByLkFwcCksIGUuZTEpLCBcbiAgICAgICAgICAgICAgICAgIHRleHQoZS5vcE5hbWUudmFsLCBkZWx0YVN0eWxlKGUpKSwgLy8gd2hhdCBhYm91dCBjaGFuZ2VzIGFzc29jaWF0ZWQgd2l0aCBlLm9wTmFtZSBcbiAgICAgICAgICAgICAgICAgIGV4cHIoIShlLmUyIGluc3RhbmNlb2YgRXhwci5BcHApLCBlLmUyKVxuICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgIGRlbHRhU3R5bGUoZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkRlZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpc2VJZihcbiAgICAgICAgICAgICAgIHBhcmVucyxcbiAgICAgICAgICAgICAgIHZlcnQoXG4gICAgICAgICAgICAgICAgICB2ZXJ0KC4uLmUuZGVmzIUudG9BcnJheSgpLm1hcChkZWZfID0+IGRlZihkZWZfKSkpLFxuICAgICAgICAgICAgICAgICAgZXhwcihmYWxzZSwgZS5lKVxuICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgIGRlbHRhU3R5bGUoZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLk1hdGNoQXMpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0KFxuICAgICAgICAgICAgICAgaG9yaXpTcGFjZShrZXl3b3JkKFwibWF0Y2hcIiwgZGVsdGFTdHlsZShlKSksIGV4cHIoZmFsc2UsIGUuZSksIGtleXdvcmQoXCJhc1wiLCBkZWx0YVN0eWxlKGUpKSksXG4gICAgICAgICAgICAgICBlbGltKGUuz4MpXG4gICAgICAgICAgICApXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5UeXBlbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0KFxuICAgICAgICAgICAgICAgaG9yaXpTcGFjZShrZXl3b3JkKFwidHlwZW1hdGNoXCIsIGRlbHRhU3R5bGUoZSkpLCBleHByKGZhbHNlLCBlLmUpLCBrZXl3b3JkKFwiYXNcIiwgZGVsdGFTdHlsZShlKSkpLFxuICAgICAgICAgICAgICAgLi4uZS5jYXNlcy50b0FycmF5KCkubWFwKCh7ZnN0OiB4LCBzbmQ6IGV9OiBQYWlyPFN0ciwgRXhwcj4pID0+IFxuICAgICAgICAgICAgICAgICAgaG9yaXpTcGFjZSh0ZXh0KHgudmFsLCBkZWx0YVN0eWxlKHgpKSwgYXJyb3coZGVsdGFTdHlsZShlKSksIGV4cHIoZmFsc2UsIGUpKVxuICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoYFVuaW1wbGVtZW50ZWQgZXhwcmVzc2lvbiBmb3JtOiAke2NsYXNzTmFtZShlKX0uYClcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgY2xhc3MgRXhwbFZhbHVlVmlldyBleHRlbmRzIFZpZXcge1xuICAgICAgdHY6IEV4cGxWYWx1ZVxuICAgICAgc2hvd192OiBib29sZWFuXG4gICAgICBzaG93X3RzOiBib29sZWFuXG4gICAgICB0X3Zpc2libGUhOiBib29sZWFuXG4gICAgICB2X3Zpc2libGUhOiBib29sZWFuXG5cbiAgICAgIGFzc2VydFZhbGlkICgpOiB2b2lkIHtcbiAgICAgICAgIGFzc2VydCh0aGlzLnNob3dfdiB8fCB0aGlzLnNob3dfdHMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yICh0djogRXhwbFZhbHVlLCBzaG93X3Y6IGJvb2xlYW4sIHNob3dfdHM6IGJvb2xlYW4pIHtcbiAgICAgICAgIHN1cGVyKClcbiAgICAgICAgIHRoaXMudHYgPSB0dlxuICAgICAgICAgdGhpcy5zaG93X3YgPSBzaG93X3ZcbiAgICAgICAgIHRoaXMuc2hvd190cyA9IHNob3dfdHNcbiAgICAgICAgIHRoaXMuaW5pdGlhbGlzZSgpXG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2UgKCk6IFtFeHBsW10sIEV4cGxWYWx1ZSB8IG51bGxdIHtcbiAgICAgICAgIGNvbnN0IHRzOiBFeHBsW10gPSBzcGxpdEV4cGxzKHRoaXMudHYudClcbiAgICAgICAgIGlmICh0cy5sZW5ndGggPT09IDAgfHwgIXRoaXMuc2hvd190cykge1xuICAgICAgICAgICAgdGhpcy50X3Zpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy52X3Zpc2libGUgPSB0cnVlXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50X3Zpc2libGUgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLnZfdmlzaWJsZSA9IHRoaXMuc2hvd192XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gW3RzLCBzcGxpdFZhbHVlKHRoaXMudHYpXVxuICAgICAgfVxuXG4gICAgICByZW5kZXJfICgpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWQoKVxuICAgICAgICAgY29uc3QgW3RzLCB0dl06IFtFeHBsW10sIEV4cGxWYWx1ZSB8IG51bGxdID0gdGhpcy5pbml0aWFsaXNlKClcbiAgICAgICAgIGxldCBnOiBTVkdTVkdFbGVtZW50IFxuICAgICAgICAgaWYgKCF0aGlzLnZfdmlzaWJsZSkge1xuICAgICAgICAgICAgZyA9IGV4cGxzKHRzKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoIXRoaXMudF92aXNpYmxlKSB7XG4gICAgICAgICAgICBnID0gdmFsdWVWaWV3KHR2ISkucmVuZGVyKClcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnID0gdmVydChleHBscyh0cyksIGhvcml6U3BhY2UodGV4dChcIuKWuFwiLCBkZWx0YVN0eWxlKG50aCh0cywgdHMubGVuZ3RoIC0gMSkpKSwgdmFsdWVWaWV3KHR2ISkucmVuZGVyKCkpKVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKHRoaXMudHYgPT09IF9fY3VycmVudEVkaXRvciEuaGVyZS50dikge1xuICAgICAgICAgICAgcmV0dXJuIGFkZEJvcmRlcl9mb2N1cyghdGhpcy50X3Zpc2libGUgJiYgdHMubGVuZ3RoID4gMCAgPyBlZGdlX2xlZnQoZykgOiBnKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvZ2dsZVZhbHVlICgpOiB2b2lkIHtcbiAgICAgICAgIGlmICghdGhpcy5zaG93X3YpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd192ID0gdHJ1ZVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy5zaG93X3RzKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dfdiA9IGZhbHNlXG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvZ2dsZUV4cGwgKCk6IHZvaWQge1xuICAgICAgICAgaWYgKCF0aGlzLnNob3dfdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd190cyA9IHRydWVcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKHRoaXMuc2hvd192KSB7XG4gICAgICAgICAgICB0aGlzLnNob3dfdHMgPSBmYWxzZVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgRXhwbFZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgICAgIHQ6IEV4cGxcbiAgICAgIGJvZHlWaXNpYmxlOiBib29sZWFuIC8vIGlmIEkgYW0gYW4gYXBwbGljYXRpb24gdmlldywgd2hldGhlciB0aGUgZnVuY3Rpb24gYm9keSBpcyB2aXNpYmxlXG5cbiAgICAgIGNvbnN0cnVjdG9yICh0OiBFeHBsKSB7XG4gICAgICAgICBzdXBlcigpXG4gICAgICAgICB0aGlzLnQgPSB0XG4gICAgICAgICB0aGlzLmJvZHlWaXNpYmxlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmVuZGVyXyAoKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICAgICBsZXQgZzogU1ZHU1ZHRWxlbWVudFxuICAgICAgICAgaWYgKHRoaXMudCBpbnN0YW5jZW9mIEV4cGwuVmFyKSB7XG4gICAgICAgICAgICBnID0gaG9yaXoodGV4dCh0aGlzLnQueC52YWwsIGRlbHRhU3R5bGUodGhpcy50KSkpXG4gICAgICAgICB9XG4gICAgICAgICBlbHNlXG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5VbmFyeUFwcCkge1xuICAgICAgICAgICAgZyA9IHZpZXcodGhpcy50LnRmLCBmYWxzZSwgdHJ1ZSkucmVuZGVyKClcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKHRoaXMudCBpbnN0YW5jZW9mIEV4cGwuQmluYXJ5QXBwKSB7XG4gICAgICAgICAgICBnID0gaG9yaXpTcGFjZShcbiAgICAgICAgICAgICAgIHZpZXcodGhpcy50LnR2MSwgZmFsc2UsIHRydWUpLnJlbmRlcigpLCBcbiAgICAgICAgICAgICAgIHRleHQodGhpcy50Lm9wTmFtZS52YWwsIGRlbHRhU3R5bGUodGhpcy50KSksIC8vIHdoYXQgYWJvdXQgY2hhbmdlcyBhc3NvY2lhdGVkIHdpdGggdC5vcE5hbWU/IFxuICAgICAgICAgICAgICAgdmlldyh0aGlzLnQudHYyLCBmYWxzZSwgdHJ1ZSkucmVuZGVyKClcbiAgICAgICAgICAgIClcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKHRoaXMudCBpbnN0YW5jZW9mIEV4cGwuQXBwKSB7XG4gICAgICAgICAgICBnID0gdmVydChcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2Uodmlldyh0aGlzLnQudGYsIGZhbHNlLCB0cnVlKS5yZW5kZXIoKSwgdmlldyh0aGlzLnQudHUsIGZhbHNlLCB0cnVlKS5yZW5kZXIoKSksXG4gICAgICAgICAgICAgICB0aGlzLmFwcEJvZHkoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5EZWZzKSB7XG4gICAgICAgICAgICBnID0gdmVydCguLi50aGlzLnQuZGVmzIUudG9BcnJheSgpLm1hcChkZWbigpwpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5NYXRjaEFzKSB7XG4gICAgICAgICAgICBnID0gdmVydChcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2Uoa2V5d29yZChcIm1hdGNoXCIsIGRlbHRhU3R5bGUodGhpcy50KSksIHZpZXcodGhpcy50LnR1LCBmYWxzZSwgdHJ1ZSkucmVuZGVyKCksIGtleXdvcmQoXCJhc1wiLCBkZWx0YVN0eWxlKHRoaXMudCkpKSxcbiAgICAgICAgICAgICAgIGVsaW1NYXRjaCh0aGlzLnQuzr4pXG4gICAgICAgICAgICApXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmICh0aGlzLnQgaW5zdGFuY2VvZiBFeHBsLlR5cGVtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQodGhpcy50KVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoXCJVbmtub3duIGV4cGxhbmF0aW9uIGZvcm1cIiwgdGhpcy50KVxuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIHNoYWRpbmcoZywgXCJ3aGl0ZVwiKVxuICAgICAgfVxuXG4gICAgICBhcHBCb2R5ICgpOiBTVkdFbGVtZW50IHtcbiAgICAgICAgIGNvbnN0IGFwcDogRXhwbC5BcHAgPSBhcyh0aGlzLnQsIEV4cGwuQXBwKVxuICAgICAgICAgY29uc3QgdHM6IEV4cGxbXSA9IHNwbGl0RXhwbHMoYXBwLnQpXG4gICAgICAgICBpZiAodHMubGVuZ3RoID09PSAwIHx8IHRoaXMuYm9keVZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBscyh0cylcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnOiBTVkdFbGVtZW50ID0gZWxsaXBzaXMoZGVsdGFTdHlsZShhcHAudCkpXG4gICAgICAgICAgICBnLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXY6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICB0aGlzLmJvZHlWaXNpYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgX19jdXJyZW50RWRpdG9yIS5vblZpZXdDaGFuZ2UoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBWYWx1ZVZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgICAgIC8vIFdlIG5lZWQgdGhlIFwibGVhZlwiIGV4cGxhbmF0aW9uIHRvIHJlbmRlciBhIHZhbHVlLCBmb3IgdHdvIHJlYXNvbnM6IHNvIHdlIGNhbiByZXRyaWV2ZSB0aGUgb3JpZ2luYWwgZXhwcmVzc2lvbiBmb3IgXG4gICAgICAvLyBlZGl0aW5nIHB1cnBvc2VzLCBhbmQgdG8gcmVuZGVyIGNvbXBvbmVudCBleHBsYW5hdGlvbnMgb2YgZGF0YSB2YWx1ZXMuXG4gICAgICB0djogRXhwbFZhbHVlXG5cbiAgICAgIGNvbnN0cnVjdG9yICh0djogRXhwbFZhbHVlKSB7XG4gICAgICAgICBzdXBlcigpXG4gICAgICAgICB0aGlzLnR2ID0gdHZcbiAgICAgIH1cblxuICAgICAgcmVuZGVyXyAoKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICAgICBsZXQgZzogU1ZHU1ZHRWxlbWVudFxuICAgICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIE51bSkge1xuICAgICAgICAgICAgY29uc3QgZTogRXhwciA9IGV4cHJGb3IodGhpcy50di50KVxuICAgICAgICAgICAgZyA9IGhvcml6KG51bV8odGhpcy50di52LCBlIGluc3RhbmNlb2YgRXhwci5Db25zdE51bSA/IGUudmFsIDogdW5kZWZpbmVkKSlcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIFN0cikge1xuICAgICAgICAgICAgZyA9IGhvcml6KHN0cl8odGhpcy50di52KSlcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIENsb3N1cmUpIHtcbiAgICAgICAgICAgIC8vIHRyZWF0IGNsb3N1cmVzIGFzIHRoZWlyIGZ1bmN0aW9uIGxpdGVyYWxzLCBmb3Igbm93XG4gICAgICAgICAgICBnID0gaG9yaXpTcGFjZShrZXl3b3JkKFwiZnVuXCIsIGRlbHRhU3R5bGUodGhpcy50di52KSksIGVsaW0odGhpcy50di52LmYpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50di52IGluc3RhbmNlb2YgRGF0YVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50di52IGluc3RhbmNlb2YgR3JhcGhpY3NFbGVtZW50KSB7XG4gICAgICAgICAgICAgICBjb25zdCB0ZzogRXhwbFZhbHVlPEdyYXBoaWNzRWxlbWVudD4gPSB0aGlzLnR2IGFzIEV4cGxWYWx1ZTxHcmFwaGljc0VsZW1lbnQ+XG4gICAgICAgICAgICAgICBjb25zdCBkaW0gPSB7IHdpZHRoOiBkZWZhdWx0RGltc1swXSwgaGVpZ2h0OiBkZWZhdWx0RGltc1sxXSB9XG4gICAgICAgICAgICAgICBsZXQgZzE6IFNWR0dFbGVtZW50XG4gICAgICAgICAgICAgICBbZywgZzFdID0gc3ZnRWxlbWVudF9pbnZlcnRlZChkaW0ud2lkdGgsIGRpbS5oZWlnaHQpXG4gICAgICAgICAgICAgICBuZXcgR3JhcGhpY3NSZW5kZXJlcihfX2N1cnJlbnRFZGl0b3IhLCBnLCBnMSkucmVuZGVyKHRnLCBfX25vbk51bGwoZGltZW5zaW9ucykodGcpKVxuICAgICAgICAgICAgICAgX19kaW1lbnNpb25zLnNldChnLCBkaW0pXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmICh0aGlzLnR2LnYgaW5zdGFuY2VvZiBQYWlyKSB7XG4gICAgICAgICAgICAgICBnID0gcGFpcih0aGlzLnR2IGFzIEV4cGxWYWx1ZTxQYWlyPilcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIExpc3QpIHtcbiAgICAgICAgICAgICAgIGcgPSBsaXN0KHRoaXMudHYgYXMgRXhwbFZhbHVlPExpc3Q+KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGcgPSBkYXRhQ29uc3RyKGZhbHNlLCB0aGlzLnR2IGFzIEV4cGxWYWx1ZTxEYXRhVmFsdWU+KVxuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGcgPSB1bmltcGxlbWVudGVkKHRoaXMudHYudilcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBzaGFkaW5nKGcsIFwibGF2ZW5kZXJcIilcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gVmFsdWVzIGFyZSB0cmVhdGVkIHNsaWdodGx5IGRpZmZlcmVudGx5IGJlY2F1c2UgdGhlIFwia2V5XCIgb2YgYSB2YWx1ZSB2aWV3IGlzIHRoZSB2YWx1ZSAodG8gZGlzdGluZ3Vpc2hcbiAgIC8vIGl0IGZyb20gdGhlIHZpZXcgb2YgdGhlIEV4cGxWYWx1ZSksIGJ1dCB0aGUgRXhwbCBpcyBhbHNvIHJlcXVpcmVkIHRvIHJlbmRlciB0aGUgdmFsdWUuXG4gICBleHBvcnQgZnVuY3Rpb24gdmFsdWVWaWV3ICh0djogRXhwbFZhbHVlKTogVmFsdWVWaWV3IHtcbiAgICAgIGxldCB3OiBWYWx1ZVZpZXcgfCB1bmRlZmluZWQgPSB2aWV3cy5nZXQoX19ub25OdWxsKHR2KS52KSBhcyBWYWx1ZVZpZXdcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHcgPSBuZXcgVmFsdWVWaWV3KHR2KVxuICAgICAgICAgdmlld3Muc2V0KHR2LnYsIHcpXG4gICAgICAgICByZXR1cm4gd1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB3XG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiB2aWV3ICh0djogRXhwbFZhbHVlLCBzaG93X3Y6IGJvb2xlYW4sIHNob3dfdHM6IGJvb2xlYW4pOiBFeHBsVmFsdWVWaWV3IHtcbiAgICAgIGxldCB3OiBFeHBsVmFsdWVWaWV3IHwgdW5kZWZpbmVkID0gdmlld3MuZ2V0KHR2KSBhcyBFeHBsVmFsdWVWaWV3XG4gICAgICBpZiAodyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB3ID0gbmV3IEV4cGxWYWx1ZVZpZXcodHYsIHNob3dfdiwgc2hvd190cylcbiAgICAgICAgIHZpZXdzLnNldCh0diwgdylcbiAgICAgICAgIHJldHVybiB3XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHdcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gdmlld19jaGlsZDxUIGV4dGVuZHMgRGF0YVZhbHVlPiAoQzogQ2xhc3M8VD4sIHR2OiBFeHBsVmFsdWU8VD4sIHByb3BfOiBrZXlvZiBULCBzaG93X3Y6IGJvb2xlYW4sIHNob3dfdHM6IGJvb2xlYW4pOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIGlmICh2ZXJzaW9uZWQodHYudikgJiYgdmVyc2lvbmVkKHR2LnQpKSB7XG4gICAgICAgICBjb25zdCBwcm9wOiBzdHJpbmcgPSBwcm9wXyBhcyBzdHJpbmdcbiAgICAgICAgIGNvbnN0IHc6IFZpZXcgPSB2aWV3KEV4cGwuZXhwbENoaWxkKHR2LnQsIHR2LnYsIHByb3BfKSwgc2hvd192LCBzaG93X3RzKVxuICAgICAgICAgY29uc3QgZzogU1ZHU1ZHRWxlbWVudCA9IHcucmVuZGVyKClcbiAgICAgICAgIGlmICh0di52Ll9f4bqfIGluc3RhbmNlb2YgQ2hhbmdlICYmIHR2LnYuX1/hup8uaGFzQ2hhbmdlZChwcm9wIGFzIHN0cmluZykpIHtcbiAgICAgICAgICAgIC8vIEFsbCBhIGJpdCBoYWNreSwgbmVlZCB0byByZXRoaW5rOlxuICAgICAgICAgICAgY29uc3QgdF9wcmV2OiBFeHBsID0gXG4gICAgICAgICAgICAgICB0di50Ll9f4bqfIGluc3RhbmNlb2YgQ2hhbmdlICYmIHR2LnQuX1/hup8uaGFzQ2hhbmdlZChwcm9wIGFzIHN0cmluZykgPyBcbiAgICAgICAgICAgICAgIGFzKHR2LnQuX1/hup8uY2hhbmdlZFtwcm9wXS5iZWZvcmUsIEV4cGwuRXhwbCkgOlxuICAgICAgICAgICAgICAgdHYudFxuICAgICAgICAgICAgY29uc3Qgd19leGlzdGluZzogVmlldyB8IHVuZGVmaW5lZCA9IHZpZXdzLmdldChleHBsVmFsdWUodF9wcmV2LCBhcyh0di52Ll9f4bqfLmNoYW5nZWRbcHJvcF0uYmVmb3JlLCBWYWx1ZSkpKVxuICAgICAgICAgICAgaWYgKHdfZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgIF9fbGlua3MuYWRkKHsgZnJvbTogdywgdG86IHdfZXhpc3RpbmcgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRCb3JkZXJfY2hhbmdlZChnKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBleHBsVmlldyAodDogRXhwbC5FeHBsKTogVmlldyB7XG4gICAgICBsZXQgdzogRXhwbFZpZXcgfCB1bmRlZmluZWQgPSB2aWV3cy5nZXQodCkgYXMgRXhwbFZpZXdcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHcgPSBuZXcgRXhwbFZpZXcodClcbiAgICAgICAgIHZpZXdzLnNldCh0LCB3KVxuICAgICAgICAgcmV0dXJuIHdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gd1xuICAgICAgfVxuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gc3BsaXRFeHBscyAodDogRXhwbCk6IEV4cGxbXSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuQ29uc3QpIHtcbiAgICAgICAgIHJldHVybiBbXVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuRnVuKSB7XG4gICAgICAgICByZXR1cm4gW11cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkRhdGFFeHBsKSB7XG4gICAgICAgICByZXR1cm4gW11cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlZhcikge1xuICAgICAgICAgLy8gdmFsdWVzIG9mIHZhcmlhYmxlcyB0aGVtc2VsdmVzIGhhdmUgZXhwbGFuYXRpb25zLCBidXQgaWdub3JlIHRob3NlIGZvciBub3dcbiAgICAgICAgIHJldHVybiBbdF1cbiAgICAgIH0gZWxzZVxuICAgICAgICAgLy8gZG9uJ3QgcmVjdXJzZSBpbnRvIEFwcCBhcyBpdCBoYXMgaXRzIG93biBleHBhbnNpb24gc3RhdGVcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5VbmFyeUFwcCB8fCB0IGluc3RhbmNlb2YgRXhwbC5CaW5hcnlBcHApIHtcbiAgICAgICAgIHJldHVybiBbdF1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkFwcCkge1xuICAgICAgICAgcmV0dXJuIFt0XVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuTm9uVGVybWluYWwpIHtcbiAgICAgICAgIHJldHVybiBbdCwgLi4uc3BsaXRFeHBscyh0LnQpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoXCJVbmtub3duIGV4cGxhbmF0aW9uIGZvcm1cIiwgdClcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gVGhlIHZhbHVlIHBhcnQgbXVzdCBiZSBhbiBFeHBsVmFsdWUsIGJlY2F1c2UgaW4gdGhlIGRhdGEgdmFsdWUgY2FzZSB3ZSBuZWVkIHRoZSBleHBsYW5hdGlvbiBhcyB3ZWxsIHRvXG4gICAvLyByZW5kZXIgdGhlIHZhbHVlLlxuICAgZXhwb3J0IGZ1bmN0aW9uIHNwbGl0VmFsdWUgKHR2OiBFeHBsVmFsdWUpOiBFeHBsVmFsdWUge1xuICAgICAgY29uc3Qge3QsIHZ9OiBFeHBsVmFsdWUgPSB0dlxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkNvbnN0KSB7XG4gICAgICAgICByZXR1cm4gdHZcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkZ1bikge1xuICAgICAgICAgcmV0dXJuIHR2XG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5EYXRhRXhwbCkge1xuICAgICAgICAgcmV0dXJuIHR2XG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5WYXIpIHtcbiAgICAgICAgIC8vIHZhbHVlcyBvZiB2YXJpYWJsZXMgdGhlbXNlbHZlcyBoYXZlIGV4cGxhbmF0aW9ucywgYnV0IGlnbm9yZSB0aG9zZSBmb3Igbm93XG4gICAgICAgICByZXR1cm4gc3BsaXRWYWx1ZShleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIH0gZWxzZVxuICAgICAgICAgLy8gZG9uJ3QgcmVjdXJzZSBpbnRvIEFwcCBhcyBpdCBoYXMgaXRzIG93biBleHBhbnNpb24gc3RhdGVcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5VbmFyeUFwcCB8fCB0IGluc3RhbmNlb2YgRXhwbC5CaW5hcnlBcHApIHtcbiAgICAgICAgIHJldHVybiB0dlxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuQXBwKSB7XG4gICAgICAgICByZXR1cm4gdHZcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLk5vblRlcm1pbmFsKSB7XG4gICAgICAgICByZXR1cm4gc3BsaXRWYWx1ZShleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gZXhwbHMgKHRzOiBFeHBsW10pOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiB2ZXJ0KC4uLnRzLm1hcCh0ID0+IGV4cGxWaWV3KHQpLnJlbmRlcigpKSlcbiAgIH1cblxuICAgLy8gVG8gdmlzdWFsaXNlIGFuIGVsaW1pbmF0b3IsIHdlIHJlY29uc3RydWN0IHRoZSBwYXR0ZXJucyBmcm9tIHRoZSB0cmllLiBMaXN0IHN5bnRheCBpbiBwYXJ0aWN1bGFyIGRvZXNuJ3QgaGF2ZVxuICAgLy8gYW4gYW5hbG9nb3VzIFwiY2FzZSB0cmVlXCIgZm9ybS5cbiAgIHR5cGUgUGF0dGVybkVsZW1lbnQgPSBbQ3RyIHwgU3RyLCBEZWx0YVN0eWxlXVxuXG4gICBmdW5jdGlvbiBjb21wYXJlQ3RyIChjMTogc3RyaW5nLCBjMjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgIGNvbnN0IG46IG51bWJlciA9IGN0ckZvcihjMSkuYXJpdHkgLSBjdHJGb3IoYzIpLmFyaXR5XG4gICAgICByZXR1cm4gbiA9PT0gMCA/IGMxLmxvY2FsZUNvbXBhcmUoYzIpIDogblxuICAgfVxuXG4gICBmdW5jdGlvbiBjb250ICjOujogQ29udCk6IFtQYXR0ZXJuRWxlbWVudFtdLCBFeHByXVtdIHtcbiAgICAgIGlmICjOuiBpbnN0YW5jZW9mIEV4cHIuRXhwcikge1xuICAgICAgICAgcmV0dXJuIFtbW10sIM66XV1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKM66IGluc3RhbmNlb2YgRWxpbSkge1xuICAgICAgICAgcmV0dXJuIGNsYXVzZXMozropXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGNsYXVzZXM8SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPik6IFtQYXR0ZXJuRWxlbWVudFtdLCBFeHByXVtdIHtcbiAgICAgIGlmIChWYXJFbGltLmlzKM+DKSkge1xuICAgICAgICAgY29uc3QgY3M6IFtQYXR0ZXJuRWxlbWVudFtdLCBFeHByXVtdID0gY29udCjPgy7OuilcbiAgICAgICAgIC8vIGRpc3JlZ2FyZCBhbnkgZGVsdGEgaW5mb3JtYXRpb24gb24geCA6LS9cbiAgICAgICAgIHJldHVybiBjcy5tYXAoKFtjeHMsIGVdKSA9PiBbW1vPgy54LCBkZWx0YVN0eWxlKM+DKV0sIC4uLmN4c10sIGVdKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoRGF0YUVsaW0uaXMoz4MpKSB7XG4gICAgICAgICBjb25zdCBjzrpzOiBbc3RyaW5nLCBDb250XVtdID0gemlwKGZpZWxkcyjPgyksIM+DLl9fY2hpbGRyZW4gYXMgQ29udFtdKS5zb3J0KChbYzEsIF0sIFtjMiwgXSk6IG51bWJlciA9PiBjb21wYXJlQ3RyKGMxLCBjMikpXG4gICAgICAgICByZXR1cm4gZmxhdHRlbihjzrpzLmZpbHRlcigoW2MsIM66XSkgPT4gzrogIT09IHVuZGVmaW5lZCkubWFwKChbYywgzrpdKTogW1BhdHRlcm5FbGVtZW50W10sIEV4cHJdW10gPT5cbiAgICAgICAgICAgIGNvbnQoX19ub25OdWxsKM66KSkubWFwKChbY3hzLCBlXTogW1BhdHRlcm5FbGVtZW50W10sIEV4cHJdKSA9PiBbW1tjdHJGb3IoYyksIGRlbHRhU3R5bGUoz4MpXSwgLi4uY3hzXSwgZV0pXG4gICAgICAgICApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBjb25zQ29tbWEgKOG6n19zdHlsZTogRGVsdGFTdHlsZSwgc3JjPzogRXhwci5EYXRhRXhwcik6IFNWR0VsZW1lbnQge1xuICAgICAgY29uc3QgZzogU1ZHRWxlbWVudCA9IGNvbW1hKOG6n19zdHlsZSlcbiAgICAgIGcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldjogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgIGlmIChzcmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3UmV2aXNpb24oKVxuICAgICAgICAgICAgaWYgKGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgIGlmIChldi5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIG15IHRhaWwgaXMgYW5vdGhlciBjb25zLCBzd2FwIHRoZSB0d28gaGVhZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgY29uc3QgZTogRXhwciA9IGFzKG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3RvKENvbnMsIFwidGFpbFwiKS52LCBFeHByLkV4cHIpXG4gICAgICAgICAgICAgICAgICBpZiAoaXNFeHByRm9yKGUsIENvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICBjb25zdCBlMTogRXhwciA9IGFzKG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3RvKENvbnMsIFwiaGVhZFwiKS52LCBFeHByLkV4cHIpXG4gICAgICAgICAgICAgICAgICAgICBjb25zdCBlMjogRXhwciA9IGFzKG5ldyBFeHByQ3Vyc29yKGUpLmNvbnN0cl90byhDb25zLCBcImhlYWRcIikudiwgRXhwci5FeHByKVxuICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3RyX3NwbGljZSBvbiBzcmMsIHJlcGxhY2luZyBoZWFkIHdpdGggaGVhZCBvZiBzcmMudGFpbFxuICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3RyX3NwbGljZSBvbiBzcmMudGFpbCwgcmVwbGFjaW5nIGhlYWQgd2l0aCBoZWFkIG9mIHNyY1xuICAgICAgICAgICAgICAgICAgICAgbmV3IEV4cHJDdXJzb3Ioc3JjKS5jb25zdHJfc3BsaWNlKENvbnMsIFtcImhlYWRcIl0sIChbZV06IEV4cHJbXSk6IEV4cHJbXSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2UyXVxuICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKGUpLmNvbnN0cl9zcGxpY2UoQ29ucywgW1wiaGVhZFwiXSwgKFtlXTogRXhwcltdKTogRXhwcltdID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZTFdXG4gICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3NwbGljZShDb25zLCBbXCJoZWFkXCJdLCAoW2VdOiBFeHByW10pOiBFeHByW10gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgY29uc3QgZcq5OiBFeHByID0gRXhwci5hcHAoRXhwci52YXJfKHN0cihcInNxXCIpKM69KCkpKSjOvSgpKSwgRXhwci52YXJfKHN0cihcInhcIikozr0oKSkpKM69KCkpKSjOvSgpKVxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdChleHByQ2xhc3MoUGFpciksIGUsIGXKuSkozr0oKSldXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3NwbGljZShDb25zLCBbXCJ0YWlsXCJdLCAoW2VdOiBFeHByW10pOiBFeHByW10gPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZcq5OiBFeHByID0gRXhwci5jb25zdE51bShudW0oMCkozr0oKSkpKM69KCkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2F0KGV4cHJDbGFzcyhDb25zKSwgZcq5LCBlKSjOvSgpKV1cbiAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2N1cnJlbnRFZGl0b3IhLm9uRWRpdCgpXG4gICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIGdcbiAgIH1cblxuICAgZnVuY3Rpb24gZGF0YUNvbnN0ciAocGFyZW5zOiBib29sZWFuLCB7dCwgdn06IEV4cGxWYWx1ZTxEYXRhVmFsdWU+KTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCB0dnM6IEV4cGxWYWx1ZVtdID0gRXhwbC5leHBsQ2hpbGRyZW4odCwgdilcbiAgICAgIC8vIGEgY29uc3RydWN0b3IgZXhwcmVzc2lvbiBtYWtlcyBpdHMgdmFsdWUsIHNvIHRoZWlyIHJvb3QgZGVsdGEgaGlnaGxpZ2h0aW5nIG11c3QgYWdyZWVcbiAgICAgIGNvbnN0IGdzOiBTVkdTVkdFbGVtZW50W10gPSB0dnMubWFwKHR2yrkgPT4gdmlldyh0dsq5LCB0cnVlLCBmYWxzZSkucmVuZGVyKCkpXG4gICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gaG9yaXpTcGFjZSh0ZXh0KHYuY3RyLCBkZWx0YVN0eWxlKHYpKSwgLi4uKHR2cy5sZW5ndGggPiAyID8gW3ZlcnQoLi4uZ3MpXSA6IGdzKSlcbiAgICAgIHJldHVybiBwYXJlbnRoZXNpc2VJZih0dnMubGVuZ3RoID4gMCAmJiBwYXJlbnMsIGcsIGRlbHRhU3R5bGUodCkpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIGRhdGFDb25zdHJfZXhwciAocGFyZW5zOiBib29sZWFuLCBlOiBFeHByLkRhdGFFeHByKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBlczogRXhwcltdID0gZS5fX2NoaWxkcmVuXG4gICAgICBjb25zdCBnczogU1ZHU1ZHRWxlbWVudFtdID0gZXMubWFwKGXKuSA9PiBleHByKHRydWUsIGXKuSkpXG4gICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gaG9yaXpTcGFjZSh0ZXh0KGUuY3RyLCBkZWx0YVN0eWxlKGUpKSwgLi4uKGVzLmxlbmd0aCA+IDIgPyBbdmVydCguLi5ncyldIDogZ3MpKVxuICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZUlmKGVzLmxlbmd0aCA+IDAgJiYgcGFyZW5zLCBnLCBkZWx0YVN0eWxlKGUpKVxuICAgfVxuXG4gICBmdW5jdGlvbiBkZWYgKGRlZjogRXhwci5EZWYpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLlByaW0pIHtcbiAgICAgICAgIHJldHVybiBob3JpelNwYWNlKGtleXdvcmQoXCJwcmltaXRpdmVcIiwgZGVsdGFTdHlsZShkZWYpKSwgcGF0dGVyblZhcihkZWYueCkpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCkge1xuICAgICAgICAgaWYgKGRlZi5lIGluc3RhbmNlb2YgRXhwci5GdW4pIHtcbiAgICAgICAgICAgIHJldHVybiBob3JpelNwYWNlKGtleXdvcmQoXCJsZXRfXCIsIGRlbHRhU3R5bGUoZGVmKSksIHBhdHRlcm5WYXIoZGVmLngpLCBlbGltKGRlZi5lLs+DKSlcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShcbiAgICAgICAgICAgICAgIGtleXdvcmQoXCJsZXRfXCIsIGRlbHRhU3R5bGUoZGVmKSksIFxuICAgICAgICAgICAgICAgcGF0dGVyblZhcihkZWYueCksIFxuICAgICAgICAgICAgICAga2V5d29yZChcImVxdWFsc1wiLCBkZWx0YVN0eWxlKGRlZikpLCBcbiAgICAgICAgICAgICAgIGV4cHIoZmFsc2UsIGRlZi5lKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwci5MZXRSZWMpIHtcbiAgICAgICAgIHJldHVybiBob3JpelNwYWNlKGtleXdvcmQoXCJsZXRSZWNcIiwgZGVsdGFTdHlsZShkZWYpKSwgdmVydCguLi5kZWYuzrQudG9BcnJheSgpLm1hcChkZWYgPT4gcmVjRGVmKGRlZikpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gZGVm4oKcIChkZWY6IEV4cGwuRGVmKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwbC5QcmltKSB7XG4gICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShrZXl3b3JkKFwicHJpbWl0aXZlXCIsIGRlbHRhU3R5bGUoZGVmKSksIHBhdHRlcm5WYXIoZGVmLngpKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwbC5MZXQpIHtcbiAgICAgICAgIGlmIChkZWYudHYudCBpbnN0YW5jZW9mIEV4cGwuRnVuICYmIGRlZi50di52IGluc3RhbmNlb2YgQ2xvc3VyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhvcml6U3BhY2Uoa2V5d29yZChcImxldF9cIiwgZGVsdGFTdHlsZShkZWYpKSwgcGF0dGVyblZhcihkZWYueCksIGVsaW0oZGVmLnR2LnYuZikpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhvcml6U3BhY2UoXG4gICAgICAgICAgICAgICBrZXl3b3JkKFwibGV0X1wiLCBkZWx0YVN0eWxlKGRlZikpLCBcbiAgICAgICAgICAgICAgIHBhdHRlcm5WYXIoZGVmLngpLCBcbiAgICAgICAgICAgICAgIGtleXdvcmQoXCJlcXVhbHNcIiwgZGVsdGFTdHlsZShkZWYpKSxcbiAgICAgICAgICAgICAgIHZpZXcoZGVmLnR2LCBmYWxzZSwgdHJ1ZSkucmVuZGVyKClcbiAgICAgICAgICAgIClcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cGwuTGV0UmVjKSB7XG4gICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShrZXl3b3JkKFwibGV0UmVjXCIsIGRlbHRhU3R5bGUoZGVmKSksIHZlcnQoLi4uZGVmLs60LnRvQXJyYXkoKS5tYXAoZGVmID0+IHJlY0RlZuKCnChkZWYpKSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGVsaW08SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIHZlcnQoLi4uY2xhdXNlcyjPgykubWFwKChbY3hzLCBlXSkgPT4ge1xuICAgICAgICAgY29uc3QgW1tnXSwgY3hzyrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKGZhbHNlLCAxLCBjeHMpXG4gICAgICAgICBhc3NlcnQoY3hzyrkubGVuZ3RoID09PSAwKVxuICAgICAgICAgY29uc3QgZ8q5OiBTVkdFbGVtZW50ID0gXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXhwci5GdW4gP1xuICAgICAgICAgICAgZWxpbShlLs+DKSA6IC8vIGN1cnJpZWQgZnVuY3Rpb24gcmVzdWdhcmluZ1xuICAgICAgICAgICAgaG9yaXpTcGFjZShhcnJvdyhkZWx0YVN0eWxlKGUpKSwgZXhwcihmYWxzZSwgZSkpXG4gICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShnLCBnyrkpXG4gICAgICB9KSlcbiAgIH1cblxuICAgLy8gSGFjayBqdXN0IHRvIHN1cHBvcnQgQm9vbCwgT3JkZXJpbmcsIGV0Yy5cbiAgIGZ1bmN0aW9uIGVsaW1NYXRjaDxLIGV4dGVuZHMgQ29udD4gKM6+OiBNYXRjaDxLPik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgY29uc3QgdHY6IEV4cGxWYWx1ZTxEYXRhVmFsdWU+ID0gbnRoKM6+LnR2zIUudG9BcnJheSgpLCAwKVxuICAgICAgLy8gZG9uJ3QgdGhpbmsgdGhlIGNvbnRpbmF0aW9uIGlzIG5lZWRlZDsgYWxyZWFkeSBzdG9yZWQgaW4gdGhlIHRyYWNlXG4gICAgICByZXR1cm4gaG9yaXpTcGFjZSh0ZXh0KHR2LnYuY3RyLCBkZWx0YVN0eWxlKHR2LnYpKSwgYXJyb3coZGVsdGFTdHlsZSh0di52KSkpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIGV4cHJfIChwYXJlbnM6IGJvb2xlYW4sIGU6IEV4cHIpOiBFeHByVmlldyB7XG4gICAgICBsZXQgdzogRXhwclZpZXcgfCB1bmRlZmluZWQgPSB2aWV3cy5nZXQoZSkgYXMgRXhwclZpZXdcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHcgPSBuZXcgRXhwclZpZXcocGFyZW5zLCBlKVxuICAgICAgICAgdmlld3Muc2V0KGUsIHcpXG4gICAgICAgICByZXR1cm4gd1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB3XG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGV4cHIgKHBhcmVuczogYm9vbGVhbiwgZTogRXhwcik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIGV4cHJfKHBhcmVucywgZSkucmVuZGVyKClcbiAgIH1cblxuICAgLy8gUmVhbGx5IHdhbnQgc29tZSBraW5kIG9mIHZpZXcgdHlwZWNsYXNzLCBzbyB0aGlzIGlzbid0IHNwZWNpZmljIHRvIGV4cHJlc3Npb24uIEFsc286IGNvbnNvbGlkYXRlIHdpdGggRXhwckN1cnNvci5cbiAgIGZ1bmN0aW9uIGV4cHJfY2hpbGQ8VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+LCBwYXJlbnM6IGJvb2xlYW4sIGU6IEV4cHIuRGF0YUV4cHIsIHByb3A6IGtleW9mIFQpOiBTVkdFbGVtZW50IHtcbiAgICAgIGlmICh2ZXJzaW9uZWQoZSkpIHtcbiAgICAgICAgIGNvbnN0IHc6IEV4cHJWaWV3ID0gZXhwcl8ocGFyZW5zLCBlLl9fY2hpbGQocHJvcCBhcyBrZXlvZiBFeHByLkRhdGFFeHByKSlcbiAgICAgICAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSB3LnJlbmRlcigpXG4gICAgICAgICBpZiAoZS5fX+G6nyBpbnN0YW5jZW9mIENoYW5nZSAmJiBlLl9f4bqfLmhhc0NoYW5nZWQocHJvcCBhcyBzdHJpbmcpKSB7XG4gICAgICAgICAgICBjb25zdCB3X2V4aXN0aW5nOiBWaWV3IHwgdW5kZWZpbmVkID0gdmlld3MuZ2V0KGFzKGUuX1/hup8uY2hhbmdlZFtwcm9wIGFzIHN0cmluZ10uYmVmb3JlLCBFeHByLkV4cHIpKVxuICAgICAgICAgICAgaWYgKHdfZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgIF9fbGlua3MuYWRkKHsgZnJvbTogdywgdG86IHdfZXhpc3RpbmcgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRCb3JkZXJfY2hhbmdlZChnKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9ICAgXG4gICB9XG5cbiAgIGZ1bmN0aW9uIGxpc3QgKHt0LCB2fTogRXhwbFZhbHVlPExpc3Q+KTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBpZiAoQ29ucy5pcyh2KSkge1xuICAgICAgICAgY29uc3Qgdsq5OiBDb25zID0gdiBhcyBDb25zXG4gICAgICAgICBjb25zdCBlOiBFeHByID0gZXhwckZvcih0KVxuICAgICAgICAgcmV0dXJuIGhvcml6KFxuICAgICAgICAgICAgdmlld19jaGlsZChDb25zLCBleHBsVmFsdWUodCwgdsq5KSwgXCJoZWFkXCIsIHRydWUsIGZhbHNlKSxcbiAgICAgICAgICAgIGNvbnNDb21tYShkZWx0YVN0eWxlKHYpLCBpc0V4cHJGb3IoZSwgQ29ucykgPyBlIGFzIEV4cHIuRGF0YUV4cHIgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgc3BhY2UoKSxcbiAgICAgICAgICAgIHZpZXcoRXhwbC5leHBsQ2hpbGQodCwgdsq5LCBcInRhaWxcIiksIHRydWUsIGZhbHNlKS5yZW5kZXIoKVxuICAgICAgICAgKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoTmlsLmlzKHYpKSB7XG4gICAgICAgICByZXR1cm4gaG9yaXooY2VudHJlRG90KGRlbHRhU3R5bGUodikpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBsaXN0X2V4cHIgKHBhcmVuczogYm9vbGVhbiwgZTogRXhwci5EYXRhRXhwcik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgaWYgKGlzRXhwckZvcihlLCBDb25zKSkge1xuICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZUlmKHBhcmVucywgXG4gICAgICAgICAgICBob3JpeihcbiAgICAgICAgICAgICAgIGV4cHJfY2hpbGQoQ29ucywgZmFsc2UsIGUsIFwiaGVhZFwiKSxcbiAgICAgICAgICAgICAgIGNvbnNDb21tYShkZWx0YVN0eWxlKGUpLCBlKSxcbiAgICAgICAgICAgICAgIHNwYWNlKCksIFxuICAgICAgICAgICAgICAgbGlzdF9leHByKGZhbHNlLCBlLl9fY2hpbGQoXCJ0YWlsXCIgYXMga2V5b2YgRXhwci5EYXRhRXhwcikgYXMgRXhwci5EYXRhRXhwcilcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBkZWx0YVN0eWxlKGUpXG4gICAgICAgICApXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChpc0V4cHJGb3IoZSwgTmlsKSkge1xuICAgICAgICAgcmV0dXJuIGhvcml6KGNlbnRyZURvdChkZWx0YVN0eWxlKGUpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gaG9yaXooZXhwcihmYWxzZSwgZSkpIC8vIHByb21vdGUgdG8gbmVzdGVkIFNWRzsgbmVlZCB0byByZXRoaW5rXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIG51bV8gKG46IE51bSwgc3JjPzogTnVtKTogU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBTVkdFbGVtZW50ID0gdGV4dChuLnRvU3RyaW5nKCksIGRlbHRhU3R5bGUobikpXG4gICAgICBpZiAoc3JjICYmIE51bWJlci5pc0ludGVnZXIoc3JjLnZhbCkpIHtcbiAgICAgICAgIGcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldjogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgbmV3UmV2aXNpb24oKVxuICAgICAgICAgICAgbmV3IEV4cHJDdXJzb3Ioc3JjKS5zZXROdW0oZXYubWV0YUtleSA/IHNyYy52YWwgLSAxIDogc3JjLnZhbCArIDEpXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgX19jdXJyZW50RWRpdG9yIS5vbkVkaXQoKVxuICAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBnXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhaXIgKHR2OiBFeHBsVmFsdWU8UGFpcj4pOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiBwYXJlbnRoZXNpc2UoXG4gICAgICAgICBob3JpeihcbiAgICAgICAgICAgIHZpZXdfY2hpbGQoUGFpciwgdHYsIFwiZnN0XCIsIHRydWUsIGZhbHNlKSxcbiAgICAgICAgICAgIHBhaXJDb21tYShkZWx0YVN0eWxlKHR2LnQpLCBleHByRm9yKHR2LnQpIGFzIEV4cHIuRGF0YUV4cHIpLFxuICAgICAgICAgICAgc3BhY2UoKSxcbiAgICAgICAgICAgIHZpZXdfY2hpbGQoUGFpciwgdHYsIFwic25kXCIsIHRydWUsIGZhbHNlKVxuICAgICAgICAgKSwgXG4gICAgICAgICBkZWx0YVN0eWxlKHR2LnQpXG4gICAgICApXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhaXJDb21tYSAo4bqfX3N0eWxlOiBEZWx0YVN0eWxlLCBzcmM/OiBFeHByLkRhdGFFeHByKTogU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBTVkdFbGVtZW50ID0gY29tbWEo4bqfX3N0eWxlKVxuICAgICAgZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgaWYgKHNyYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSZXZpc2lvbigpXG4gICAgICAgICAgICBpZiAoZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgbmV3IEV4cHJDdXJzb3Ioc3JjKS5jb25zdHJfc3BsaWNlKFBhaXIsIFtcImZzdFwiLCBcInNuZFwiXSwgKFtlMSwgZTJdOiBFeHByW10pOiBFeHByW10gPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlMiwgZTFdXG4gICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jdXJyZW50RWRpdG9yIS5vbkVkaXQoKVxuICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBnXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhaXJfZXhwciAoZTogRXhwci5EYXRhRXhwcik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZShcbiAgICAgICAgIGhvcml6KFxuICAgICAgICAgICAgZXhwcl9jaGlsZChQYWlyLCBmYWxzZSwgZSwgXCJmc3RcIiksXG4gICAgICAgICAgICBwYWlyQ29tbWEoZGVsdGFTdHlsZShlKSwgZSksXG4gICAgICAgICAgICBzcGFjZSgpLFxuICAgICAgICAgICAgZXhwcl9jaGlsZChQYWlyLCBmYWxzZSwgZSwgXCJzbmRcIilcbiAgICAgICAgICksIFxuICAgICAgICAgZGVsdGFTdHlsZShlKVxuICAgICAgKVxuICAgfVxuICAgZnVuY3Rpb24gcGF0dGVybnMgKHBhcmVuczogYm9vbGVhbiwgbjogbnVtYmVyLCBjeHM6IFBhdHRlcm5FbGVtZW50W10pOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSB7XG4gICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgcmV0dXJuIFtbXSwgY3hzXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGNvbnN0IFtjdHJfeCwg4bqfX3N0eWxlXSA9IGN4c1swXVxuICAgICAgICAgaWYgKGN0cl94IGluc3RhbmNlb2YgQ3RyKSB7XG4gICAgICAgICAgICBpZiAoY3RyX3guQyA9PT0gUGFpcikge1xuICAgICAgICAgICAgICAgY29uc3QgW1tnMSwgZzJdLCBjeHPKuV06IFtTVkdFbGVtZW50W10sIFBhdHRlcm5FbGVtZW50W11dID0gcGF0dGVybnMoZmFsc2UsIDIsIGN4cy5zbGljZSgxKSlcbiAgICAgICAgICAgICAgIGNvbnN0IFtnc8q5LCBjeHPKucq5XTogW1NWR0VsZW1lbnRbXSwgUGF0dGVybkVsZW1lbnRbXV0gPSBwYXR0ZXJucyhwYXJlbnMsIG4gLSAxLCBjeHPKuSlcbiAgICAgICAgICAgICAgIHJldHVybiBbW3BhcmVudGhlc2lzZShob3JpeihnMSwgY29tbWEo4bqfX3N0eWxlKSwgc3BhY2UoKSwgZzIpLCDhup9fc3R5bGUpLCAuLi5nc8q5XSwgY3hzyrnKuV1cbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgaWYgKGN0cl94LkMgPT09IE5pbCkge1xuICAgICAgICAgICAgICAgY29uc3QgW2csIGN4c8q5XTogW1NWR0VsZW1lbnQsIFBhdHRlcm5FbGVtZW50W11dID0gW2NlbnRyZURvdCjhup9fc3R5bGUpLCBjeHMuc2xpY2UoMSldXG4gICAgICAgICAgICAgICBjb25zdCBbZ3MsIGN4c8q5yrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKHBhcmVucywgbiAtIDEsIGN4c8q5KVxuICAgICAgICAgICAgICAgcmV0dXJuIFtbZywgLi4uZ3NdLCBjeHPKucq5XVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBpZiAoY3RyX3guQyA9PT0gQ29ucykge1xuICAgICAgICAgICAgICAgY29uc3QgW1tnX2hlYWQsIGdfdGFpbF0sIGN4c8q5XTogW1NWR0VsZW1lbnRbXSwgUGF0dGVybkVsZW1lbnRbXV0gPSBwYXR0ZXJucyhmYWxzZSwgY3RyX3guYXJpdHksIGN4cy5zbGljZSgxKSlcbiAgICAgICAgICAgICAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSBob3JpeihnX2hlYWQsIGNvbW1hKOG6n19zdHlsZSksIHNwYWNlKCksIGdfdGFpbClcbiAgICAgICAgICAgICAgIGNvbnN0IFtnc8q5LCBjeHPKucq5XTogW1NWR0VsZW1lbnRbXSwgUGF0dGVybkVsZW1lbnRbXV0gPSBwYXR0ZXJucyhwYXJlbnMsIG4gLSAxLCBjeHPKuSlcbiAgICAgICAgICAgICAgIHJldHVybiBbW3BhcmVudGhlc2lzZUlmKGN0cl94LmFyaXR5ID4gMCAmJiBwYXJlbnMsIGcsIOG6n19zdHlsZSksIC4uLmdzyrldLCBjeHPKucq5XVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGNvbnN0IFtncywgY3hzyrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKHRydWUsIGN0cl94LmFyaXR5LCBjeHMuc2xpY2UoMSkpXG4gICAgICAgICAgICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gaG9yaXpTcGFjZSh0ZXh0KGN0cl94LmMsIOG6n19zdHlsZSksIC4uLmdzKVxuICAgICAgICAgICAgICAgY29uc3QgW2dzyrksIGN4c8q5yrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKHBhcmVucywgbiAtIDEsIGN4c8q5KVxuICAgICAgICAgICAgICAgcmV0dXJuIFtbcGFyZW50aGVzaXNlSWYoY3RyX3guYXJpdHkgPiAwICYmIHBhcmVucywgZywg4bqfX3N0eWxlKSwgLi4uZ3PKuV0sIGN4c8q5yrldXG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChjdHJfeCBpbnN0YW5jZW9mIFN0cikge1xuICAgICAgICAgICAgY29uc3QgW2dzLCBjeHPKuV06IFtTVkdFbGVtZW50W10sIFBhdHRlcm5FbGVtZW50W11dID0gcGF0dGVybnMocGFyZW5zLCBuIC0gMSwgY3hzLnNsaWNlKDEpKVxuICAgICAgICAgICAgLy8gb3VjaCwgaWdub3JlIOG6n19zdHlsZSBjb21pbmcgZnJvbSB0cmllIGFuZCB1c2UgdmFyaWFibGUgaW5zdGVhZCA6LS9cbiAgICAgICAgICAgIHJldHVybiBbW3BhdHRlcm5WYXIoY3RyX3gpLCAuLi5nc10sIGN4c8q5XVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBwYXR0ZXJuVmFyICh4OiBTdHIpOiBTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiB0ZXh0KHgudmFsLCBkZWx0YVN0eWxlKHgpKVxuICAgfVxuXG4gICBmdW5jdGlvbiByZWNEZWYgKGRlZjogRXhwci5SZWNEZWYpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiBob3JpelNwYWNlKHBhdHRlcm5WYXIoZGVmLngpLCBlbGltKGRlZi7PgykpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlY0RlZuKCnCAoZGVmOiBFeHBsLlJlY0RlZik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIGhvcml6U3BhY2UocGF0dGVyblZhcihkZWYueCksIGVsaW0oZGVmLnRmLnYuZikpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHN0cl8gKHN0cjogU3RyKTogU1ZHRWxlbWVudCB7XG4gICAgICByZXR1cm4gdGV4dChzdHIudG9TdHJpbmcoKSwgZGVsdGFTdHlsZShzdHIpKVxuICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6Zm9udC93b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBR1ZrQUJBQUFBQUFybmdBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQmJBQUFBQndBQUFBY2NRcW0wa2RFUlVZQUFBR0lBQUFBSFFBQUFCNEFKd0RzVDFNdk1nQUFBYWdBQUFCWkFBQUFZR3NqMndGamJXRndBQUFDQkFBQUFYZ0FBQUhLQS9GQTUyTjJkQ0FBQUFOOEFBQUFPQUFBQURnTFhBOC9abkJuYlFBQUE3UUFBQUd4QUFBQ1pWTzBMNmRuWVhOd0FBQUZhQUFBQUFnQUFBQUlBQUFBRUdkc2VXWUFBQVZ3QUFCWUNBQUFtMkRMOU10MGFHVmhaQUFBWFhnQUFBQTJBQUFBTmdMaHJXTm9hR1ZoQUFCZHNBQUFBQ0FBQUFBa0QwRUljMmh0ZEhnQUFGM1FBQUFCaFFBQUE1aUI1bTU0Ykc5allRQUFYMWdBQUFISEFBQUJ6c2V4b25wdFlYaHdBQUJoSUFBQUFDQUFBQUFnQWdNQjdXNWhiV1VBQUdGQUFBQUJnd0FBQXhJb3YyZHhjRzl6ZEFBQVlzUUFBQUhlQUFBQ3RQNDJ2WTF3Y21Wd0FBQmtwQUFBQUw4QUFBRk91NmhJMHdBQUFBRUFBQUFBMWUxRnVBQUFBQURCV1hZT0FBQUFBTm5ENnd0NDJtTmdaR0JnNEFGaU1TQm1ZbUFFd3FkQXpBTG1NUUFBRFhVQkZBQUFBSGphWTJCbWZzZjRoWUdWZ1lYVm1IVVdBd09qUElSbXZzNlF3aVRBd01ERXpjYkp6TURNd01EUXdNQ2dENVRQWm9DQ2dEVFhGQ0Nsb1BxSHJmOWZQd01EMjFyR1NRNE1ETUt0VjRDcVRqRGxnK1FZR0FHcGZBOWRBQUFBZU5wallHQmdab0JnR1FaR0JoQTRBdVF4Z3Zrc0RDdUF0QnFEQXBERnhsREg4Sjh4bUxHQzZSalRIUVV1QlJFRktRVTVCU1VGTlFWOUJTdUZlSVUxaWtxcWYvNy9CNnBYWUZqQUdBUlZ4NkFnb0NDaElBTlZaNGxROS8veC8wUC9DLzc3L1AzLzk5V0Q0dzhPUGRqL1lOK0QzUTkyUE5qd1lQbUQ1Z2ZtOXcvZGVnbDFEeEdBa1kwQnJwaVJDVWd3b1NzQWVwR0ZsWTJkZzVPTG00ZVhqMTlBVUVoWVJGUk1YRUpTU2xwR1ZrNWVRVkZKV1VWVlRWMURVMHRiUjFkUDM4RFF5TmpFMU16Y3d0TEsyc2JXenQ3QjBjblp4ZFhOM2NQVHk5dkgxODgvSURBb09DUTBMRHdpTWlvNkpqWXVQaUdSb2EyOXMzdnlqSG1MRnkxWnRuVDV5dFdyMXF4ZHYyN0R4czFidDJ6YnNYM1A3cjM3R0lwU1VqUHZWaXdzeUg1U2xzWFFNWXVobUlFaHZSenN1cHdhaGhXN0dwUHpRT3pjMm50SlRhM1REeDIrZXUzVzdlczNkakljUE1MdytNRkRvRXpselRzTUxUM052VjM5RXliMlRaM0dNR1hPM05rTVI0OFZBcVdxZ0JnQU1adUR1QUFBQTZjRS9BQjZBSEVBZGdCL0FJWUFpd0RTQUpFQWZBQ0VBSWdBalFDUkFKVUFtZ0NlQUtJQXBnQ3JBTlFBWmdCU0FGMEFSQVVSZU5wZFVidE9XMEVRM1EwUEE0SEUyQ0E1MmhTem1aREdlNkVGQ2NUVmpXSmtPNFhsQ0drM2NwR0xjUUVmUUlGRURkcXZHYUNocEVpYkJpRVhTSHhDUGlFU00ydUlvalE3TzdOenpwa3pTOHFScW5mcGE4OVQ1eVNRd3QwR3pUYjlUa2kxc3dEM3BPdnJqWXkwZ3dkYWJHYjB5blg3L2dzR205R1VPMm9BNVQxdktROFpUVHVCV3JTbi90SDhDb2I3L0Ivek94aTBOTlAwMURvSjZTRUU1cHR4UzRQdkdjMjZ5dy82Z3RYaFlqQXdwSmltNGk0L3BsTCt0elRuYXN1d3RaSFJ2SU16RWZuSk5FQlRhMjBFbXY3VUlkWHpjUlJMa011bXNUYVltTEwrSkJQQmhjbDBWVk8xelBqYXdWMnlzK2hnZ3lyTmdRZll3MVo1REI0T0R5WVUwcmNreWl3TkVmWmlxOFFJRVpNY0NqbmwzTW4rcEVENVNCTEd2RWxLTytPR3RRYkdrZGZBb0RaUHMvODhtMDF0YngzQytGa2N3WGUvR1VzNitNaUcyaGdSWWp0aUtZQUpSRUpHVmZtR0dzKzlMQWJrVXZ2UFFKU0E1ZkdQZjUwSXRPN1lSRHlYdFhVT01WWUllbjdiM1BMTGlydFd1YzZMUW5kdnFtcW8waW5OKzE3T3ZzY0RuaDRMdzBGandadlArLzVLZ2ZvOExLNDBhQTRFUTNvM2V2K2l0ZXFJcTd3WFBySW4wNyt4V2dBQUFBQUJBQUgvL3dBUGVOclV2UWw4VzlXVlAzN3ZlMC83K3JSNnR4YmJzaTFic2lYYnNydzdpWmM0emg1bmRmYUVCR2ZmOTRRc2hKQkFBMDFJRTZCc1pTa3dwZS9KRHVrQWJkTlNXbHJvU3B1WnRuUTZwWlQrM0gwNjdWQ0lyZnpPdVU5eTdDd1E1aitmK1gzK0VGbFBUN0x1dmVlZTVYdVdlMHc0TW9FUWJvV3FoL0JFUTBJeUplR0doRWJJK21ORVZxdmVia2p3SEZ3U21jZmJLcnlkMEtpemh4b1NGTzlIUmE5WTZCVzlFemhQc29DZVRhNVc5WHo0L0FUaHV3UytrbTY2TWdqZk94ZStOWXQwa0lTR2tPQUFyeU9pRUtSU2RsaWlsd1pVTG55VmV1cTNxYWcyS0d0ZGc1STJMTnRjZzNJT0RjbzJyV2pyNTlRYXZzQWRKeFdWQlZVMUVaZEQ3ZU9yWWswMEduRzVYVTRIdk9ublE1UnU2bGpSMmJraVlqWlY1dVRIREZxUksxeVZKMWdyVm5SMHJPZ1FmbEpWNFBHVmxYbWk1VTlsREwvQlZiZWR3VG1TZC9sSmZCbXMzVUx5U1RlUkxHRXBQenFnMHhHdEVKUXlJMVR5aENYK2txU095RWJIb0dTMHluWWFsRndST2NjeEtIdGhka1pldE1rNlN6d3UyVVhKR3BkeWJISm1maHduYW8vVlZGY1ZWVmZWd0NTZERndHRwbU5mdjF2bU1OWDQvUEVKa2IrVU8welZlRlhKcnpyZUZIWE5kdFhHbTFzNlh6NldNK1lWWWZPTkVpZi9QUlZQc2trK1BVVVNXbzRFSlUxVUl1R0VJeU03R28wT1VJR1VDc0VFSitaRUlwRUVvZnBnZnd2SjBnVWxJZHpQVy9QeUM5elJBUlg3VEw5YXB6Y1Z1SlZGWmwyU013MkRVcVpWMXNDeXRIQ3B0Y291dUhUQ3BkTXFHM0N4QnJab3FTYnJwZVlULzVoUG5FRzlJR1ZaNVV6K2c1ZWFqLzlqTHQ2UVhDSEpHSkpjVnZqRkQ1QmdCc01IS3ZoUVA1ZWxzUWY3ZWZaVGpUOWhySDVkcGhZdVhOWit2Y3NBRjA1cnY4bHBoQTlZMlUrUi9YVGd6NWVhNy9uSEt2aCtBMzdZalI5VzRlOW5zTitIYjg5T2YyTU8zaG56NlZ6MjZmNDhOZ0o4SWg4L2tZRHY4QnozSFBlcnphSXRMdVhHeVlzR285UGx6c3dOS2YvUkZpdkhJNEdzb3NPZGtaMlRtNWNmdXVZL3FTV0xFaEFYMFNiWjQ1SWdTclk0YkhzenRXdmdFZU5qK0xCUTl0RFlOZkRBdDZLNmI1ZitVdlBya3IzQmQ0b1BsTHhrZUxuMERjT2I1WHZMZjEyMk0zamsxeVcvb29jWDhYUWh0NVNuQzFUSngzbmFyVTUra1YvT0paOFJsdkRKVDJub0RpRjVXa1UzTEJYb1BJNkF4TzYrOGpqL2dxcWFWSkk0YVNXUEVha2lMSlZIWlkxcVVLcUxKQ28wdVAwVllkaiszTEFVQzBzRlVka0diMlZGRXJZWXZtV3o2MEFZeDRVbHl5VTVZaHFVSWxZNVRJTUpqYTBHdUVjT0dRWUhISzdNZ2pyZ0VpbGtsUnRoOC9NamNvbHhVQjRQL0JDeEFQTlRQaDZYU3hyaEtqY0hHRi9XVkFBOUtvR2s0Z1ZDTFlVbGtacFdrRndwWnBOeWdEek5GSmpmN1hLTFJZRVFEOElRcTQ2aUFPZFNsMXRURktnSzA2S0F5R1RhVERWT2YzV1JuWDNZVEdrVHJhNEtGQVYyejlWcGJqczNzYmh4ZHFtWXVQY0laLzd5bHJsNnl1bmE5NjdQL0Y3SG94dDIvcUpvZzY5b1FTOE5MOTU0bTcvOWE3dFZacXRtblVoZnpiTGxkazVxOW16NHZHMlB3R3RzaGluMjR4czRvMWt3OXRpUzI0b01DNzQwK2NRNjh4MTd6ZnpPUlMxMkMxMW02QjE2eWJhemMyV3QzUVZ5cHlKMVYzN1B2NjJ5RXoweGt6eFNESEw0QkVrWVFLTWxBdkJETGhNR0UwYVFSZENXOENwSEdCeUkrQUs4Q1dnRWx3NGR1M1FJZzFTcUNrdmtrbXdCb2JKWVpUY1FVVzBjbE5SVzJRT1hKWEMzaEcyQVhBaWlWZzNQRnVRdVExeHlpLzFhblJsMW9Cd3VFVzBKWThBWEI2VlRLRW9tb0hta0RIU2tweUMvRU4vUGNjQmVxRWtjbVRHbGJkUytJanVOVXQ2UngwVWpvSVpDbk4rbkp1eE5oOXJ2NHgwdWRydklwNjQ3dW1qeFhYZCs1YTRDN3RYanc5V2xMcC9YV3RUa0tzaTNGRFhUM3JzV0xUNEtEK080WUVuTHVCbmpCTTJXY3c5dDJYVHV3YUUxd3RCbFFUQlh0bnZNSGRPaW5SNWo1MURCT3crZWUrY2MxYytjMmpWelhuYzNRVjd0dXZKYi9sOVZPdUluRmFTZTlKR0VGMGduNVVibGdHYVFhVEk1emdPSkdoaUpDc1RCZmxVQkFZTlFhUjZVQ3F4eURaRERBSndIVENqWFZJcTI4MXJlR3dpWmtia01vcHhYanN3WDhJcklaMUpjZkpHb0RObDVvU2k4emVnUUcxRzlhbzI5SnFXYlkyNjF4cTBKbUtuZlZ4UkRJalJ4elpTYUtYQWQ4bHNSVUtucm51MzNQN2w5NjJkM3JueXZPWmZuZFVmYVpwL2N1YW5seFJYSHp6KzBabHJSdFBxdzBaVDhjUHJDRlhzNmVtYlYxVTZud1IxdnQwaWYydnpRUTl0WHZCUkxYdXhjcU5VS1ZzR3NXYkIzeTB2enowOWRkdUhzM0MyNXBhVm1DMTFhL1FpM2ZzVzU0aVB0SGZObkVVTHAwL3drN2w1bWkwclJFcVhNRUpXc28yeVFMSTYyT21CbjZEVjJoajU5TTNOQ2NJeWM1S1A4S3RVczRpQjJRaVVuSTdYWlBJaXFIci9NU29BbVFBMi9UNlBtbkE0YlNDV2hPVFRqVDAwYW5XRGhkZnIrNy96eEIrUC9tdndkSjlKTSt2WFYrd1JPM1pjOCtmWi9KSHQzclRsQWY0NWprTlBKaDdqZnFXWVNFeHZEakxPWDlmcEIyY0xHY05mWXFxdTRRQXhzdnBWb1R2L2c3Mzk2TS9BaExVMys0TXJnZW5yeXQrL1NZMnZ2MkpLTUpQK2MvRU95ZURkK1h3LzVLZis4VUVSRVF1d3hGUjhGM2NBWHVsVlVZNkFCMmxOTnUvS2Zwbm91bjdiRmtvOVJidVBiNzIya0J1NnRJdy9SUG1PZUtmbmQwL3Y2a20vTW83T1N6eTJnVWZ5K1h2SmovaWtoVEF4a0JnSExDZlpUcHVwQlNUVmlMdlc2WUlJU3ZLUTg2a2RqV05KZmtyaUlyQU5oRlNJSm5SN2YwMm5nWTNvZFh1cUpMaWliMlBMczFWNFJVSkhUSy9yRlh0cDNrQzVLUG5HUW03VVBuL2NsNzZCM0VMWVBNNUxQY0p2SmoyQWZpb25rQ0E5WVVuc05PeUpja20zaVlFS3d3VGNUd1FqZm5Ob2N4clloR2doeDZlM1cwQm54VUo3ZFlyWmFNOXNxNHowL1MvNm1lbEpGb2QxcjFCbU1wWm5oOWtYZFQvNkM3Y245WEF1L21Yc2RwTkNOYTVhcFpoQWZGR0NCckVwUDNIay85eXV1NWRneG1OOUd3RzdMeUkrSmxsUmZSVzQyQUJhanJxbWtRLzRaaStKa1BmdTJ3aFJPSzZJYk94Z0FXMXpSMXJha3ZRM25jdmpLcy94KzFYU1lpNFZJTkR4cURtN3Fwb2U1Zzd1SDkyV3Ixalo5aUJBTlBuWGJsVUgrbkVvRnRNb25RVEtKSkt5b2N2MmdORlNvTkxMVnNJd3l4c2xPSXdNckpTbFZVWTVLMVFtNjBhcks4Q0IrbExQOW9tMUFieUR1WUVveE5JRkd6T01kWnQ3dkMzRXhoNXVHUUJtWU9Yc2VnTXNtc0ZDQjJ6cTNuWnBjdi9YMnFlSEthWDBiNDVOUGJaOTROSmQrcmJndlZyRjBlclM3WkVPZHY3T2p4cGZGYlQwOTlGUnZ6YWFIZjU2OGRHcFZ4YnpIaDE2NFl4UFhObVBXaEwydkpUTm1MdkIycjM5dTFhZlg0L3BmdnBMa080VWsySkp4SktIR3RXaUVRWW1QQUtRbVFGUkRXTkpla25uVFlJTFhJblB4S3VBekxZK1hXalZ3Z3hGV3hRTXFsaWpEbVlWUk1lcjBWa2RGemN1MFk4bDd3MC85Y1ZpWThVK1hOMjNheEwvZHlmWWV5TWdmQWZxRnlFS1NJRGhlc1hwUXVTalhEaVl5a0lobUpHSTRMQmt1eWRubXdZUWhHNGN6SUZ0WHdIRFpCbEE0d1RKVXNjV0VqU3lWaTFJd0xwbHRBNExEbWUxbDFJeFdOOUZZazBwUm5CcVEwZ0NENkdETU9ZMVpyZkZHWWpWdTU1bEowazVmL2podmllM2tiWk8yNUtnMDZ0VzFGOWM5OUMvRmt4dEQ2bzY4Q2NHNlNoZm5OdXBObHZrUC9HeHRmbTVyNVlUT3d0dnU2U3pUNXVsbUx0bnd3ek90dS9yR0IxWGpjc2RIT2lZVzZVekNTYmJHZTYvOGpyOU5SV0NOUFNSUmhrdlR3Um85dUxRczllQ0F6VkxtQVJOc0U1UlZHaS9KSllCMjNKNUxvdXczRGVJYWlXelJnV0VsdEFRTnEwMlVpdUpTbGkyUmsrdVB4eGx3eWFQdVBGNnhrNkFkcXlPeGxJa1lXYVZhazBlZGFFK0w3bDJyMDJ1MTdxcEpKZXRQZmY1SXJ2OXdlMHZuL2lWMzlFNXRlR3oyQTkrNWZmYnlYZjhxTC8zaTNvUDZJcjNPNFhlZlc3UHhzR3FMSjJkajQ4eXR5K2ExZG56bHpvVm5QUVg5bXgvNjJTU0crWmZEL2ozQytNVkVscENFRGxFSEJ5c2JJQVlkWndKa0g1VUo2QzkxaENsYjR5VkpGNUVGL2FDa2lTUUVJKzZqQUd5VE1BcDRhY1F0QlVVc0MwYllSdzQyMUpEYVVBNnhCS29CaWd6bEIvVUZqdDF5TG4vbmswOCtrRHhCZDlDbGEvakkwSzhPZ0k1ZHVwK3JaM0k4eU44bkRCRWYyVUVTbmpUTkhVaHpOOUE4eStKeEFNMnpWRUJ6UDZONUxoaUJncFFEOFgrRzdtTCtnaU5rbHV3WFZmQWJINWlsakl0RXRtY0ErdTRIRTV5UkJ0bHlMc3hWZHJxUS9YQ1QrZ20xNVRLT3UyWlgxSnFBSFRRdm56TDBzQk9IRCtnNVh2RFZ6YTlZZStiYzJuRUhRcjFsM0YzRGYzV3NXUHZNejkvN3dwYlh2N0JFVTZqU2VzczluN3YzdnNlYjZ3cTV1dzhtNzR1OCs4M1gzMW1sK0Z2SEFmY2RVZWxKQVltUXphbFZvdlF3eldPQlZXWlVlRlN3eWd5VW42aWloTXhNQ1FXQnlMbGdXYXZRaVVJYUEwTUZ4Zk42VUVXRnhZaGFjbTJ5Vm9OcnFpaEd4c3QxQXFQSmxnejRwRFl1cVVSSnd4UVVjM1BkR3FiMlFUUHhHbnlkeHluTEN4VEYxSzZya081NFRlMVA5enl4ZmJuQm90SjRPb3Q4NCtlUGozQ2xuNTQ1WWQreStwOThadTVqTlV0T216NnpmZDdCNHZIZEpSM0h1TGEvbkh2a2thM3J0VjZWeHBrcE50MzJ5dDZPbWZIVmp5Mzk2aC9tekxqL2QvTGZQblB2MUowVHZMMU12aDRISHR3S2UyMGtKZUIxSWdlaXNwSUptaEFUVTFnYSs2QnNSamxpSGhFZlZ5d0t4M084MzJhdnNUL092WFZ3MC9iWmorL1kxN1pOMkhwc2F2S255ZThuTHlaL1QxZlRjUVBVaFhwK0Q5RDZtTW9JRnNvSC9nemdReWRSMUh0Q2gyT0ZFUnhHR0lremdMc3pySklmNVZjTmdxd09veGpETFRrUFF3YndiaG0rWlFUeVIrRkdHV2o5OHpyZW1lMnhNQ3NRem9iWFJHMjBlVXBHOEdHSVhnV0lhVGxtbUxDbXFpaUFrREFQRUVZYUZlNjVkL1BjdnRmdnYrZmlob1hyNzM3bm1TZi8vZFI5cTFmZTg4RGVSYnVyUXVQR3VkMlRsMjN2bWJtSnRxNTd0YWI4OFlXSHZpVHQ3MzJtTW5KeHc2ZmYvTllUUzQ0ZGV1bXpnY0E1TGhLZVcxZW0xNWNjN1p5MnNROTU3UjVZL3dHVmxuaEpPZkthaVNpQ3BQZ1VRZUMxL0VJVE9oTDV5R3NoUmdnZjhKclB5Z0lsV2xnc3VnNCtJTDlzc1lJU3l4SFBtMng4ZmpIYU9rbHJrMHBnNlc0VGJJNGxMdVZqdUVJT0ZnTG5hVWxPL0txM2dNNlhCaEZ4SUlheWhRNURyQ1oyRlNMREs2VEFQVDg1dSs0cjRiS2EyRS8zUHIxMXVkR2sxV1JOSyttK094QlNsOTB6OWI3dm5iaXp0KzF3cVhocWMrOWhmdG1MZnpsKy9JNzNCdS8vOUdlMnJ0Y1VxRlhXck5uek43M1JPdkZYWDdycmdaNk9sMzc3TU9FVXZNRXZBN3doZ2ljN0dtVUEvQjB3cHZDR0RSY042aTJGTlNSVCtncmpNcU5SaDNndC9CZ0RRcml2VnJTMUwybHJnM0VaRG9OeEhTU1hUQ05TVG5nZ0l6VldYaHFKU1RhcmxBWHNOT0JVQmdXSVpvd09aQ25qNXFNcVJZaWhjN2h6a001WllzS1NrUjFYc1BrTkVCcy9Nck5yb0Z1eE1zVWJJVGloUFRWZlNqcklVbDRTN2lZQUcreTBXa2VyYVFkLyszQVY5NjJoaDdsRlNmNUJlb3IyM1orc1picXJsL2J5VC9HSFdGd3ZTMEY5WUNZUWJDRURhY095YmdUNFVYajA4aE9ITHZBVGFlLysvZlR6Ky9jem5FcW13M2d2S2VQRjJIRE82ZHlidzNYODhxWHBvWmF6c1E1ZitRMi9DekMvRHhEYUNpS1ZoZ2VLbE4zTEQ4dThSZ0ZvdGt1eWFCenNGMjErYzNDZ1dDR21xREN2MnE2Z05kRUdrc25uRnhhVmxDSXhpMFVwQTROcWtoRllONzhJVmI5YTlDa3ltOFlXQW5Cckx2VmpNS0ZKU0prQmU1ckloOGY5ZU5zejMzRGxWbm5yZEhIUFVWK1RwalcvM0xHbmQ4cVp5a1FuMHJ0VDJMZHkwMXVmQ2Myc2JjZ0xhNk1MeHZYMHpOZzBRVHV1YUZ4NzBZTDlTNllQTlZlMHR6UGN5cEVXc0hmL3JMSUNJdTRnOTVCRUJjcG5VRFdZVUtOOGVzRFJ0OFVyMUFyS0dNZ1p4eTV6RUhCME1sRUZsMTRxdE1wT2RGL2hzc2JLekhCdVN5UWltOEhibjRqZWZnMmdVN1hORTZ6QXhadEZ1VHlFOWlHSUlaVVFBeVhsNE52YVpETks5emd4NFN3a0tjbHQ0bEYwd1N5SS9tclVYSXdhWEQxRmNwakJXS0NOWko1ZGlDOVVwTGlKYTBTa1N6WHFsb2FsaDQ2MWJmcHlwZE1wN0oyMmIvM0RxM3FMZXV1cjhoN2JQT0ZnWDJ2MTdNMDdtbll0ajkzNTROVFAzSHQ3QzMxNjBZVFFETGZGVEgyVjlYTTkwN25EUjM5NWVsWDV6aldoOWQzTnlhVlRsank4b2VlQkFvdUYyL3pFdUFOdjNibmxxL3RtRjQxZjNoTmEvWmxmcnh1L3NLSTh0NmVpSVNDNFhMVkF6enpBd2YrbXNnTjM2a21aZ2t3bFBzb015NEJhU3lqUVQ0MzBNNFFSODRKaFFkQ3JqNk9iRUtWKzNzdmJ2WHdlZmRWSy8vakF2Y2sxZTgvU2VRT2N5dm5oSCttMjVOMzBQZm9lMmhURVRzK0EzWEt4cU1QeUZQNUZyY3JzVndVL09GRGdaME1Wb0htcFpGdmx4b2hEUkhKYjVWemNGZXVnVklybVJBZndKUUkzU3QyaXdwRit0NkpNQzBSNEtWWFlKQjJpWU5FYlFjMUpSeXlKeHN6NUE5RVVZQXdVQlduMTZCZkxhVitrYVg3aDNLV3JacTg1c25GbHliTHh0Vy8vYlcyOHRhTzdiZHkrSDc2K3ZiNitkVUpUZk9OM2hDRmV0QmFkbWR0N3psOXdZZVBLNTRPaWpkK1hsYnU5dldPdk4zOVhadGFTMnZpeVREZks3RXl3SXhkVkdoSWdUVXFNUmM3aVUxenFFQWI3OVY2MUZ2UmJjWHFwNkM0UldaK0YwdVhPelVQV2M0aHNLV20rMGlBL2dTK0V2aEZHQlpCLzNHZ1NRc0xNbHVWSDlyY2MrRW5WTVQzVkZCL3ErdFMzdm50NjByMWxmUTJ2YjQ2dDNiQzRxNVRiY2VwM0p4Y1gzcjExdk5iSTZ6bTljY0swNUsvLzlrSHk3Vm1kYmNzMjVqYmNmdUoxbEszMXdBc3Z3RDZaU1RhcFRlMlNSVWp0VWpadVRZNFNPVE94eUJsS2tSYTJJeGVubm0xaG1BbjRBa2dQQnN6bWRIQm93Z0xNV29sV21IZVFycWVsUzQrMTdOais2V05OKytZZFB6UnBmYzJGUjZvM1RUckhDY25za2luSlN4ZmZTbjZuM1dQZjVDcllTenZwNUVObFdVei83UVQrdVF1d3R3RXpHQ1NOY2Rtc0JMRElLb1ZOVmFqaGpHeUNPcE1TSW1EaEE1MUJGNVM0aUJJclNBVUlsT0NBOHRqSlc0WjNjYTdoMzNHSGhPU0I1TUxEeWFJRGl0NTlGTWJkRCtQcVNJc3k3dlZqSWxIMHlwajYwV1B5dWxSd0FvUDJZd1o4bFB2bGNJTCtJdWtYa3Z1VEcvWU8zNnVNMVhYbEQvd0w4SzBsWkNOSkZCREZaVklDY2lLTWw1ZGZvSVh4OG5DOFVqYWVDK1REcFNodUwzamNoa2dpeDR0RDUrVEJvSWg3YzF5QUt5emFBblNsdktKa0JsbkpBLzZTdkhGWnpFYytNeGhkYVFkY3BYQVlZeTYxUnUyMHVrRS94VUNQZVVYR1lueFhZVlBQM0JVemlyZC9NN2JTWXNvN05IUFdReFV0dTViZHYyUDliK25hdWQ5WTBINzA4TElHYnNQV3J4Kzl2YW5ZdkhuNUtsMysrRm1MNXUzOGZ2TFMzUnVuMElxOVNWUHJoT0lsSjMrRmE5MEFmSFlHK014TnBwS0VBelVPVVRRTzJuUzl5NEdVMWVOS014VHhzQTRtT0xVdUVtSGF3QUcraXlFaTJ6R1daUnVVTTVsUzBqTWRnR1NPT2xnMnlpbDZ4YWh5NFlmTERZOVN6a1QvOWpCbnVUOXBGb1lvSjNBYXB6RnA0WHc4R0NyRDVRcHUyZkJqYkIrZWhybkZZVzZNMXd5TTExU0RFbzBvem9iQW8wZkgySXhqV3c2b2VJVEgxSkVFeHlKUkhNRlVUeVRGYSs3cUtCSVN2RG12OCtuTGYrUjJEVk1kdDFNdzc5eDUrVDkyc0RGWGdrMUQvZWdoblNTUmgyTnFZZS90T0tBTkJuVENnTjZ3WkdXS0l1RzI0aEJ1SjNpVFZqZGVXbTJ3NFQ0a0E2YnBaRUt2dXNvYzZqaStxam8xUGdiMEdZaGN1VmpOQytyU0pSVkxhOHcybmZCM3J1TWJndHNkZkdoaHowUGJ0Nm16Vk5wQWVMcWp4dGNsbG5JLzI3bHp1TGloYzAzcGpMbGRPTmM1Vjk3blh3Tzk1Z0JmVExFV1ltcnZ0TkYwTE5NaG9pUE1JbWJNRVVsb2pEWm1JMkY3WE1CZEluWFZVeDMxcVMyVWFzUTV6M05tRGVjTU5sY244emloZklIYm5aeXdRa2lhUkoxNStMZmNITVB3VDRkTEJJNXlkNjBmL29zaUs4ZGdqNDRBdlhTa1BxVVBOUHhnS25DakNLTUdXRWJESkZHamc3MGdWcGx6RExMOEdhY0JWaEVRR0xwVGsvRTZqejBOKzhhdEFpMWt0dG5zbDEvZHkvUTM2c0lrK0ZyZHFYV3FVK3NVb3N6YmdsR01ScGFPeEdRZE9FRG9lTWxHd2p4NlNTT0M5eVdwMlZDTUJqS3ZqVFB0R05XQmIrOFhxWitLNEowMDB0YTF4NUovaUNXVE1QcndmZHpteTRSL2JUaEpMdytOVTlhNkN1YnhKTXpEUktZby9JaXlJdUE4cVBMTTRnMHdHUlBvUEpOVjVtRVNlaE1HVWhtMDRVM0tmUFNpWklDWkNCaEQ0bzJwdmFBcENzQlVWcDNnTXM1eVd1M200ZThKUTBOVCtYNjkxV3k1SE9QL05PUlFmUENHSzMrRWZkZkR2cGVTOWxUMEwxdWJzbWlGcUhxRG1FMU9POTZZU2pHQWlKYkJzd2VndVd4Vkk0b3FCS2N2UVltQmNZUE5xbGcybDZnNE95SE96akFTQSt4TUZabjVob2FGKzNZMnJuK3RjVXAzdzdmV04rM2V1M0JHb0tWblRubjdrZEo0cE9SVDNjR1pNNXVMNlYrbzU3ZGczM1p2UDV2ODRNcTUzWHVMbDM2YW50ajI1WjNUdkQxemQ3M3hrNzJybHVkMnJaUFlPdENXUEFXOEk1SThNbUcwVnMvVERBNVliVXlyV3hHYTV6T3Fpb0E3YkJGRXlCbXdFZ1FmSHVUcVBJRElzbFlYSHcwMUdNWUlVcEgzamdJV08rbWQwWmE1UlhNWEw1cGQyTk5VZVJuNGVHbTBwcUc1cm5ibFg0UWh3V0V2Zi83MXo1Zlo3TUx3bTV5Y2xkM1gxTEloTjRmUk8zbUowYnVNakNlM0U0WE1UWnBCaFBKT2NDQXlRQ2RNWURNc0I0S1hXK1ZDbUo0VklLM1ZLc2VSOXNDUGJYZ0xuVXQxdEFtTlFCekFhbll1WGhsc0NYZEdKdnBIY3BPVG1ZTENkSkptOUpab2xOM1ErRFErY0VWRFhBQWdTSFZJaUxGZFlvSFowWnUwNFpzTms3c2pqeTZneHR5bVVPYW1IQ0d6eG03T05UczZ3dTdkOWV2V1RxbThwNmhsMXJ4dzRjVFpyV1ZWcGZkMWw4MmExUlRnN3JqL3Q1OWFYTGhuNTRQSm9TdG5iOXNwNWxkVVp1dnBQWlJTbGRuUWVGNGw2S3BXbi96WHM5dStzbWVtM3pXKzcrVmRieDI4ZlZsKzE0WVhnRVpiWUM4dnBQWnlBVW1ZUjFtUzFIYWFyOTFPL1EyMlU4NFEwVnNIcVpCMGlwMjBXUm00bFBMRTY5RWtDSzQvazQ0R2oxdm96bWpyL0tMWmkrL2JTZ09QSjMvei92dnBMZjR0MitLeXA1WWQrRmIrOExlNHFqR2JURWtmWU1RblZUeUpra1VrVVpuVyswN215YWlVUENXNGEzNllzNThsLzZYc2lCdzBLMGxKdnkyVjk1VU00b0RXNGd4VUltWU0yc0JYSTdKSGk3RVZhc3ZJREtaQ2RKanh4WEE2U2xaUlFTQ1ZxMktnVWpINitEN0hrcjQ4R0lpK0hwMDYvTml5UXcrc0tVcitkTnl4dDUrOS9aOWI1aHRVZ2J0bTM3N3ZVUER6cHl1WDU3UXVQalYvNS9kUG5oS3NabTNEdEhzV3JCK1hzYU55NWVtN0xzNll2SnMzRzdYeHR2V1R0MHpLYkowWVduZ2lzbUpaVjJnbTAyY3RvTS82UVo5cFNKMFNkMC9Gc05RWWZFZUhXRkpma2xWZ1dGVnFWTjhxQUZJSnRRb3YxUmcxdmVvdFkyNm5oZCtTUEhhL3NPL2d3Y3NIaFFNcGZUbklQd0U4NFNXTkpKR0RORFduYklQa0FNWHRVN0FhRUZHd0QwbzZWa3NpdTBCWS9QQnNGNENtNWh5bGRJVEJCOVNPS2NLQlVoS2pJZ281V2xBZzJxckhPSk0yMzNkNHl1UWpQdTh4dTZmNkcxdTJmYjNLSTlJdjhSUFVnc1pwc0E1ZDNqVytjK3JrenJZRGZNdlFxM1AyTml5OTdiWWw5VHZaUEtOZ1I5OENPcWpKWklVT2tpcWFJRWdLWG9qQ1JEVXNZeWZBUkxWS3NMWlIrTU1MR0t3MVM3eFY0aTZxSk1FcXFTN3lST0pDVk9aVUxFcUw4MGI3UXYzUk03U0QxdHlibk5VcUpJZUMvRnNmWG9ZeC9URG1iMW44OEFXU01ESnNZNGltUnFYcTZJaGRvMkRYcUZWV0EwazBCbWJYY0FJWHYvdjMzN05vTWJGS3hvdG0rQVJNNDZYR1MzOCtnSGRWa2lGa2x2UVhaY3BwWmM3OUFVeno0a3RmRC85NW5mS21MZ1RtUUF2dm0yV1YrZ05KdUVnR09GNVE2WlU2and0NHJkTWJqS1BMT21CODVsS3dSV1ZUL01mN0RkVHZ2L1A0ZDh1K3YzWFhkMnJmL3JkNk1GWlA4R1JvaUYvMjRXViswdEI1Umx2Z05QNHJ6RjhvVWlMMXFCVXdXQTgwUnV6R2dKbk02V0MzQlQzVDRVQXo5cyt2b3pQcHd1UnpEMUlUMVp4TWZwbjJQWjU4Ti9sbjdnUzNKWmxOZnpOODMvQm0rbUZTRFdQVXdSamZoakcwNE5HeVNCa2pJN2pPTENHbnVTU3J4VUZNdzhscVRTckdUNVNMOUJZQis5Wjlqc1pwOXRua0F3K0I3VC9GclJrYVNtcnBQNjdhL1g2MlY5VnBqS05tS0Y5Z1BLSm1JVjhsMXF0SkpROTRFUnh6U2JCSmFnUWExZFJiN2RWUWI2VEc3VnpGSFI1K2dIZHl3M2R6ODgxK0U3ZFN5RGk0OHZKN0Z1NGVsZ2MxWGVuaTU2aDZRU2JETEVLbFVyRUlGZVZaaEFvNVFtVUVnU1JwZ1VSd3B3aWlLdVhXVUJNM01SbW5yNytvdHUzKzhCZmJQaksvYUk5UnplSGQzTUdkS252VGg2Y2I0TFBQWGVuaS9wWWVYeE9XQ1l6UGh4RnNzL0VCVmFoaGZLcE9KNE1sa2g3ZkRZT0RqK0o5anI2ZWpITVRoMTlzVmZsM2YvQW4rTTZ2Y2w5aE9GNU55a2txbXFFVWxBa1JKbHprMGdEdklob2hpUElGRUUwTk5GVGg1c0RXYUF6MHF6UmVScDNydnZrcjdzK2NhZmp2VVhwYjhrRzJMeDFYZXZtWHJ2eFV5ZUhDSkVGeDRXTjAvaFJJMHNGdkdibzNzQTlvbTh0djVYYXBGaEViNXBoTjRRR3FJenFNYk5yWkZIUXVZb1FwT05nVUVLcVJPRllUdUYxdVptOVEyYUNxQ2REYzIyT1pYa3VMT2NOa3RZcmxUVGxabFFGVk1IcTBNU0RHeGR6NkVyTlptKzNONjF1allMVVZvQVAzOEsrQURveVRkWW9XVE9RakN4V0NNKytnNk5Yemd3T2FpbnhNRFdrd3VsT25CTEt0VndQWlpaRUlKaUhsK2xRMFc3SmhMSHRBZE9RWFZyRDRmVVVoT2h1NW1DNEJ4cFpGR3dwU2pJVzgzRkVXY0dWNU9XWm13SEttWW1LeDBZRXY1WDljNUlwMWZiSFBMbGlaeDVuTk5TYyt2Nkx6d1BmV1AxK2VLOTV6N3NLOUx6eXdadDcwQTBXNWVTcWZ2dG5qY3BteTV1WE5tUG5YbWZjSEhBNk8rZ3NLV3pMbXIxNTRlTnFreXBVZHc2K3Mydi9aN2VPV3RCZm50NWQ2bXpRYXh4S2t4MjZneDdPcW1TUURaSFZPQ3ZPaDJ5bDdOWU1KUGRLalhLM0VuU2h6SGFUTWlLU3h5Z0dNTzRsS3VFbUR1Z2dNYkVEczUzaTlnMUdnM0lzT3Rsc3p4clZKWjRiTUhGb0pqYzNxemhNVXNCVGljYTI3djhDWmpHVVB6ZXM0c3E1MXdzYTd1MmFkQ2xYRjFKcVN5cWF3MjlNNnRiNmtwSDVhYzM3NzFpelZUTDFKYnhyK3o4bno2amUvc24zM2F6dWJwMDdZeSsxTy9xVXlPcmswUzJNdTc5Zy9ZOUY5MHlLV2ljM0lsMXZRaCtSZkl2bUFKaEs1dURnWExJN0h4VEg4NDJFN2JCZFo5U0NSclM2TWNoSk5abFlLOXhFR0J6Qk1MakEwNEJxSkw1RXRWUHU5RFJkcVYrc296OWxMcTJhVUg1RXZITzg0Rk80Wk43RDhXOGtQNlkvZm92WUZNM1pyL0dwVlJxRW40eXNQZis2SDlUWExPN3VwRytQZmdISE9BTzF6WVY2QTBleEkrMHljWGdGQUhUVlZVa29KZFpoWmVEMFdlaWpWV1htQWV2S3NLT2F5dlFSNDBXSlNjSTh1RHl1ck1oRzZoZ3N3WmVmU2pRbS9LdHRnZDdqOVJZMVU4U3BpbzcwS3pOOXh2UlZUYmw5VHUvaCszMmVwVWN0cFA2MHJlMmgrKzZFMXJTZjlOWjBUZk4wSHMreFdjYzc4VU5tc2FaWDA3VldmWHpjeGYwNFhWNlYzbWl5WG0ydThlWUhwVTNzYnRuM2o5Tng3ZTJxZFMyWTByTCszdm5WT3ZuZmlDU1o3ditjL3hYK0ZWVW5jUmhMWnVGU25DclFuTGpVZ0RBNTRMTm1ZcS9RSUl3VVRGbGlxSjRJUk5RUWhScjBTaGZkYllIVXFKMll4SktPWU1Mc3pHRjYzb0RPRjE1SkhsSWt4ZnJXQWdxRTNqUmZaTFJVWTVHSmVodmR3eVNzNmRwMmQzYmp4OXNrV1BUKzhtaTl2NlpsYWNuclJqUG9YYmx2eXVWMXRwemllYStqY1ZESjlXZ1A5OXQ1djdHanlkUjJkWDErWG56OXRmM2VsN2ZhcEhWM04yeS84MUc3cjdlakphZHFLL0hZUTdOKy9nVjd6a1JtcEdqSVNsdktpTWdYZG5ST1JIR0dNbTdDY3M1ZFY3WGpBVGNtT0pEd3NSdVhKQTFUbjllQ2xGMUZkQWJLa0EwUU0vQmEyb3Vvb0M1NnpyS3NhUUhZcU1HWG1jcW1DL0E2K1lmZFdQTC9pZk45NGxZRnlRdjdhMW9ZVk9WWXJSeXVUMy84VU43UzF0M3Q5OVpTZU80NVJuYzZtRGpkVVIzS25oQ3NtYmgwV3VDR2xubVZxOGpIK1RmNmJZTWU3eVN6eUJ1QWgyQ0RKR3BWbndRTHNFYWttTERjTGcxSm5HRFBOVWs1WW5vYkw2UWxMdWt2eUZQQ3ZDUWFqNitGaWlsWHk0TFZnWUViVFk4QmI4Z3pZd1V6allQLzR6Qm5hb0Z3QnpEc2I3a3lwVjd4eGp3ZzJXcHBoYTlIbEdJdHJtanNtVFoyRjZIMjhLSnZkb0ZBck10RmhkdUoyZHpZREYxU1FldVNDWWxIbUpzVlpmYlBnZ2VkcG9xek9nK2RaTmxtWHliZ0VuQmV3UDFWWVo1Zk9wYnJoa1U5UkZTdlorQUFpZlF6dXdmMW95cWtaS2J4aDk1bFg0d09hcTIwT0YyWmVmVlBQVHVwcjdmcmh2WWNYTEQ5b3Nkb3k4dVpQREgvcmVGTjhYRzNGYkh0OU1GdW55WjN2NitqS2FWMXlac0cyTHl3b3ZhdDM2dWFqM1hPcjYvTlAyemVWYlMzYjlkeXVYYzhkWHI4ME1MdDNYdWxkM2NkZW5UZUw3aFRLTytZZStvcXpQbFJ1TlZLT21zMjU2MXNDa3lmSEN3TGp1N3FuRk9TWFZIUVhOdXRVVktWdTRYNkxYNkRnNXBPd2VUc0FWM2dCNVNseEdWdVU3UjNHU3huUVVDQytGOVM0TmlJTHprSEpxNkI4bTM0VXlqZG1JWFd6MExEcDRnQjRSUVUxUlVkUWY3cXdIWGd0WmN2UVRqbkZrODlSa3piMjFJTHBkL3A5OS9NWkdaSEo0L2I0Yyt5cTZaeWdNMm1OdysvTXVIM09sTWtQREgrYnF3cFZUYytwbndrT2IzVDROOHd1ZnhmbUhsUTFFeDE0ckl0VHFBN2xSUk5SMUFOR0YwVkFwN3BCbG1YbFVuRXNMaDNIU25DYWtmQWlaKzEzY0FZeldDalhJRnVlaGdOSDNtaXlpa3FOZmxTSk9vcFJKMG5sNGI3NzUxL1RIVDlQYm0yYTI5UTBkenYzOHM2aDcyNFhucHZiMkRpM0VldGJrZy94RHBoYk52R1RlU1FoTXNNQjg4a01ZN0FkNUZqT3gya1ZoQ1V6bUJHWWx0bU9jekZiWVM1bW1BdDQrbUJQWVM0WWlMQ2JZUzU1K1Q0L3M1TlczVWhZMGgxTDE0cWdPNFhRTGUxUXBXZTVmTEZHeDZsZDVlMkJ4cFZaR2NrbjZYOVlza09KMVhNZW9NK3ppYjl6UUowajZOeUZHVTIxVlV0NS9lNmhzOTE5MWZPWHRxbStvNnhFaVErK3ovOEVlTVJKYWxJOFlvb210Q2pmeUI4dXBVREV5bUtVYnRROFdvelBhZXdnUWxTVWhQalYwS0FTcC9TbkFwWEhQcytaTmZUSHhlM1Z5VzMwVFhQWlhMY3JlV2dQcDVwcEZIV1dvVi9RZm4zeTN1SHZDeHlsdjlpUy9HeXFYbU14ekVOSEdzYnNOc09LS2lWejhGR2JuTTRkVktkUXJ2Tng2a3krVHgraGp1M0NpaDJYQzdmREdGUEFUM2dWN0UwSWF6VVlxQ0UrOE9rb3JKYVpWOGtZbFV0QWtlVkdXTkVWckR3RTNoM0hTc2xSR253bWh2a2NiTmRZRVpic0R6RnBrSHdZL1pBY1NwcXR4QUdLaU5lNTAyQkhvd2dJVTlFczVTbFcxV0NFQ0l0VzJTdW1zdkY2eWpIT2QxdHRVNjhoZTh1RXBaVjJHejFCS2FkV3Vhb2FLd0xIOVlhSzdISGhQUDZaM21qTDVQcW1ycTdjMmVYMXd5dTVjNm9TaHlmTFVEV3JkY2J3QTl6eCtkNkNnamsxMDRidlkvdDdEOWJCd0pxejAva2dXT1RWRmNzTzlVaW1LdHZLMXBwdFJaZVBtVlpNSnBxeTJRTEI1S1NyWkxEYTZtWVNmOCtac2VLKzE1OXQ1NTk1OG5vNTc2eEt5Zm5NSzcvbFh3RDhiUWNVTUlFa0xPbHNKeFB5M0t0b0RPUGtEcXVjaFNGYnEzS1dKUXNMeDFWWVZTem51bEZzOUtNdHZBSXJVVlc3UnNxdFpuYnUvTnpjNmFlM3RiZHQrOHlzdVkvdDZIajQ2VzBiSG45NjQrYlAwZS8ydlhTd3EyWG5WN2R0ZW5uMytJbjdMMng5NXMxWG5objQrdGNaSms0K3ovZkRIQjJrRERVcG0yTU9JRWFDWkdRVFJidm5BSGtwVDh1TFRHMlJDQVozZlRoaFFKSWg1Qi9ueUlTTGM0QkY5RFpPd1dNS1FhOUNZZEZ2ZHpCN014b05xM2VmcVhoa2ZzZVI5ZU1tYkxxN3ErZUI4Sm5Ubk5HVXZhMDl2M1Y2VTJsWjQ4eW12STRkMlpuOE15ZTc1OVp0ZW1YSDN0ZDJOazF0VDRiNVdiTzZaK2MxalRlWGRSeWN0ZlRUVXlwTlhVMTFqUFp6WUYxMzh4ZkJPeXZCZFkxVUw1bEgxbFhJdEd3NmpaWmhaU1ZMV05GdDhnRE90QUtQWVBaTXpNQjFPVWVDMXNSbWlvL2FDaUdmb29KbDJURXVYWk9URG9oeWM5cTIzRGVsdEx1bVBNY3VDUGVjS2o4Mzc3Ri9QLzNZdWtrQUxGMDVSenNxRjB3T2dZNTRaVnV6TGNmdnk5WHFqbDBXNk8rbjlsTG5YMTk2QS9Ia295M1RwaFZQT1lhOC9nYkk5L1BBNjVsWWthTkVxMGNZM1lLc2xNV1drY2tZWGM1bU5aUXMzYUJUMUptU2tsWEVGZkE5cDZCQlFGSk84WTBIVldYL3ZPYk15amFOMFNqVXJNeXQ2NXlZbDVldjR2aG5CNWIycmJwWFkzR28yazM1NHlyQ2N5b0xrclV3bDIyQWJlK0V1ZFJnQldRMWl4OEJkcy9CcVJRaG5JMkZwY3hMY29tVm5hREFDdGtLWUpwYXJQL05UQWNyamVKNW5UV25xTHdhOFU2RkxaSHY5VEZZVzZSakVjdk1mRS9GNklpbGNsUUNQZUNRZWlSa09TcGlTVm5FRXZocjJ5eTl5dFY4MThUYlRpd3FmaW5UN3F3cHFNaDF2djdvNnZNdHN3MUM0VjF6cDI5ZFdQQmgzZDNSUldkN2YzL2dsTXBzVldkR1lqTmJKNVhaNm5VYWJVWkdTYkRSdS9aY2Q4ZEJQa2RWTVgxaXJLMWNuT2lkZkxSbTFheW9Fbzg1ZWVWUC9LZUVWOEE2dnBKQzllaGZNZERJUmRHZmx2d1JaaDY5TEdtUUVCblFGYzJneFF0VDFaWS92L3dGRmovemh6QTRwZ0xjLzRGWjBsMVVTWDVyUCtmbjhjalVUeStmWTBlbUxOWit2VVZuRC9ZYjhLZXEzNGhQQ1hneDZyeVVQazc2ZVlOT240NmdHWXdXdi9McTZzRW9GMnE2ekxoa0VlVU1MMlBmV0JSSXkvS0FGb1RTNmxSY21OV2xzQktwMkVudWwrTGpIS2VuZ2xFUWFDVDVwazJ0bjFlL2VIUG81TU1uMnpPekJEc2Yzbms1eTJSd2E5M3J5NEs3TDF3NFVqRmxZcy9XMjFjVUxCa2YrL3Z2Z0ZZSHdCZTlrMzhHTU5ya2xNZkhDS2JGUUN3U3pLd0VZb0ZTUFBBS3p5b0pKQlBJbmxWQmFFNGVacDBOWEtHMXc0V1Q4WEVHVEQ2YlJxK0p4b0tYVjExVkhVdUZaTGtEM0dsdjlwTGExdTNld2dmMER3bGM2S0c1Q3g4cEZtMGNmWVRURGI5L2JGeXNZVXJqaEcwY04vUkNUWDVXdGs3Zk1YbmVpZ1ZGaXhwU2RWWlhQZ0FmK2xsaUljV0tSbVRhVU5KSDJmRVAvU1ZXenk2aWlCR3NkbUMxb1ZFWGtwRGFhMkpSUEFJNVhlWjBBaldmV1pwM1o4SHFkN2Z3eitxekJKVjJlQmJ0L2RXVHovem44Ty9ZT0I2UTZYK0ZjVnprUEVtNGNCeWIzUm5GU0t6aWcxREpyVVRkOUpoNXhsUUY4azlUOUM5Sy9OVUovT080S0tzelBwQTBGMS82K2hmLytLd1NZN1dIWktkREMyK1pRUzQva0xRWFgycWU5bCtmVTk2endlOFlyTEpXcDVWczRGVm5mcURDbDliTUQzaHlYcTNSNmd5TzlKRTdQWHRwdGRrZHpqSEg3R1FWU1dkTzdZaU8zTEFiZGx1c0psQlZIZVZZWU5aelJ0Q29oV09Qei85bW5kVkVqelVzUHY2RnA0N3d6NXF6N2JiaGhkelo0VDU2eC9HdDA2M21aSG15bEZzMC9BU2p4VkxNeHdFdHhzWnE2VWZIYXJOWnJKYnlTK25FNUpjZis2L0J6eVIvUU9kK1BwbjhHMzJiZmpmNUZGMlFyRTNtMDdYSjA4cStocElQOCtkaERCL21yQzM0M1psUnlSdEc3Y1U4VkZCYVdlS2c0b1hxdkN3S2h4SkRYWXJFZ0dmTk11azF6WlNPMlc0S0Jnek1jYmRLelhPQ3F6cC9ZcDNYazVjOGNvSHFCV3JycjdJOUdJZ2xmMUZZTnYrK1hjbmZIeEVNRmw3cnptcjBkN1h4bjlObmF3VGo4RlQ2WC9ldnZ1UGswTkR5eXR2U01kOXpNTS9yWTc3MEU4UjhuZW1ZNy9qaDMzTC9PdndhVjg1Q3Z0eHJCMWNPeDVXUUw0eTFOdmt5UDBHVlFhYUJMcGNhdzNJZFlFUXNUaFFROHVONU1CY0MxT25NMzUzWURZYlJpM0dKQ3JpWWdlUFhOY0w0YlhHSmlITDVSTFEwTnFrNExtV0tDVjBPS3poeDJmcEZoejFiQ1M1VnA5eEtVQzVObWpwYVQ1MGdybUNFTU15RTNwWW1qOGRLRFJCdFFYbTNsQXVwQXFsNnB5TC8ydUtGNWRYcWxXWmZUa2xXMkZsbHJWVTFkWmc3c3NKZTZ3eTFKN1RDRzZ2SjE4d3l1cjFpdVRHdTZ1N1N0ZGhyM09WWkJYbm16ZHFhMHJuMHJjM2gySTZNSlZrdjlwcGNWcE5XemRPdEZIU2JQbnBQeHVMTTVhMkxnNGJTamgzZDNvMVo1K3EwUm8ySzIwSUZsZDVvTTh6OVVlbVJ2THVxUzVTelFxOGszK0RhVkxVczdvdkJYcFJQSHR4NmZDaHhYd29LaWI1eWQvSU45Ym9QVGpFYWZ4bG8vQUNqOFd3Q01Fb09NZUxLcmhTcFV3VHV2Q1RIR3pEQ2hlalVreVp3cUJ3SVhJZ2tsVDBOaktCU0t5TzNwVTBodDFhaGJCMlhwMVlxWHNCOVo1Uk5rOVdzTHFWWTVsYkhOZkVwOGpkeHNhSTBYVU84MnYvbEpsV3R0Y29aemlySjhabFhxcXJMZTR0TDU1YldhRGViOHdxeXl0MDE5aFpkVjdjcWJpd1h2VzdqTEUxK1RjeTdJdVJSejdCNncxa2RadUhKclpSWGEwMVdsNm4zeGF3bEdUdGk0YzBsMVhmbEhTbjkwVnlEemFoWENYUUxwOUlZdFhYbnNqWjZ1M2QwbEJxQ2kxdVhaeTdPdUNlcU53cGdDdkJjR2ZjWi9udjhCWkpCcW9nU3JuUUJ6MXRCT0xHbUFLaVZ4YVRTaWhETWdTRXdtWGV4aXBJVUhHTWdrNzlhREFld1V0TVRQak1yUExNaDF1d0pUWWtzcWp3OUp6UTFYdDNpV3ppWnV6SjlsYWU4M05NNllVcjNKbCs0d3JmL3VqUHluU21OekN5N0p2eVJaK1cxN0t5OG1Eb2tMK0loZVY2dDRSUUhuSXdja3ErSjJhTjJqTE9rVW9kRnFVUHlkYW5EOGVtejhzSVhXUEh4VUtqOHFReXVldmlOdGpPZTFIbDU5TSt2TE9ZZkZwS2trSlJSbmlnVklONHdwclU5VWRtdEdRUTRLL1BJVVFwY0x3TFRVYVFnOVJBekgxSlJGcFc5dnRDM2llenpocjdOQU1tMjkyWEZPdmlza25EUkxIbXRESTc0clAyOFQwQTRzdlg5WnhnYzhRSWM4U0ljY1hrWkhIR3pGeDc4K1ZMem9YK0k3RVB3YTM3OHRmNFMvS25xTDhXbkJOd2FoVmxLNGduNGloUjZHZERwWGY2U3RObmhCWGpwOXZoTFNxODkzWTJsbmdOR1lzcG10ZDJnOFZnU3JjcldET2hQQTY1NXFqWVN3MWFCTkNjRXFTWVFLMEprN3JhYjZmTExiK1llcDFvZDUzcHM1bndkRllTNnhZdTVybnVydTFvSFZscnl0dWVldlhEL3hzWHpEajNOaFg1QXJmcjN6Q2FyYVBpODU4Qld0Wmt6cW5WQ1crNXd0Q0cydktQN1hmUC9LU1ZYWGozOGNoSDNEZTByVE1hblhYbUhmMVVZQWt3c2swUU4ycStLcUJ3RWFHaGx4NTVVZzNKVmpkVnprWVVSQi9TNkdxc0o5aTBxNjFXRFVuNkVRV2IxSmJuQU5KZ29ZT210QXE4dTJKOWJvQWErWWdVOVlUa1hub29pQ1ZNdXZtM1NBWjZzWmZWR1dJQmlBSEVveUFXMnkvY1ZWN0ZZUzFXTlVxWWNGTkdJRmR1d1dGa255bXBReW5LV0huN0hoR0VPcTNKT1BnYjZBRldCdnpxcUZBU01ISEZCYlJKMStsR05JT2hPMXkyalJ6K3R2aWhnN2NnLzJtZCs2L1M1VGZOMUpwWFdNekV3NzVENGhwUXpLUyt6L2NlMVBlTmlmV3RxZGgxbzd2djB5bXlISjNQOWlVbDNiQnZmOHN5YnF6ZHA4bFE2ZC9hZE8rUGQyN1pQUDdkTDFSUHY2eWtQVFFiK1BrR244VnVGV3ZCenZHUXprVnl3Y0ZDVGFLVFJzL0N4YkhpMllSQmQrWHlsMUlWQnhXeUFpdjFVVUdjaWErU0wvUnFESXdNdnJiWitvMW0wTTVya2dzTG90eEhsRGEvWUw1aEZpcGM2Vzc5S1l6QXBOaXBXVkJVTHhEQmE2bzY1TlM0SG5rbEdTS3hKQjBGUGJLbXIzenB4NjR6VksyWnVucmlwc1dIanhJMHpiMXM5Yzh1U1hjL3QzUGtjUGJ0bHhwc3p0MHpjMGxBUDc4Nzh3WXhOblJ2ckd6ZlQxNVhJSlNWZGdITmVBdm5OSUR2VDJGTEpGdytJTmdzeEljcVVSVml4TVRMZ2RMRWI2aWdtRGlSdEJOVWc5Z2F3dTdGTTNRejJSaGVKSk13V0ZuL1Q2ckFjTW1FeDR5dUxFMTZKRVJaUk1GdlNlV2ZYbUx5ejA1djYzMS90VGYzZjlTZ3RvZGF6eVllb0kva0hmSnhJL29ybTQwTklEditPY3d3dktkMTJjTXUzdjczbDRMWlMxSmRYYmFHRzVKSlVqaGdMSG5rVEM2cHB3Q2JxUm13aXI5akZ1OEV5Y3Q4Y3J1UHY1OTRlTG1DKytwMVg3dWZucXBhUUpqS0ZIQ0JTUTFqV2d5SXJocTFIWURhVk5jUUlnb2Znd1BoNk0xd0VXUnhINm9qSWNUQ1dVY0JzMDJDbHpWa0lEbW1jY1Qzc3E4bldvdGVMdWNYaGh2RVRKblhqVHNmRmhMZWdCbkZKMUNaNU1GUUJvbkNCMEN5UE56NmhPMzJLalV1ZllrTi9rMVh2cDg4ak1jZDVsTk01cXE0Y0ZMcWQzV1BORWVBWHpmVE9OUm9BR1VKT1RXLzFnZzJMaXQrcVB0UTdxWDM4MXo2MTh0bUtMWUF2T091eWlkUDYxdVdkS2xreGQ5YUUxdkd2blYzMTh1YjEzbnQ4dnVMdGVmc3pTcXBhOXZGR0c2LzNWL29YajU4Znkyak9uN3hyd29iczRON1dIZiswZE5ZcWxka3VsRTFlMkxxb3pscHREKzl1YWw2YlhiWi93cDVFTC9mcXNtcHJ3Q3lPQzZ5cXN4VHJ6ZTJNeHU4SmgzaXZhanJzbEVYSnJvUDNKZk82UVVrZndTZm0yVkJ3TlZ5RGtrcEp0NWxjaXBOVFVXbExtYkIwdjVmM0dtWTNOczZta1laWmpZMnpoSy9PYm1DdjhhZVNVOGtoQVg1SWFDUm1rT0phc29NQWZCK3dzVFlubUU0SkEzZVhLR0tkQVhhVjNhZFNuT1hCTFFiaWdrOVpsR0JZR2NoNUdmTUtCN1RzRGJrT3ZjSXkwZGFpTXhoNVcwYXVKMXJEUkxza2pQZTBGbWVXaDNnajBhdTVUQlozb3A0UUhRbVZlZFR1OUY3U2FoWjlHcDNrTE1xaGhXK3VlUEhvMUtQdkp2LzI3dEdGZjNybTZULy9LVG53bDgzeXZzWDNPUG8wbExQazF2cW5idHc0dldLR2UwSHdya2w3djhoVi9veEdwcC80K3RyNy91UEU4Zis0NzhYaDRRc3ZKcE1EaDc3UU43TkU2NlhhREk5cjJmeUZkMFJLRzFvbnZjem84ekNOOGF1RXkzQVZJSEd5aHlTeTBVYTRyaUx2d3JBY2hLZElXTFlLQ1B4WllsNjRKQmNiUVN3VWF5NGlCUGNhbGNSOE1hWXlzSkJQOG9ubkRhN3N3cUJpQmZCSW1lejF3LzBJQnJSQkc4b21NNEpJa1gwNmRkd0lNMndxQk54S2pqQ1ZxM2VOU2RYSG1paG02b3RZTFBSaDdvM2h2c1lHc1RpM3l0bHM2S1I1cmtEdnZuRWRLMStZZlNnLzQrQ2l2YXZ2UHRJWm45T1daL1VaR3Z3UmUxTURqVzNZUUw4UVcrWFJtWFVhbnN2czhEWE9uN1cxYlZ4a2FiSzFiZTYrUmVVdHJUbDFaUVZVNEEzajhad24yY2QvbXE4aWFtSWl4RjVOM1JxcVNUMGRwN0dwNzFQMWpBb2FtL1lQZUthWEttaW81Ni9KZDJiUWVla3JabzlmcHVQNGFkeTNpSXBVcEU5YnBUc0tDSmhkVmpPQzhzYkJoTUJPY3dzWVo5ZU1kQTN3aXk5ekR4emkyZzRsOXdETStzUm45b1V4TWxBQ21QYkYwVkpRSEI0b1ZWb0RGWmZpNE1YWUU2Z3FQSkN0dkQxS0xLcXZGNHVCRWdNcGdGZWxrVlNEa2dHdjhyWjNqS2hnaTQ0UzFJaEdUQktIeFFFRGJ3c1VNTk5uazkxRmNNOHBnbU1CT2hBckNBdnhScWs0UUN6T0FpMStxQW9QQ0h5RUVObEZEUGd6L1dmWDhINm5xUGgyV0FkNUV4RjY3V3U5bFpIYThkVjNManR3dEcraXR5VGtuYmp5eHJLVERIQ3puYzZabGJFNWxpdkVUTWt3bmVMTUxDdlB0c00rREF0SGVVSDRBUGJCUjFMaWdnKzJEd1JXejd1d3VtZlVsZ3h6R3VIb2xpMm9BOS9uL2d0MFlBN1JFaHRwWXhWR1JvRmwybmo4QXJ0U0VtaGc1WUJZdzYwQ2JJSDVFTE51Vk5jcldUU0MyeUdvMG9lOVVtZmJZb2dPV05lVzk1OTQ3d240dDMvKy92bndUOUJ0ZXVLSmQ1NTRmT3VFSlV2YTRLR2NCU1IrL2xuaEhER0FMbDVNV0hCRFBYaEx6UytzTjI1K1lWRk9IYVQ2WHhpVnlpanh1aFlZN0dCaHVnMUc4aXcvaWZ2SzFWWVl3eXNQSGdUNnZzdXArU3BWSnZnWE13aVFCQ21FQjAvWTBVR2tVbEZZeXJra3F3MkRpUndHVkhQc0lEZFlJYVBPWVdjdmlHekVZSjBqTG9raU85dHFHeUI2ZFViaG1IT0NHbkQ2bFE0RTNtcHdTdE1uZWJIVStOM3lKeGJ0UExjNGIrTzJDTjFtMEpzc3c2OFc5N1hkcm83R1pyWFhMczFWNndWaHc3VDVSeGV2bXBzemRXR3R6aVFjbkI5YlZ6ZGRWZG9WakhaRkNyWFpHaVd1OFI3SDhjMnFMSkQrdVVRS2hXV3RnTjdrZ0ZPUnNPeXc3Qk9VVWg4RFlBdlk4d3pFRnRqcEI2dDhESGp3dXhoVGxscldoaUFZVjhTbE9DNWwyeEo1K1lYeFZFU0l1a2QxOGRGVXUwWWRmcit1RWNGN2kyRzNESjRaWlpQNlRQN0pNV2R4bG1YQjFObmpxMjRybUZUMXFTbWJIbXFwYXAzOTB0NVpuK0h1NnRNVjZRMFpuaWt4MFZlVUlhemltb0lWRXlQbDNZM2pEczJ2blNNYVZyUXNQOTZPc1lqSGhYTHVrdW9zeUlJSGE5Q3dwc3lJU29ORkpRWTRGekdQU0FLMXUzbjYrTURCN3dscmFQbWM1QjhZalNxVHovUC95VDlEU29FakU0WG9zK1JIWlFNUXlxMkVtaVFSbTVteGluNmUxZDRwMVE2bEJ0WWx5WXFwUXFOUzJtOVZLMUVLdXlqNVVzY0wrck56Zk1YS3J0ZllsQ0R0bUlndDBnbzhOOFVWVm41YU5aVzArR2grMW9KSTdZcnNyTU9pcXpTLzFtU0tlUmJWdEN6Uit1K2VPbW0vaDBzK3Y1RU8zY1hwaG4reXVhV21vYk9wWVQyWFA5emVsbDljbVptNXVyS2xkL3pFdVZNbkpMLzlvTkxiWkN1L1R6V1RpS1NGU1psR05aZ3dzcXlxMFFReW9vdXc5THI1a213eTRKbUpBZUxDbWp3VVJKT1YxV3lDTWtnZFpyYXpncllvU2hIK0g2S0gxNjhJYmVwc29YVEhRN3NmZW90L2YrbFRRWWVELzlDcjZ2dndESit2L3o3dXowYXVnbHZHWjRPK0NaRlVETUVtM0VyREZucnRpV251NlhUSEZ2emVjY2t6dkIydTNOaERCT3QzQnd3NjRvZVpHNndEWm9Ga3daWHJxZ25Kd0hZUEF5YkZScGlVY2w2N2daMllrazJvekhpemkrVmVNS0NDM3FKQmxLazl6Z29RWGFsSzhTQ05SVFZ1cGNHZjMwZkhSZWR2cWk1eE9XSU43cmtHWHpTbmNmdnRSNVB2OUV6TXQ3dk1waTh1NVRoelhtdUQwcXRnR1BTSlYyVWxlanc3eDhxdjFlRlVpNVdSN2lxR1Q5eGRaWmlhNTN4MStML2VmRTNZODhEd1NnQVgvNGlNNEtvUDRjcE84a2hIMmo2Z2huZURCNVViVm9vYzg1bnBkeGhHa3E3WVM4K1RUcnBxeEpHa3EyQWNoWkZHNVRCalYzdDBJUlJhK01xUitPcWVhTTM4dFhVSEJ2WnVtTlMxWWQzWjlRaDV1S2JuZnhhYTg2bDVpODh1Q0gvem4zWWVPYmhuMzRrVDErS2JHQTNFcUpNV0trL0hxZXI5YVRTV2ZJWDZxUG9mN09yN05PK3ZQY2tmVlNTZm1URnloWHdnRU9PVlRmd1BWV3RZSDdSTVFCemZZajBUbmRHQkxJVUo3T0FQWmpGL01BUG9tc1VjeFN3UmJVVjRRS01vUWg0N1NMS1NBd3IzalNEc3ViZ25BenpER0RmZUZzelVaSVA3bFJFWnNDdGM1WW9rN0t4SmpSMlBvMld6aXBCc01FcXNBd1J1b0V3UmRtYUxVaGJvQ0lBa2pNWlo2SmxhNDVKYWxITGlzaEdyUjRrcGxaeEtiN1NkdW1rczFRVUZQTlZBdE5yNDA3Wnp5Y1ZQZkhZYmQzRHA4TDcvUXp1YlY2MWErTldMd3QrM0QvOSszang2S25BNVI3VWw5dUhKMVhYMHllVDZLWTg4MXYxWHhOekdLMnY0djZWb0ZTWG5pZVFiZ1Z1ZWlGUStBczAraWpSVnQwU2FVa0FoVHVVenBVNThvOVFIbEtnZVE0bFM4YnpSWkxGbFltQmNjdHFrUEd5SDVNTlRCd2pXeXdIRVc1ejV4ZWpIM0p3dU9ucGphMXB6MVppT3BSWE5MemcwYWNtZXlSbnpGeGJUVXIzV1lFaldlSHBxZW9TZThiWGxrek5VR3Y0Nkl0SXZ0blN1Nlo3UjdtcnBLdGNZaEZXZFpYTkM0L2kydXBMNjRseTFTdzA4NkdZOHVCTTBYSVEwZ295L1I1VEVOR3VNVTRJMkpScVc0dEdCSm9VbFk1RkV0QW1KRW0wQXdqVkY4YktwR2doWEZoNVFLM1EzaHdmc3lvY3J3djFaRlI1emNDQXpwY3BhTVEyUnhyOHViQVBoVjY0QkNEY0RSelpFQm1JS1I5WkZFckZtL1BKWUhNWnBadjBWbTZPd0QrTlFyYnRZQnhpNXVRU2VtK0pTVEpRcnF0a2hxQ2pjcUlwTFphTFVFbGRxd1VtY1ZURmh3NWhNc1Q4bjExK1ppaE5oenZsV1RmLzFYT3p1MW1pMURkME5QWWJzcHJMTURJTnpZa3RiVGVuMDNJYVN6VTN6OTBWTHFpYWNYakYrOTNMdUVPemJMOUk4enQvZW84blhWamVWbWJQejdQd01HdkVWMVJjWE5GUldyKzRzYnpmcHBsWk5YVjg3OU16MTNLLzB6dmtOZjBlcUo4UTJrakNnZWZlRTVVek5JSmozVkgrSWRDR3F5ODZPRk91WmdVREwyQythaW1FYkNwUTJFUVhoVk1NSVZwOWE0RktxaFBRWVM1Uk10dk9abnNLaTBpRER5b1pNaEU4NXVlbUtDWUc1a1ZGMkRGOFk0M2F6RUFNMlJ6eCt3LzRRcThlOXRlMloxd1pabHdnNjlhWU5JcGF1M1BRVy8zZXdrNVVWYlNEenJLZUJ1b2RvQUdtYnIrOXFZTHphMWNBU1JqaERsQUpBOCtpdUJqR1ZobzdwYkxCak9vMVhKTDgxdXIrQjZ2V1RYK29aZXBpKzl6ODBacUZieFk4Wjh4U05UMDgrSFJ3ejVxTmZPcm4vdWpITmdIV3VHOU55ZFV4Ym1PRVptYUxxRmNlTUdYVnJBcHF4VFJ5S3FMRnNlUHlQMzYwZE0vQ0pOMStmY3YrSm9VZVZuZzdLMkgwd3RnOThodG5YanUxUGp5MWx3WEpWekkvUXE1Z2ZnVjREek1UUGtLTnN6Y0x1Tjdtc2syWStDOS9wYlFrejlwa2FQVXUwd2t6dVFNK2xhcHRaaTVFeDAxWnYzRkhVbGVkcUxMVmtaRm84MnU2RytkWEZrNnRhOHdwcmdqVmpWdkt5WEpqdGJ0Vmwya0w2R1pQYUsrb3JhdHVIMXVLeVFLOHA2NXJLNG1VMmtrVldYYnN5NjhqS3dPWm1BbTdXS1NlMHMxbXExT1JpcDNEUmZjeEk1WVZNbUx0V1k3Y1Fod2pmZ1NlaHBReWJyR0sya0ZyWjBZcXJTMDNIM094WEwwY3RzWUJGM0hCZmVsZ1E3dXFhV0RTdVlXZzVmWS8rSjdzYzJhTmU0QTNzckhQYlNDMGtwdGRzQWxZMXAyeGVxdEZPeW54aGlSZkdHM1RzRlF1M093WGxCRWlXT0tEV1VJZFJDWjlMZGxoQkRuYUxFWFRVNkhBekRZbmQrNnBUVXExSmRRZ3gwRlFRWFoxSHY5U3hlTjNENjVkMzBuZEdHb1pNaTdSSDRCOG4vSmQyVlZ0WFgxOVgrMnIxWldPNmd3ajlaU0FXbXhLclVmUVoyQmYrMzRVazdJNmRuRW1kWWlPV2FQUnFTd2c3TzBvNFlMWWFjYVBNS216V1lCeHBFT0ZRU3U2TnJJTUZ1TXFTTWNJNkxZTlRyUldaT2Vld2RZTVdXemM0VXlmdkRIOTRMWDN3alY2RTM1UHNGL3ZORmp2MlNNYWZmRDgxVysycGZCWFdhMkpoalQzMUVHSDlVZEd2by9kejdjbUhCUnBNL2d0UGU1S2x5Yit2Ty9GSDkwakRDVG8vK1RUOUlmZUNjbjROY0Q3MkRta2tXOGhJeXhCczV4Tk9CMU1IZklxbDFBTTZhUnBwbCtLMk1pODJBTEMyR1ZzRHV6RTRxblprZVgybFpiRmFwZXRXS1d4a1dWeXFFZVZBZVR3dTYzMm9xZDIxOGZpdE5oeXgwQkYvSUREYVQ3aDVHNUtxWjVmclVzN0MyaEVId3RHNmErZTgyTlhHSkJyVHRZMUpacTh6VGsxNUZOMHBGK01oVmNXSyszNCtjbzc3THRCOUdFdjUySzRnMW8vckNpSmUxeFdFZ2dFWTFSbGsrREZVL3lQYnBmb21hUDcvblhtQVVSZzlqMS9TK0l6a1UxY244bGt3QjJQblljT3VHaDg5RC92SHpRUDFsNDRvSFhhdW5ROHpHS09udElTYW1MbTRPcW03bWFsZ01XOWxYbE5oWG5hU2piMU5QbXBtT0xHc3FHd0JsZXFLcEd0NGJ6aE5rNDRvcVhjTTJtRWpta3dYU3oxaGVhK0lDdGRzajE4N2RYSk5PbVAwR2hhTVNXMk1MT1RMVEpVcS94VDl3L3FEWE4zdm0zWUlzZDVTaHhEeHVnNGh5SGZwTGlIRGc4aDBJNzFDR056NFg1a0Q4Rng2RHNsaXhuQlhKNEg0WTh3Y2JGaG5lOU01Mkc5cERvemZPRkJGSnJPb3RHMGJPeC9HY3lOa09VT041VVBBY0ZjbmRTTEZjSHhxWHFQNDdTWXp1NTdWUG42YS9hS08wd1lWR3grK2h2bFlGNlN4MDc2VzMwYm0vOW5SekhaMUVWOGR5MndjYVlLMXZNejZHeFFoRG1FMTJqWlZxaGVoang4Y29NVENtNEpTb1hMc0NndFFBOWduQmdQRk5yQnd2a2pDeHJyRjJBcXhXNHlOZFl2QnBkaXNMQXFrTnczS3hla21MYkkrbFJtS2ptcmdwUFo3UlRzN3NNbWFIWVQ0SUVWZnBtazV6VnQwcEduOStrZE85cHhLWGo2eWU4S1N5Z1hMcW1QNTdWT3FBL2RmdXNUZHZwM0x6UXROVC83NGhSOGxYeHhmeksxSkd1M2V4cjg5dU9WZkpwWFdPTlhKQmR0eGZheTNDV0JJRXlraHgyL2MzUVFyQURDR1U4UlFaTHBvKy9wZUoxaXliU0lNVUV1OE9NQlozVjVzSzRsZzBwQ1R4OEpjSTcxUFpEY2UzRFFYc0NhelJhTHN4RU5VVmx2Q2tYSll4blpHNFJYc3FkU3Rqd2FmbzFxbTFDaklNeStVbFlLZWpYTlQwRE1XdkxhZGl1cWZFWDE2dktQZ1o3eE55Wit5SGlzZ1U5aGpKVVFtM3JETFN2aEdYVllxVWwxVytxM3FZRG16ODUrNDBRbzZQTGZVYkdVZTZxUmI3TGpDcGN6ay8rdTFnVDY3cGJXZFpicnVWaGVubU41cjFsWjVrN1ZGYnJTMjZLaTFoZjY3YTJPNjhaYVdsNS95NjI1MWdTTm1mR1NOZmJER0N0Sk9EcWZXR0V1dnNWVXAzTWdEVVMxbkVrdWxEclppL01NQmxWYTVJYlhpVG5pdXBFcFZkNE40M3VvdUtLNVFzejhmWUdOSnlkYll5UHJsUEd6SjZ3eFd4RmxvVE00cGhHZTNMWkh0TDdnWmRXNG1xdnd0OUJVYS94RXkzSDFyUFljRStRYWlQWng5ZzBaRVFvcWVVeG5QUkVnZFdYc0Rya0dtaVVmbEVOaW9hdER0OWFOWkNMTXZGV0NCS3F5c3VYRXRYTlplWlN3a2QxVUZNbGEydXZDL3gxalhGbi9jRW9jNVJsdTJXMld6YTBBV0pWK2dKZnhHUVEwMm5OaDFOS2JEbUtkR1I3OUF1V1J5S2JsQ3VhWEo5Nm13SkptOFF1ZzkxRWpGaGNuL3BLYjV5VDhsLzdpSWlzbC9LUHg2Z0g5TjFRY2VmQ0Z3N0xyVTJiamlOSFU5bXBGR2s5bG1WbFdHTVMwOGlhMlBNQ2NxRzAyaU8xT0p5bW9kTG5WZUViS3B4U2JyRE95d2t3T1kySVZIZWM4YkxKa2tsM1VMVmFmS2Nwa0h4ZXJJUmtnY3dIcEV1OE9OUjNGQmF0TUhoc0pVb2V2aHZrWHJOem50akxhSDF0N1d0L1BvdmUzMGlTbkxHRlhQZEM5aVZGWnhkOXlIQkowdTE3K1ZVNVFpNnZTdnhuNzFSVHI1bC9md3RpNGs1L0NYMnhUcW1vaGlZd2Y1SjBBM2VZRU9MVGZxaUZOMHM0NDRnZFJaMlg1empxOUFxV245K0tZNGFFWnUxaGpuWldZNVBxNDdqckFpWlRQKzkrY09adUptYy85UXNRd2ZPL2w2eFNhTW5uc3htWGFqdVpmY2JPNmxhZC9MRjJkck9HL084UmNVc1c3bExsYTVjV3RyWVdiaFpzczVtTFlFSDd1Z3dDZ2JvS3hwS3F5cEJPemN0dXRYaFl1cWlNcUZvTERLSXVrKzRha2w5dnVaeXhad2pWNXNmOWhsaDV0QkYwYWo1YkJMTVlrQkxHdENlQ1lGUWUxajNzUnVrOHNyYnJFdjA3V0s2MlkwT01ZMERxMXNuTlhRTU92akNiRmd0SmJpbFA0L3NMOWFZcnkrQTVCcHBBT1ErYU03QU9HZlVMbmFCV2haeXJlLzJndUlmeXJOVCttK2RXNVNRS2FQNmxzMzRNcGczck1MSEdsZEFidGtsZk9GU2xRSWJJRTJJeEpoUE9aV09yUGpDY2NpUlAwRkdha201VmZQdmVkU3BWMExJMmVRWnRJeHZld2Vwd2IxMzdvMzFHQTN1K28xRTY5UVFXbDBWclBxYjhJUXI5TGFkY1l2V1hQS24zLzltYklzYS9MTDlHdXBYbWZab05NM1hmazlmMEUxbjFTUk8wWjNZTUU4aEM4cyt3RTNsSVZsTGVJR1Z2b2tWNEZXcmxKNjBZakFKd1l4Qi9pa3hNeEtDQTNtd1VTSkFiMlpFa3l4c1lxbkt0RTJvSFdZTTEzTTJtVVNSVHY3UkZsMEEvLzRtV05RaGswUWNiRlYrRGN5cmtuV3BJTlpZNXNESzEwbm5PSW0zdUVJblY5ejl1ZHp1cmNjLzlrak94Wk5ySis2L09Ta2huR2JtK3JyQ3VvNkQvZFdMZmRuNXdqOHNvYk92ckxidDEwNk5mZFVvT0RiZHp6OXErWXQ0VFBycHg0dExObG16ZHJWdWZKNFZiUzRiMkxEMElNZ1Q2eFBqK29zeUZNMWlaTU5OKy9VRS9ya25YcGVaSjE2YXBTb1gram12WHF3K3U5V2V2VVVzVE9EOXBoZGM0dTlldlpYWVorZW5RZlByMHIxNnZGOVZLc2VTckZaajJDYWszeXJpZW1hLy8vUkpwdTYrVTlFbTg4UEhQemVyZE9HajZVS2VOSzAyY05vMDBDMjN4SnRHbTlLbTZZeHRMbVFvazBkMnB0c214VC9ueVZSMUE1VzZSTlJLZkJ1MmErWFBQcjBKeUJVZ0hxUy85YitveCtNOE5FaDFXcldEM0E2ZVhZMHJWckgwS29yVFN1cEtpeVg0cC91QzhzRnFJOW1NTW8xQWVXYVVwVHJWQ2duVlVia21mQzZDYUdpemNmKzJFT0xEdWhYVUZyVjJOcXRFRkFPbzkyU3UxcXZJNkZjQ2pwTDlqWEM3OVdKY21VdFBCZllFc1g0K1ZzaDd3MXlZcnppNjF4SDlvK2k5KzBiZHhaTnluRTNsRjcxZXJ4TmxlWFJ6TUthWU1XMWUzSHpUUkFxNWFLc2pKYTA1K01wRDNscTI0ZU9Yck0xNFBjb3ZEdWQ4VzRqYVNNRHQ4Qzl5THdUb25JY1lFVUx3SXIyMGF3Y2d3Mm9CL2hRUDVhckFkRkw0OW14QVhpdk9TeVBCMmpSY1pYUjVYcjBNOFhDZlBRdG04V0VvOElTWjUxMUVvYVdOcndhTDhxdEUvNUhlZjlhV1BLSmhFRFRPQXFyZkFKUk9IRk5qWDZhL2lkUzlHOG5YN3MxK2crMEtxbW50dkJBUEpVeTdMaG1Hd2FhbE93aFNNbDRlRld2dkxwbVgxZ0FJSzF0WXFJa3hxVW1tNVNQQkwvZ0tLeW9qVGMwV3RnZlVLeG5mM1B4aHZTWDIwQ1krbXZxNm1NczRmai9aVE1DNmJ6a0o5cU51ZXNmWHJmdVlaV1N0ZndFdXpIdmRGL2Y2Yjd6Z1pyWWxKb2EwRTFPMkl1Lzg2K1FHaktSOUpCK2tnaGhCTFFxS2hmejdDK0gycFdqeXF4YWVYcGtRTlVXc3B1Q2tpK0tiZWVscmdnZTJQQ2licC9OZGlKbUhKUmlqUGFZQ1BFYjJFZjhWbmtTQnBrTWcvSWNlSTZOL0YyYThXTENhSytLTTJ3a3V5cmhlWktZeUN3TzRSMlBUU3BGRnhmN3dBVGpVcHVZSUtXVkdKRXhxdkRYWGVtL3RLdlF2cWFacHB2SXBrcGczTXJQUEM2WHFrYjZDNHdxK0V4dkNGL1VTRFdJTkdsaDlVaS9HT2ZpM3U0OTVTYjc5SXJnek56TzRONjJybDFlMzdiVytnMEZXWmw4Y3JZemEzWGo0dGpFc2ozanB4d3Y5ZTd0MnZESTRYbk5aVjJpU3MxUldyWTJVaEdoejRHVnNZOExkRVVEdzdQT2x2aFVYUFdFd21oanVHUitUZjJFZXZqWFVMS3hyWFdLYmZHOFVQMkVybGxWZFpQR3RYWS92bmZjb2tqSW5GZVVXVzJhd2dsWkdiT28ybGd5c3l4WU1ibCtCZXV2bHp6RCt1dFY0L210S081VFRuUk1pejFBM0tuaWZxa3lQSkRMOHJOVXFrbTMzWlBzU29qQkJ6dUJPcXZjanNsWjN1ckt5UzBNc0pNclJDNEZYcGNDY2FsU2xIM0ZRTzViYk5LbnZsbEt0b2k3YWV1K25mMDNTTWxlK1AxTmV2a2RGTHV2eWNRK2FLVml5cjcrbmo4Rk9DMlhGSkZTTXA0b3pmM3M2WTUzUG1Gd0lNK1VpUjN2OGdTbFNUakc3N0c1WHdSaldFUTIyVk4vVnd5N0xaTXg3ZXl1YTJiSGVwY3dERHJTemM2aXZXRTNPL045ckpuZFJvQ2ZWeHZhTFpnN3BwM2RsdWR5bXJaeVgwOUJ6djhuYTJHWThSYlg4aGpBeFk5ZUMvMUR1c1k3dlpZOWJDM2xINytXME9pMWhQK2JhMUhBM1MwdVIzeTM3SjNGano3OU1TdDYreXFXRTFKcm1nNXJLaVFoMEpwSHJsMVZLYXlxU0ZsVkVUdE9KVlZIWmE4T2tSbzdhcHRhWWxHa1A5K0V3UWkvVXEyREtZWXFsOUtxeG84SGF6MFlhcTRRKysyWnFsTGxVRXpDR1NobVdhU3JaQ242YUxLa1RReWZJazg2Ry9qUjlMbVQyZXJ3Q0pYb2JDVThjUk1xOGF1WmFSOStRZUhsbHJTaFQvZWFPMHQweElSbjJtL1VhNDc5NVlDUDdEOW1TZldWay9HMC9aaW1jaFNFVUdrb04vdzJ5Rmlxblp5cU5TVk0vOVBqRzY0YjMrN21VdzN0VnB3LytQMTBPN3YwSVlmMCtIdGdmQ3ZwdXRuNDRzZU1iMHVObnpBWUxmSHJac0RZUFVXRUx5TTNQL1owZWg0THJySXR5S0l5bCttczcxOG1SdnB2MHZsUHlvaGk4ei9KRVdGdG5ReVg4RGlQeGNWS2xUaWN5cGlKOXRzMW1JMTJBK05tWSt3YTA1c3FBZE9iQ0pRY21mRWJ0d0VzR05NT2NQanAwVkd3OVBUSEhPMVUrcGw5VWJXVVpKTXk4azVLNXZMVktkT0hiY0swWWNrNjBpa3NCNHhkam5LVVZLVEJmcGZvTUFmbEFvQ0pCV0haWVIwYzNZOUFxOE4rQkRwdDZOdFV0b3A0TFZxVjNnVGlucTl2WUYwRnROWitqVmEwQnlXZHRWK3ZzOXFEL1JiOGlmZHRlRDhCTjBjMUdMREVFL0J4dkxMRlNiOUdiN0d4OWdJalY2eXhlRUVPZG1wUUdUT1oxUzNPUjNLUk9Hc3RvRkphQzBRajdxS0FLaEFyQW51S2NYeGJLb3BQVW4raHVrcnBJenN6K1UrbmxqZHVTVjR1L01uaXpVOHZtdlVML3hjSHA4VUdWcDlQRGozOHpMYnd2Rm5SbXRsenk2cVh6Nmlrci8rQUZxNzU3TjZ1cFhYVG9yN3FTWTI5a2VUN3lRTS91N04zQmJYOSt2bnZGRTAvKzUxVGs3eGxQWGhPZ1BXM0E1ODFtOFRJWFRmcGNJZG5tOEE5UldjMUQ3M1UycHYwdTR1bmN4azVNVmloU1J4UTV4V0U4SlNvWkxUSkpjSDQxUzU0Y2tFby9iRXFVUTVHVVBQYkVyNlMwblJTL0tZZDh2aWJ1S0kzNnB5MzVTUDh6WnQyMVJNdTNNQzdWR1NMOWRvRFBZTzk5dnhZRFhPRGJuc0ZOK3EyVjVnNitOR3Zzbmg4U3ArQVcydTRoL2pqNWszM0RpSGl1Rm5qUGU0YkkvR3QvLzE1STlhNCtid1RpQzV1Tm0vNnA1SFlrekx2UFd6ZVJUZVpkK0JHOHk0ZU5XLy9KNXMzVTdRM243by9oU1J1T3Z0L0c5SEc2Zm12aHZtSFNCMDVrSnAvSkQzL1dqV3JOY2xSc1lRRTY0RlV6MVlUaHRXRXJldzRCNjRHRTZ4aG9oeDRyQmJQcTF6ZW9wQkZLVGlSL0xDMjJraHFiWEpPRWRnUFJ3bHpySUlpdkNtNWJJa3MxdmJ1K25YZnJOQ1ovNmlHajZzMjdyaFdwTktKNjZLYjlvTGtaNHdSS1NWVnZUemRJRkpJMFdrNnE2SUtrUEFJcGZMVGxDb0VTbVdIcFZCVWRvUEpLZ1dUVlpGVy8vM09IRVJYV0pLWGsrb1dhUjNzTDlmN01JVHZZaUg4Y3JCYWxWZzVCYXBZZG1VRGJVckUvMXZjMmNlMmRWVUIvTjczL1B3Uk83YWY3VGgyblBnajhVZWNPSEhpbHlaMTBpWmRFbWNOZGIwbWFaWitxSVZPTWQyZ29TelFSV0lORTRKSkc0eXlrbFlhaUE4VldqcUJnUGNTQzZxQ21CamFud2dKb2NMS0prQUNpZncxR09JZnhBejMzUHVlOC95UkxyQS9KclY2OW51Szc3dm5uSGZ1dmUrZTh6dkVNa0t3V1MxM3VwUmVXblF4RnRyVlFpclRLNTFrdENHdVRrSWJkRFNUS3NJb3N2M3BPcG1jWXJPcEplMXhuZFRtVXp5NmlyYjVWWU9QZklMSXNpRWtXOU1sa3dXbGFONGdaSVRMYmxwQVBnV3JQazlhRnU1QlpMR2xaVnQyWmlCR1RNMUsxbTZSVTQ5WHVUK1ZEdzduaDdWL2tFVmUvZ1A5d24yZkhxak5ydk0vTU1TUkQ0V0pMajZLTmtWYWUxM1RSQkNlT1ZaSjBFK3MxTytFN1IzRjVxUkZCZWxXaURaaC9aRlpFRDFON1JIbS9tVUxsRStFMmpkdU5zM2ZRclpBQXE0SkxzV2trenJkeVdhQ2gyMXN5QWVuKzloR3VvM3RUREI1UDVKZm1Yc0pKTDU4Y3VFanB4OCs5clZwUEpiWnYvcnRieHc4ZFBGR25nbTc4NFhSNjgrWFFkejlMNDNjbm54bC9kb3lsL08vV202Ty9oUVhpakJ2byt4QTRoZkJLeDdSOCtLcjZJSEVNNFlhMFFOaktqMXcweDltWEVsYXJ0SzdHenR3QW12a1FIRHExZlJBSTdlREQzd2JuSG9EaEdCblhBTUk4cTlUei82KzNUL01oM2UvZjl3SjN2M0JIZUMxdGFQV2g2ZXBoeis1YXg4U3UvUUJIRDFQSGx3NURMblRKWCtrTXhwblNCN3FHZmZhSTlYdDc5NnBEZFh0UDdCYjNEOTB2cC8xYTQ3MEN6emFaM2JwR1hTTWVMV3VIYS9HdXJrVjRVUEVnY1c4TlIzZTZuTzIxRHUyR0E4djl4UFVzU2wrTStTUmExNXRyeEtvZldPOHV5ak9WNFhkUEZqUFM5VnplOHBHSlBiYVNYVGRnSTZZcU5BUnUvOC9PaUlZNWw0SWlUaENUUFRkTVluQ3J6UXpKZmQrR1JqR1JKK3RSSnNMVEp0S3lMUzlhY0dzVmpka2RBUHhlNEFHVHZtZ2pLVGdoVEtTUGxZdnpTNnF1b0tOY0l1Ymx2a05RV2lvMThoR1oxSHkxSlgwRVBrR0dPUEwzN0pYYzR5NVJoamo4dmVNMzdGSHhYTFRubURHdktxYk9hSWJpQkZicmRVT0JNTU9Ta3FjR0dwZmhoYStqOTVUdXIwVUZhT0doMjM1QjFMRU5rRi9FQ1hXSFJWZEpZdFRqQUFZUzA2SmloZUNLL3d1cFg4UU92Ky9hN2ZXUlBlaTZRL3JqZlhkTlc3c3F0bkQ0SkQ3UDIvemZ4VHNxQTMxb1ExVjcwNHlHZ0s0VHdsclpWT3RNRDdDaDZTd1hiSTV2UEJXeUdhcXZPc0syR2pZRjBERVRHNEFQN01pcXM0dUdpVXRVazRBK1FBQVg2am8zaFdBNWJVWHhCUm1vQXZGNW9EWlNZQ1dZSk9qV2NXYzFLQ3dUbGE2WXQ5TzdrR0U3a1FrNG02bityeUxxdVc0YytrcnM4dlQrSDc1Rm82WDcwTnEwS0h6ajM0OTJmL1piR2lwWjkrY282a3RtWTJrRndQZDNETTRmR1BsM0FkRzFlU0VRNFZubm4wUnU4cC9leUgvMEdLTysxMXcvNEhvL0xGTE5PZjVyL3cvK1orZ1hqU0Y1aUJMcWhOV2tIRko2UkRnVlJpZE5jaFdTWmtnTm5RMFU1cjJkWUpzcG5jMk8xVUFFeFFROUZpM04zTWVrRWx1UHhFRjdIZm1LSWhKc0haMHhuMURCK2JVV3NVaG1ORkRLbk00Q2dsdW9oSWFKc2RwMTVZSHBXQ25YWjRRRlRlUUxBVXRTRzZrYXJQQTBJNDdjTVNyb3hGVDRsd2lQbEtwWEFlSlpaV29ES01RWVdYZFdjbGEyMmpxaS9uc2NpU3hjcUR3Zk5qVVpEVGdjaC91YUNzZS9HUnU5c0pYUDFjODlXUnE4VVJIOW5MUWYyb29PZDdjYkxHTUp2c1dBMUc4Z1pjNHU4TjdwS2Qvd2V2RGYvNzVoWVdsd2I2K3dSTW4zZDNwcnRIMnlhYldIejQwTm5yc3hNWGpDOEhDMk5yZnYzbm02R3dxYWlwOHZqRDFpV2xMSWpPZXpVKzVlbnR5L25oaWFJdyt0eXcyNkJGa1JrNHlaMXV1amc2Q3JJeFdTYkZab013SVJiczEzVlBzNUttMXE1VkV5ZnpaWlRTUnA5WkxoaEpLY211aUpBVEZ4Y0tIRks4UnBteStiTU9JSXE3bWlkeUpMcXFtZCttRGpGNnJDc0RFMkdWdzh3WXkvaHVKQlFGVXhDaVZPQlV4VXFtY1pkRXFaM0VHdFhLVytrSU11OWk0WFBVT0RLTzdocFA4eDhpNnF3ME5JMGhITlJOVGJFMHJIQmhkSUExN2hFZ3h1eUFacmFVTmxrcXRsQ0xEdVRhTlFLNmlOSkhHUzZPN3U2OSthbDRicUpIMmVxWVQwc09iMEh1OFpyaXF1MlpBVmRmTSttdm1uV3Y0RXZjV2QxMW9JMnVLYmlTTGFSQzBXVjFDUUIxYlVhMWppMHgybHBCSUtTSGsrUURLYTlEQTBzenhwZnN6WTZtZzJ4NTArWEtEMlVYK0t6ZmZIQitlSFlpN3cxYVB2Y2VmbmpsTDI1b25iYTJTdGp6UWxvY3VWMmhiTFJTTTRTSnRHU0JIQkJsc3BDMHZhNHRHcVZJcUpFUGh0WGhNZUI0YWM5aWRUaiswZHAvdm8yMUZiQmFyalRhV3Yva21hNjk4bTF0RnYzN3Y3V1g3OWUyVi83THZ5RUNzcmowTzNlRGU0cCtnc2t5Z0FraFRqa21xUUdtU1QzY0RtVUtoTDhnK0NwQ3pBZkJ6S0FBeFpiQnk4c0I3Vkk1bllZZTFNby9WbnJqeCtzTjZIZUNYYTNWeTY0MGFuZVRydGNTaGRkS0hHYXFqSlBTQm1FRlNVZ1VuUnpNMEFhWk9kbG8rVDRLYzlTZmdyRCtpRmdIM0ErU3JKY242MEVDMnNRYm4xc2RTSVoyNDhXUDE2czVFcThVLzNzQUNTRi9LdC9rWnF2LzNyeS9aL3VxKzFKdFNwcXVtTHcyc0MrT3p1TVRkNVp2MFRCOGJZL3JZVktZUHd3UGJHTlBIVm1INnFDdCtNaE0rVy94eXNUaDdtUE5kV1Y2K3NreThnWjJzUjM2QmZrTitVeVIrOFRnYkp4U0hUNUpVVnBCaTlXUXk5R3dGSGhUUXdZTlVZbVBKenI2UkFjUkZ2clV5UmtNN2JYMUVJd3JGNmo3WUdXSUlQNlllejdIakJ4bHhhTERxd0h4Vmtsam56eWkveG91MG9ZRGNpVlVkQ3NqVHkyQjlPRmxINmF2NSsyQ0R2OWNCNWxVb0R2bWRPaFlPK05NcElyY2ZDMFl5a3BBNThRRElySmNzM3h3dzEyc2xjejJFQnh6TnZYS1hSQXRKeGpJbGs1R2VDRXBBZ3BMYjJWNGdmMDhlemlnUksyd0h5bVlJRldxMzBpMUFzZ2dZWUJCZEpNcDliRHNGb2xVY0lpVW51RWVrZlVNalhTTVNCRENveUZ3MklURkZUTFNlQWpub3BqSDlmR0lxTUMrc0JoNzNEY2FMSytlSFhsNlJ6SUp3ZXYySk96MG1IdjhyVlk0SUdOL3FMMTlybVpCZXpILzZ6T2phN2VFTG56cFhjT0pYMXNLRjRhZldGaVkvSkxWZS9JS3B3M2o2dWF2dHRxZEdKenJzYSt2SFo2YVBuMy9jTjFuODdncjR2aWozSmY0TndZTk1SRGZyakxpa1dKcUpKYUVLMVVabHl3Rmd5ZXpJWkdpVkFTUFJBQ1duTks2M0N4WkdWRlB5TXJwS1V3YjRJRTV5Z3BFSmFSVmxpRktRclZRK3pWbjFOUmV3c3JBb3VTZG9yWE1IV1lTSlVmemFuVFA0Mk9HTm8wZW5IaDAvR0g3UzhPcjgvRHUvNUNUeS85bnliNjlkZitkcGZPZmpLOXp2eTRkQngvRFM3U1ova3p3bEtnc2ZLR2NtY3ArNnp4cnhqQlh5MU9wNU12RFpvQmdSNFFmK0RUaXEvd0ltdXpub0FBRUFBQUFCQWszZTlsOGFYdzg4OVFBZkNBQUFBQUFBd1ZsMkRnQUFBQURadytzTEFBRCtsZ2lSQm1vQUFBQUlBQUlBQUFBQUFBQjQybU5nWkdCZ1cvc3ZqNEdCVTU2QjRmOS9qb2tNUUJFVThBd0FlMVFGeDNqYWRkTk5SMFJSR0FmdzU4eFVEQldWdEttWm1EWnRJbWt6a2xGUld2UTIwcUpFZWhsR3FqR0dNWldSeE9oRkxtbVJTR0lXUTErZ0tYMkEzRzh4V3JWdkZmM1BPZi9MT09yeTg5eDdQT2ZjNXp6bjN0Q1hUQW11VUZXa1NUU1ZSYXpEQ0JRaEFiTVlyMEF2N205Z0dkYnd2SVRvSVI0Z25zSU8xT0FXcm1DVDQrZndDSWR3YWZQTjNHbTdqaXd5THdsUnprdkJIaFRnd2RZZys0QTZaQnRXb015OE5Jd3hWOGNjWkxoZW1udUpNemRoeDFRYjMxbUZkMXVMNmtQYzRyNXpyRTAvbjhBOFhJUFArc3JjMDV6ZGsxbTd5TG8rSU0vOEV2ZlhEeHN3eEpwMjhiNVh4RGYyTStpOVhuc0JMdGgzblhNR242RDdmODkrMW16dnpkZ1BmTFBldXMxVnVyWmh1MGZUN3dubUJmTmJxWWZQMFg5RXVMZUNvK0lZYnpnSDF6TmoycEhnV2xuMitTL2RQQXQzM0hla0dzN0I1VEdXSFBvc2poaTcyQS9VcERvUlg4S2pJaTBaa1NDRzRpTHFEam9zOFJGbkVGZk52K01GbW1QaVJXTG12OGpiNzl4ODYvbzhqaTIxanRpdTUrSitVTlByWW13U0JzSlBJcitIWVdMd0FBQUFlTnBqWUdEUWdjSTZobXVNOTVnbU1ac3dIMkgreHFMQkVzQlN3YktMNVJNckY2c0Zhd0RyRHRZUGJFbHNGOWhsMlBzNGhEaGNPSTV3T25IV2NWN2pmTVBGeDZYRU5ZWGJoanVQK3dXUEUwOGZ6eWxlQnQ0eTNpTzgvL2hDK0tieG5lRG40US9nM3lMQUlUQkw0SmRnaWVBU3dSOUNSa0xMaEc0SWN3amJDV2NJMXdtdkVMNGkvRVpFVFdTZHFJSm9qdWdUc1FpeEhlSlR4RDlKT0Vnc2szZ2xLU001VGZLWmxJWFVFbWtlNlNEcEN6SnBNb2RrdnNuV3lLNlRZNUt6a0xzZzkwcStSbjZmL0Q0RkFZVTdpZzJLSDVUQ2xLcVVkWlNUbEQrcE5La3NVVG1qOGtSMWd1bzYxVTlxRG1wTDFNWFV6ZFNYcVQvVEVOTEkwSmluOFVsVFRIT05Wb1MyanZZeTdRYzZVam9ST2tkMHRYU242TEhwemRDN282K2duNk4veFVETUlNSmdpU0dYWVpVUmsxR0IwVDNqQU9NZkptMG1LMHgxVEx0TVg1Z0ZtZDB3RnpBdk1QOWwwV0VwWnJuR3FzVGF4UHFYelFYYkdOdERkaHAyayt3MTdEUHNWOWkvYy9CelpIT2M0L2pES2NScGk3T0g4d1VYUHBjV2x5ZXVicTZiM0d6Y1pybHp1VS96VVBONDV1bm1XZUM1RFFjODRubko4NEhuTzg4L1hrWmVXVjZMdkZtOHM3d3ZlUC95Q1FMQ0lwOXBQdE44Rlh3N2ZEY0FBTWQ1bXcwQUFBRUFBQURtQUZZQUJRQUFBQUFBQWdBQkFBSUFGZ0FBQVFBQmt3QUFBQUI0Mm5WU1MwN0RNQlFjSndVSnFXTFpCU3N2V0VMNkFRcDBXNmtTVXFFU1JaUnRDMmticVNRaFNVRmNoQ053RmlnbjRBcWNnbm0yQ3l5SXJOamplWG56NXIwRVFCVXY4S0VxVzRCcUF3NHIxSGl6MkVOVjlSMzJjYUZ1SEs1Z1Y3MDZ2QUd0Vmc1dk12Zkw0VGZVdkxYbU94cGV6ZUVWdHIyZXd4L0VWeFovK3RqeEp1Z2lRNGd4Q3U1MzBKamdtZnNsbVJSem9qNzVSMFRjWTk2V3lJbGp6SWpuUkRuUEJFOG1WaEFsV0JodVRFYlVlbVJpUnVUTW1CVWlJTnZsTFdXZGpBb3o2aFRrV21od3RVdHJCeVlTVWwvYzVzN3QwdFFKcVNUMTUwUWFRNXd4VTJOQUZldDY3VUlVSTl3YVZoVDJUQmNGVjRvTzZsdzVvK0lxSlplenBuUzc0R25kMTZuWm8wYkFDakhmVEl5TzlDenpHK1BjdUlybzZ2NmZ6cVhIZ0QxcTF0SWxDamJXeEJIMmNjTEhUdVc0OU8yL0ZhL05ITVJ4WXJxV3pLYXAyTUJwYWNVUnN5YVkva3pJWm96Y2ZBZk1FRlliQmZIVjRkUGlmb2dEOTlXYWpNazNtRkp0U2QzQ3pEMHpFNWIvNVhmNlF6eVFpUmlUZjI3eERjYWNkMHNBZU5wdDBFbHNqSEVjeHZIdnI1M090Tk45WCt3N1ZienZPNTB1OXBtMlk5OHBTbEhhemd6VjF0U2dhQkg3R2lMaFJHaGRFUHNhZ29NMjlpMUZjSEFVZXh4d2s2RHYzODF6K2VUM0hKN0RqeERhODh0UEpmL0xPNUFRQ1NVVUMyRllzUkZPQkhZaWlTS2FHR0tKSTU0RUVra2ltUlJTU1NPZEREclFrVTUwcGd0ZDZVWjNldENUWHZTbUQzM3BSeWI5eVdJQUF4bUVobzZCZzJ5YzVKQkxIdmtNWmdoREdjWndSakFTRjI0S0tLUUlENk1ZelJqR01vN3hUR0FpazVqTUZLWXlqZW5Nb0ppWnpHSTJKY3hoTHFYTVl6NExLQk1Meld4aU16YzR3SHUyc0llZEhPSTR4eVNNSGJ4aEkvdkZLaloyYzVCdDNPYXRoSE9ZRS96Z096OXA0aFQzdU1OcEZyS0l2WlR6Z0FydWNwOG5QT1FSai9udzUzdHRQT1VaWi9EeWpYMjg1RGt2OFBHSkwyeG5NWDZXc0pRcXFqbENEY3VvSlVBZFFaYXpncFY4WkJXcnFXY05EYXpsS2tkWlJ5UHIyY0Judm5LTnM1empPcTk0TFJGaWwwaUprbWlKa1ZpSmszaEprRVJKa21SSjRUd1h1TXdWV3JqSUpWclp5a2xKNVNhM0pFM1MyU1VaVm05VmZhMVBOekZzd1dxL3ByazBaYUdwVy9WdWh6TC9yNGFtYVVwZGFTZ2R5bXlsVTVtanpGWG1LZi90dVV4MXRhdnI5a3EvTnhpb0tDK3I4NW1WNFRGMWVpeEZ3VUJOKytIMEZQd0daZ2FUOVFBQWVOcEZ6RDBPZ2tBUUJXRFdsUVdSZnhZN0U2eTM4UVRHUWlqRXdsaEI1QnpHU20wbzlTeURsZkU0WGdRSFhKZHV2cGQ1NzBYYUdzaGR5OEhjRncwaGo3TEptQ2dXNEpjNThBTWV0M0lPVEZTRkJqUkpnWW9ONkVuNjFpaUp0WkhvUFU3U3AzNlJZQWo2a1RBUXJKSXdFY1pXWW9JdytROEVMTG5zZHNzVzRiamMwT3lFaVlOLzdsblJSanFWNGhScHJ4Vzl2bjV0aDdyZkpSNkpoaVRBaWw4cmhzamdxQmdodzUwaVIwWXJ4UmpKbDRvelpNei9MSUdMTHdDOVhUc0FcIiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG52YXIgZXhwb3J0ZWQgPSBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDoge307XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkOyIsImltcG9ydCB7IF9fbm9uTnVsbCwgYXNzZXJ0IH0gZnJvbSBcIi4vQ29yZVwiXG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuPFQ+ICh4zIXMhTogVFtdW10pOiBUW10ge1xuICAgY29uc3QgeMyFOiBUW10gPSBbXSAvLyBvdGhlcndpc2UgVFMgaXMgY29uZnVzZWRcbiAgIHJldHVybiB4zIUuY29uY2F0LmFwcGx5KFtdLCB4zIXMhSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50czxUPiAoeMyFOiBUW10pOiBNYXA8VCwgbnVtYmVyPiB7XG4gICBjb25zdCBjb3VudHM6IE1hcDxULCBudW1iZXI+ID0gbmV3IE1hcFxuICAgeMyFLmZvckVhY2goeCA9PiB7XG4gICAgICBpZiAoY291bnRzLmhhcyh4KSkge1xuICAgICAgICAgY291bnRzLnNldCh4LCBfX25vbk51bGwoY291bnRzLmdldCh4KSkgKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGNvdW50cy5zZXQoeCwgMSlcbiAgICAgIH1cbiAgIH0pXG4gICByZXR1cm4gY291bnRzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6aXA8VCwgVT4gKHjMhTogVFtdLCB5zIU6IFVbXSk6IFtULCBVXVtdIHtcbiAgIHJldHVybiB6aXBXaXRoKCh0OiBULCB1OiBVKTogW1QsIFVdID0+IFt0LCB1XSkoeMyFLCB5zIUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6aXBXaXRoPFQsIFUsIFY+IChmOiAodDogVCwgdTogVSkgPT4gVik6ICh4zIU6IFRbXSwgecyFOiBVW10pID0+IFZbXSB7XG4gICByZXR1cm4gKHjMhSwgecyFKSA9PiB4zIUubWFwKCh4OiBULCBuOiBudW1iZXIpOiBWID0+IGYoeCwgecyFW25dKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzPFQ+ICh4zIU6IFRbXSwgecyFOiBUW10pOiBib29sZWFuIHtcbiAgIHJldHVybiB5zIUuZXZlcnkoeSA9PiB4zIUuaW5jbHVkZXMoeSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcTxUPiAoeMyFOiBUW10sIHnMhTogVFtdKTogYm9vbGVhbiB7XG4gICBsZXQgbjogbnVtYmVyID0geMyFLmxlbmd0aFxuICAgaWYgKG4gIT0gecyFLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgaWYgKHjMhVtuXSAhPT0gecyFW25dKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbnRoPFQ+ICh4zIU6IFRbXSwgbjogbnVtYmVyKTogVCB7XG4gICBhc3NlcnQoMCA8PSBuICYmIG4gPCB4zIUubGVuZ3RoKVxuICAgcmV0dXJuIHjMhVtuXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFzdDxUPiAoeMyFOiBUW10pOiBUIHtcbiAgIGFzc2VydCh4zIUubGVuZ3RoID4gMClcbiAgIHJldHVybiB4zIUuc2xpY2UoLTEpWzBdXG59XG4iLCIvLyBBIG5vbWluYWwgdHlwaW5nIGlkaW9tOyBzZWUgaHR0cHM6Ly9iYXNhcmF0LmdpdGJvb2tzLmlvL3R5cGVzY3JpcHQvZG9jcy90aXBzL25vbWluYWxUeXBpbmcuaHRtbC5cbmV4cG9ydCBpbnRlcmZhY2UgVGFnPFQgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgIHR5cGVuYW1lOiBUXG59XG5cbmV4cG9ydCB0eXBlIENsYXNzPFQgPSBPYmplY3Q+ID0gbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVFxuXG4vLyBQb3NzaWJseSBhYnN0cmFjdCBjbGFzczsgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM2ODg2MDgyLlxuZXhwb3J0IHR5cGUgQUNsYXNzPFQ+ID0gRnVuY3Rpb24gJiB7IHByb3RvdHlwZTogVCB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc09mPFQ+ICh4OiBUKTogQ2xhc3M8VD4ge1xuICAgcmV0dXJuIChfX25vbk51bGwoeCkgYXMgT2JqZWN0KS5jb25zdHJ1Y3RvciBhcyBDbGFzczxUPiAvLyB3ZWlyZGx5IGZhaWxpbmcgb24gQ2lyY2xlQ0kgd2l0aG91dCBjYXN0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWUgKG86IE9iamVjdCk6IHN0cmluZyB7XG4gICByZXR1cm4gY2xhc3NPZihvKS5uYW1lXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhczxVLCBUIGV4dGVuZHMgVT4gKHg6IFUsIEM6IEFDbGFzczxUPik6IFQge1xuICAgaWYgKF9fbm9uTnVsbCh4KSBpbnN0YW5jZW9mIEMpIHtcbiAgICAgIHJldHVybiA8VD54XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydChmYWxzZSwgXCJbYXNdIEV4cGVjdGVkIFwiICsgQy5uYW1lICsgXCIsIGdvdCBcIiArIGNsYXNzTmFtZSh4KSlcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzT3B0PFUsIFQgZXh0ZW5kcyBVPiAoeDogVSwgY2xzOiBBQ2xhc3M8VD4pOiBUIHtcbiAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHggYXMgVFxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcyh4LCBjbHMpXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQgKGI6IGJvb2xlYW4sIG1zZz86IHN0cmluZywgLi4ueMyFOiB1bmtub3duW10pOiBhbnkge1xuICAgaWYgKCFiKSB7XG4gICAgICBpZiAoeMyFLmxlbmd0aCA+IDApIHtcbiAgICAgICAgIGNvbnNvbGUud2FybihcIkFzc2VydGlvbiBkYXRhOlxcblwiKVxuICAgICAgICAgeMyFLmZvckVhY2goeCA9PiBjb25zb2xlLndhcm4oeCkpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIilcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFic3VyZCAobXNnPzogc3RyaW5nLCAuLi54zIU6IHVua25vd25bXSk6IGFueSB7XG4gICBhc3NlcnQoZmFsc2UsIG1zZywgLi4ueMyFKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaWQ8VD4gKHg6IFQpOiBUIHtcbiAgIHJldHVybiB4XG59XG5cbi8vIFVzZXItbGV2ZWwgZXJyb3IuXG5leHBvcnQgZnVuY3Rpb24gdXNlckVycm9yIChtc2c6IHN0cmluZywgLi4ueMyFOiB1bmtub3duW10pOiBhbnkge1xuICAgaWYgKHjMhS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBkYXRhOlxcblwiKVxuICAgICAgeMyFLmZvckVhY2goeCA9PiBjb25zb2xlLndhcm4oeCkpXG4gICB9XG4gICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIGVycm9yOiBcIiArIG1zZylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vdFlldEltcGxlbWVudGVkICgpOiBhbnkge1xuICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKVxufVxuXG4vLyBVc2VmdWwgd2hlbiBhIG5vdGlvbmFsbHkgYWJzdHJhY3QgY2xhc3MgbmVlZHMgdG8gYmUgY29uY3JldGUuXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3RNZXRob2RFcnJvcjxUPiAodGhpc186IE9iamVjdCk6IFQge1xuICAgcmV0dXJuIGFzc2VydChmYWxzZSwgXCJBYnN0cmFjdCBtZXRob2QgaW4gXCIgKyB0aGlzXylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbm9uTnVsbDxUPiAoeDogVCB8IG51bGwgfCB1bmRlZmluZWQsIG1zZz86IHN0cmluZyk6IFQge1xuICAgaWYgKHggIT09IG51bGwgJiYgeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geFxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnQoZmFsc2UsIGBVbmV4cGVjdGVkIG51bGwgfCB1bmRlZmluZWQuJHttc2cgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgXFxuJHttc2d9YH1gKVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19sb2c8VD4gKFxuICAgeDogVCxcbiAgIG1zZz86IChpdDogVCkgPT4gc3RyaW5nLFxuICAgdHJhbnNmb3JtOiAoaXQ6IFQpID0+IFQgPSAoaXQ6IFQpID0+IGl0XG4pOiBUIHtcbiAgIGNvbnN0IHhfID0gdHJhbnNmb3JtKHgpXG4gICBpZiAobXNnKSB7XG4gICAgICBjb25zb2xlLmxvZyhtc2coeF8pKVxuICAgfVxuICAgY29uc29sZS5sb2coeF8pXG4gICByZXR1cm4geFxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jaGVjazxUPiAoeDogVCwgcHJlZGljYXRlOiAoaXQ6IFQpID0+IGJvb2xlYW4pOiBUIHtcbiAgIGFzc2VydChwcmVkaWNhdGUoeCkpXG4gICByZXR1cm4geFxufVxuIiwiaW1wb3J0IHsgX19ub25OdWxsIH0gZnJvbSBcIi4vQ29yZVwiXG5pbXBvcnQgeyBCb29sZWFuTGF0dGljZSB9IGZyb20gXCIuL09yZFwiXG5cbi8vIEFjdHVhbGx5IGEgYm9vbGVhbiBsYXR0aWNlLi4uXG5hYnN0cmFjdCBjbGFzcyBMYXR0aWNlSW1wbDxUPiBpbXBsZW1lbnRzIEJvb2xlYW5MYXR0aWNlPFQ+IHtcbiAgIGFic3RyYWN0IGJvdDogVFxuICAgYWJzdHJhY3QgdG9wOiBUXG5cbiAgIGpvaW4gKC4uLnTMhTogVFtdKTogVCB7XG4gICAgICByZXR1cm4gdMyFLnJlZHVjZSgodDEsIHQyKSA9PiB0aGlzLmpvaW4yKHQxLCB0MikpXG4gICB9XG5cbiAgIG1lZXQgKC4uLnTMhTogVFtdKTogVCB7XG4gICAgICByZXR1cm4gdMyFLnJlZHVjZSgodDEsIHQyKSA9PiB0aGlzLm1lZXQyKHQxLCB0MikpXG4gICB9XG5cbiAgIGFic3RyYWN0IGpvaW4yICh0MTogVCwgdDI6IFQpOiBUXG4gICBhYnN0cmFjdCBtZWV0MiAodDE6IFQsIHQyOiBUKTogVFxuICAgYWJzdHJhY3QgbmVnYXRlICh0OiBUKTogVFxufVxuXG5leHBvcnQgY2xhc3MgQm9vbExhdHRpY2UgZXh0ZW5kcyBMYXR0aWNlSW1wbDxib29sZWFuPiB7XG4gICBib3QgPSBmYWxzZVxuICAgdG9wID0gdHJ1ZVxuXG4gICAvLyBJbXBvcnRhbnQgdG8gYXNzZXJ0IHRoYXQgYXJndW1lbnRzIGFyZSBkZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBwcm9wYWdhdGVzIGluIGFuIHVuaGVscGZ1bCB3YXkuXG4gICBqb2luMiAoYjE6IGJvb2xlYW4sIGIyOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gX19ub25OdWxsKGIxKSB8fCBfX25vbk51bGwoYjIpXG4gICB9XG5cbiAgIG1lZXQyIChiMTogYm9vbGVhbiwgYjI6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBfX25vbk51bGwoYjEpICYmIF9fbm9uTnVsbChiMilcbiAgIH1cblxuICAgbmVnYXRlIChiOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gIWJcbiAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJvb2xfOiBCb29sZWFuTGF0dGljZTxBbm5vdGF0aW9uPiA9IG5ldyBCb29sTGF0dGljZSgpXG5leHBvcnQgdHlwZSBBbm5vdGF0aW9uID0gYm9vbGVhbiAvLyBmb3Igbm93XG4iLCJpbXBvcnQgeyBFcSB9IGZyb20gXCIuL0VxXCJcblxuZXhwb3J0IGludGVyZmFjZSBPcmQ8SyBleHRlbmRzIE9yZDxLPj4gZXh0ZW5kcyBFcTxLPiB7XG4gICAvLyBUaGUgYXJndW1lbnQgaXMgYWx3YXlzIG9mIHRoZSB0eXBlIGltcGxlbWVudGluZyBPcmQuXG4gICBsZXEgKGE6IEspOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcTxLIGV4dGVuZHMgT3JkPEs+PihhOiBLLCBiOiBLKTogYm9vbGVhbiB7XG4gICByZXR1cm4gYS5sZXEoYikgJiYgYi5sZXEoYSlcbn1cblxuZXhwb3J0IHR5cGUgQ29tcGFyYXRvcjxUPiA9ICh4OiBULCB5OiBUKSA9PiBudW1iZXJcblxuZXhwb3J0IGludGVyZmFjZSBKb2luU2VtaWxhdHRpY2U8VD4ge1xuICAgam9pbiAoLi4udHM6IFRbXSk6IFRcbiAgIGJvdDogVFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lZXRTZW1pbGF0dGljZTxUPiB7XG4gICBtZWV0ICguLi50czogVFtdKTogVFxuICAgdG9wOiBUXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF0dGljZTxUPiBleHRlbmRzIEpvaW5TZW1pbGF0dGljZTxUPiwgTWVldFNlbWlsYXR0aWNlPFQ+IHtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCb29sZWFuTGF0dGljZTxUPiBleHRlbmRzIExhdHRpY2U8VD4ge1xuICAgbmVnYXRlICh0OiBUKTogVFxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRpZmY8VD4gKHjMhTogU2V0PFQ+LCB5zIU6IFNldDxUPik6IFNldDxUPiB7XG4gICByZXR1cm4gZmlsdGVyKHjMhSwgeCA9PiAhKHnMhS5oYXMoeCkpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlcnk8VD4gKHjMhTogU2V0PFQ+LCBwcmVkOiAoeDogVCkgPT4gYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgcmV0dXJuIEFycmF5LmZyb20oeMyFKS5ldmVyeShwcmVkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQ+ICh4zIU6IFNldDxUPiwgcHJlZDogKHg6IFQpID0+IGJvb2xlYW4pOiBTZXQ8VD4ge1xuICAgcmV0dXJuIG5ldyBTZXQoWy4uLnjMhV0uZmlsdGVyKHByZWQpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+ICh4zIU6IFNldDxUPiwgZjogKHg6IFQpID0+IFUpOiBTZXQ8VT4ge1xuICAgcmV0dXJuIG5ldyBTZXQoWy4uLnjMhV0ubWFwKGYpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc29tZTxUPiAoeMyFOiBTZXQ8VD4sIHByZWQ6ICh4OiBUKSA9PiBib29sZWFuKTogYm9vbGVhbiB7XG4gICByZXR1cm4gQXJyYXkuZnJvbSh4zIUpLnNvbWUocHJlZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPFQ+ICguLi54zIXMhTogU2V0PFQ+W10pOiBTZXQ8VD4ge1xuICAgY29uc3QgecyFOiBTZXQ8VD4gPSBuZXcgU2V0KClcbiAgIHjMhcyFLmZvckVhY2goeMyFID0+IHtcbiAgICAgIHjMhS5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgecyFLmFkZCh4KVxuICAgICAgfSlcbiAgIH0pXG4gICByZXR1cm4gecyFXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb248VD4gKHjMhcyFOiBTZXQ8VD4sIHnMhTogU2V0PFQ+KTogU2V0PFQ+IHtcbiAgIGNvbnN0IHpzOiBTZXQ8VD4gPSBuZXcgU2V0KClcbiAgIHjMhcyFLmZvckVhY2goeCA9PiB7XG4gICAgICBpZiAoecyFLmhhcyh4KSkge1xuICAgICAgICAgenMuYWRkKHgpXG4gICAgICB9XG4gICB9KVxuICAgcmV0dXJuIHpzXG59XG4iXSwic291cmNlUm9vdCI6IiJ9