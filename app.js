(() => {
  // output-es/runtime.js
  function binding(init2) {
    let state = 0;
    let value;
    return () => {
      if (state === 2) {
        return value;
      }
      if (state === 1) {
        throw new Error("Binding demanded before initialized");
      }
      state = 1;
      value = init2();
      state = 2;
      return value;
    };
  }
  function fail() {
    throw new Error("Failed pattern match");
  }

  // node_modules/d3-array/src/ascending.js
  function ascending_default(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector_default(f) {
    let delta = f;
    let compare2 = f;
    if (f.length === 1) {
      delta = (d, x2) => f(d) - x2;
      compare2 = ascendingComparator(f);
    }
    function left2(a, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    }
    function right2(a, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
    function center2(a, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      const i = left2(a, x2, lo, hi - 1);
      return i > lo && delta(a[i - 1], x2) > -delta(a[i], x2) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function ascendingComparator(f) {
    return (d, x2) => ascending_default(f(d), x2);
  }

  // node_modules/d3-array/src/number.js
  function number_default(x2) {
    return x2 === null ? NaN : +x2;
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector_default(ascending_default);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector_default(number_default).center;
  var bisect_default = bisectRight;

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function ticks_default(start2, stop, count) {
    var reverse3, i = -1, n, ticks, step;
    stop = +stop, start2 = +start2, count = +count;
    if (start2 === stop && count > 0)
      return [start2];
    if (reverse3 = stop < start2)
      n = start2, start2 = stop, stop = n;
    if ((step = tickIncrement(start2, stop, count)) === 0 || !isFinite(step))
      return [];
    if (step > 0) {
      let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
      if (r0 * step < start2)
        ++r0;
      if (r1 * step > stop)
        --r1;
      ticks = new Array(n = r1 - r0 + 1);
      while (++i < n)
        ticks[i] = (r0 + i) * step;
    } else {
      step = -step;
      let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
      if (r0 / step < start2)
        ++r0;
      if (r1 / step > stop)
        --r1;
      ticks = new Array(n = r1 - r0 + 1);
      while (++i < n)
        ticks[i] = (r0 + i) / step;
    }
    if (reverse3)
      ticks.reverse();
    return ticks;
  }
  function tickIncrement(start2, stop, count) {
    var step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error3 = step / Math.pow(10, power);
    return power >= 0 ? (error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1);
  }
  function tickStep(start2, stop, count) {
    var step0 = Math.abs(stop - start2) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error3 = step0 / step1;
    if (error3 >= e10)
      step1 *= 10;
    else if (error3 >= e5)
      step1 *= 5;
    else if (error3 >= e2)
      step1 *= 2;
    return stop < start2 ? -step1 : step1;
  }

  // node_modules/d3-array/src/range.js
  function range_default(start2, stop, step) {
    start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n);
    while (++i < n) {
      range3[i] = start2 + i * step;
    }
    return range3;
  }

  // node_modules/d3-axis/src/array.js
  var slice = Array.prototype.slice;

  // node_modules/d3-axis/src/identity.js
  function identity_default(x2) {
    return x2;
  }

  // node_modules/d3-axis/src/axis.js
  var top = 1;
  var right = 2;
  var bottom = 3;
  var left = 4;
  var epsilon = 1e-6;
  function translateX(x2) {
    return "translate(" + x2 + ",0)";
  }
  function translateY(y2) {
    return "translate(0," + y2 + ")";
  }
  function number(scale) {
    return (d) => +scale(d);
  }
  function center(scale, offset) {
    offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
    if (scale.round())
      offset = Math.round(offset);
    return (d) => +scale(d) + offset;
  }
  function entering() {
    return !this.__axis;
  }
  function axis(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
    function axis2(context) {
      var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale.range(), range0 = +range3[0] + offset, range1 = +range3[range3.length - 1] + offset, position2 = (scale.bandwidth ? center : number)(scale.copy(), offset), selection3 = context.selection ? context.selection() : context, path2 = selection3.selectAll(".domain").data([null]), tick = selection3.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text2 = tick.select("text");
      path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
      tick = tick.merge(tickEnter);
      line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k * tickSizeInner));
      text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
      if (context !== selection3) {
        path2 = path2.transition(context);
        tick = tick.transition(context);
        line = line.transition(context);
        text2 = text2.transition(context);
        tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
          return isFinite(d = position2(d)) ? transform2(d + offset) : this.getAttribute("transform");
        });
        tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
          var p = this.parentNode.__axis;
          return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset);
        });
      }
      tickExit.remove();
      path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
      tick.attr("opacity", 1).attr("transform", function(d) {
        return transform2(position2(d) + offset);
      });
      line.attr(x2 + "2", k * tickSizeInner);
      text2.attr(x2, k * spacing).text(format2);
      selection3.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
      selection3.each(function() {
        this.__axis = position2;
      });
    }
    axis2.scale = function(_) {
      return arguments.length ? (scale = _, axis2) : scale;
    };
    axis2.ticks = function() {
      return tickArguments = slice.call(arguments), axis2;
    };
    axis2.tickArguments = function(_) {
      return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis2) : tickArguments.slice();
    };
    axis2.tickValues = function(_) {
      return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis2) : tickValues && tickValues.slice();
    };
    axis2.tickFormat = function(_) {
      return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
    };
    axis2.tickSize = function(_) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
    };
    axis2.tickSizeInner = function(_) {
      return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
    };
    axis2.tickSizeOuter = function(_) {
      return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
    };
    axis2.tickPadding = function(_) {
      return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
    };
    axis2.offset = function(_) {
      return arguments.length ? (offset = +_, axis2) : offset;
    };
    return axis2;
  }
  function axisBottom(scale) {
    return axis(bottom, scale);
  }
  function axisLeft(scale) {
    return axis(left, scale);
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t2; i < n; ++i) {
      if (!(t2 = arguments[i] + "") || t2 in _ || /[\s.]/.test(t2))
        throw new Error("illegal type: " + t2);
      _[t2] = [];
    }
    return new Dispatch(_);
  }
  function Dispatch(_) {
    this._ = _;
  }
  function parseTypenames(typenames, types2) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name3 = "", i = t2.indexOf(".");
      if (i >= 0)
        name3 = t2.slice(i + 1), t2 = t2.slice(0, i);
      if (t2 && !types2.hasOwnProperty(t2))
        throw new Error("unknown type: " + t2);
      return { type: t2, name: name3 };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._, T = parseTypenames(typename + "", _), t2, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t2 = (typename = T[i]).type) && (t2 = get(_[t2], typename.name)))
            return t2;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t2 = (typename = T[i]).type)
          _[t2] = set(_[t2], typename.name, callback);
        else if (callback == null)
          for (t2 in _)
            _[t2] = set(_[t2], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _ = this._;
      for (var t2 in _)
        copy2[t2] = _[t2].slice();
      return new Dispatch(copy2);
    },
    call: function(type2, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t2; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (t2 = this._[type2], i = 0, n = t2.length; i < n; ++i)
        t2[i].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (var t2 = this._[type2], i = 0, n = t2.length; i < n; ++i)
        t2[i].value.apply(that, args);
    }
  };
  function get(type2, name3) {
    for (var i = 0, n = type2.length, c; i < n; ++i) {
      if ((c = type2[i]).name === name3) {
        return c.value;
      }
    }
  }
  function set(type2, name3, callback) {
    for (var i = 0, n = type2.length; i < n; ++i) {
      if (type2[i].name === name3) {
        type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
        break;
      }
    }
    if (callback != null)
      type2.push({ name: name3, value: callback });
    return type2;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name3) {
    var prefix2 = name3 += "", i = prefix2.indexOf(":");
    if (i >= 0 && (prefix2 = name3.slice(0, i)) !== "xmlns")
      name3 = name3.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix2) ? { space: namespaces_default[prefix2], local: name3 } : name3;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name3) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name3) : document2.createElementNS(uri, name3);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name3) {
    var fullname = namespace_default(name3);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array_default(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      var group2 = select.apply(this, arguments);
      return group2 == null ? [] : array_default(group2);
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function")
      select = arrayAll(select);
    else
      select = selectorAll_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          subgroups.push(select.call(node, node.__data__, i, group2));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match5) {
    return function() {
      return find.call(this.children, match5);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match5) {
    return this.select(match5 == null ? childFirst : childFind(typeof match5 === "function" ? match5 : childMatcher(match5)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children() {
    return this.children;
  }
  function childrenFilter(match5) {
    return function() {
      return filter.call(this.children, match5);
    };
  }
  function selectChildren_default(match5) {
    return this.selectAll(match5 == null ? children : childrenFilter(typeof match5 === "function" ? match5 : childMatcher(match5)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match5) {
    if (typeof match5 !== "function")
      match5 = matcher_default(match5);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group2[i]) && match5.call(node, node.__data__, i, group2)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update3) {
    return new Array(update3.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group2, enter, update3, exit, data) {
    var i = 0, node, groupLength = group2.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node = group2[i]) {
        node.__data__ = data[i];
        update3[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group2[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey(parent, group2, enter, update3, exit, data, key) {
    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group2[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group2) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update3[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group2[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
        exit[i] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default(value);
    for (var m = groups.length, update3 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j], group2 = groups[j], groupLength = group2.length, data = array_default(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update3[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update3 = new Selection(update3, parents);
    update3._enter = enter;
    update3._exit = exit;
    return update3;
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update3 = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null)
      update3 = onupdate(update3);
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update3 ? enter.merge(update3).order() : update3;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(selection3) {
    if (!(selection3 instanceof Selection))
      throw new Error("invalid merge");
    for (var groups0 = this._groups, groups1 = selection3._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
      for (var group2 = groups[j], i = group2.length - 1, next = group2[i], node; --i >= 0; ) {
        if (node = group2[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare2) {
    if (!compare2)
      compare2 = ascending;
    function compareNode(a, b) {
      return a && b ? compare2(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group2 = groups[j], i = 0, n = group2.length; i < n; ++i) {
        var node = group2[i];
        if (node)
          return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size3 = 0;
    for (const node of this)
      ++size3;
    return size3;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group2 = groups[j], i = 0, n = group2.length, node; i < n; ++i) {
        if (node = group2[i])
          callback.call(node, node.__data__, i, group2);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name3) {
    return function() {
      this.removeAttribute(name3);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name3, value) {
    return function() {
      this.setAttribute(name3, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name3);
      else
        this.setAttribute(name3, v);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function attr_default(name3, value) {
    var fullname = namespace_default(name3);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name3) {
    return function() {
      this.style.removeProperty(name3);
    };
  }
  function styleConstant(name3, value, priority) {
    return function() {
      this.style.setProperty(name3, value, priority);
    };
  }
  function styleFunction(name3, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name3);
      else
        this.style.setProperty(name3, v, priority);
    };
  }
  function style_default(name3, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name3, value, priority == null ? "" : priority)) : styleValue(this.node(), name3);
  }
  function styleValue(node, name3) {
    return node.style.getPropertyValue(name3) || window_default(node).getComputedStyle(node, null).getPropertyValue(name3);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name3) {
    return function() {
      delete this[name3];
    };
  }
  function propertyConstant(name3, value) {
    return function() {
      this[name3] = value;
    };
  }
  function propertyFunction(name3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name3];
      else
        this[name3] = v;
    };
  }
  function property_default(name3, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name3, value)) : this.node()[name3];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string4) {
    return string4.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name3) {
      var i = this._names.indexOf(name3);
      if (i < 0) {
        this._names.push(name3);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name3) {
      var i = this._names.indexOf(name3);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name3) {
      return this._names.indexOf(name3) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.add(names[i]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name3, value) {
    var names = classArray(name3 + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n)
        if (!list.contains(names[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name3) {
    var create2 = typeof name3 === "function" ? name3 : creator_default(name3);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name3, before) {
    var create2 = typeof name3 === "function" ? name3 : creator_default(name3), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event2) {
      listener.call(this, event2, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name3 = "", i = t2.indexOf(".");
      if (i >= 0)
        name3 = t2.slice(i + 1), t2 = t2.slice(0, i);
      return { type: t2, name: name3 };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i)
        on.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on)
        for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t2;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t2 = typenames[i]).type === o.type && t2.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i)
      this.each(on(typenames[i], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type2, params) {
    var window2 = window_default(node), event2 = window2.CustomEvent;
    if (typeof event2 === "function") {
      event2 = new event2(type2, params);
    } else {
      event2 = window2.document.createEvent("Event");
      if (params)
        event2.initEvent(type2, params.bubbles, params.cancelable), event2.detail = params.detail;
      else
        event2.initEvent(type2, false, false);
    }
    node.dispatchEvent(event2);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group2 = groups[j], i = 0, n = group2.length, node; i < n; ++i) {
        if (node = group2[i])
          yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
  var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
  var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
  var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
  var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
  var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }
  function rgb_formatRgb() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s, l, a) {
    if (a <= 0)
      h = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s = NaN;
    else if (s <= 0)
      h = NaN;
    return new Hsl(h, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s = max4 - min3, l = (max4 + min3) / 2;
    if (s) {
      if (r === max4)
        h = (g - b) / s + (g < b) * 6;
      else if (g === max4)
        h = (b - r) / s + 2;
      else
        h = (r - g) / s + 4;
      s /= l < 0.5 ? max4 + min3 : 2 - max4 - min3;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
    }
  }));
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values2) {
    var n = values2.length - 1;
    return function(t2) {
      var i = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n - 1) : Math.floor(t2 * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
      return basis((t2 - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values2) {
    var n = values2.length;
    return function(t2) {
      var i = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
      return basis((t2 - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default2 = (x2) => () => x2;

  // node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t2) {
      return a + t2 * d;
    };
  }
  function exponential(a, b, y2) {
    return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t2) {
      return Math.pow(a + t2 * b, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y2) : constant_default2(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t2) {
        start2.r = r(t2);
        start2.g = g(t2);
        start2.b = b(t2);
        start2.opacity = opacity(t2);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t2) {
        color2.r = r(t2);
        color2.g = g(t2);
        color2.b = b(t2);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t2) {
      for (i = 0; i < n; ++i)
        c[i] = a[i] * (1 - t2) + b[i] * t2;
      return c;
    };
  }
  function isNumberArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x2[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t2) {
      for (i = 0; i < na; ++i)
        c[i] = x2[i](t2);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = new Date();
    return a = +a, b = +b, function(t2) {
      return d.setTime(a * (1 - t2) + b * t2), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default2(a, b) {
    return a = +a, b = +b, function(t2) {
      return a * (1 - t2) + b * t2;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t2) {
      for (k in i)
        c[k] = i[k](t2);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t2) {
      return b(t2) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default2(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t2) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t2);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t2 = typeof b, c;
    return b == null || t2 === "boolean" ? constant_default2(b) : (t2 === "number" ? number_default2 : t2 === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default2)(a, b);
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a, b) {
    return a = +a, b = +b, function(t2) {
      return Math.round(a * (1 - t2) + b * t2);
    };
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees = 180 / Math.PI;
  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b))
      a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d)
      c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d))
      c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c)
      a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse2, pxComma, pxParen, degParen) {
    function pop2(s) {
      return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180)
          b += 360;
        else if (b - a > 180)
          a += 360;
        q.push({ i: s.push(pop2(s) + "rotate(", null, degParen) - 2, x: number_default2(a, b) });
      } else if (b) {
        s.push(pop2(s) + "rotate(" + b + degParen);
      }
    }
    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({ i: s.push(pop2(s) + "skewX(", null, degParen) - 2, x: number_default2(a, b) });
      } else if (b) {
        s.push(pop2(s) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop2(s) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop2(s) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a, b) {
      var s = [], q = [];
      a = parse2(a), b = parse2(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null;
      return function(t2) {
        var i = -1, n = q.length, o;
        while (++i < n)
          s[(o = q[i]).i] = o.x(t2);
        return s.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time2) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time2;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time2) {
    var t2 = new Timer();
    t2.restart(callback, delay, time2);
    return t2;
  }
  function timerFlush() {
    now();
    ++frame;
    var t2 = taskHead, e;
    while (t2) {
      if ((e = clockNow - t2._time) >= 0)
        t2._call.call(null, e);
      t2 = t2._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now3 = clock.now(), delay = now3 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now3;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time2 = Infinity;
    while (t1) {
      if (t1._call) {
        if (time2 > t1._time)
          time2 = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time2);
  }
  function sleep(time2) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time2 - clockNow;
    if (delay > 24) {
      if (time2 < Infinity)
        timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time2) {
    var t2 = new Timer();
    delay = delay == null ? 0 : +delay;
    t2.restart((elapsed) => {
      t2.stop();
      callback(elapsed + delay);
    }, delay, time2);
    return t2;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name3, id3, index3, group2, timing) {
    var schedules = node.__transition;
    if (!schedules)
      node.__transition = {};
    else if (id3 in schedules)
      return;
    create(node, id3, {
      name: name3,
      index: index3,
      group: group2,
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id3) {
    var schedule = get2(node, id3);
    if (schedule.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node, id3) {
    var schedule = get2(node, id3);
    if (schedule.state > STARTED)
      throw new Error("too late; already running");
    return schedule;
  }
  function get2(node, id3) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id3]))
      throw new Error("transition not found");
    return schedule;
  }
  function create(node, id3, self) {
    var schedules = node.__transition, tween;
    schedules[id3] = self;
    self.timer = timer(schedule, 0, self.time);
    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start2, self.delay, self.time);
      if (self.delay <= elapsed)
        start2(elapsed - self.delay);
    }
    function start2(elapsed) {
      var i, j, n, o;
      if (self.state !== SCHEDULED)
        return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name)
          continue;
        if (o.state === STARTED)
          return timeout_default(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id3) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout_default(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING)
        return;
      self.state = STARTED;
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t2 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node, t2);
      }
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop();
      }
    }
    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id3];
      for (var i in schedules)
        return;
      delete node.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name3) {
    var schedules = node.__transition, schedule, active, empty5 = true, i;
    if (!schedules)
      return;
    name3 = name3 == null ? null : name3 + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name3) {
        empty5 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }
    if (empty5)
      delete node.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name3) {
    return this.each(function() {
      interrupt_default(this, name3);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id3, name3) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id3), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name3) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id3, name3, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule = set2(this, id3), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t2 = { name: name3, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name3) {
            tween1[i] = t2;
            break;
          }
        }
        if (i === n)
          tween1.push(t2);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name3, value) {
    var id3 = this._id;
    name3 += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id3).tween;
      for (var i = 0, n = tween.length, t2; i < n; ++i) {
        if ((t2 = tween[i]).name === name3) {
          return t2.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id3, name3, value));
  }
  function tweenValue(transition2, name3, value) {
    var id3 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id3);
      (schedule.value || (schedule.value = {}))[name3] = value.apply(this, arguments);
    });
    return function(node) {
      return get2(node, id3).value[name3];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a, b) {
    var c;
    return (typeof b === "number" ? number_default2 : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name3) {
    return function() {
      this.removeAttribute(name3);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name3, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name3);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name3, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name3);
      string0 = this.getAttribute(name3);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name3, value) {
    var fullname = namespace_default(name3), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name3, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name3, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name3, i) {
    return function(t2) {
      this.setAttribute(name3, i.call(this, t2));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t2) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t2));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name3, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolate(name3, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name3, value) {
    var key = "attr." + name3;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace_default(name3);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id3, value) {
    return function() {
      init(this, id3).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id3, value) {
    return value = +value, function() {
      init(this, id3).delay = value;
    };
  }
  function delay_default(value) {
    var id3 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id3, value)) : get2(this.node(), id3).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id3, value) {
    return function() {
      set2(this, id3).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id3, value) {
    return value = +value, function() {
      set2(this, id3).duration = value;
    };
  }
  function duration_default(value) {
    var id3 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id3, value)) : get2(this.node(), id3).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id3, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set2(this, id3).ease = value;
    };
  }
  function ease_default(value) {
    var id3 = this._id;
    return arguments.length ? this.each(easeConstant(id3, value)) : get2(this.node(), id3).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function")
        throw new Error();
      set2(this, id3).ease = v;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match5) {
    if (typeof match5 !== "function")
      match5 = matcher_default(match5);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group2[i]) && match5.call(node, node.__data__, i, group2)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name3) {
    return (name3 + "").trim().split(/^|\s+/).every(function(t2) {
      var i = t2.indexOf(".");
      if (i >= 0)
        t2 = t2.slice(0, i);
      return !t2 || t2 === "start";
    });
  }
  function onFunction(id3, name3, listener) {
    var on0, on1, sit = start(name3) ? init : set2;
    return function() {
      var schedule = sit(this, id3), on = schedule.on;
      if (on !== on0)
        (on1 = (on0 = on).copy()).on(name3, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name3, listener) {
    var id3 = this._id;
    return arguments.length < 2 ? get2(this.node(), id3).on.on(name3) : this.each(onFunction(id3, name3, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id3) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition)
        if (+i !== id3)
          return;
      if (parent)
        parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select) {
    var name3 = this._name, id3 = this._id;
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule_default(subgroup[i], name3, id3, i, subgroup, get2(node, id3));
        }
      }
    }
    return new Transition(subgroups, this._parents, name3, id3);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select) {
    var name3 = this._name, id3 = this._id;
    if (typeof select !== "function")
      select = selectorAll_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          for (var children2 = select.call(node, node.__data__, i, group2), child, inherit2 = get2(node, id3), k = 0, l = children2.length; k < l; ++k) {
            if (child = children2[k]) {
              schedule_default(child, name3, id3, k, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name3, id3);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name3, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name3), string1 = (this.style.removeProperty(name3), styleValue(this, name3));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name3) {
    return function() {
      this.style.removeProperty(name3);
    };
  }
  function styleConstant2(name3, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name3);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name3, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name3), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name3), styleValue(this, name3));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id3, name3) {
    var on0, on1, listener0, key = "style." + name3, event2 = "end." + key, remove4;
    return function() {
      var schedule = set2(this, id3), on = schedule.on, listener = schedule.value[key] == null ? remove4 || (remove4 = styleRemove2(name3)) : void 0;
      if (on !== on0 || listener0 !== listener)
        (on1 = (on0 = on).copy()).on(event2, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name3, value, priority) {
    var i = (name3 += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name3, styleNull(name3, i)).on("end.style." + name3, styleRemove2(name3)) : typeof value === "function" ? this.styleTween(name3, styleFunction2(name3, i, tweenValue(this, "style." + name3, value))).each(styleMaybeRemove(this._id, name3)) : this.styleTween(name3, styleConstant2(name3, i, value), priority).on("end.style." + name3, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name3, i, priority) {
    return function(t2) {
      this.style.setProperty(name3, i.call(this, t2), priority);
    };
  }
  function styleTween(name3, value, priority) {
    var t2, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t2 = (i0 = i) && styleInterpolate(name3, i, priority);
      return t2;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name3, value, priority) {
    var key = "style." + (name3 += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name3, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i) {
    return function(t2) {
      this.textContent = i.call(this, t2);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name3 = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          var inherit2 = get2(node, id0);
          schedule_default(node, name3, id1, i, group2, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name3, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id3 = that._id, size3 = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size3 === 0)
          resolve();
      } };
      that.each(function() {
        var schedule = set2(this, id3), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size3 === 0)
        resolve();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents, name3, id3) {
    this._groups = groups;
    this._parents = parents;
    this._name = name3;
    this._id = id3;
  }
  function transition(name3) {
    return selection_default().transition(name3);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/cubic.js
  function cubicInOut(t2) {
    return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
  }

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id3) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id3])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id3} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name3) {
    var id3, timing;
    if (name3 instanceof Transition) {
      id3 = name3._id, name3 = name3._name;
    } else {
      id3 = newId(), (timing = defaultTiming).time = now(), name3 = name3 == null ? null : name3 + "";
    }
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          schedule_default(node, name3, id3, i, group2, timing || inherit(node, id3));
        }
      }
    }
    return new Transition(groups, this._parents, name3, id3);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-brush/src/brush.js
  var { abs, max, min } = Math;
  function number1(e) {
    return [+e[0], +e[1]];
  }
  function number2(e) {
    return [number1(e[0]), number1(e[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x2, e) {
      return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y2, e) {
      return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number2(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  function type(t2) {
    return { type: t2 };
  }

  // node_modules/d3-path/src/path.js
  var pi = Math.PI;
  var tau = 2 * pi;
  var epsilon2 = 1e-6;
  var tauEpsilon = tau - epsilon2;
  function Path() {
    this._x0 = this._y0 = this._x1 = this._y1 = null;
    this._ = "";
  }
  function path() {
    return new Path();
  }
  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x2, y2) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x2, y2) {
      this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    quadraticCurveTo: function(x1, y1, x2, y2) {
      this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
      this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      } else if (!(l01_2 > epsilon2))
        ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      } else {
        var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon2) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }
        this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x2, y2, r, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      } else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
        this._ += "L" + x0 + "," + y0;
      }
      if (!r)
        return;
      if (da < 0)
        da = da % tau + tau;
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      } else if (da > epsilon2) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
      }
    },
    rect: function(x2, y2, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
    },
    toString: function() {
      return this._;
    }
  };
  var path_default = path;

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x2) {
    return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
  }
  function formatDecimalParts(x2, p) {
    if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
      return null;
    var i, coefficient = x2.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x2.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x2) {
    return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t2 = [], j = 0, g = grouping[0], length6 = 0;
      while (i > 0 && g > 0) {
        if (length6 + g + 1 > width)
          g = Math.max(1, width - length6);
        t2.push(value.substring(i -= g, i + g));
        if ((length6 += g + 1) > width)
          break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t2.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match5 = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match5;
    return new FormatSpecifier({
      fill: match5[1],
      align: match5[2],
      sign: match5[3],
      symbol: match5[4],
      zero: match5[5],
      width: match5[6],
      comma: match5[7],
      precision: match5[8] && match5[8].slice(1),
      trim: match5[9],
      type: match5[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s) {
    out:
      for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0)
              i0 = i;
            i1 = i;
            break;
          default:
            if (!+s[i])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d)
      return x2 + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d)
      return x2 + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x2, p) => (x2 * 100).toFixed(p),
    "b": (x2) => Math.round(x2).toString(2),
    "c": (x2) => x2 + "",
    "d": formatDecimal_default,
    "e": (x2, p) => x2.toExponential(p),
    "f": (x2, p) => x2.toFixed(p),
    "g": (x2, p) => x2.toPrecision(p),
    "o": (x2) => Math.round(x2).toString(8),
    "p": (x2, p) => formatRounded_default(x2 * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
    "x": (x2) => Math.round(x2).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default2(x2) {
    return x2;
  }

  // node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan2 = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma2 = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
      if (type2 === "n")
        comma2 = true, type2 = "g";
      else if (!formatTypes_default[type2])
        precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
      if (zero2 || fill === "0" && align === "=")
        zero2 = true, fill = "0", align = "=";
      var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
      var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix2, valueSuffix = suffix, i, n, c;
        if (type2 === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan2 : formatType(Math.abs(value), precision);
          if (trim2)
            value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign2 !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
          valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma2 && !zero2)
          value = group2(value, Infinity);
        var length6 = valuePrefix.length + value.length + valueSuffix.length, padding = length6 < width ? new Array(width - length6 + 1).join(fill) : "";
        if (comma2 && zero2)
          value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length6 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length6);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
      return function(value2) {
        return f(k * value2) + prefix2;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max4) {
    step = Math.abs(step), max4 = Math.abs(max4) - step;
    return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
  }

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range3) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range3).domain(domain);
        break;
    }
    return this;
  }

  // node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index3 = /* @__PURE__ */ new Map(), domain = [], range3 = [], unknown = implicit;
    function scale(d) {
      var key = d + "", i = index3.get(key);
      if (!i) {
        if (unknown !== implicit)
          return unknown;
        index3.set(key, i = domain.push(d));
      }
      return range3[(i - 1) % range3.length];
    }
    scale.domain = function(_) {
      if (!arguments.length)
        return domain.slice();
      domain = [], index3 = /* @__PURE__ */ new Map();
      for (const value of _) {
        const key = value + "";
        if (index3.has(key))
          continue;
        index3.set(key, domain.push(value));
      }
      return scale;
    };
    scale.range = function(_) {
      return arguments.length ? (range3 = Array.from(_), scale) : range3.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range3).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }

  // node_modules/d3-scale/src/band.js
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
      step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round2)
        step = Math.floor(step);
      start2 += (stop - start2 - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round2)
        start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values2 = range_default(n).map(function(i) {
        return start2 + step * i;
      });
      return ordinalRange(reverse3 ? values2.reverse() : values2);
    }
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_) {
      return arguments.length ? (round2 = !!_, rescale()) : round2;
    };
    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }

  // node_modules/d3-scale/src/constant.js
  function constants(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number3(x2) {
    return +x2;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity2(x2) {
    return x2;
  }
  function normalize(a, b) {
    return (b -= a = +a) ? function(x2) {
      return (x2 - a) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a, b) {
    var t2;
    if (a > b)
      t2 = a, a = b, b = t2;
    return function(x2) {
      return Math.max(a, Math.min(b, x2));
    };
  }
  function bimap(domain, range3, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
    if (d1 < d0)
      d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else
      d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x2) {
      return r0(d0(x2));
    };
  }
  function polymap(domain, range3, interpolate) {
    var j = Math.min(domain.length, range3.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range3 = range3.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r[i] = interpolate(range3[i], range3[i + 1]);
    }
    return function(x2) {
      var i2 = bisect_default(domain, x2, 1, j) - 1;
      return r[i2](d[i2](x2));
    };
  }
  function copy(source2, target) {
    return target.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
  }
  function transformer() {
    var domain = unit, range3 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity2, piecewise, output, input;
    function rescale() {
      var n = Math.min(domain.length, range3.length);
      if (clamp !== identity2)
        clamp = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform2), range3, interpolate)))(transform2(clamp(x2)));
    }
    scale.invert = function(y2) {
      return clamp(untransform((input || (input = piecewise(range3, domain.map(transform2), number_default2)))(y2)));
    };
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
    };
    scale.rangeRound = function(_) {
      return range3 = Array.from(_), interpolate = round_default, rescale();
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp = _ ? true : identity2, rescale()) : clamp !== identity2;
    };
    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t2, u) {
      transform2 = t2, untransform = u;
      return rescale();
    };
  }
  function continuous() {
    return transformer()(identity2, identity2);
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start2, stop, count, specifier) {
    var step = tickStep(start2, stop, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
          specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
          specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
          specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
      var d = domain();
      return ticks_default(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
      if (count == null)
        count = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start2 = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start2) {
        step = start2, start2 = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop, count);
        if (step === prestep) {
          d[i0] = start2;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear2() {
    var scale = continuous();
    scale.copy = function() {
      return copy(scale, linear2());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }

  // node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while (i < n)
      colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  // node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
  var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  // node_modules/d3-shape/src/constant.js
  function constant_default4(x2) {
    return function constant() {
      return x2;
    };
  }

  // node_modules/d3-shape/src/array.js
  var slice2 = Array.prototype.slice;
  function array_default2(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }

  // node_modules/d3-shape/src/curve/linear.js
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(x2, y2);
          break;
      }
    }
  };
  function linear_default(context) {
    return new Linear(context);
  }

  // node_modules/d3-shape/src/point.js
  function x(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }

  // node_modules/d3-shape/src/line.js
  function line_default(x2, y2) {
    var defined = constant_default4(true), context = null, curve = linear_default, output = null;
    x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default4(x2);
    y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default4(y2);
    function line(data) {
      var i, n = (data = array_default2(data)).length, d, defined0 = false, buffer;
      if (context == null)
        output = curve(buffer = path_default());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0)
            output.lineStart();
          else
            output.lineEnd();
        }
        if (defined0)
          output.point(+x2(d, i, data), +y2(d, i, data));
      }
      if (buffer)
        return output = null, buffer + "" || null;
    }
    line.x = function(_) {
      return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default4(+_), line) : x2;
    };
    line.y = function(_) {
      return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default4(+_), line) : y2;
    };
    line.defined = function(_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default4(!!_), line) : defined;
    };
    line.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };
    line.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };
    return line;
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k, x2, y2) {
    this.k = k;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point2) {
      return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity3 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom)
      if (!(node = node.parentNode))
        return identity3;
    return node.__zoom;
  }

  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text2) {
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text2.length)
        text2.decompose(0, text2.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text2.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start2 = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start2, pos = start2; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start2 = this.line(from).from;
        inner = this.iterRange(start2, Math.max(start2, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text2) {
      if (text2.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text2.length == 1 && !text2[0])
        return Text.empty;
      return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text2, length6 = textLength(text2)) {
      super();
      this.text = text2;
      this.length = length6;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let string4 = this.text[i], end = offset + string4.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string4);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text2 = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text2.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text2);
      }
    }
    replace(from, to, text2) {
      if (!(text2 instanceof TextLeaf))
        return super.replace(from, to, text2);
      let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text2.length - (to - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        let line = this.text[i], end = pos + line.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text2, target) {
      let part = [], len = -1;
      for (let line of text2) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children2, length6) {
      super();
      this.children = children2;
      this.length = length6;
      this.lines = 0;
      for (let child of children2)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text2) {
      if (text2.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text2);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy2 = this.children.slice();
              copy2[i] = updated;
              return new TextNode(copy2, this.length - (to - from) + text2.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text2);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length6 = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length6;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length6 + chA.scanIdentical(chB, dir);
        length6 += chA.length + 1;
      }
    }
    static from(children2, length6 = children2.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children2)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children2)
          ch.flatten(flat);
        return new TextLeaf(flat, length6);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add(child) {
        let last2;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children2)
        add(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length6);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text2) {
    let length6 = -1;
    for (let line of text2)
      length6 += line.length + 1;
    return length6;
  }
  function appendText(text2, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text2.length && pos <= to; i++) {
      let line = text2[i], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text2, from, to) {
    return appendText(text2, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text2, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text2];
      this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last2 = this.nodes.length - 1;
        let top3 = this.nodes[last2], offsetValue = this.offsets[last2], offset = offsetValue >> 1;
        let size3 = top3 instanceof TextLeaf ? top3.text.length : top3.children.length;
        if (offset == (dir > 0 ? size3 : 0)) {
          if (last2 == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last2 - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last2] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top3 instanceof TextLeaf) {
          let next = top3.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last2] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top3.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last2] += dir;
          } else {
            if (dir < 0)
              this.offsets[last2]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text2, start2, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text2, start2 > end ? -1 : 1);
      this.pos = start2 > end ? text2.length : 0;
      this.from = Math.min(start2, end);
      this.to = Math.max(start2, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to, number6, text2) {
      this.from = from;
      this.to = to;
      this.number = number6;
      this.text = text2;
    }
    get length() {
      return this.to - this.from;
    }
  };
  var extend2 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend2.length; i++)
    extend2[i] += extend2[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend2.length; i += 2)
      if (extend2[i] > code)
        return extend2[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          let index3 = i >> 1;
          while (inserted.length < index3)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins = this.sections[i + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length6, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force2 = false) {
        if (!force2 && !sections.length)
          return;
        if (pos < length6)
          addSection(sections, length6 - pos, -1);
        let set4 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set4.map(total)) : set4;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length6)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length6})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert4 } = spec;
          if (from > to || from < 0 || to > length6)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length6})`);
          let insText = !insert4 ? Text.empty : typeof insert4 == "string" ? Text.of(insert4.split(lineSep || DefaultSplit)) : insert4;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process(changes);
      flush(!total);
      return total;
    }
    static empty(length6) {
      return new ChangeSet(length6 ? [length6, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json.length; i++) {
        let part = json[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last2 = sections.length - 2;
    if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
      sections[last2] += len;
    else if (len == 0 && sections[last2] == 0)
      sections[last2 + 1] += ins;
    else if (forceJoin) {
      sections[last2] += len;
      sections[last2 + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values2, sections, value) {
    if (value.length == 0)
      return;
    let index3 = sections.length - 2 >> 1;
    if (index3 < values2.length) {
      values2[values2.length - 1] = values2[values2.length - 1].append(value);
    } else {
      while (values2.length < index3)
        values2.push(Text.empty);
      values2.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text2 = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text2 = text2.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text2);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert4 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        let len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a.len, len);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert4)
              addInsert(insert4, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, left2 = a.len;
        while (left2) {
          if (b.ins == -1) {
            let piece = Math.min(left2, b.len);
            len += piece;
            left2 -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left2) {
            left2 -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a.i ? a.ins : 0);
        if (insert4 && inserted < a.i)
          addInsert(insert4, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left2);
      } else if (a.done && b.done) {
        return insert4 ? ChangeSet.createSet(sections, insert4) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert4 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert4 ? ChangeSet.createSet(sections, insert4) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert4)
          addInsert(insert4, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert4 && insB)
            addInsert(insert4, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert4)
            addInsert(insert4, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert4 && !b.off)
            addInsert(insert4, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set4) {
      this.set = set4;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index3 = this.i - 2 >> 1;
      return index3 >= inserted.length ? Text.empty : inserted[index3];
    }
    textBit(len) {
      let { inserted } = this.set, index3 = this.i - 2 >> 1;
      return index3 >= inserted.length && !len ? Text.empty : inserted[index3].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range3, main2 = true) {
      return EditorSelection.create([range3].concat(this.ranges), main2 ? 0 : this.mainIndex + 1);
    }
    replaceRange(range3, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range3;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range3 = ranges[i];
        if (range3.empty ? range3.from <= pos : range3.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range3.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5 | (bidiLevel == null ? 3 : Math.min(2, bidiLevel));
      return head < anchor ? SelectionRange.create(head, anchor, 16 | 8 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 4 : 0) | flags);
    }
    static normalized(ranges, mainIndex = 0) {
      let main2 = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main2);
      for (let i = 1; i < ranges.length; i++) {
        let range3 = ranges[i], prev = ranges[i - 1];
        if (range3.empty ? range3.from <= prev.to : range3.from < prev.to) {
          let from = prev.from, to = Math.max(range3.to, prev.to);
          if (i <= mainIndex)
            mainIndex--;
          ranges.splice(--i, 2, range3.anchor > range3.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection3, docLength) {
    for (let range3 of selection3.ranges)
      if (range3.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    static define(config = {}) {
      return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get3);
    }
    computeN(deps, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get3);
    }
    from(field2, get3) {
      if (!get3)
        get3 = (x2) => x2;
      return this.compute([field2], (state) => get3(state.field(field2)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type2, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type2;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id3 = this.id, idx = addresses[id3] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id3];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compare2(a[i], b[i]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get3(state) {
      let values2 = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values2.push(val);
        else
          values2.push(value);
      }
      return facet.combine(values2);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get3(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get3(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get3(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id3, createF, updateF, compareF, spec) {
      this.id = id3;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config) {
      let field2 = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
      if (config.provide)
        field2.provides = config.provide(field2);
      return field2;
    }
    create(state) {
      let init2 = state.facet(initField).find((i) => i.field == this);
      return ((init2 === null || init2 === void 0 ? void 0 : init2.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create2) {
      return [this, initField.of({ field: this, create: create2 })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field2 of fields) {
        address[field2.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field2.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id3 in facets) {
        let providers = facets[id3], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id3] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : false
  });
  var Annotation = class {
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map6) {
      this.map = map6;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type2) {
      return this.type == type2;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState2, changes, selection3, effects, annotations, scrollIntoView2) {
      this.startState = startState2;
      this.changes = changes;
      this.selection = selection3;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView2;
      this._doc = null;
      this._state = null;
      if (selection3)
        checkSelection(selection3, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState2, changes, selection3, effects, annotations, scrollIntoView2) {
      return new Transaction(startState2, changes, selection3, effects, annotations, scrollIntoView2);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type2) {
      for (let ann of this.annotations)
        if (ann.type == type2)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event2) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event2 || e.length > event2.length && e.slice(0, event2.length) == event2 && e[event2.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter5) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter5 = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter5 = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter5 ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter5 of state.facet(changeFilter)) {
      let value = filter5(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none2 = [];
  function asArray(value) {
    return value == null ? none2 : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch = str[i];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char2) => {
      if (!/\S/.test(char2))
        return CharCategory.Space;
      if (hasWordChar(char2))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char2.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config, doc2, selection3, values2, computeSlot, tr) {
      this.config = config;
      this.doc = doc2;
      this.selection = selection3;
      this.values = values2;
      this.status = config.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
    field(field2, require2 = true) {
      let addr = this.config.address[field2.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text2) {
      if (typeof text2 == "string")
        text2 = this.toText(text2);
      return this.changeByRange((range3) => ({
        changes: { from: range3.from, to: range3.to, insert: text2 },
        range: EditorSelection.cursor(range3.from + text2.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string4) {
      return Text.of(string4.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json, prop)) {
            let field2 = fields[prop], value = json[prop];
            fieldInit.push(field2.init((state) => field2.spec.fromJSON(value, state)));
          }
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
      });
    }
    static create(config = {}) {
      let configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection3 = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
      checkSelection(selection3, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection3 = selection3.asSingle();
      return new EditorState(configuration, doc2, selection3, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase, ...insert4) {
      for (let map6 of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map6, phrase)) {
          phrase = map6[phrase];
          break;
        }
      if (insert4.length)
        phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
          if (i == "$")
            return "$";
          let n = +(i || 1);
          return !n || n > insert4.length ? m : insert4[n - 1];
        });
      return phrase;
    }
    languageDataAt(name3, pos, side = -1) {
      let values2 = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name3))
            values2.push(result[name3]);
        }
      }
      return values2;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text: text2, from, length: length6 } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start2 = pos - from, end = pos - from;
      while (start2 > 0) {
        let prev = findClusterBreak(text2, start2, false);
        if (cat(text2.slice(prev, start2)) != CharCategory.Word)
          break;
        start2 = prev;
      }
      while (end < length6) {
        let next = findClusterBreak(text2, end);
        if (cat(text2.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start2 == end ? null : EditorSelection.range(start2 + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return Range.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    static create(from, to, value) {
      return new Range(from, to, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last2 = this.chunk.length - 1;
      return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size3 = this.nextLayer.size;
      for (let chunk of this.chunk)
        size3 += chunk.value.length;
      return size3;
    }
    chunkEnd(index3) {
      return this.chunkPos[index3] + this.chunk[index3].length;
    }
    update(updateSpec) {
      let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter5 = updateSpec.filter;
      if (add.length == 0 && !filter5)
        return this;
      if (sort)
        add = add.slice().sort(cmpRange);
      if (this.isEmpty)
        return add.length ? RangeSet.of(add) : this;
      let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur.value || i < add.length) {
        if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
          let range3 = add[i++];
          if (!builder.addInner(range3.from, range3.to, range3.value))
            spill.push(range3);
        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter5 || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
          cur.nextChunk();
        } else {
          if (!filter5 || filterFrom > cur.to || filterTo < cur.from || filter5(cur.from, cur.to, cur.value)) {
            if (!builder.addInner(cur.from, cur.to, cur.value))
              spill.push(Range.create(cur.from, cur.to, cur.value));
          }
          cur.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter5, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start2, start2 + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start2));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start2, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        if (to >= start2 && from <= start2 + chunk.length && chunk.between(start2, from - start2, to - start2, f) === false)
          return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set4) => set4.maxPoint > 0 || !set4.isEmpty && set4.maxPoint >= minPointSize);
      let b = newSets.filter((set4) => set4.maxPoint > 0 || !set4.isEmpty && set4.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length6) => compare(sideA, fromA, sideB, fromB, length6, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a = oldSets.filter((set4) => !set4.isEmpty && newSets.indexOf(set4) < 0);
      let b = newSets.filter((set4) => !set4.isEmpty && oldSets.indexOf(set4) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let openRanges = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          let active = cursor.activeForPoint(cursor.to);
          let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range3 of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range3.from, range3.to, range3.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur = ranges[i];
        if (cmpRange(prev, cur) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last2 = chunk.value.length - 1;
      this.last = chunk.value[last2];
      this.lastFrom = chunk.from[last2] + from;
      this.lastTo = chunk.to[last2] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set4 of a)
      for (let i = 0; i < set4.chunk.length; i++)
        if (set4.chunk[i].maxPoint <= 0)
          inA.set(set4.chunk[i], set4.chunkPos[i]);
    let shared = /* @__PURE__ */ new Set();
    for (let set4 of b)
      for (let i = 0; i < set4.chunk.length; i++) {
        let known = inA.get(set4.chunk[i]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set4.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set4.chunk[i].length)))
          shared.add(set4.chunk[i]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index3) {
      if (index3 == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index3;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
          if (cur.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur, skip, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur of this.heap)
        cur.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur of this.heap)
        cur.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top3 = this.heap[0];
        this.from = top3.from;
        this.to = top3.to;
        this.value = top3.value;
        this.rank = top3.rank;
        if (top3.value)
          top3.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index3) {
    for (let cur = heap[index3]; ; ) {
      let childIndex = (index3 << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0)
        break;
      heap[childIndex] = cur;
      heap[index3] = child;
      index3 = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index3) {
      remove2(this.active, index3);
      remove2(this.activeTo, index3);
      remove2(this.activeRank, index3);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, { value, to, rank } = this.cursor;
      while (i < this.activeRank.length && this.activeRank[i] <= rank)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove2(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
          this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length6, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length6;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (a[i] != b[i] && !a[i].eq(b[i]))
        return false;
    return true;
  }
  function remove2(array, index3) {
    for (let i = index3, e = array.length - 1; i < e; i++)
      array[i] = array[i + 1];
    array.pop();
  }
  function insert(array, index3, value) {
    for (let i = array.length - 1; i >= index3; i--)
      array[i + 1] = array[i];
    array[index3] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array.length; i++)
      if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array[i];
      }
    return found;
  }
  function countColumn(string4, tabSize, to = string4.length) {
    let n = 0;
    for (let i = 0; i < to; ) {
      if (string4.charCodeAt(i) == 9) {
        n += tabSize - n % tabSize;
        i++;
      } else {
        n++;
        i = findClusterBreak(string4, i);
      }
    }
    return n;
  }
  function findColumn(string4, col, tabSize, strict) {
    for (let i = 0, n = 0; ; ) {
      if (n >= col)
        return i;
      if (i == string4.length)
        break;
      n += string4.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
      i = findClusterBreak(string4, i);
    }
    return strict === true ? -1 : string4.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id3 = top2[COUNT] || 1;
      top2[COUNT] = id3 + 1;
      return C + id3.toString(36);
    }
    static mount(root3, modules) {
      (root3[SET] || new StyleSet(root3)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root3) {
      if (!root3.head && root3.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root3.adoptedStyleSheets = [adoptedSet.sheet, ...root3.adoptedStyleSheets];
          return root3[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root3.adoptedStyleSheets = [this.sheet, ...root3.adoptedStyleSheets];
        adoptedSet = this;
      } else {
        this.styleTag = (root3.ownerDocument || root3).createElement("style");
        let target = root3.head || root3;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root3[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index3 = this.modules.indexOf(mod);
        if (index3 < j && index3 > -1) {
          this.modules.splice(index3, 1);
          j--;
          index3 = -1;
        }
        if (index3 == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index3)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text2 = "";
        for (let i = 0; i < this.modules.length; i++)
          text2 += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text2;
      }
    }
  };

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || chrome && +chrome[1] < 57;
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  var code;
  function keyName(event2) {
    var ignoreKey = brokenModifierNames && (event2.ctrlKey || event2.altKey || event2.metaKey) || ie && event2.shiftKey && event2.key && event2.key.length == 1 || event2.key == "Unidentified";
    var name3 = !ignoreKey && event2.key || (event2.shiftKey ? shift : base)[event2.keyCode] || event2.key || "Unidentified";
    if (name3 == "Esc")
      name3 = "Escape";
    if (name3 == "Del")
      name3 = "Delete";
    if (name3 == "Left")
      name3 = "ArrowLeft";
    if (name3 == "Up")
      name3 = "ArrowUp";
    if (name3 == "Right")
      name3 = "ArrowRight";
    if (name3 == "Down")
      name3 = "ArrowDown";
    return name3;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root3) {
    let target;
    if (root3.nodeType == 11) {
      target = root3.getSelection ? root3 : root3.ownerDocument;
    } else {
      target = root3;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection3) {
    if (!selection3.anchorNode)
      return false;
    try {
      return contains(dom, selection3.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index3 = 0; ; index3++) {
      node = node.previousSibling;
      if (!node)
        return index3;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
  function flattenRect(rect, left2) {
    let x2 = left2 ? rect.left : rect.right;
    return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom, rect, side, x2, y2, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur = dom; cur; ) {
      if (cur.nodeType == 1) {
        let bounding, top3 = cur == doc2.body;
        if (top3) {
          bounding = windowRect(win);
        } else {
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.assignedSlot || cur.parentNode;
            continue;
          }
          let rect2 = cur.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (y2 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x2 == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top3) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start2 = cur.scrollTop;
              cur.scrollTop += moveY;
              movedY = cur.scrollTop - start2;
            }
            if (moveX) {
              let start2 = cur.scrollLeft;
              cur.scrollLeft += moveX;
              movedX = cur.scrollLeft - start2;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x2 = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y2 = "nearest";
          }
        }
        if (top3)
          break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  function scrollableParent(dom) {
    let doc2 = dom.ownerDocument;
    for (let cur = dom.parentNode; cur; ) {
      if (cur == doc2.body) {
        break;
      } else if (cur.nodeType == 1) {
        if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
          return cur;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
    return null;
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range3) {
      this.set(range3.anchorNode, range3.anchorOffset, range3.focusNode, range3.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt = stack[i++], top3 = stack[i++], left2 = stack[i++];
        if (elt.scrollTop != top3)
          elt.scrollTop = top3;
        if (elt.scrollLeft != left2)
          elt.scrollLeft = left2;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range3 = scratchRange || (scratchRange = document.createRange());
    range3.setEnd(node, to);
    range3.setStart(node, from);
    return range3;
  }
  function dispatchKey(elt, name3, code) {
    let options = { key: name3, code: name3, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection3) {
    let node = selection3.focusNode, offset = selection3.focusOffset;
    if (!node || selection3.anchorNode != node || selection3.anchorOffset != offset)
      return false;
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view2) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view2)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view2) {
      return this.posBefore(view2) + view2.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(view2, track) {
      if (this.dirty & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.dirty) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(view2, track);
            child.dirty = 0;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(view2, track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children2 = noChildren) {
      this.markDirty();
      for (let i = from; i < to; i++) {
        let child = this.children[i];
        if (child.parent == this)
          child.destroy();
      }
      this.children.splice(from, to - from, ...children2);
      for (let i = 0; i < children2.length; i++)
        children2[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name3 = this.constructor.name.replace("View", "");
      return name3 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name3 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children2, pos, i) {
      this.children = children2;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert4, breakAtStart, openStart, openEnd) {
    let { children: children2 } = parent;
    let before = children2.length ? children2[fromI] : null;
    let last2 = insert4.length ? insert4[insert4.length - 1] : null;
    let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert4.length < 2 && before.merge(fromOff, toOff, insert4.length ? last2 : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children2.length) {
      let after = children2[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
          insert4[insert4.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert4.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last2)
          last2.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert4.length && before.merge(fromOff, before.length, insert4[0], false, openStart, 0)) {
          before.breakAfter = insert4.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert4.length) {
      if (children2[toI - 1].become(insert4[insert4.length - 1])) {
        toI--;
        insert4.pop();
        openEnd = insert4.length ? 0 : openStart;
      } else if (children2[fromI].become(insert4[0])) {
        fromI++;
        insert4.shift();
        openStart = insert4.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert4.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert4.length)
      parent.replaceChildren(fromI, toI, insert4);
  }
  function mergeChildrenInto(parent, from, to, insert4, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view2 of insert4)
      dLen += view2.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert4, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text2) {
      super();
      this.text = text2;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view2, track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from, to, source2) {
      if (source2 && (!(source2 instanceof TextView) || this.length - (to - from) + source2.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from) + (source2 ? source2.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children2 = [], length6 = 0) {
      super();
      this.mark = mark;
      this.children = children2;
      this.length = length6;
      for (let ch of children2)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name3 in this.mark.attrs)
          dom.setAttribute(name3, this.mark.attrs[name3]);
      return dom;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(view2, track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4)
        this.setAttrs(this.dom);
      super.sync(view2, track);
    }
    merge(from, to, source2, _hasStart, openStart, openEnd) {
      if (source2 && (!(source2 instanceof MarkView && source2.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source2 ? source2.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i;
        off = end;
        i++;
      }
      let length6 = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length6);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text2, pos, side) {
    let length6 = text2.nodeValue.length;
    if (pos > length6)
      pos = length6;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length6 && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length6) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length6)
        to++;
    }
    let rects = textRange(text2, from, to).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    constructor(widget, length6, side) {
      super();
      this.widget = widget;
      this.length = length6;
      this.side = side;
      this.prevWidget = null;
    }
    static create(widget, length6, side) {
      return new (widget.customView || WidgetView)(widget, length6, side);
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync(view2) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view2)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view2));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      if (source2 && (!(source2 instanceof WidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source2 ? source2.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event2) {
      return this.widget.ignoreEvent(event2);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top3 = this;
      while (top3.parent)
        top3 = top3.parent;
      let { view: view2 } = top3, text2 = view2 && view2.state.doc, start2 = this.posAtStart;
      return text2 ? text2.slice(start2, start2 + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return this.length ? rect : flattenRect(rect, this.side > 0);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      let { topView, text: text2 } = this.widget;
      if (!topView)
        return new DOMPos(text2, Math.min(pos, text2.nodeValue.length));
      return scanCompositionTree(pos, 0, topView, text2, (v, p) => v.domAtPos(p), (p) => new DOMPos(text2, Math.min(p, text2.nodeValue.length)));
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      let { topView, text: text2 } = this.widget;
      if (!topView)
        return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text2);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      let { topView, text: text2 } = this.widget;
      if (!topView)
        return textCoords(text2, pos, side);
      return scanCompositionTree(pos, side, topView, text2, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text2, pos2, side2));
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
    canReuseDOM() {
      return true;
    }
  };
  function scanCompositionTree(pos, side, view2, text2, enterView, fromText) {
    if (view2 instanceof MarkView) {
      for (let child = view2.dom.firstChild; child; child = child.nextSibling) {
        let desc = ContentView.get(child);
        if (!desc)
          return fromText(pos, side);
        let hasComp = contains(child, text2);
        let len = desc.length + (hasComp ? text2.nodeValue.length : 0);
        if (pos < len || pos == len && desc.getSide() <= 0)
          return hasComp ? scanCompositionTree(pos, side, desc, text2, enterView, fromText) : enterView(desc, pos, side);
        pos -= len;
      }
      return enterView(view2, view2.length, -1);
    } else if (view2.dom == text2) {
      return fromText(pos, side);
    } else {
      return enterView(view2, pos, side);
    }
  }
  function posFromDOMInCompositionTree(node, offset, view2, text2) {
    if (view2 instanceof MarkView) {
      let pos = 0;
      for (let child of view2.children) {
        let hasComp = contains(child.dom, text2);
        if (contains(child.dom, node))
          return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text2) : child.localPosFromDOM(node, offset));
        pos += hasComp ? text2.nodeValue.length : child.length;
      }
    } else if (view2.dom == text2) {
      return Math.min(offset, text2.nodeValue.length);
    }
    return view2.localPosFromDOM(node, offset);
  }
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      let imgRect = this.dom.getBoundingClientRect();
      let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view2, side) {
    let parent = view2.parent, index3 = parent ? parent.children.indexOf(view2) : -1;
    while (parent && index3 >= 0) {
      if (side < 0 ? index3 > 0 : index3 < parent.children.length) {
        let next = parent.children[index3 + side];
        if (next instanceof TextView) {
          let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect)
            return nextRect;
        }
        index3 += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index3 = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        let last2 = parent.dom.lastChild;
        if (last2 && last2.nodeName == "BR")
          return last2.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children: children2 } = parent, i = 0;
    for (let off = 0; i < children2.length; i++) {
      let child = children2[i], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j = i; j > 0; j--) {
      let prev = children2[j - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children2.length; j++) {
      let next = children2[j];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view2, open) {
    let last2, { children: children2 } = parent;
    if (open > 0 && view2 instanceof MarkView && children2.length && (last2 = children2[children2.length - 1]) instanceof MarkView && last2.mark.eq(view2.mark)) {
      joinInlineInto(last2, view2.children[0], open - 1);
    } else {
      children2.push(view2);
      view2.setParent(parent);
    }
    parent.length += view2.length;
  }
  function coordsInChildren(view2, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view3, pos2) {
      for (let i = 0, off = 0; i < view3.children.length && off <= pos2; i++) {
        let child = view3.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if (!after && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view2, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view2);
  }
  function fallbackRect(view2) {
    let last2 = view2.dom.lastChild;
    if (!last2)
      return view2.dom.getBoundingClientRect();
    let rects = clientRectsFor(last2);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source2, target) {
    for (let name3 in source2) {
      if (name3 == "class" && target.class)
        target.class += " " + source2.class;
      else if (name3 == "style" && target.style)
        target.style += ";" + source2.style;
      else
        target[name3] = source2[name3];
    }
    return target;
  }
  function attrsEq(a, b) {
    if (a == b)
      return true;
    if (!a || !b)
      return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
      return false;
    for (let key of keysA) {
      if (keysB.indexOf(key) == -1 || a[key] !== b[key])
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = null;
    if (prev) {
      for (let name3 in prev)
        if (!(attrs && name3 in attrs))
          dom.removeAttribute(changed = name3);
    }
    if (attrs) {
      for (let name3 in attrs)
        if (!(prev && prev[name3] == attrs[name3]))
          dom.setAttribute(changed = name3, attrs[name3]);
    }
    return !!changed;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom, view2) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event2) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0, block = !!spec.block;
      side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start: start2, end } = getInclusive(spec, block);
        startSide = (start2 ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start: start2, end } = getInclusive(spec);
      super(start2 ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start2, inclusiveEnd: end } = spec;
    if (start2 == null)
      start2 = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start2 !== null && start2 !== void 0 ? start2 : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last2 = ranges.length - 1;
    if (last2 >= 0 && ranges[last2] + margin >= from)
      ranges[last2] = Math.max(ranges[last2], to);
    else
      ranges.push(from, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      if (source2) {
        if (!(source2 instanceof LineView))
          return false;
        if (!this.dom)
          source2.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source2 ? source2.attrs : null);
      mergeChildrenInto(this, from, to, source2 ? source2.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i].split(off), 0);
        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (let j = i; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0)
        this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(view2, track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view2, track);
      let last2 = this.dom.lastChild;
      while (last2 && ContentView.get(last2) instanceof MarkView)
        last2 = last2.lastChild;
      if (!last2 || !this.length || last2.nodeName != "BR" && ((_a2 = ContentView.get(last2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
        if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
          let dist = (height - heightOracle.textHeight) / 2;
          return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
        }
      }
      return rect;
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i = 0, off = 0; i < docView.children.length; i++) {
        let block = docView.children[i], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length6, type2) {
      super();
      this.widget = widget;
      this.length = length6;
      this.type = type2;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source2, _takeDeco, openStart, openEnd) {
      if (source2 && (!(source2 instanceof BlockWidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source2 ? source2.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view2) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view2)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view2));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event2) {
      return this.widget.ignoreEvent(event2);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last2 = this.content[this.content.length - 1];
      return !last2.breakAfter && !(last2 instanceof BlockWidgetView && last2.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view2) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view2);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
        this.flushBuffer();
      else
        this.pendingBuffer = 0;
      if (!this.posCovered())
        this.getLine();
    }
    buildText(length6, active, openStart) {
      while (length6 > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length6--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take4 = Math.min(this.text.length - this.textOff, length6, 512);
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take4)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take4;
        length6 -= take4;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index3) {
      if (this.disallowBlockEffectsFor[index3] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let { type: type2 } = deco;
          if (type2 == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type2));
        } else {
          let view2 = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view2.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view2.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view2, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer)
            this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text2, from, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text2, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view2, active) {
    for (let mark of active)
      view2 = new MarkView(mark, [view2], view2.length);
    return view2;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var focusChangeEffect = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x2) => x2)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x2) => x2)
  });
  var ScrollTarget = class {
    constructor(range3, y2 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5) {
      this.range = range3;
      this.y = y2;
      this.x = x2;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id3, create2, domEventHandlers, buildExtensions) {
      this.id = id3;
      this.create = create2;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
    static define(create2, spec) {
      const { eventHandlers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create2, eventHandlers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view2) => {
            let pluginInst = view2.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view2) => new cls(view2), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view2) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view2);
          } catch (e) {
            logException(view2.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update3 = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update3);
          } catch (e) {
            logException(update3.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view2) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view2.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set4) {
      let i = set4.length, me = this;
      for (; i > 0; i--) {
        let range3 = set4[i - 1];
        if (range3.fromA > me.toA)
          continue;
        if (range3.toA < me.fromA)
          break;
        me = me.join(range3);
        set4.splice(i - 1, 1);
      }
      set4.splice(i, 0, me);
      return set4;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view2, state, transactions) {
      this.view = view2;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view2.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    static create(view2, state, transactions) {
      return new ViewUpdate(view2, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index3, level, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span2 = order[i];
        if (span2.from <= index3 && span2.to >= index3) {
          if (span2.level == level)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span2.from < index3 : span2.to > index3 : order[maybe].level > span2.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type2 = charType(line.charCodeAt(i));
      if (type2 == 512)
        type2 = prev;
      else if (type2 == 8 && prevStrong == 4)
        type2 = 16;
      types[i] = type2 == 4 ? 2 : type2;
      if (type2 & 7)
        prevStrong = type2;
      prev = type2;
    }
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type2 = types[i];
      if (type2 == 128) {
        if (i < len - 1 && prev == types[i + 1] && prev & 24)
          type2 = types[i] = prev;
        else
          types[i] = 256;
      } else if (type2 == 64) {
        let end = i + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace3 = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace3;
        i = end - 1;
      } else if (type2 == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type2;
      if (type2 & 7)
        prevStrong = type2;
    }
    for (let i = 0, sI = 0, context = 0, ch, br, type2; i < len; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type3 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type3)
                types[i] = types[BracketStack[sJ]] = type3;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type2 = types[i]) == 2 || type2 == 1) {
        let embed = type2 == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur = BracketStack[sJ + 2];
          if (cur & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i = 0; i < len; i++) {
      if (types[i] == 256) {
        let end = i + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i ? types[i - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace3 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i; j < end; j++)
          types[j] = replace3;
        i = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i = 0; i < len; ) {
        let start2 = i, rtl = types[i++] != 1;
        while (i < len && rtl == (types[i] != 1))
          i++;
        if (rtl) {
          for (let j = i; j > start2; ) {
            let end = j, l = types[--j] != 2;
            while (j > start2 && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start2, i, 0));
        }
      }
    } else {
      for (let i = 0; i < len; ) {
        let start2 = i, rtl = types[i++] == 2;
        while (i < len && rtl == (types[i] == 2))
          i++;
        order.push(new BidiSpan(start2, i, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length6) {
    return [new BidiSpan(0, length6, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start2, forward) {
    var _a2;
    let startIndex = start2.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last2 = order[order.length - 1];
      if (last2.level != dir) {
        startIndex = last2.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a2 = start2.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start2.assoc);
    let span2 = order[spanI];
    if (startIndex == span2.side(forward, dir)) {
      span2 = order[spanI += forward ? 1 : -1];
      startIndex = span2.side(!forward, dir);
    }
    let indexForward = forward == (span2.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span2.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span2.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span2.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span2.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span2.level);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text2) {
      this.text += text2;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start2, end) {
      if (!start2)
        return this;
      let parent = start2.parentNode;
      for (let cur = start2; ; ) {
        this.findPointBefore(parent, cur);
        this.readNode(cur);
        let next = cur.nextSibling;
        if (next == end)
          break;
        let view2 = ContentView.get(cur), nextView = ContentView.get(next);
        if (view2 && nextView ? view2.breakAfter : (view2 ? view2.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore))
          this.lineBreak();
        cur = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text2 = node.nodeValue;
      for (let point2 of this.points)
        if (point2.node == node)
          point2.pos = this.text.length + Math.min(point2.offset, text2.length);
      for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text2.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m = re2.exec(text2)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point2 of this.points)
            if (point2.node == node && point2.pos > this.text.length)
              point2.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view2 = ContentView.get(node);
      let fromView = view2 && view2.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak)
            this.lineBreak();
          else
            this.append(i.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point2 of this.points)
        if (point2.node == node && node.childNodes[point2.offset] == next)
          point2.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
      for (let point2 of this.points)
        if (node.nodeType == 3 ? point2.node == node : node.contains(point2.node))
          point2.pos = this.text.length + Math.min(maxLen, point2.offset);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DocView = class extends ContentView {
    constructor(view2) {
      super();
      this.view = view2;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view2.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view2.state.doc.length)], 0);
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update3) {
      let changedRanges = update3.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update3.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update3.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update3.transactions.length || this.dirty)
        this.compositionDeco = computeCompositionDeco(this.view, update3.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update3 && update3.state.doc.lines != update3.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update3.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update3.startState.doc.length);
        if (update3.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(this.view, track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      let cursor = this.childCursor(oldLength);
      for (let i = changes.length - 1; ; i--) {
        let next = i >= 0 ? changes[i] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next;
        let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection()))
        return;
      let force2 = this.forceSelection;
      this.forceSelection = false;
      let main2 = this.view.state.selection.main;
      let anchor = this.domAtPos(main2.anchor);
      let head = main2.empty ? anchor : this.domAtPos(main2.head);
      if (browser.gecko && main2.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force2 = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force2 || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel)
            ;
          else if (main2.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text2 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text2)
                  anchor = new DOMPos(text2, nextTo == 1 ? 0 : text2.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main2.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main2.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range3 = document.createRange();
            if (main2.anchor > main2.head)
              [anchor, head] = [head, anchor];
            range3.setEnd(head.node, head.offset);
            range3.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range3);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size)
        return;
      let { view: view2 } = this, cursor = view2.state.selection.main;
      let sel = getSelection(view2.root);
      let { anchorNode, anchorOffset } = view2.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view2.observer.readSelectionRange();
      let newRange = view2.observer.selectionRange;
      if (view2.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    mayControlSelection() {
      let active = this.view.root.activeElement;
      return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
    }
    nearest(dom) {
      for (let cur = dom; cur; ) {
        let domView = ContentView.get(cur);
        if (domView && domView.rootView == this)
          return domView;
        cur = cur.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view2 = this.nearest(node);
      if (!view2)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view2.localPosFromDOM(node, offset) + view2.posAtStart;
    }
    domAtPos(pos) {
      let { i, off } = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off < child.length || child instanceof LineView)
          break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i = this.children.length - 1; ; i--) {
        let child = this.children[i], start2 = off - child.breakAfter - child.length;
        if (pos > start2 || pos == start2 && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start2, side);
        off = start2;
      }
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last2 = child.dom.lastChild;
            let rects = last2 ? clientRectsFor(last2) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs.viewports.length ? null : vs.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d, i) => {
        let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      for (let i = allDeco.length; i < allDeco.length + 3; i++)
        this.dynamicDecorationMap[i] = false;
      return this.decorations = [
        ...allDeco,
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      let { range: range3 } = target;
      let rect = this.coordsAt(range3.head, range3.empty ? range3.assoc : range3.head > range3.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range3.empty && (other = this.coordsAt(range3.anchor, range3.anchor > range3.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
        if (margins) {
          let { left: left2, right: right2, top: top3, bottom: bottom2 } = margins;
          if (left2 != null)
            mLeft = Math.max(mLeft, left2);
          if (right2 != null)
            mRight = Math.max(mRight, right2);
          if (top3 != null)
            mTop = Math.max(mTop, top3);
          if (bottom2 != null)
            mBottom = Math.max(mBottom, bottom2);
        }
      let targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range3.head < range3.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function compositionSurroundingNode(view2) {
    let sel = view2.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let cView = view2.docView.nearest(textNode);
    if (!cView)
      return null;
    if (cView instanceof LineView) {
      let topNode = textNode;
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return { from: pos, to: pos, node: topNode, text: textNode };
    } else {
      for (; ; ) {
        let { parent } = cView;
        if (!parent)
          return null;
        if (parent instanceof LineView)
          break;
        cView = parent;
      }
      let from = cView.posAtStart;
      return { from, to: from + cView.length, node: cView.dom, text: textNode };
    }
  }
  function computeCompositionDeco(view2, changes) {
    let surrounding = compositionSurroundingNode(view2);
    if (!surrounding)
      return Decoration.none;
    let { from, to, node, text: textNode } = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let { state } = view2, text2 = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text2.length) {
      if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text2.length), LineBreakPlaceholder) == text2)
        newTo = newFrom + text2.length;
      else if (state.doc.sliceString(Math.max(0, newTo - text2.length), newTo, LineBreakPlaceholder) == text2)
        newFrom = newTo - text2.length;
      else
        return Decoration.none;
    } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text2) {
      return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
      topView = topView.widget.topView;
    else if (topView)
      topView.parent = null;
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true }).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top3, text2, topView) {
      super();
      this.top = top3;
      this.text = text2;
      this.topView = topView;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(startNode, startOffset, side) {
    if (side <= 0)
      for (let node = startNode, offset = startOffset; ; ) {
        if (node.nodeType == 3)
          return node;
        if (node.nodeType == 1 && offset > 0) {
          node = node.childNodes[offset - 1];
          offset = maxOffset(node);
        } else {
          break;
        }
      }
    if (side >= 0)
      for (let node = startNode, offset = startOffset; ; ) {
        if (node.nodeType == 3)
          return node;
        if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
          node = node.childNodes[offset];
          offset = 0;
        } else {
          break;
        }
      }
    return null;
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur = node; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
      if (cur.nodeType == 1 && cur.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x2, rect) {
    return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right);
  }
  function getdy(y2, rect) {
    return rect.top > y2 ? rect.top - y2 : Math.max(0, y2 - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top3) {
    return top3 < rect.top ? { top: top3, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom2) {
    return bottom2 > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom: bottom2 } : rect;
  }
  function domPosAtCoords(parent, x2, y2) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x2, rect), dy = getdy(y2, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x2, y2) : domPosAtCoords(child, x2, y2);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y2 < rect.top ? -1 : 1 : dx ? x2 < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y2 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y2 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y2) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y2) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y2);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y2);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x2, y2) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node, i, i + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x2 - rect.left;
        let dy = (rect.top > y2 ? rect.top - y2 : y2 - rect.bottom) - 1;
        if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
          let right2 = x2 >= (rect.left + rect.right) / 2, after = right2;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right2;
          }
          if (dy <= 0)
            return { node, offset: i + (after ? 1 : 0) };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view2, coords, precise, bias = -1) {
    var _a2, _b;
    let content2 = view2.contentDOM.getBoundingClientRect(), docTop = content2.top + view2.viewState.paddingTop;
    let block, { docHeight } = view2.viewState;
    let { x: x2, y: y2 } = coords, yOffset = y2 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view2.state.doc.length;
    for (let halfLine = view2.defaultLineHeight / 2, bounced = false; ; ) {
      block = view2.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y2 = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view2.viewport.from)
      return view2.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view2, content2, block, x2, y2);
    if (lineStart > view2.viewport.to)
      return view2.viewport.to == view2.state.doc.length ? view2.state.doc.length : precise ? null : posAtCoordsImprecise(view2, content2, block, x2, y2);
    let doc2 = view2.dom.ownerDocument;
    let root3 = view2.root.elementFromPoint ? view2.root : doc2;
    let element = root3.elementFromPoint(x2, y2);
    if (element && !view2.contentDOM.contains(element))
      element = null;
    if (!element) {
      x2 = Math.max(content2.left + 1, Math.min(content2.right - 1, x2));
      element = root3.elementFromPoint(x2, y2);
      if (element && !view2.contentDOM.contains(element))
        element = null;
    }
    let node, offset = -1;
    if (element && ((_a2 = view2.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x2, y2);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range3 = doc2.caretRangeFromPoint(x2, y2);
        if (range3) {
          ({ startContainer: node, startOffset: offset } = range3);
          if (!view2.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x2) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x2))
            node = void 0;
        }
      }
    }
    if (!node || !view2.docView.dom.contains(node)) {
      let line = LineView.find(view2.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x2, y2));
    }
    let nearest = view2.docView.nearest(node);
    if (!nearest)
      return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view2, contentRect, block, x2, y2) {
    let into = Math.round((x2 - contentRect.left) * view2.defaultCharacterWidth);
    if (view2.lineWrapping && block.height > view2.defaultLineHeight * 1.5) {
      let line = Math.floor((y2 - block.top) / view2.defaultLineHeight);
      into += line * view2.viewState.heightOracle.lineLength;
    }
    let content2 = view2.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view2.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x2) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x2;
  }
  function isSuspiciousChromeCaretResult(node, offset, x2) {
    if (offset != 0)
      return false;
    for (let cur = node; ; ) {
      let parent = cur.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x2 - rect.left > 5;
  }
  function moveToLineBoundary(view2, start2, forward, includeWrap) {
    let line = view2.state.doc.lineAt(start2.head);
    let coords = !includeWrap || !view2.lineWrapping ? null : view2.coordsAtPos(start2.assoc < 0 && start2.head > line.from ? start2.head - 1 : start2.head);
    if (coords) {
      let editorRect = view2.dom.getBoundingClientRect();
      let direction = view2.textDirectionAt(line.from);
      let pos = view2.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view2.docView, start2.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view2, start2, forward, by) {
    let line = view2.state.doc.lineAt(start2.head), spans = view2.bidiSpans(line);
    let direction = view2.textDirectionAt(line.from);
    for (let cur = start2, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur, forward), char2 = movedOver;
      if (!next) {
        if (line.number == (forward ? view2.state.doc.lines : 1))
          return cur;
        char2 = "\n";
        line = view2.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view2.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char2);
      } else if (!check(char2)) {
        return cur;
      }
      cur = next;
    }
  }
  function byGroup(view2, pos, start2) {
    let categorize = view2.state.charCategorizer(pos);
    let cat = categorize(start2);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view2, start2, forward, distance) {
    let startPos = start2.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view2.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start2.assoc);
    let goal = start2.goalColumn, startY;
    let rect = view2.contentDOM.getBoundingClientRect();
    let startCoords = view2.coordsAtPos(startPos), docTop = view2.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view2.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view2.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : view2.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view2, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, start2.assoc, void 0, goal);
    }
  }
  function skipAtoms(view2, oldPos, pos) {
    let atoms = view2.state.facet(atomicRanges).map((f) => f(view2));
    for (; ; ) {
      let moved = false;
      for (let set4 of atoms) {
        set4.between(pos.from - 1, pos.from + 1, (from, to, value) => {
          if (pos.from > from && pos.from < to) {
            pos = oldPos.head > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view2) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.mouseSelection = null;
      let handleEvent = (handler, event2) => {
        if (this.ignoreDuringComposition(event2))
          return;
        if (event2.type == "keydown" && this.keydown(view2, event2))
          return;
        if (this.mustFlushObserver(event2))
          view2.observer.forceFlush();
        if (this.runCustomHandlers(event2.type, view2, event2))
          event2.preventDefault();
        else
          handler(view2, event2);
      };
      for (let type2 in handlers) {
        let handler = handlers[type2];
        view2.contentDOM.addEventListener(type2, (event2) => {
          if (eventBelongsToEditor(view2, event2))
            handleEvent(handler, event2);
        }, handlerOptions[type2]);
        this.registeredEvents.push(type2);
      }
      view2.scrollDOM.addEventListener("mousedown", (event2) => {
        if (event2.target == view2.scrollDOM && event2.clientY > view2.contentDOM.getBoundingClientRect().bottom) {
          handleEvent(handlers.mousedown, event2);
          if (!event2.defaultPrevented && event2.button == 2) {
            let start2 = view2.contentDOM.style.minHeight;
            view2.contentDOM.style.minHeight = "100%";
            setTimeout(() => view2.contentDOM.style.minHeight = start2, 200);
          }
        }
      });
      if (browser.chrome && browser.chrome_version == 102) {
        view2.scrollDOM.addEventListener("wheel", () => {
          if (this.chromeScrollHack < 0)
            view2.contentDOM.style.pointerEvents = "none";
          else
            window.clearTimeout(this.chromeScrollHack);
          this.chromeScrollHack = setTimeout(() => {
            this.chromeScrollHack = -1;
            view2.contentDOM.style.pointerEvents = "";
          }, 100);
        }, { passive: true });
      }
      this.notifiedFocused = view2.hasFocus;
      if (browser.safari)
        view2.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view2, plugins) {
      var _a2;
      let handlers2;
      this.customHandlers = [];
      for (let plugin of plugins)
        if (handlers2 = (_a2 = plugin.update(view2).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
          this.customHandlers.push({ plugin: plugin.value, handlers: handlers2 });
          for (let type2 in handlers2)
            if (this.registeredEvents.indexOf(type2) < 0 && type2 != "scroll") {
              this.registeredEvents.push(type2);
              view2.contentDOM.addEventListener(type2, (event2) => {
                if (!eventBelongsToEditor(view2, event2))
                  return;
                if (this.runCustomHandlers(type2, view2, event2))
                  event2.preventDefault();
              });
            }
        }
    }
    runCustomHandlers(type2, view2, event2) {
      for (let set4 of this.customHandlers) {
        let handler = set4.handlers[type2];
        if (handler) {
          try {
            if (handler.call(set4.plugin, event2, view2) || event2.defaultPrevented)
              return true;
          } catch (e) {
            logException(view2.state, e);
          }
        }
      }
      return false;
    }
    runScrollHandlers(view2, event2) {
      this.lastScrollTop = view2.scrollDOM.scrollTop;
      this.lastScrollLeft = view2.scrollDOM.scrollLeft;
      for (let set4 of this.customHandlers) {
        let handler = set4.handlers.scroll;
        if (handler) {
          try {
            handler.call(set4.plugin, event2, view2);
          } catch (e) {
            logException(view2.state, e);
          }
        }
      }
    }
    keydown(view2, event2) {
      this.lastKeyCode = event2.keyCode;
      this.lastKeyTime = Date.now();
      if (event2.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
        view2.observer.delayAndroidKey(event2.key, event2.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
        this.pendingIOSKey = pending || event2;
        setTimeout(() => this.flushIOSKey(view2), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view2) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view2.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event2) {
      if (!/^key/.test(event2.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event2) {
      return event2.type == "keydown" && event2.keyCode != 229;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update3) {
      if (this.mouseSelection)
        this.mouseSelection.update(update3);
      if (update3.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  function dragScrollSpeed(dist) {
    return dist * 0.7 + 8;
  }
  var MouseSelection = class {
    constructor(view2, startEvent, style, mustSelect) {
      this.view = view2;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = { x: 0, y: 0 };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParent = scrollableParent(view2.contentDOM);
      let doc2 = view2.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view2.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view2, startEvent);
      this.dragMove = dragMovesSelection(view2, startEvent);
      this.dragging = isInPrimarySelection(view2, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event2) {
      if (this.dragging === false) {
        event2.preventDefault();
        this.select(event2);
      }
    }
    move(event2) {
      var _a2;
      if (event2.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event2);
      let sx = 0, sy = 0;
      let rect = ((_a2 = this.scrollParent) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
      if (event2.clientX <= rect.left)
        sx = -dragScrollSpeed(rect.left - event2.clientX);
      else if (event2.clientX >= rect.right)
        sx = dragScrollSpeed(event2.clientX - rect.right);
      if (event2.clientY <= rect.top)
        sy = -dragScrollSpeed(rect.top - event2.clientY);
      else if (event2.clientY >= rect.bottom)
        sy = dragScrollSpeed(event2.clientY - rect.bottom);
      this.setScrollSpeed(sx, sy);
    }
    up(event2) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event2.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = { x: sx, y: sy };
      if (sx || sy) {
        if (this.scrolling < 0)
          this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      if (this.scrollParent) {
        this.scrollParent.scrollLeft += this.scrollSpeed.x;
        this.scrollParent.scrollTop += this.scrollSpeed.y;
      } else {
        this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
      }
      if (this.dragging === false)
        this.select(this.lastEvent);
    }
    select(event2) {
      let selection3 = this.style.get(event2, this.extend, this.multiple);
      if (this.mustSelect || !selection3.eq(this.view.state.selection) || selection3.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection: selection3,
          userEvent: "select.pointer"
        });
      this.mustSelect = false;
    }
    update(update3) {
      if (update3.docChanged && this.dragging)
        this.dragging = this.dragging.map(update3.changes);
      if (this.style.update(update3))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view2, event2) {
    let facet = view2.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
  }
  function dragMovesSelection(view2, event2) {
    let facet = view2.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
  }
  function isInPrimarySelection(view2, event2) {
    let { main: main2 } = view2.state.selection;
    if (main2.empty)
      return false;
    let sel = getSelection(view2.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event2.clientX && rect.right >= event2.clientX && rect.top <= event2.clientY && rect.bottom >= event2.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view2, event2) {
    if (!event2.bubbles)
      return true;
    if (event2.defaultPrevented)
      return false;
    for (let node = event2.target, cView; node != view2.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event2))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var handlerOptions = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view2) {
    let parent = view2.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view2.focus();
      target.remove();
      doPaste(view2, target.value);
    }, 50);
  }
  function doPaste(view2, input) {
    let { state } = view2, changes, i = 1, text2 = state.toText(input);
    let byLine = text2.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text2.toString();
    if (linewise) {
      let lastLine2 = -1;
      changes = state.changeByRange((range3) => {
        let line = state.doc.lineAt(range3.from);
        if (line.from == lastLine2)
          return { range: range3 };
        lastLine2 = line.from;
        let insert4 = state.toText((byLine ? text2.line(i++).text : input) + state.lineBreak);
        return {
          changes: { from: line.from, insert: insert4 },
          range: EditorSelection.cursor(range3.from + insert4.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range3) => {
        let line = text2.line(i++);
        return {
          changes: { from: range3.from, to: range3.to, insert: line.text },
          range: EditorSelection.cursor(range3.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text2);
    }
    view2.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers.keydown = (view2, event2) => {
    view2.inputState.setSelectionOrigin("select");
    if (event2.keyCode == 27)
      view2.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event2.keyCode) < 0)
      view2.inputState.lastEscPress = 0;
  };
  handlers.touchstart = (view2, e) => {
    view2.inputState.lastTouchTime = Date.now();
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.touchmove = (view2) => {
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
  handlers.mousedown = (view2, event2) => {
    view2.observer.flush();
    if (view2.inputState.lastTouchTime > Date.now() - 2e3)
      return;
    let style = null;
    for (let makeStyle of view2.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view2, event2);
      if (style)
        break;
    }
    if (!style && event2.button == 0)
      style = basicMouseSelection(view2, event2);
    if (style) {
      let mustFocus = view2.root.activeElement != view2.contentDOM;
      view2.inputState.startMouseSelection(new MouseSelection(view2, event2, style, mustFocus));
      if (mustFocus)
        view2.observer.ignore(() => focusPreventScroll(view2.contentDOM));
      if (view2.inputState.mouseSelection)
        view2.inputState.mouseSelection.start(event2);
    }
  };
  function rangeForClick(view2, pos, bias, type2) {
    if (type2 == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type2 == 2) {
      return groupAt(view2.state, pos, bias);
    } else {
      let visual = LineView.find(view2.docView, pos), line = view2.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view2.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = (y2, rect) => y2 >= rect.top && y2 <= rect.bottom;
  var inside = (x2, y2, rect) => insideY(y2, rect) && x2 >= rect.left && x2 <= rect.right;
  function findPositionSide(view2, pos, x2, y2) {
    let line = LineView.find(view2.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x2, y2, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x2, y2, after))
      return 1;
    return before && insideY(y2, before) ? -1 : 1;
  }
  function queryPos(view2, event2) {
    let pos = view2.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
    return { pos, bias: findPositionSide(view2, pos, event2.clientX, event2.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event2) {
    if (!BadMouseDetail)
      return event2.detail;
    let last2 = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event2;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event2.clientX) < 2 && Math.abs(last2.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view2, event2) {
    let start2 = queryPos(view2, event2), type2 = getClickType(event2);
    let startSel = view2.state.selection;
    return {
      update(update3) {
        if (update3.docChanged) {
          start2.pos = update3.changes.mapPos(start2.pos);
          startSel = startSel.map(update3.changes);
        }
      },
      get(event3, extend3, multiple) {
        let cur = queryPos(view2, event3);
        let range3 = rangeForClick(view2, cur.pos, cur.bias, type2);
        if (start2.pos != cur.pos && !extend3) {
          let startRange = rangeForClick(view2, start2.pos, start2.bias, type2);
          let from = Math.min(startRange.from, range3.from), to = Math.max(startRange.to, range3.to);
          range3 = from < range3.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend3)
          return startSel.replaceRange(startSel.main.extend(range3.from, range3.to));
        else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range3)))
          return removeRange(startSel, range3);
        else if (multiple)
          return startSel.addRange(range3);
        else
          return EditorSelection.create([range3]);
      }
    };
  }
  function removeRange(sel, range3) {
    for (let i = 0; ; i++) {
      if (sel.ranges[i].eq(range3))
        return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
  }
  handlers.dragstart = (view2, event2) => {
    let { selection: { main: main2 } } = view2.state;
    let { mouseSelection } = view2.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main2;
    if (event2.dataTransfer) {
      event2.dataTransfer.setData("Text", view2.state.sliceDoc(main2.from, main2.to));
      event2.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view2, event2, text2, direct) {
    if (!text2)
      return;
    let dropPos = view2.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
    event2.preventDefault();
    let { mouseSelection } = view2.inputState;
    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text2 };
    let changes = view2.state.changes(del ? [del, ins] : ins);
    view2.focus();
    view2.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
  }
  handlers.drop = (view2, event2) => {
    if (!event2.dataTransfer)
      return;
    if (view2.state.readOnly)
      return event2.preventDefault();
    let files = event2.dataTransfer.files;
    if (files && files.length) {
      event2.preventDefault();
      let text2 = Array(files.length), read3 = 0;
      let finishFile = () => {
        if (++read3 == files.length)
          dropText(view2, event2, text2.filter((s) => s != null).join(view2.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text2[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
    } else {
      dropText(view2, event2, event2.dataTransfer.getData("Text"), true);
    }
  };
  handlers.paste = (view2, event2) => {
    if (view2.state.readOnly)
      return event2.preventDefault();
    view2.observer.flush();
    let data = brokenClipboardAPI ? null : event2.clipboardData;
    if (data) {
      doPaste(view2, data.getData("text/plain") || data.getData("text/uri-text"));
      event2.preventDefault();
    } else {
      capturePaste(view2);
    }
  };
  function captureCopy(view2, text2) {
    let parent = view2.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text2;
    target.focus();
    target.selectionEnd = text2.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view2.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range3 of state.selection.ranges)
      if (!range3.empty) {
        content2.push(state.sliceDoc(range3.from, range3.to));
        ranges.push(range3);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view2, event2) => {
    let { text: text2, ranges, linewise } = copiedRange(view2.state);
    if (!text2 && !linewise)
      return;
    lastLinewiseCopy = linewise ? text2 : null;
    let data = brokenClipboardAPI ? null : event2.clipboardData;
    if (data) {
      event2.preventDefault();
      data.clearData();
      data.setData("text/plain", text2);
    } else {
      captureCopy(view2, text2);
    }
    if (event2.type == "cut" && !view2.state.readOnly)
      view2.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  var isFocusChange = /* @__PURE__ */ Annotation.define();
  function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
      let effect = getEffect(state, focus);
      if (effect)
        effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
  }
  function updateForFocusChange(view2) {
    setTimeout(() => {
      let focus = view2.hasFocus;
      if (focus != view2.inputState.notifiedFocused) {
        let tr = focusChangeTransaction(view2.state, focus);
        if (tr)
          view2.dispatch(tr);
        else
          view2.update([]);
      }
    }, 10);
  }
  handlers.focus = (view2) => {
    view2.inputState.lastFocusTime = Date.now();
    if (!view2.scrollDOM.scrollTop && (view2.inputState.lastScrollTop || view2.inputState.lastScrollLeft)) {
      view2.scrollDOM.scrollTop = view2.inputState.lastScrollTop;
      view2.scrollDOM.scrollLeft = view2.inputState.lastScrollLeft;
    }
    updateForFocusChange(view2);
  };
  handlers.blur = (view2) => {
    view2.observer.clearSelectionRange();
    updateForFocusChange(view2);
  };
  handlers.compositionstart = handlers.compositionupdate = (view2) => {
    if (view2.inputState.compositionFirstChange == null)
      view2.inputState.compositionFirstChange = true;
    if (view2.inputState.composing < 0) {
      view2.inputState.composing = 0;
    }
  };
  handlers.compositionend = (view2) => {
    view2.inputState.composing = -1;
    view2.inputState.compositionEndedAt = Date.now();
    view2.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android)
      view2.observer.flushSoon();
    setTimeout(() => {
      if (view2.inputState.composing < 0 && view2.docView.compositionDeco.size)
        view2.update([]);
    }, 50);
  };
  handlers.contextmenu = (view2) => {
    view2.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view2, event2) => {
    var _a2;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event2.inputType))) {
      view2.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view2.hasFocus) {
            view2.contentDOM.blur();
            view2.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines;
    }
    heightForLine(length6) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length6 - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h = lineHeights[i];
        if (h < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h = knownHeights[i];
          if (h < 0)
            i++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length6, top3, height, type2) {
      this.from = from;
      this.length = length6;
      this.top = top3;
      this.height = height;
      this.type = type2;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType2;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length6, height, flags = 2) {
      this.length = length6;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this, doc2 = oracle.doc;
      for (let i = changes.length - 1; i >= 0; i--) {
        let { fromA, toA, fromB, toB } = changes[i];
        let start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start2.to >= toA ? start2 : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start2.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start2.from)
            start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start2.from - fromA;
        fromA = start2.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j) {
          if (before > after * 2) {
            let split3 = nodes[i - 1];
            if (split3.break)
              nodes.splice(--i, 1, split3.left, null, split3.right);
            else
              nodes.splice(--i, 1, split3.left, split3.right);
            j += 1 + split3.break;
            before -= split3.size;
          } else if (after > before * 2) {
            let split3 = nodes[j];
            if (split3.break)
              nodes.splice(j, 1, split3.left, null, split3.right);
            else
              nodes.splice(j, 1, split3.left, split3.right);
            j += 2 + split3.break;
            after -= split3.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length6, height, type2) {
      super(length6, height);
      this.type = type2;
    }
    blockAt(_height, _oracle, top3, offset) {
      return new BlockInfo(offset, this.length, top3, this.height, this.type);
    }
    lineAt(_value, _type, oracle, top3, offset) {
      return this.blockAt(0, oracle, top3, offset);
    }
    forEachLine(from, to, oracle, top3, offset, f) {
      if (from <= offset + this.length && to >= offset)
        f(this.blockAt(0, oracle, top3, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length6, height) {
      super(length6, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force2 || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length6) {
      super(length6, 0);
    }
    heightMetrics(oracle, offset) {
      let firstLine2 = oracle.doc.lineAt(offset).number, lastLine2 = oracle.doc.lineAt(offset + this.length).number;
      let lines = lastLine2 - firstLine2 + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
        perLine = totalPerLine / lines;
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
      } else {
        perLine = this.height / lines;
      }
      return { firstLine: firstLine2, lastLine: lastLine2, perLine, perChar };
    }
    blockAt(height, oracle, top3, offset) {
      let { firstLine: firstLine2, lastLine: lastLine2, perLine, perChar } = this.heightMetrics(oracle, offset);
      if (oracle.lineWrapping) {
        let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top3) / this.height)) * this.length);
        let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
        let lineTop = Math.max(top3, height - lineHeight / 2);
        return new BlockInfo(line.from, line.length, lineTop, lineHeight, BlockType.Text);
      } else {
        let line = Math.max(0, Math.min(lastLine2 - firstLine2, Math.floor((height - top3) / perLine)));
        let { from, length: length6 } = oracle.doc.line(firstLine2 + line);
        return new BlockInfo(from, length6, top3 + perLine * line, perLine, BlockType.Text);
      }
    }
    lineAt(value, type2, oracle, top3, offset) {
      if (type2 == QueryType.ByHeight)
        return this.blockAt(value, oracle, top3, offset);
      if (type2 == QueryType.ByPosNoHeight) {
        let { from, to } = oracle.doc.lineAt(value);
        return new BlockInfo(from, to - from, 0, 0, BlockType.Text);
      }
      let { firstLine: firstLine2, perLine, perChar } = this.heightMetrics(oracle, offset);
      let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
      let linesAbove = line.number - firstLine2;
      let lineTop = top3 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
      return new BlockInfo(line.from, line.length, Math.max(top3, Math.min(lineTop, top3 + this.height - lineHeight)), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, oracle, top3, offset, f) {
      from = Math.max(from, offset);
      to = Math.min(to, offset + this.length);
      let { firstLine: firstLine2, perLine, perChar } = this.heightMetrics(oracle, offset);
      for (let pos = from, lineTop = top3; pos <= to; ) {
        let line = oracle.doc.lineAt(pos);
        if (pos == from) {
          let linesAbove = line.number - firstLine2;
          lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
        }
        let lineHeight = perLine + perChar * line.length;
        f(new BlockInfo(line.from, line.length, lineTop, lineHeight, BlockType.Text));
        lineTop += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last2 = nodes[nodes.length - 1];
        if (last2 instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last2.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
          oracle.heightChanged = true;
        return result;
      } else if (force2 || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left2, brk, right2) {
      super(left2.length + brk + right2.length, left2.height + right2.height, brk | (left2.outdated || right2.outdated ? 2 : 0));
      this.left = left2;
      this.right = right2;
      this.size = left2.size + right2.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, oracle, top3, offset) {
      let mid = top3 + this.left.height;
      return height < mid ? this.left.blockAt(height, oracle, top3, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type2, oracle, top3, offset) {
      let rightTop = top3 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left2 = type2 == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left2 ? this.left.lineAt(value, type2, oracle, top3, offset) : this.right.lineAt(value, type2, oracle, rightTop, rightOffset);
      if (this.break || (left2 ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type2 == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left2)
        return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, oracle, top3, offset).join(base2);
    }
    forEachLine(from, to, oracle, top3, offset, f) {
      let rightTop = top3 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, oracle, top3, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top3, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, oracle, top3, offset, f);
        if (mid.to >= from && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left2 = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left2 - 1);
      if (to < this.length) {
        let right2 = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right2);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left2 = this.left.length;
      if (to <= left2)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left2++;
        if (to >= left2)
          result.push(null);
      }
      if (to > left2)
        this.right.decomposeLeft(to - left2, result);
    }
    decomposeRight(from, result) {
      let left2 = this.left.length, right2 = left2 + this.break;
      if (from >= right2)
        return this.right.decomposeRight(from - right2, result);
      if (from < left2)
        this.left.decomposeRight(from, result);
      if (this.break && from < right2)
        result.push(null);
      result.push(this.right);
    }
    balanced(left2, right2) {
      if (left2.size > 2 * right2.size || right2.size > 2 * left2.size)
        return HeightMap.of(this.break ? [left2, null, right2] : [left2, right2]);
      this.left = left2;
      this.right = right2;
      this.height = left2.height + right2.height;
      this.outdated = left2.outdated || right2.outdated;
      this.size = left2.size + right2.size;
      this.length = left2.length + this.break + right2.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      let { left: left2, right: right2 } = this, rightStart = offset + left2.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left2.length && measured.more)
        rebalance = left2 = left2.updateHeight(oracle, offset, force2, measured);
      else
        left2.updateHeight(oracle, offset, force2);
      if (measured && measured.from <= rightStart + right2.length && measured.more)
        rebalance = right2 = right2.updateHeight(oracle, rightStart, force2, measured);
      else
        right2.updateHeight(oracle, rightStart, force2);
      if (rebalance)
        return this.balanced(left2, right2);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
        if (last2 instanceof HeightMapText)
          last2.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last2 instanceof HeightMapText)
        return last2;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length6) {
      let line = this.ensureLine();
      line.length += length6;
      line.collapsed += length6;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length6;
    }
    finish(from) {
      let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last2 == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left2 = Math.max(0, rect.left), right2 = Math.min(win.innerWidth, rect.right);
    let top3 = Math.max(0, rect.top), bottom2 = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left2 = Math.max(left2, parentRect.left);
          right2 = Math.min(right2, parentRect.right);
          top3 = Math.max(top3, parentRect.top);
          bottom2 = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom2, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left2 - rect.left,
      right: Math.max(left2, right2) - rect.left,
      top: top3 - (rect.top + paddingTop),
      bottom: Math.max(top3, bottom2) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size3) {
      this.from = from;
      this.to = to;
      this.size = size3;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        let gA = a[i], gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size3, vertical) {
      super();
      this.size = size3;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main: main2 } = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main2.head : main2.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update3, scrollTarget = null) {
      this.state = update3.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update3.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update3 ? update3.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update3.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update3.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update3.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update3.changes.empty || update3.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update3.changes)));
      update3.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update3.selectionSet && update3.view.lineWrapping && update3.state.selection.main.empty && update3.state.selection.main.assoc && !update3.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view2) {
      let dom = view2.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view2.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view2.scrollDOM.clientWidth;
        result |= 8;
      }
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view2.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view2.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view2.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view2.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view2.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view2.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view2.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view2));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view2.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map6 = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map6.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map6.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map6.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map6.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map6.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from, to }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top3 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
      let { bottom: bottom2 } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top3 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom2 >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top3 > visibleTop - 2 * 1e3 && bottom2 < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from, to, line, structure) => {
        if (to - from < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find2(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from)
              to = lineStart;
          }
          gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
        }
        gaps.push(gap);
      };
      for (let line of this.viewportLines) {
        if (line.length < doubleMargin)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          continue;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top3, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top3 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top3 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top3);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left2, right2;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left2 = targetFrac - spaceFrac;
            right2 = targetFrac + spaceFrac;
          } else {
            left2 = (this.pixelViewport.left - marginWidth) / totalWidth;
            right2 = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left2);
          viewTo = findPosition(structure, right2);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({ from, to });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let { from, to } = ranges[i], size3 = to - from;
      if (dist <= size3)
        return from + dist;
      dist -= size3;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find2(array, f) {
    for (let val of array)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top3 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
        let bottom2 = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom2 - top3;
        return { from, to, top: top3, bottom: bottom2, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main2, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main2;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main2 + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace:before": {
      content: "attr(data-display)",
      position: "absolute",
      pointerEvents: "none",
      color: "#888"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var DOMChange = class {
    constructor(view2, start2, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view2.docView;
      if (view2.state.readOnly && start2 > -1) {
        this.newSel = null;
      } else if (start2 > -1 && (this.bounds = view2.docView.domBoundsAround(start2, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view2);
        let reader = new DOMReader(selPoints, view2.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view2.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view2.contentDOM, domSel.focusNode) ? view2.state.selection.main.head : view2.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view2.contentDOM, domSel.anchorNode) ? view2.state.selection.main.anchor : view2.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view2, domChange) {
    let change;
    let { newSel } = domChange, sel = view2.state.selection.main;
    if (domChange.bounds) {
      let { from, to } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (view2.inputState.lastKeyCode === 8 && view2.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view2.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && view2.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view2.hasFocus && view2.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = { from: sel.from, to: sel.to, insert: view2.state.doc.slice(sel.from, sel.to) };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view2.state.doc.slice(sel.from, change.from).append(change.insert).append(view2.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view2.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view2.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change) {
      let startState2 = view2.state;
      if (browser.ios && view2.inputState.flushIOSKey(view2))
        return true;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view2.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view2.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view2.contentDOM, "Delete", 46)))
        return true;
      let text2 = change.insert.toString();
      if (view2.state.facet(inputHandler).some((h) => h(view2, change.from, change.to, text2)))
        return true;
      if (view2.inputState.composing >= 0)
        view2.inputState.composing++;
      let tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view2.inputState.composing < 0) {
        let before = sel.from < change.from ? startState2.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState2.sliceDoc(change.to, sel.to) : "";
        tr = startState2.replaceSelection(view2.state.toText(before + change.insert.sliceString(0, void 0, view2.state.lineBreak) + after));
      } else {
        let changes = startState2.changes(change);
        let mainSel = newSel && !startState2.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState2.selection.ranges.length > 1 && view2.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
          let replaced = view2.state.sliceDoc(change.from, change.to);
          let compositionRange = compositionSurroundingNode(view2) || view2.state.doc.lineAt(sel.head);
          let offset = sel.to - change.to, size3 = sel.to - sel.from;
          tr = startState2.changeByRange((range3) => {
            if (range3.from == sel.from && range3.to == sel.to)
              return { changes, range: mainSel || range3.map(changes) };
            let to = range3.to - offset, from = to - replaced.length;
            if (range3.to - range3.from != size3 || view2.state.sliceDoc(from, to) != replaced || compositionRange && range3.to >= compositionRange.from && range3.from <= compositionRange.to)
              return { range: range3 };
            let rangeChanges = startState2.changes({ from, to, insert: change.insert }), selOff = range3.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range3.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState2.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view2.composing) {
        userEvent += ".compose";
        if (view2.inputState.compositionFirstChange) {
          userEvent += ".start";
          view2.inputState.compositionFirstChange = false;
        }
      }
      view2.dispatch(tr, { scrollIntoView: true, userEvent });
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView2 = false, userEvent = "select";
      if (view2.inputState.lastSelectionTime > Date.now() - 50) {
        if (view2.inputState.lastSelectionOrigin == "select")
          scrollIntoView2 = true;
        userEvent = view2.inputState.lastSelectionOrigin;
      }
      view2.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
      from++;
    if (from == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  function selectionPoints(view2) {
    let result = [];
    if (view2.root.activeElement != view2.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view2.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view2) {
      this.view = view2;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.resizeContent = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view2.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view2.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event2) => {
          this.queue.push({
            target: event2.target,
            type: "characterData",
            oldValue: event2.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resizeScroll.observe(view2.scrollDOM);
        this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());
        this.resizeContent.observe(view2.contentDOM);
      }
      this.addWindowListeners(this.win = view2.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runScrollHandlers(this.view, e);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event2) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view: view2 } = this, sel = this.selectionRange;
      if (view2.state.facet(editable) ? view2.root.activeElement != this.dom : !hasSelection(view2.dom, sel))
        return;
      let context = sel.anchorNode && view2.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event2)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view2.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view: view2 } = this;
      let range3 = browser.safari && view2.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view2.root);
      if (!range3 || this.selectionRange.eq(range3))
        return false;
      let local = hasSelection(this.dom, range3);
      if (local && !this.selectionChanged && view2.inputState.lastFocusTime > Date.now() - 200 && view2.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range3)) {
        this.view.inputState.lastFocusTime = 0;
        view2.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range3);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            if (!this.flush() && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    processRecords() {
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record3 of records) {
        let range3 = this.readMutation(record3);
        if (!range3)
          continue;
        if (range3.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to } = range3);
        } else {
          from = Math.min(range3.from, from);
          to = Math.max(range3.to, to);
        }
      }
      return { from, to, typeOver };
    }
    readChange() {
      let { from, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return null;
      if (from > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      return new DOMChange(this.view, from, to, typeOver);
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange)
        return false;
      let startState2 = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState2)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
      var _a2, _b, _c, _d;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view2) {
    let found = null;
    function read3(event2) {
      event2.preventDefault();
      event2.stopImmediatePropagation();
      found = event2.getTargetRanges()[0];
    }
    view2.contentDOM.addEventListener("beforeinput", read3, true);
    view2.dom.ownerDocument.execCommand("indent");
    view2.contentDOM.removeEventListener("beforeinput", read3, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view2.docView.domAtPos(view2.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  var EditorView = class {
    constructor(config = {}) {
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: fixed; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this._root = config.root || getRoot(config.parent) || document;
      this.viewState = new ViewState(config.state || EditorState.create(config));
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config.parent)
        config.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update3;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr) => tr.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus;
        focusFlag = 1;
      } else if (focus != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus;
        dispatchFocus = focusChangeTransaction(state, focus);
        if (!dispatchFocus)
          focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update3 = ViewUpdate.create(this, state, transactions);
      update3.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main: main2 } = tr.state.selection;
            scrollTarget = new ScrollTarget(main2.empty ? main2 : EditorSelection.cursor(main2.head, main2.head > main2.anchor ? -1 : 1));
          }
          for (let e of tr.effects)
            if (e.is(scrollIntoView))
              scrollTarget = e.value;
        }
        this.viewState.update(update3, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update3.changes);
        if (!update3.empty) {
          this.updatePlugins(update3);
          this.inputState.update(update3);
        }
        redrawn = this.docView.update(update3);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update3.startState.facet(theme) != update3.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update3.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update3);
      if (dispatchFocus || domChange)
        Promise.resolve().then(() => {
          if (dispatchFocus && this.state == dispatchFocus.startState)
            this.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(this, domChange) && pendingKey.force)
              dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update3) {
      let prevSpecs = update3.startState.facet(viewPlugin), specs = update3.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update3;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update3)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update3;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;
      let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
      try {
        for (let i = 0; ; i++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let refBlock = this.viewState.lineBlockAtHeight(refHeight);
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update3 = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
          update3.flags |= changed;
          if (!updated)
            updated = update3;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update3.empty) {
            this.updatePlugins(update3);
            this.inputState.update(update3);
            this.updateAttrs();
            redrawn = this.docView.update(update3);
          }
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                let m = measuring[i2];
                if (m.write)
                  m.write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrolled = true;
            } else {
              let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
              if (diff > 1 || diff < -1) {
                this.scrollDOM.scrollTop += diff;
                scrolled = true;
              }
            }
          }
          if (redrawn)
            this.docView.updateSelection(true);
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request2) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request2) {
        if (this.measureRequests.indexOf(request2) > -1)
          return;
        if (request2.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request2.key) {
              this.measureRequests[i] = request2;
              return;
            }
          }
        this.measureRequests.push(request2);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start2, forward, by) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
    }
    moveByGroup(start2, forward) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
    }
    moveToLineBoundary(start2, forward, includeWrap = true) {
      return moveToLineBoundary(this, start2, forward, includeWrap);
    }
    moveVertically(start2, forward, distance) {
      return skipAtoms(this, start2, moveVertically(this, start2, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span2 = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span2.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from);
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root3) {
      if (this._root != root3) {
        this._root = root3;
        this.observer.setWindow((root3.nodeType == 9 ? root3 : root3.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    static theme(spec, options) {
      let prefix2 = StyleModule.newName();
      let result = [theme.of(prefix2), styleModule.of(buildTheme(`.${prefix2}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to, dir, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty)
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
        let entry = cache[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view2, facet, base2) {
    for (let sources = view2.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      let source2 = sources[i], value = typeof source2 == "function" ? source2(view2) : source2;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name3, platform) {
    const parts = name3.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt2, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt2 = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt2)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name3, event2, shift2) {
    if (event2.altKey)
      name3 = "Alt-" + name3;
    if (event2.ctrlKey)
      name3 = "Ctrl-" + name3;
    if (event2.metaKey)
      name3 = "Meta-" + name3;
    if (shift2 !== false && event2.shiftKey)
      name3 = "Shift-" + name3;
    return name3;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event2, view2) {
      return runHandlers(getKeymap(view2.state), event2, view2, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map6 = Keymaps.get(bindings);
    if (!map6)
      Keymaps.set(bindings, map6 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map6;
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name3, is) => {
      let current = isPrefix[name3];
      if (current == null)
        isPrefix[name3] = is;
      else if (current != is)
        throw new Error("Key binding " + name3 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command2, preventDefault2) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix2 = parts.slice(0, i).join(" ");
        checkPrefix(prefix2, true);
        if (!scopeObj[prefix2])
          scopeObj[prefix2] = {
            preventDefault: true,
            run: [(view2) => {
              let ourObj = storedPrefix = { view: view2, prefix: prefix2, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding2 = scopeObj[full] || (scopeObj[full] = { preventDefault: false, run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || [] });
      if (command2)
        binding2.run.push(command2);
      if (preventDefault2)
        binding2.preventDefault = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : ["editor"];
      if (b.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, run: [] };
          for (let key in scopeObj)
            scopeObj[key].run.push(b.any);
        }
      let name3 = b[platform] || b.key;
      if (!name3)
        continue;
      for (let scope of scopes) {
        add(scope, name3, b.run, b.preventDefault);
        if (b.shift)
          add(scope, "Shift-" + name3, b.shift, b.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map6, event2, view2, scope) {
    let name3 = keyName(event2);
    let charCode = codePointAt(name3, 0), isChar = codePointSize(charCode) == name3.length && name3 != " ";
    let prefix2 = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view2 && storedPrefix.scope == scope) {
      prefix2 = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event2.keyCode) < 0)
        storedPrefix = null;
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding2) => {
      if (binding2) {
        for (let cmd of binding2.run)
          if (!ran.has(cmd)) {
            ran.add(cmd);
            if (cmd(view2, event2))
              return true;
          }
        if (binding2.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map6[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix2 + modifiers(name3, event2, !isChar)]))
        return true;
      if (isChar && (event2.altKey || event2.metaKey || event2.ctrlKey) && !(browser.windows && event2.ctrlKey && event2.altKey) && (baseName = base[event2.keyCode]) && baseName != name3) {
        if (runFor(scopeObj[prefix2 + modifiers(baseName, event2, true)]))
          return true;
        else if (event2.shiftKey && (shiftName = shift[event2.keyCode]) != name3 && shiftName != baseName && runFor(scopeObj[prefix2 + modifiers(shiftName, event2, false)]))
          return true;
      } else if (isChar && event2.shiftKey) {
        if (runFor(scopeObj[prefix2 + modifiers(name3, event2, true)]))
          return true;
      }
      if (runFor(scopeObj._any))
        return true;
    }
    return fallthrough;
  }
  var CanHidePrimary = !browser.ios;
  var themeSpec = {
    ".cm-line": {
      "& ::selection": { backgroundColor: "transparent !important" },
      "&::selection": { backgroundColor: "transparent !important" }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config = {}) {
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match5) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match5 != "function")
        match5 = NodeType.match(match5);
      return (type2) => {
        let result = match5(type2);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class {
    constructor(name3, props, id3, flags = 0) {
      this.name = name3;
      this.props = props;
      this.id = id3;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type2 = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type2);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type2;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name3) {
      if (typeof name3 == "string") {
        if (this.name == name3)
          return true;
        let group2 = this.prop(NodeProp.group);
        return group2 ? group2.indexOf(name3) > -1 : false;
      }
      return this.id == name3;
    }
    static match(map6) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map6)
        for (let name3 of prop.split(" "))
          direct[name3] = map6[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type2, children2, positions, length6, props) {
      this.type = type2;
      this.children = children2;
      this.positions = positions;
      this.length = length6;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children2 = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children2)
            children2 += ",";
          children2 += str;
        }
      }
      return !this.type.name ? children2 : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children2.length ? "(" + children2 + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && !c.type.isAnonymous)
            leave(c);
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id3 in this.props)
          result.push([+id3, this.props[id3]]);
      return result;
    }
    balance(config = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children2, positions, length6) => new Tree(this.type, children2, positions, length6, this.propValues), config.makeTree || ((children2, positions, length6) => new Tree(NodeType.none, children2, positions, length6)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index3) {
      this.buffer = buffer;
      this.index = index3;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length6, set4) {
      this.buffer = buffer;
      this.length = length6;
      this.set = set4;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index3 = 0; index3 < this.buffer.length; ) {
        result.push(this.childString(index3));
        index3 = this.buffer[index3 + 3];
      }
      return result.join(",");
    }
    childString(index3) {
      let id3 = this.buffer[index3], endIndex = this.buffer[index3 + 3];
      let type2 = this.set.types[id3], result = type2.name;
      if (/\W/.test(result) && !type2.isError)
        result = JSON.stringify(result);
      index3 += 4;
      if (endIndex == index3)
        return result;
      let children2 = [];
      while (index3 < endIndex) {
        children2.push(this.childString(index3));
        index3 = this.buffer[index3 + 3];
      }
      return result + "(" + children2.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from) {
      let b = this.buffer;
      let copy2 = new Uint16Array(endI - startI), len = 0;
      for (let i = startI, j = 0; i < endI; ) {
        copy2[j++] = b[i++];
        copy2[j++] = b[i++] - from;
        let to = copy2[j++] = b[i++] - from;
        copy2[j++] = b[i++] - startI;
        len = Math.max(len, to);
      }
      return new TreeBuffer(copy2, len, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last2 = scan.lastChild;
      if (!last2 || last2.to != scan.to)
        break;
      if (last2.type.isError && last2.from == last2.to) {
        node = scan;
        scan = last2.prevSibling;
      } else {
        scan = last2;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from, index3, _parent) {
      this._tree = _tree;
      this.from = from;
      this.index = index3;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children: children2, positions } = parent._tree, e = dir > 0 ? children2.length : -1; i != e; i += dir) {
          let next = children2[i], start2 = positions[i] + parent.from;
          if (!checkSide(side, pos, start2, start2 + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index3 = next.findChild(0, next.buffer.length, dir, pos - start2, side);
            if (index3 > -1)
              return new BufferNode(new BufferContext(parent, next, i, start2), null, index3);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start2, i, parent);
            let inner = new TreeNode(next, start2, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type2, before = null, after = null) {
      let r = getChildren(this, type2, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type2, before = null, after = null) {
      return getChildren(this, type2, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  function getChildren(node, type2, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
      return result;
    if (before != null) {
      while (!cur.type.is(before))
        if (!cur.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur.type.is(after))
        return result;
      if (cur.type.is(type2))
        result.push(cur.node);
      if (!cur.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name)
          return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index3, start2) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index3;
      this.start = start2;
    }
  };
  var BufferNode = class {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index3) {
      this.context = context;
      this._parent = _parent;
      this.index = index3;
      this.type = context.buffer.set.types[context.buffer.buffer[index3]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index3 < 0 ? null : new BufferNode(this.context, this, index3);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index3 < 0 ? null : new BufferNode(this.context, this, index3);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children2 = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1];
        children2.push(buffer.slice(startI, endI, from));
        positions.push(0);
      }
      return new Tree(this.type, children2, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type2, before = null, after = null) {
      let r = getChildren(this, type2, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type2, before = null, after = null) {
      return getChildren(this, type2, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  var TreeCursor = class {
    get name() {
      return this.type.name;
    }
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index3, type2) {
      this.index = index3;
      let { start: start2, buffer } = this.buffer;
      this.type = type2 || buffer.set.types[buffer.buffer[index3]];
      this.from = start2 + buffer.buffer[index3 + 1];
      this.to = start2 + buffer.buffer[index3 + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index3 < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index3);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index3, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({ index: index3, parent } = buffer);
      } else {
        ({ index: index3, _parent: parent } = this._tree);
      }
      for (; parent; { index: index3, _parent: parent } = parent) {
        if (index3 > -1)
          for (let i = index3 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
            let child = parent._tree.children[i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan:
          for (let index3 = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache; c; c = c._parent)
              if (c.index == index3) {
                if (index3 == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index3 = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node, context);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
        if (d < 0)
          return matchNodeContext(this.node, context, i);
        let type2 = types2[buffer.buffer[this.stack[d]]];
        if (!type2.isAnonymous) {
          if (context[i] && context[i] != type2.name)
            return false;
          i--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children3, positions2, inRepeat) {
      let { id: id3, start: start2, end, size: size3 } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size3 < 0) {
        cursor.next();
        if (size3 == -1) {
          let node2 = reused[id3];
          children3.push(node2);
          positions2.push(start2 - parentStart);
          return;
        } else if (size3 == -3) {
          contextHash = id3;
          return;
        } else if (size3 == -4) {
          lookAhead = id3;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size3}`);
        }
      }
      let type2 = types2[id3], node, buffer2;
      let startPos = start2 - parentStart;
      if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index3 = data2.length;
        while (cursor.pos > endPos)
          index3 = copyToBuffer(buffer2.start, data2, index3);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size3;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id3 >= minRepeatType ? id3 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type2);
          node = balanceRange(type2, localChildren, localPositions, 0, localChildren.length, 0, end - start2, make, make);
        } else {
          node = makeTree(type2, localChildren, localPositions, end - start2, lookAheadAtStart - end);
        }
      }
      children3.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type2) {
      return (children3, positions2, length7) => {
        let lookAhead2 = 0, lastI = children3.length - 1, last2, lookAheadProp;
        if (lastI >= 0 && (last2 = children3[lastI]) instanceof Tree) {
          if (!lastI && last2.type == type2 && last2.length == length7)
            return last2;
          if (lookAheadProp = last2.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last2.length + lookAheadProp;
        }
        return makeTree(type2, children3, positions2, length7, lookAhead2);
      };
    }
    function makeRepeatLeaf(children3, positions2, base2, i, from, to, type2, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children3.length > i) {
        localChildren.push(children3.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children3.push(makeTree(nodeSet.types[type2], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type2, children3, positions2, length7, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair = [NodeProp.contextHash, contextHash];
        props = props ? [pair].concat(props) : [pair];
      }
      if (lookAhead2 > 25) {
        let pair = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair].concat(props) : [pair];
      }
      return new Tree(type2, children3, positions2, length7, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size3 = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size3;
            result.start = start2;
            result.skip = skip;
            skip += 4;
            size3 += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start2 = nodeStart;
          size3 += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size3 == maxSize) {
        result.size = size3;
        result.start = start2;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index3) {
      let { id: id3, start: start2, end, size: size3 } = cursor;
      cursor.next();
      if (size3 >= 0 && id3 < minRepeatType) {
        let startIndex = index3;
        if (size3 > 4) {
          let endPos = cursor.pos - (size3 - 4);
          while (cursor.pos > endPos)
            index3 = copyToBuffer(bufferStart, buffer2, index3);
        }
        buffer2[--index3] = startIndex;
        buffer2[--index3] = end - bufferStart;
        buffer2[--index3] = start2 - bufferStart;
        buffer2[--index3] = id3;
      } else if (size3 == -3) {
        contextHash = id3;
      } else if (size3 == -4) {
        lookAhead = id3;
      }
      return index3;
    }
    let children2 = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children2, positions, -1);
    let length6 = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children2.length ? positions[0] + children2[0].length : 0;
    return new Tree(types2[data.topID], children2.reverse(), positions.reverse(), length6);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size3 = nodeSizeCache.get(node);
    if (size3 == null) {
      size3 = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size3 = 1;
          break;
        }
        size3 += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size3);
    }
    return size3;
  }
  function balanceRange(balanceType, children2, positions, from, to, start2, length6, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
      total += nodeSize(balanceType, children2[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide2(children3, positions2, from2, to2, offset) {
      for (let i = from2; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children3[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize(balanceType, children3[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children3[groupFrom];
            divide2(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children3[groupFrom]);
        } else {
          let length7 = positions2[i - 1] + children3[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children3, positions2, groupFrom, i, groupStart, length7, null, mkTree));
        }
        localPositions.push(groupStart + offset - start2);
      }
    }
    divide2(children2, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length6);
  }
  var TreeFragment = class {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse2 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse2.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string4) {
      this.string = string4;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set4, base2, modified) {
      this.set = set4;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set4 = [], tag = new Tag(set4, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config of configs)
            set4.push(Modifier.get(parent, config));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x2, i) => x2 == b[i]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
      for (let j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array[i]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last2 = pieces.length - 1, inner = pieces[last2];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last2 > 0 ? pieces.slice(0, last2) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map6 = /* @__PURE__ */ Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map6[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map6[tag.id] = style.class;
    }
    let { scope, all: all3 = null } = options || {};
    return {
      style: (tags3) => {
        let cls = all3;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map6[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number4 = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number: number4,
    integer: t(number4),
    float: t(number4),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  var sublanguageProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    constructor(data, parser, extraExtensions = [], name3 = "") {
      this.data = data;
      this.name = name3;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => {
          let top3 = topNodeAt(state, pos, side), data2 = top3.type.prop(languageDataProp);
          if (!data2)
            return [];
          let base2 = state.facet(data2), sub = top3.type.prop(sublanguageProp);
          if (sub) {
            let innerNode = top3.resolve(pos - top3.from, side);
            for (let sublang of sub)
              if (sublang.test(innerNode, state)) {
                let data3 = state.facet(sublang.facet);
                return sublang.type == "replace" ? data3 : data3.concat(base2);
              }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({ from: r.from + from, to: r.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size3 = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size3)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch = tree.children[i];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        if (node.type.isTop)
          tree = node;
    }
    return tree;
  }
  function syntaxTree(state) {
    let field2 = state.field(Language.state, false);
    return field2 ? field2.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser, state, viewport) {
      return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from < to)
              skipped.push({ from, to });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let { from, to } = this.skipped[i];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({ from, to });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
  }
  var LanguageState = class {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout2 = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout2);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout2 = setTimeout(() => {
        idle = requestIdleCallback(callback, { timeout: 500 - 100 });
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout2) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view2) {
      this.view = view2;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update3) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update3.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update3.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state } = this.view, field2 = state.field(Language.state);
      if (field2.tree != field2.context.tree || !field2.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now3 = Date.now();
      if (this.chunkEnd < now3 && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now3 + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field2 = state.field(Language.state);
      if (field2.tree == field2.context.tree && field2.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field2.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field2.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now3;
      if (done || this.chunkBudget <= 0) {
        field2.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field2.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field2.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? { "data-language": lang.name } : {};
      })
    ]
  });
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values2) => {
      if (!values2.length)
        return "  ";
      let unit3 = values2[0];
      if (!unit3 || /\S/.test(unit3) || Array.from(unit3).some((e) => e != unit3[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
      return unit3;
    }
  });
  function getIndentUnit(state) {
    let unit3 = state.facet(indentUnit);
    return unit3.charCodeAt(0) == 9 ? state.tabSize * unit3.length : unit3.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "	") {
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
      ch = " ";
    }
    for (let i = 0; i < cols; i++)
      result += ch;
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text: text2, from } = this.lineAt(pos, bias);
      return text2.slice(pos - from, Math.min(text2.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let { text: text2, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text2, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text2, text2.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text: text2, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text2, text2.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last2 = tree.lastChild, closed = last2 && close.indexOf(last2.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last2.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      let line = this.state.doc.lineAt(this.node.from);
      for (; ; ) {
        let atBreak = this.node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, this.node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
      if (parent == cur)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last2 = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last2)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  var HighlightStyle = class {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all3 = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type2) => type2.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type2) => type2 == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, { tag: null }))
      })), {
        all: all3
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  };
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index3 = brackets.indexOf(node.name);
      if (index3 > -1 && index3 % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index3 + dir]];
    }
    return null;
  }
  function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
  }
  function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
      let matches = matchingNodes(cur.type, dir, brackets);
      if (matches && cur.from < cur.to) {
        let handle = findHandle(cur);
        if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
          return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
      }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token2, handle, matching, brackets) {
    let parent = token2.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token2.from) : cursor.childAfter(token2.to)))
      do {
        if (dir < 0 ? cursor.to <= token2.from : cursor.from >= token2.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            let endHandle = findHandle(cursor);
            return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            if (depth == 0) {
              let endHandle = findHandle(cursor);
              return {
                start: firstToken,
                end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                matched: false
              };
            }
            depth--;
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text2 = iter.value;
      if (dir < 0)
        distance += text2.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text2.length - 1, end = dir > 0 ? text2.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text2[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text2.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name3] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name3);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name3 = tagStr.replace(/ /g, "_"), type2 = NodeType.define({
      id: typeArray.length,
      name: name3,
      props: [styleTags({ [name3]: tag })]
    });
    typeArray.push(type2);
    return type2.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option2) {
    return ({ state, dispatch: dispatch3 }) => {
      if (state.readOnly)
        return false;
      let tr = f(option2, state);
      if (!tr)
        return false;
      dispatch3(state.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      let last2 = ranges.length - 1;
      if (last2 >= 0 && ranges[last2].to > fromLine.from)
        ranges[last2].to = toLine.to;
      else
        ranges.push({ from: fromLine.from, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option2, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c) => c))
      return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option2 != 2 && !comments.every((c) => c)) {
      return { changes: state.changes(ranges.map((range3, i) => {
        if (comments[i])
          return [];
        return [{ from: range3.from, insert: tokens[i].open + " " }, { from: range3.to, insert: " " + tokens[i].close }];
      })) };
    } else if (option2 != 1 && comments.some((c) => c)) {
      let changes = [];
      for (let i = 0, comment2; i < comments.length; i++)
        if (comment2 = comments[i]) {
          let token2 = tokens[i], { open, close } = comment2;
          changes.push({ from: open.pos - token2.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token2.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option2, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      let token2 = getConfig(state, from).line;
      if (!token2)
        continue;
      for (let pos = from; pos <= to; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from == to || to > line.from)) {
          prevLine = line.from;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty5 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token2.length) == token2 ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line, comment: comment2, token: token2, indent, empty: empty5, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i = startI; i < lines.length; i++)
          if (lines[i].indent < lines[i].line.text.length)
            lines[i].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option2 != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line, token: token2, indent, empty: empty5, single } of lines)
        if (single || !empty5)
          changes.push({ from: line.from + indent, insert: token2 + " " });
      let changeSet = state.changes(changes);
      return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    } else if (option2 != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token: token2 } of lines)
        if (comment2 >= 0) {
          let from = line.from + comment2, to = from + token2.length;
          if (line.text[to - line.from] == " ")
            to++;
          changes.push({ from, to });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection3) {
      let effects = none3;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection3 || tr.startState.selection, none3);
    }
    static selection(selections) {
      return new HistEvent(void 0, none3, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start2 = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start2, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i = 0; i < ranges.length; ) {
        let from = ranges[i++], to = ranges[i++];
        if (t2 >= from && f <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  var none3 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection3) {
    if (!branch.length) {
      return [HistEvent.selection([selection3])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection3))
        return branch;
      sels.push(selection3);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last2 = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last2.setSelAfter(last2.selectionsAfter.slice(0, last2.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length6 = branch.length, selections = none3;
    while (length6) {
      let event2 = mapEvent(branch[length6 - 1], mapping, selections);
      if (event2.changes && !event2.changes.empty || event2.effects.length) {
        let result = branch.slice(0, length6);
        result[length6 - 1] = event2;
        return result;
      } else {
        mapping = event2.mapped;
        length6--;
        selections = event2.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none3;
  }
  function mapEvent(event2, mapping, extraSelections) {
    let selections = conc(event2.selectionsAfter.length ? event2.selectionsAfter.map((s) => s.map(mapping)) : none3, extraSelections);
    if (!event2.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event2.changes.map(mapping), before = mapping.mapDesc(event2.changes, true);
    let fullMapping = event2.mapped ? event2.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event2.effects, mapping), fullMapping, event2.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event2, time2, userEvent, config, tr) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event2.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time2 - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event2.changes)) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event2.changes.compose(lastEvent.changes), conc(event2.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none3));
      } else {
        done = updateBranch(done, done.length, config.minDepth, event2);
      }
      return new HistoryState(done, none3, time2, userEvent);
    }
    addSelection(selection3, time2, userEvent, newGroupDelay) {
      let last2 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none3;
      if (last2.length > 0 && time2 - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last2[last2.length - 1], selection3))
        return this;
      return new HistoryState(addSelection(this.done, selection3), this.undone, time2, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection3) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event2 = branch[branch.length - 1];
      if (selection3 && event2.selectionsAfter.length) {
        return state.update({
          selection: event2.selectionsAfter[event2.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch) }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event2.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none3 : branch.slice(0, branch.length - 1);
        if (event2.mapped)
          rest = addMappingToBranch(rest, event2.mapped);
        return state.update({
          changes: event2.changes,
          selection: event2.startSelection,
          effects: event2.effects,
          annotations: fromHistory.of({ side, rest }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none3, none3);
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection3) {
    return state.update({ selection: selection3, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state, dispatch: dispatch3 }, how) {
    let selection3 = updateSel(state.selection, how);
    if (selection3.eq(state.selection))
      return false;
    dispatch3(setSel(state, selection3));
    return true;
  }
  function rangeEnd(range3, forward) {
    return EditorSelection.cursor(forward ? range3.to : range3.from);
  }
  function cursorByChar(view2, forward) {
    return moveSel(view2, (range3) => range3.empty ? view2.moveByChar(range3, forward) : rangeEnd(range3, forward));
  }
  function ltrAtCursor(view2) {
    return view2.textDirectionAt(view2.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view2) => cursorByChar(view2, !ltrAtCursor(view2));
  var cursorCharRight = (view2) => cursorByChar(view2, ltrAtCursor(view2));
  function cursorByGroup(view2, forward) {
    return moveSel(view2, (range3) => range3.empty ? view2.moveByGroup(range3, forward) : rangeEnd(range3, forward));
  }
  var cursorGroupLeft = (view2) => cursorByGroup(view2, !ltrAtCursor(view2));
  var cursorGroupRight = (view2) => cursorByGroup(view2, ltrAtCursor(view2));
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start2, forward) {
    let pos = syntaxTree(state).resolveInner(start2.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start2.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match5, newPos;
    if (bracket2 && (match5 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match5.matched)
      newPos = forward ? match5.end.to : match5.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view2) => moveSel(view2, (range3) => moveBySyntax(view2.state, range3, !ltrAtCursor(view2)));
  var cursorSyntaxRight = (view2) => moveSel(view2, (range3) => moveBySyntax(view2.state, range3, ltrAtCursor(view2)));
  function cursorByLine(view2, forward) {
    return moveSel(view2, (range3) => {
      if (!range3.empty)
        return rangeEnd(range3, forward);
      let moved = view2.moveVertically(range3, forward);
      return moved.head != range3.head ? moved : view2.moveToLineBoundary(range3, forward);
    });
  }
  var cursorLineUp = (view2) => cursorByLine(view2, false);
  var cursorLineDown = (view2) => cursorByLine(view2, true);
  function pageInfo(view2) {
    let selfScroll = view2.scrollDOM.clientHeight < view2.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
      for (let source2 of view2.state.facet(EditorView.scrollMargins)) {
        let margins = source2(view2);
        if (margins === null || margins === void 0 ? void 0 : margins.top)
          marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom)
          marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height = view2.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view2.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view2.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view2, forward) {
    let page = pageInfo(view2);
    let { state } = view2, selection3 = updateSel(state.selection, (range3) => {
      return range3.empty ? view2.moveVertically(range3, forward, page.height) : rangeEnd(range3, forward);
    });
    if (selection3.eq(state.selection))
      return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view2.coordsAtPos(state.selection.main.head);
      let scrollRect = view2.scrollDOM.getBoundingClientRect();
      let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
        effect = EditorView.scrollIntoView(selection3.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view2.dispatch(setSel(state, selection3), { effects: effect });
    return true;
  }
  var cursorPageUp = (view2) => cursorByPage(view2, false);
  var cursorPageDown = (view2) => cursorByPage(view2, true);
  function moveByLineBoundary(view2, start2, forward) {
    let line = view2.lineBlockAt(start2.head), moved = view2.moveToLineBoundary(start2, forward);
    if (moved.head == start2.head && moved.head != (forward ? line.to : line.from))
      moved = view2.moveToLineBoundary(start2, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view2.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start2.head != line.from + space)
        moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, true));
  var cursorLineBoundaryBackward = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, false));
  var cursorLineBoundaryLeft = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, !ltrAtCursor(view2)));
  var cursorLineBoundaryRight = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, ltrAtCursor(view2)));
  var cursorLineStart = (view2) => moveSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).from, 1));
  var cursorLineEnd = (view2) => moveSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).to, -1));
  function toMatchingBracket(state, dispatch3, extend3) {
    let found = false, selection3 = updateSel(state.selection, (range3) => {
      let matching = matchBrackets(state, range3.head, -1) || matchBrackets(state, range3.head, 1) || range3.head > 0 && matchBrackets(state, range3.head - 1, 1) || range3.head < state.doc.length && matchBrackets(state, range3.head + 1, -1);
      if (!matching || !matching.end)
        return range3;
      found = true;
      let head = matching.start.from == range3.head ? matching.end.to : matching.end.from;
      return extend3 ? EditorSelection.range(range3.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch3(setSel(state, selection3));
    return true;
  }
  var cursorMatchingBracket = ({ state, dispatch: dispatch3 }) => toMatchingBracket(state, dispatch3, false);
  function extendSel(view2, how) {
    let selection3 = updateSel(view2.state.selection, (range3) => {
      let head = how(range3);
      return EditorSelection.range(range3.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
    });
    if (selection3.eq(view2.state.selection))
      return false;
    view2.dispatch(setSel(view2.state, selection3));
    return true;
  }
  function selectByChar(view2, forward) {
    return extendSel(view2, (range3) => view2.moveByChar(range3, forward));
  }
  var selectCharLeft = (view2) => selectByChar(view2, !ltrAtCursor(view2));
  var selectCharRight = (view2) => selectByChar(view2, ltrAtCursor(view2));
  function selectByGroup(view2, forward) {
    return extendSel(view2, (range3) => view2.moveByGroup(range3, forward));
  }
  var selectGroupLeft = (view2) => selectByGroup(view2, !ltrAtCursor(view2));
  var selectGroupRight = (view2) => selectByGroup(view2, ltrAtCursor(view2));
  var selectSyntaxLeft = (view2) => extendSel(view2, (range3) => moveBySyntax(view2.state, range3, !ltrAtCursor(view2)));
  var selectSyntaxRight = (view2) => extendSel(view2, (range3) => moveBySyntax(view2.state, range3, ltrAtCursor(view2)));
  function selectByLine(view2, forward) {
    return extendSel(view2, (range3) => view2.moveVertically(range3, forward));
  }
  var selectLineUp = (view2) => selectByLine(view2, false);
  var selectLineDown = (view2) => selectByLine(view2, true);
  function selectByPage(view2, forward) {
    return extendSel(view2, (range3) => view2.moveVertically(range3, forward, pageInfo(view2).height));
  }
  var selectPageUp = (view2) => selectByPage(view2, false);
  var selectPageDown = (view2) => selectByPage(view2, true);
  var selectLineBoundaryForward = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, true));
  var selectLineBoundaryBackward = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, false));
  var selectLineBoundaryLeft = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, !ltrAtCursor(view2)));
  var selectLineBoundaryRight = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, ltrAtCursor(view2)));
  var selectLineStart = (view2) => extendSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).from));
  var selectLineEnd = (view2) => extendSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).to));
  var cursorDocStart = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: state.doc.length }));
    return true;
  };
  var selectDocStart = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state, dispatch: dispatch3 }) => {
    dispatch3(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
  };
  var selectAll = ({ state, dispatch: dispatch3 }) => {
    dispatch3(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state, dispatch: dispatch3 }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch3(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state, dispatch: dispatch3 }) => {
    let selection3 = updateSel(state.selection, (range3) => {
      var _a2;
      let context = syntaxTree(state).resolveInner(range3.head, 1);
      while (!(context.from < range3.from && context.to >= range3.to || context.to > range3.to && context.from <= range3.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
        context = context.parent;
      return EditorSelection.range(context.to, context.from);
    });
    dispatch3(setSel(state, selection3));
    return true;
  };
  var simplifySelection = ({ state, dispatch: dispatch3 }) => {
    let cur = state.selection, selection3 = null;
    if (cur.ranges.length > 1)
      selection3 = EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
      selection3 = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
    if (!selection3)
      return false;
    dispatch3(setSel(state, selection3));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event2 = "delete.selection", { state } = target;
    let changes = state.changeByRange((range3) => {
      let { from, to } = range3;
      if (from == to) {
        let towards = by(from);
        if (towards < from) {
          event2 = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event2 = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? { range: range3 } : { changes: { from, to }, range: EditorSelection.cursor(from) };
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event2,
      effects: event2 == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop3 = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i = 0; i < drop3 && before[before.length - 1 - i] == " "; i++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    }
    return targetPos;
  });
  var deleteCharBackward = (view2) => deleteByChar(view2, false);
  var deleteCharForward = (view2) => deleteByChar(view2, true);
  var deleteByGroup = (target, forward) => deleteBy(target, (start2) => {
    let pos = start2, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == start2 && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar != " " || pos != start2)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view2) => deleteBy(view2, (pos) => {
    let lineEnd = view2.lineBlockAt(pos).to;
    return pos < lineEnd ? lineEnd : Math.min(view2.state.doc.length, pos + 1);
  });
  var deleteToLineStart = (view2) => deleteBy(view2, (pos) => {
    let lineStart = view2.lineBlockAt(pos).from;
    return pos > lineStart ? lineStart : Math.max(0, pos - 1);
  });
  var splitLine = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range3) => {
      return {
        changes: { from: range3.from, to: range3.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range3.from)
      };
    });
    dispatch3(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range3) => {
      if (!range3.empty || range3.from == 0 || range3.from == state.doc.length)
        return { range: range3 };
      let pos = range3.from, line = state.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch3(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range3 of state.selection.ranges) {
      let startLine = state.doc.lineAt(range3.from), endLine = state.doc.lineAt(range3.to);
      if (!range3.empty && range3.to == endLine.from)
        endLine = state.doc.lineAt(range3.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range3);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range3] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch3, forward) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward ? block.to == state.doc.length : block.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size3 = nextLine.length + 1;
      if (forward) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size3), Math.min(state.doc.length, r.head + size3)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size3, r.head - size3));
      }
    }
    if (!changes.length)
      return false;
    dispatch3(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state, dispatch: dispatch3 }) => moveLine(state, dispatch3, false);
  var moveLineDown = ({ state, dispatch: dispatch3 }) => moveLine(state, dispatch3, true);
  function copyLine(state, dispatch3, forward) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward)
        changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
      else
        changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch3(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state, dispatch: dispatch3 }) => copyLine(state, dispatch3, false);
  var copyLineDown = ({ state, dispatch: dispatch3 }) => copyLine(state, dispatch3, true);
  var deleteLine = (view2) => {
    if (view2.state.readOnly)
      return false;
    let { state } = view2, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
      if (from > 0)
        from--;
      else if (to < state.doc.length)
        to++;
      return { from, to };
    }));
    let selection3 = updateSel(state.selection, (range3) => view2.moveVertically(range3, true)).map(changes);
    view2.dispatch({ changes, selection: selection3, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch: dispatch3 }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range3) => {
        let { from, to } = range3, line = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof)
          from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({ from, to } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert4 = ["", indentString(state, indent)];
        if (explode)
          insert4.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: { from, to, insert: Text.of(insert4) },
          range: EditorSelection.cursor(from + 1 + insert4[1].length)
        };
      });
      dispatch3(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range3) => {
      let changes = [];
      for (let pos = range3.from; pos <= range3.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range3.empty || range3.to > line.from)) {
          f(line, changes, range3);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range3.anchor, 1), changeSet.mapPos(range3.head, 1))
      };
    });
  }
  var indentSelection = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: (start2) => {
      let found = updated[start2];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state, (line, changes2, range3) => {
      let indent = getIndentation(context, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur != norm || range3.from < line.from + cur.length) {
        updated[line.from] = indent;
        changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch3(state.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    dispatch3(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({ from: line.from, insert: state.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state, dispatch: dispatch3 }) => {
    if (state.readOnly)
      return false;
    dispatch3(state.update(changeBySelectedLine(state, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space)
        return;
      let col = countColumn(space, state.tabSize), keep = 0;
      let insert4 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space.length && keep < insert4.length && space.charCodeAt(keep) == insert4.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert4.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
  ].concat(standardKeymap);

  // output-es/App.CodeMirror/foreign.js
  function curry2(f) {
    return (x1) => (x2) => f(x1, x2);
  }
  var startState = EditorState.create({
    doc: "",
    extensions: [keymap.of(defaultKeymap)]
  });
  function addEditorView_(id3) {
    return () => {
      const div = select_default2("#" + id3).node();
      return new EditorView({
        state: startState,
        parent: div
      });
    };
  }
  function replaceSelection_(editorState, str) {
    return editorState.replaceSelection(str);
  }
  function dispatch_(editorView, tr) {
    return () => {
      console.log(tr.state.doc.toString());
      editorView.dispatch(tr);
    };
  }
  function update_(editorState, specs) {
    return () => {
      return editorState.update(...specs);
    };
  }
  var addEditorView = addEditorView_;
  var dispatch2 = curry2(dispatch_);
  var replaceSelection = curry2(replaceSelection_);
  var update = curry2(update_);

  // output-es/Type.Proxy/index.js
  var $Proxy = () => ({ tag: "Proxy" });
  var $$Proxy = /* @__PURE__ */ $Proxy();

  // output-es/Data.Show/foreign.js
  var showIntImpl = function(n) {
    return n.toString();
  };
  var showNumberImpl = function(n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };
  var showCharImpl = function(c) {
    var code = c.charCodeAt(0);
    if (code < 32 || code === 127) {
      switch (c) {
        case "\x07":
          return "'\\a'";
        case "\b":
          return "'\\b'";
        case "\f":
          return "'\\f'";
        case "\n":
          return "'\\n'";
        case "\r":
          return "'\\r'";
        case "	":
          return "'\\t'";
        case "\v":
          return "'\\v'";
      }
      return "'\\" + code.toString(10) + "'";
    }
    return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
  };
  var showStringImpl = function(s) {
    var l = s.length;
    return '"' + s.replace(
      /[\0-\x1F\x7F"\\]/g,
      function(c, i) {
        switch (c) {
          case '"':
          case "\\":
            return "\\" + c;
          case "\x07":
            return "\\a";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          case "\v":
            return "\\v";
        }
        var k = i + 1;
        var empty5 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
        return "\\" + c.charCodeAt(0).toString(10) + empty5;
      }
    ) + '"';
  };
  var showArrayImpl = function(f) {
    return function(xs) {
      var ss = [];
      for (var i = 0, l = xs.length; i < l; i++) {
        ss[i] = f(xs[i]);
      }
      return "[" + ss.join(",") + "]";
    };
  };
  var cons = function(head) {
    return function(tail) {
      return [head].concat(tail);
    };
  };
  var intercalate = function(separator) {
    return function(xs) {
      return xs.join(separator);
    };
  };

  // output-es/Data.Show/index.js
  var showString = { show: showStringImpl };
  var showNumber = { show: showNumberImpl };
  var showInt = { show: showIntImpl };

  // output-es/Data.Ordering/index.js
  var $Ordering = (tag) => ({ tag });
  var LT = /* @__PURE__ */ $Ordering("LT");
  var GT = /* @__PURE__ */ $Ordering("GT");
  var EQ = /* @__PURE__ */ $Ordering("EQ");

  // output-es/Data.Unit/foreign.js
  var unit2 = void 0;

  // output-es/Data.Maybe/index.js
  var $Maybe = (tag, _1) => ({ tag, _1 });
  var Nothing = /* @__PURE__ */ $Maybe("Nothing");
  var Just = (value0) => $Maybe("Just", value0);
  var isNothing = (v2) => {
    if (v2.tag === "Nothing") {
      return true;
    }
    if (v2.tag === "Just") {
      return false;
    }
    fail();
  };
  var functorMaybe = {
    map: (v) => (v1) => {
      if (v1.tag === "Just") {
        return $Maybe("Just", v(v1._1));
      }
      return Nothing;
    }
  };
  var applyMaybe = {
    apply: (v) => (v1) => {
      if (v.tag === "Just") {
        if (v1.tag === "Just") {
          return $Maybe("Just", v._1(v1._1));
        }
        return Nothing;
      }
      if (v.tag === "Nothing") {
        return Nothing;
      }
      fail();
    },
    Functor0: () => functorMaybe
  };
  var applicativeMaybe = { pure: Just, Apply0: () => applyMaybe };

  // output-es/Data.Number/foreign.js
  var isFiniteImpl = isFinite;
  var ceil = Math.ceil;
  var floor = Math.floor;
  var log = Math.log;
  var pow = function(n) {
    return function(p) {
      return Math.pow(n, p);
    };
  };

  // output-es/Data.Int/foreign.js
  var fromNumberImpl = function(just) {
    return function(nothing) {
      return function(n) {
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };
  var toNumber = function(n) {
    return n;
  };
  var quot = function(x2) {
    return function(y2) {
      return x2 / y2 | 0;
    };
  };
  var rem = function(x2) {
    return function(y2) {
      return x2 % y2;
    };
  };

  // output-es/Data.Int/index.js
  var fromNumber = /* @__PURE__ */ fromNumberImpl(Just)(Nothing);
  var unsafeClamp = (x2) => {
    if (!isFiniteImpl(x2)) {
      return 0;
    }
    if (x2 >= toNumber(2147483647)) {
      return 2147483647;
    }
    if (x2 <= toNumber(-2147483648)) {
      return -2147483648;
    }
    const $1 = fromNumber(x2);
    if ($1.tag === "Nothing") {
      return 0;
    }
    if ($1.tag === "Just") {
      return $1._1;
    }
    fail();
  };
  var floor2 = (x2) => unsafeClamp(floor(x2));
  var ceil2 = (x2) => unsafeClamp(ceil(x2));

  // output-es/Data.Function/index.js
  var $$const = (a) => (v) => a;
  var applyFlipped = (x2) => (f) => f(x2);

  // output-es/Control.Semigroupoid/index.js
  var semigroupoidFn = { compose: (f) => (g) => (x2) => f(g(x2)) };

  // output-es/Data.Functor/foreign.js
  var arrayMap = function(f) {
    return function(arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };

  // output-es/Data.Functor/index.js
  var functorArray = { map: arrayMap };

  // output-es/Control.Apply/index.js
  var identity4 = (x2) => x2;

  // output-es/Control.Bind/foreign.js
  var arrayBind = function(arr) {
    return function(f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };

  // output-es/Control.Bind/index.js
  var identity5 = (x2) => x2;

  // output-es/Data.Either/index.js
  var $Either = (tag, _1) => ({ tag, _1 });
  var Left = (value0) => $Either("Left", value0);
  var Right = (value0) => $Either("Right", value0);
  var functorEither = {
    map: (f) => (m) => {
      if (m.tag === "Left") {
        return $Either("Left", m._1);
      }
      if (m.tag === "Right") {
        return $Either("Right", f(m._1));
      }
      fail();
    }
  };
  var choose = (dictAlt) => {
    const map1 = dictAlt.Functor0().map;
    return (a) => (b) => dictAlt.alt(map1(Left)(a))(map1(Right)(b));
  };
  var applyEither = {
    apply: (v) => (v1) => {
      if (v.tag === "Left") {
        return $Either("Left", v._1);
      }
      if (v.tag === "Right") {
        if (v1.tag === "Left") {
          return $Either("Left", v1._1);
        }
        if (v1.tag === "Right") {
          return $Either("Right", v._1(v1._1));
        }
        fail();
      }
      fail();
    },
    Functor0: () => functorEither
  };
  var bindEither = {
    bind: (v2) => {
      if (v2.tag === "Left") {
        return (v) => $Either("Left", v2._1);
      }
      if (v2.tag === "Right") {
        return (f) => f(v2._1);
      }
      fail();
    },
    Apply0: () => applyEither
  };
  var applicativeEither = { pure: Right, Apply0: () => applyEither };
  var monadEither = { Applicative0: () => applicativeEither, Bind1: () => bindEither };

  // output-es/Data.Identity/index.js
  var Identity = (x2) => x2;
  var functorIdentity = { map: (f) => (m) => f(m) };
  var applyIdentity = { apply: (v) => (v1) => v(v1), Functor0: () => functorIdentity };
  var bindIdentity = { bind: (v) => (f) => f(v), Apply0: () => applyIdentity };
  var applicativeIdentity = { pure: Identity, Apply0: () => applyIdentity };
  var monadIdentity = { Applicative0: () => applicativeIdentity, Bind1: () => bindIdentity };

  // output-es/Effect/foreign.js
  var pureE = function(a) {
    return function() {
      return a;
    };
  };
  var bindE = function(a) {
    return function(f) {
      return function() {
        return f(a())();
      };
    };
  };

  // output-es/Effect/index.js
  var applyEffect = {
    apply: (f) => (a) => () => {
      const f$p = f();
      const a$p = a();
      return applicativeEffect.pure(f$p(a$p))();
    },
    Functor0: () => functorEffect
  };
  var applicativeEffect = { pure: pureE, Apply0: () => applyEffect };
  var functorEffect = {
    map: (f) => (a) => () => {
      const a$p = a();
      return f(a$p);
    }
  };

  // output-es/Control.Monad.Rec.Class/index.js
  var $Step = (tag, _1) => ({ tag, _1 });
  var Loop = (value0) => $Step("Loop", value0);
  var monadRecIdentity = {
    tailRecM: (f) => {
      const go = (go$a0$copy) => {
        let go$a0 = go$a0$copy, go$c = true, go$r;
        while (go$c) {
          const v = go$a0;
          if (v.tag === "Loop") {
            go$a0 = f(v._1);
            continue;
          }
          if (v.tag === "Done") {
            go$c = false;
            go$r = v._1;
            continue;
          }
          fail();
        }
        ;
        return go$r;
      };
      return (x2) => go(f(x2));
    },
    Monad0: () => monadIdentity
  };
  var bifunctorStep = {
    bimap: (v) => (v1) => (v2) => {
      if (v2.tag === "Loop") {
        return $Step("Loop", v(v2._1));
      }
      if (v2.tag === "Done") {
        return $Step("Done", v1(v2._1));
      }
      fail();
    }
  };

  // output-es/Data.NonEmpty/index.js
  var $NonEmpty = (_1, _2) => ({ tag: "NonEmpty", _1, _2 });
  var NonEmpty = (value0) => (value1) => $NonEmpty(value0, value1);
  var functorNonEmpty = (dictFunctor) => ({ map: (f) => (m) => $NonEmpty(f(m._1), dictFunctor.map(f)(m._2)) });
  var traversableNonEmpty = (dictTraversable) => {
    const functorNonEmpty1 = functorNonEmpty(dictTraversable.Functor0());
    const $2 = dictTraversable.Foldable1();
    const foldableNonEmpty1 = {
      foldMap: (dictMonoid) => {
        const append1 = dictMonoid.Semigroup0().append;
        const foldMap1 = $2.foldMap(dictMonoid);
        return (f) => (v) => append1(f(v._1))(foldMap1(f)(v._2));
      },
      foldl: (f) => (b) => (v) => $2.foldl(f)(f(b)(v._1))(v._2),
      foldr: (f) => (b) => (v) => f(v._1)($2.foldr(f)(b)(v._2))
    };
    return {
      sequence: (dictApplicative) => {
        const Apply0 = dictApplicative.Apply0();
        const map22 = Apply0.Functor0().map;
        const sequence13 = dictTraversable.sequence(dictApplicative);
        return (v) => Apply0.apply(map22(NonEmpty)(v._1))(sequence13(v._2));
      },
      traverse: (dictApplicative) => {
        const Apply0 = dictApplicative.Apply0();
        const map22 = Apply0.Functor0().map;
        const traverse14 = dictTraversable.traverse(dictApplicative);
        return (f) => (v) => Apply0.apply(map22(NonEmpty)(f(v._1)))(traverse14(f)(v._2));
      },
      Functor0: () => functorNonEmpty1,
      Foldable1: () => foldableNonEmpty1
    };
  };
  var foldable1NonEmpty = (dictFoldable) => {
    const foldableNonEmpty1 = {
      foldMap: (dictMonoid) => {
        const append1 = dictMonoid.Semigroup0().append;
        const foldMap1 = dictFoldable.foldMap(dictMonoid);
        return (f) => (v) => append1(f(v._1))(foldMap1(f)(v._2));
      },
      foldl: (f) => (b) => (v) => dictFoldable.foldl(f)(f(b)(v._1))(v._2),
      foldr: (f) => (b) => (v) => f(v._1)(dictFoldable.foldr(f)(b)(v._2))
    };
    return {
      foldMap1: (dictSemigroup) => (f) => (v) => dictFoldable.foldl((s) => (a1) => dictSemigroup.append(s)(f(a1)))(f(v._1))(v._2),
      foldr1: (f) => (v) => {
        const $4 = f(v._1);
        const $5 = dictFoldable.foldr((a1) => {
          const $6 = f(a1);
          return (x2) => $Maybe(
            "Just",
            (() => {
              if (x2.tag === "Nothing") {
                return a1;
              }
              if (x2.tag === "Just") {
                return $6(x2._1);
              }
              fail();
            })()
          );
        })(Nothing)(v._2);
        if ($5.tag === "Nothing") {
          return v._1;
        }
        if ($5.tag === "Just") {
          return $4($5._1);
        }
        fail();
      },
      foldl1: (f) => (v) => dictFoldable.foldl(f)(v._1)(v._2),
      Foldable0: () => foldableNonEmpty1
    };
  };

  // output-es/Data.Tuple/index.js
  var $Tuple = (_1, _2) => ({ tag: "Tuple", _1, _2 });
  var Tuple = (value0) => (value1) => $Tuple(value0, value1);
  var snd = (v) => v._2;
  var functorTuple = { map: (f) => (m) => $Tuple(m._1, f(m._2)) };
  var fst = (v) => v._1;
  var ordTuple = (dictOrd) => {
    const $1 = dictOrd.Eq0();
    return (dictOrd1) => {
      const $3 = dictOrd1.Eq0();
      const eqTuple2 = { eq: (x2) => (y2) => $1.eq(x2._1)(y2._1) && $3.eq(x2._2)(y2._2) };
      return {
        compare: (x2) => (y2) => {
          const v = dictOrd.compare(x2._1)(y2._1);
          if (v.tag === "LT") {
            return LT;
          }
          if (v.tag === "GT") {
            return GT;
          }
          return dictOrd1.compare(x2._2)(y2._2);
        },
        Eq0: () => eqTuple2
      };
    };
  };

  // output-es/Data.List.Types/index.js
  var $List = (tag, _1, _2) => ({ tag, _1, _2 });
  var identity6 = (x2) => x2;
  var Nil = /* @__PURE__ */ $List("Nil");
  var Cons = (value0) => (value1) => $List("Cons", value0, value1);
  var listMap = (f) => {
    const chunkedRevMap = (chunkedRevMap$a0$copy) => (chunkedRevMap$a1$copy) => {
      let chunkedRevMap$a0 = chunkedRevMap$a0$copy, chunkedRevMap$a1 = chunkedRevMap$a1$copy, chunkedRevMap$c = true, chunkedRevMap$r;
      while (chunkedRevMap$c) {
        const v = chunkedRevMap$a0, v1 = chunkedRevMap$a1;
        const $4 = (chunksAcc, xs) => {
          const reverseUnrolledMap = (reverseUnrolledMap$a0$copy) => (reverseUnrolledMap$a1$copy) => {
            let reverseUnrolledMap$a0 = reverseUnrolledMap$a0$copy, reverseUnrolledMap$a1 = reverseUnrolledMap$a1$copy, reverseUnrolledMap$c = true, reverseUnrolledMap$r;
            while (reverseUnrolledMap$c) {
              const v2 = reverseUnrolledMap$a0, v3 = reverseUnrolledMap$a1;
              if (v2.tag === "Cons") {
                if (v2._1.tag === "Cons") {
                  if (v2._1._2.tag === "Cons") {
                    if (v2._1._2._2.tag === "Cons") {
                      reverseUnrolledMap$a0 = v2._2;
                      reverseUnrolledMap$a1 = $List("Cons", f(v2._1._1), $List("Cons", f(v2._1._2._1), $List("Cons", f(v2._1._2._2._1), v3)));
                      continue;
                    }
                    reverseUnrolledMap$c = false;
                    reverseUnrolledMap$r = v3;
                    continue;
                  }
                  reverseUnrolledMap$c = false;
                  reverseUnrolledMap$r = v3;
                  continue;
                }
                reverseUnrolledMap$c = false;
                reverseUnrolledMap$r = v3;
                continue;
              }
              reverseUnrolledMap$c = false;
              reverseUnrolledMap$r = v3;
              continue;
            }
            ;
            return reverseUnrolledMap$r;
          };
          return reverseUnrolledMap(chunksAcc)((() => {
            if (xs.tag === "Cons") {
              if (xs._2.tag === "Cons") {
                if (xs._2._2.tag === "Nil") {
                  return $List("Cons", f(xs._1), $List("Cons", f(xs._2._1), Nil));
                }
                return Nil;
              }
              if (xs._2.tag === "Nil") {
                return $List("Cons", f(xs._1), Nil);
              }
              return Nil;
            }
            return Nil;
          })());
        };
        if (v1.tag === "Cons") {
          if (v1._2.tag === "Cons") {
            if (v1._2._2.tag === "Cons") {
              chunkedRevMap$a0 = $List("Cons", v1, v);
              chunkedRevMap$a1 = v1._2._2._2;
              continue;
            }
            chunkedRevMap$c = false;
            chunkedRevMap$r = $4(v, v1);
            continue;
          }
          chunkedRevMap$c = false;
          chunkedRevMap$r = $4(v, v1);
          continue;
        }
        chunkedRevMap$c = false;
        chunkedRevMap$r = $4(v, v1);
        continue;
      }
      ;
      return chunkedRevMap$r;
    };
    return chunkedRevMap(Nil);
  };
  var functorList = { map: listMap };
  var functorNonEmptyList = /* @__PURE__ */ functorNonEmpty(functorList);
  var foldableList = {
    foldr: (f) => (b) => {
      const $2 = foldableList.foldl((b$1) => (a) => f(a)(b$1))(b);
      const $3 = (() => {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const v = go$a0, v1 = go$a1;
            if (v1.tag === "Nil") {
              go$c = false;
              go$r = v;
              continue;
            }
            if (v1.tag === "Cons") {
              go$a0 = $List("Cons", v1._1, v);
              go$a1 = v1._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(Nil);
      })();
      return (x2) => $2($3(x2));
    },
    foldl: (f) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b = go$a0, v = go$a1;
          if (v.tag === "Nil") {
            go$c = false;
            go$r = b;
            continue;
          }
          if (v.tag === "Cons") {
            go$a0 = f(b)(v._1);
            go$a1 = v._2;
            continue;
          }
          fail();
        }
        ;
        return go$r;
      };
      return go;
    },
    foldMap: (dictMonoid) => {
      const append2 = dictMonoid.Semigroup0().append;
      return (f) => foldableList.foldl((acc) => {
        const $4 = append2(acc);
        return (x2) => $4(f(x2));
      })(dictMonoid.mempty);
    }
  };
  var foldableNonEmptyList = {
    foldMap: (dictMonoid) => {
      const append1 = dictMonoid.Semigroup0().append;
      const foldMap1 = foldableList.foldMap(dictMonoid);
      return (f) => (v) => append1(f(v._1))(foldMap1(f)(v._2));
    },
    foldl: (f) => (b) => (v) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const b$1 = go$a0, v$1 = go$a1;
          if (v$1.tag === "Nil") {
            go$c = false;
            go$r = b$1;
            continue;
          }
          if (v$1.tag === "Cons") {
            go$a0 = f(b$1)(v$1._1);
            go$a1 = v$1._2;
            continue;
          }
          fail();
        }
        ;
        return go$r;
      };
      return go(f(b)(v._1))(v._2);
    },
    foldr: (f) => (b) => (v) => f(v._1)(foldableList.foldr(f)(b)(v._2))
  };
  var semigroupNonEmptyList = { append: (v) => (as$p) => $NonEmpty(v._1, foldableList.foldr(Cons)($List("Cons", as$p._1, as$p._2))(v._2)) };
  var traversableList = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map1 = Apply0.Functor0().map;
      const map6 = Apply0.Functor0().map;
      return (f) => {
        const $5 = map1((() => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v = go$a1;
              if (v.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v.tag === "Cons") {
                go$a0 = $List("Cons", v._1, b);
                go$a1 = v._2;
                continue;
              }
              fail();
            }
            ;
            return go$r;
          };
          return go(Nil);
        })());
        const $6 = (() => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v = go$a1;
              if (v.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v.tag === "Cons") {
                go$a0 = Apply0.apply(map6((b$1) => (a) => $List("Cons", a, b$1))(b))(f(v._1));
                go$a1 = v._2;
                continue;
              }
              fail();
            }
            ;
            return go$r;
          };
          return go(dictApplicative.pure(Nil));
        })();
        return (x2) => $5($6(x2));
      };
    },
    sequence: (dictApplicative) => traversableList.traverse(dictApplicative)(identity6),
    Functor0: () => functorList,
    Foldable1: () => foldableList
  };
  var traversableNonEmptyList = /* @__PURE__ */ traversableNonEmpty(traversableList);
  var unfoldable1List = {
    unfoldr1: (f) => (b) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const source2 = go$a0, memo = go$a1;
          const v = f(source2);
          if (v._2.tag === "Just") {
            go$a0 = v._2._1;
            go$a1 = $List("Cons", v._1, memo);
            continue;
          }
          if (v._2.tag === "Nothing") {
            const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
              let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
              while (go$1$c) {
                const b$1 = go$1$a0, v$1 = go$1$a1;
                if (v$1.tag === "Nil") {
                  go$1$c = false;
                  go$1$r = b$1;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$1$a0 = $List("Cons", v$1._1, b$1);
                  go$1$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              ;
              return go$1$r;
            };
            go$c = false;
            go$r = go$1(Nil)($List("Cons", v._1, memo));
            continue;
          }
          fail();
        }
        ;
        return go$r;
      };
      return go(b)(Nil);
    }
  };
  var unfoldableList = {
    unfoldr: (f) => (b) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const source2 = go$a0, memo = go$a1;
          const v = f(source2);
          if (v.tag === "Nothing") {
            const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
              let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
              while (go$1$c) {
                const b$1 = go$1$a0, v$1 = go$1$a1;
                if (v$1.tag === "Nil") {
                  go$1$c = false;
                  go$1$r = b$1;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$1$a0 = $List("Cons", v$1._1, b$1);
                  go$1$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              ;
              return go$1$r;
            };
            go$c = false;
            go$r = go$1(Nil)(memo);
            continue;
          }
          if (v.tag === "Just") {
            go$a0 = v._1._2;
            go$a1 = $List("Cons", v._1._1, memo);
            continue;
          }
          fail();
        }
        ;
        return go$r;
      };
      return go(b)(Nil);
    },
    Unfoldable10: () => unfoldable1List
  };
  var eq1List = {
    eq1: (dictEq) => (xs) => (ys) => {
      const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$c = true, go$r;
        while (go$c) {
          const v = go$a0, v1 = go$a1, v2 = go$a2;
          if (!v2) {
            go$c = false;
            go$r = false;
            continue;
          }
          if (v.tag === "Nil") {
            if (v1.tag === "Nil") {
              go$c = false;
              go$r = v2;
              continue;
            }
            go$c = false;
            go$r = false;
            continue;
          }
          if (v.tag === "Cons") {
            if (v1.tag === "Cons") {
              go$a0 = v._2;
              go$a1 = v1._2;
              go$a2 = v2 && dictEq.eq(v1._1)(v._1);
              continue;
            }
            go$c = false;
            go$r = false;
            continue;
          }
          go$c = false;
          go$r = false;
          continue;
        }
        ;
        return go$r;
      };
      return go(xs)(ys)(true);
    }
  };
  var ord1List = {
    compare1: (dictOrd) => (xs) => (ys) => {
      const go = (go$a0$copy) => (go$a1$copy) => {
        let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
        while (go$c) {
          const v = go$a0, v1 = go$a1;
          if (v.tag === "Nil") {
            if (v1.tag === "Nil") {
              go$c = false;
              go$r = EQ;
              continue;
            }
            go$c = false;
            go$r = LT;
            continue;
          }
          if (v1.tag === "Nil") {
            go$c = false;
            go$r = GT;
            continue;
          }
          if (v.tag === "Cons") {
            if (v1.tag === "Cons") {
              const v2 = dictOrd.compare(v._1)(v1._1);
              if (v2.tag === "EQ") {
                go$a0 = v._2;
                go$a1 = v1._2;
                continue;
              }
              go$c = false;
              go$r = v2;
              continue;
            }
            fail();
          }
          fail();
        }
        ;
        return go$r;
      };
      return go(xs)(ys);
    },
    Eq10: () => eq1List
  };
  var ordList = (dictOrd) => {
    const $1 = dictOrd.Eq0();
    const eqList1 = {
      eq: (xs) => (ys) => {
        const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$c = true, go$r;
          while (go$c) {
            const v = go$a0, v1 = go$a1, v2 = go$a2;
            if (!v2) {
              go$c = false;
              go$r = false;
              continue;
            }
            if (v.tag === "Nil") {
              if (v1.tag === "Nil") {
                go$c = false;
                go$r = v2;
                continue;
              }
              go$c = false;
              go$r = false;
              continue;
            }
            if (v.tag === "Cons") {
              if (v1.tag === "Cons") {
                go$a0 = v._2;
                go$a1 = v1._2;
                go$a2 = v2 && $1.eq(v1._1)(v._1);
                continue;
              }
              go$c = false;
              go$r = false;
              continue;
            }
            go$c = false;
            go$r = false;
            continue;
          }
          ;
          return go$r;
        };
        return go(xs)(ys)(true);
      }
    };
    return { compare: ord1List.compare1(dictOrd), Eq0: () => eqList1 };
  };
  var applyList = {
    apply: (v) => (v1) => {
      if (v.tag === "Nil") {
        return Nil;
      }
      if (v.tag === "Cons") {
        return foldableList.foldr(Cons)(applyList.apply(v._2)(v1))(listMap(v._1)(v1));
      }
      fail();
    },
    Functor0: () => functorList
  };
  var bindList = {
    bind: (v) => (v1) => {
      if (v.tag === "Nil") {
        return Nil;
      }
      if (v.tag === "Cons") {
        return foldableList.foldr(Cons)(bindList.bind(v._2)(v1))(v1(v._1));
      }
      fail();
    },
    Apply0: () => applyList
  };
  var applicativeList = { pure: (a) => $List("Cons", a, Nil), Apply0: () => applyList };

  // output-es/Data.List/index.js
  var identity7 = (x2) => x2;
  var updateAt = (v) => (v1) => (v2) => {
    if (v2.tag === "Cons") {
      if (v === 0) {
        return $Maybe("Just", $List("Cons", v1, v2._2));
      }
      const $3 = updateAt(v - 1 | 0)(v1)(v2._2);
      if ($3.tag === "Just") {
        return $Maybe("Just", $List("Cons", v2._1, $3._1));
      }
      return Nothing;
    }
    return Nothing;
  };
  var unzip = /* @__PURE__ */ (() => foldableList.foldr((v) => (v1) => $Tuple(
    $List("Cons", v._1, v1._1),
    $List("Cons", v._2, v1._2)
  ))($Tuple(Nil, Nil)))();
  var toUnfoldable = (dictUnfoldable) => dictUnfoldable.unfoldr((xs) => {
    if (xs.tag === "Nil") {
      return Nothing;
    }
    if (xs.tag === "Cons") {
      return $Maybe("Just", $Tuple(xs._1, xs._2));
    }
    fail();
  });
  var span = (v) => (v1) => {
    if (v1.tag === "Cons") {
      if (v(v1._1)) {
        const v2 = span(v)(v1._2);
        return { init: $List("Cons", v1._1, v2.init), rest: v2.rest };
      }
      return { init: Nil, rest: v1 };
    }
    return { init: Nil, rest: v1 };
  };
  var sortBy = (cmp) => {
    const merge = (v) => (v1) => {
      if (v.tag === "Cons") {
        if (v1.tag === "Cons") {
          if (cmp(v._1)(v1._1).tag === "GT") {
            return $List("Cons", v1._1, merge(v)(v1._2));
          }
          return $List("Cons", v._1, merge(v._2)(v1));
        }
        if (v1.tag === "Nil") {
          return v;
        }
        fail();
      }
      if (v.tag === "Nil") {
        return v1;
      }
      if (v1.tag === "Nil") {
        return v;
      }
      fail();
    };
    const mergePairs = (v) => {
      if (v.tag === "Cons") {
        if (v._2.tag === "Cons") {
          return $List("Cons", merge(v._1)(v._2._1), mergePairs(v._2._2));
        }
        return v;
      }
      return v;
    };
    const mergeAll = (mergeAll$a0$copy) => {
      let mergeAll$a0 = mergeAll$a0$copy, mergeAll$c = true, mergeAll$r;
      while (mergeAll$c) {
        const v = mergeAll$a0;
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            mergeAll$c = false;
            mergeAll$r = v._1;
            continue;
          }
          mergeAll$a0 = mergePairs(v);
          continue;
        }
        mergeAll$a0 = mergePairs(v);
        continue;
      }
      ;
      return mergeAll$r;
    };
    const $sequedesceascen = ($sequedesceascen$b$copy, $sequedesceascen$a0$copy, $sequedesceascen$a1$copy, $sequedesceascen$a2$copy) => {
      let $sequedesceascen$b = $sequedesceascen$b$copy;
      let $sequedesceascen$a0 = $sequedesceascen$a0$copy;
      let $sequedesceascen$a1 = $sequedesceascen$a1$copy;
      let $sequedesceascen$a2 = $sequedesceascen$a2$copy;
      let $sequedesceascen$c = true;
      let $sequedesceascen$r;
      while ($sequedesceascen$c) {
        if ($sequedesceascen$b === 0) {
          const v = $sequedesceascen$a0;
          if (v.tag === "Cons") {
            if (v._2.tag === "Cons") {
              if (cmp(v._1)(v._2._1).tag === "GT") {
                $sequedesceascen$b = 1;
                $sequedesceascen$a0 = v._2._1;
                $sequedesceascen$a1 = $List("Cons", v._1, Nil);
                $sequedesceascen$a2 = v._2._2;
                continue;
              }
              $sequedesceascen$b = 2;
              $sequedesceascen$a0 = v._2._1;
              $sequedesceascen$a1 = (v1) => $List("Cons", v._1, v1);
              $sequedesceascen$a2 = v._2._2;
              continue;
            }
            $sequedesceascen$c = false;
            $sequedesceascen$r = $List("Cons", v, Nil);
            continue;
          }
          $sequedesceascen$c = false;
          $sequedesceascen$r = $List("Cons", v, Nil);
          continue;
        }
        if ($sequedesceascen$b === 1) {
          const v = $sequedesceascen$a0, v1 = $sequedesceascen$a1, v2 = $sequedesceascen$a2;
          if (v2.tag === "Cons") {
            if (cmp(v)(v2._1).tag === "GT") {
              $sequedesceascen$b = 1;
              $sequedesceascen$a0 = v2._1;
              $sequedesceascen$a1 = $List("Cons", v, v1);
              $sequedesceascen$a2 = v2._2;
              continue;
            }
            $sequedesceascen$c = false;
            $sequedesceascen$r = $List("Cons", $List("Cons", v, v1), sequences(v2));
            continue;
          }
          $sequedesceascen$c = false;
          $sequedesceascen$r = $List("Cons", $List("Cons", v, v1), sequences(v2));
          continue;
        }
        if ($sequedesceascen$b === 2) {
          const v = $sequedesceascen$a0, v1 = $sequedesceascen$a1, v2 = $sequedesceascen$a2;
          if (v2.tag === "Cons") {
            if ((() => {
              const $8 = cmp(v)(v2._1);
              return $8.tag === "LT" || !($8.tag === "GT");
            })()) {
              $sequedesceascen$b = 2;
              $sequedesceascen$a0 = v2._1;
              $sequedesceascen$a1 = (ys) => v1($List("Cons", v, ys));
              $sequedesceascen$a2 = v2._2;
              continue;
            }
            $sequedesceascen$c = false;
            $sequedesceascen$r = $List("Cons", v1($List("Cons", v, Nil)), sequences(v2));
            continue;
          }
          $sequedesceascen$c = false;
          $sequedesceascen$r = $List("Cons", v1($List("Cons", v, Nil)), sequences(v2));
          continue;
        }
      }
      ;
      return $sequedesceascen$r;
    };
    const sequences = (v) => $sequedesceascen(0, v);
    const descending = (v) => (v1) => (v2) => $sequedesceascen(1, v, v1, v2);
    const ascending3 = (v) => (v1) => (v2) => $sequedesceascen(2, v, v1, v2);
    return (x2) => mergeAll(sequences(x2));
  };
  var reverse = /* @__PURE__ */ (() => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v1.tag === "Nil") {
          go$c = false;
          go$r = v;
          continue;
        }
        if (v1.tag === "Cons") {
          go$a0 = $List("Cons", v1._1, v);
          go$a1 = v1._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go(Nil);
  })();
  var unsnoc = (lst) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            go$c = false;
            go$r = $Maybe("Just", { revInit: v1, last: v._1 });
            continue;
          }
          go$a0 = v._2;
          go$a1 = $List("Cons", v._1, v1);
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    const $2 = go(lst)(Nil);
    if ($2.tag === "Just") {
      return $Maybe("Just", { init: reverse($2._1.revInit), last: $2._1.last });
    }
    return Nothing;
  };
  var zipWith = (f) => (xs) => (ys) => {
    const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1, v2 = go$a2;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = v2;
          continue;
        }
        if (v1.tag === "Nil") {
          go$c = false;
          go$r = v2;
          continue;
        }
        if (v.tag === "Cons") {
          if (v1.tag === "Cons") {
            go$a0 = v._2;
            go$a1 = v1._2;
            go$a2 = $List("Cons", f(v._1)(v1._1), v2);
            continue;
          }
          fail();
        }
        fail();
      }
      ;
      return go$r;
    };
    return reverse(go(xs)(ys)(Nil));
  };
  var range = (start2) => (end) => {
    if (start2 === end) {
      return $List("Cons", start2, Nil);
    }
    const go = (go$a0$copy) => (go$a1$copy) => (go$a2$copy) => (go$a3$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$a2 = go$a2$copy, go$a3 = go$a3$copy, go$c = true, go$r;
      while (go$c) {
        const s = go$a0, e = go$a1, step = go$a2, rest = go$a3;
        if (s === e) {
          go$c = false;
          go$r = $List("Cons", s, rest);
          continue;
        }
        go$a0 = s + step | 0;
        go$a1 = e;
        go$a2 = step;
        go$a3 = $List("Cons", s, rest);
        continue;
      }
      ;
      return go$r;
    };
    return go(end)(start2)((() => {
      if (start2 > end) {
        return 1;
      }
      return -1;
    })())(Nil);
  };
  var manyRec = (dictMonadRec) => {
    const bind12 = dictMonadRec.Monad0().Bind1().bind;
    return (dictAlternative) => {
      const Alt0 = dictAlternative.Plus1().Alt0();
      const map1 = Alt0.Functor0().map;
      const pure2 = dictAlternative.Applicative0().pure;
      return (p) => dictMonadRec.tailRecM((acc) => bind12(Alt0.alt(map1(Loop)(p))(pure2($Step("Done", unit2))))((aa) => pure2(bifunctorStep.bimap((v) => $List(
        "Cons",
        v,
        acc
      ))((v) => reverse(acc))(aa))))(Nil);
    };
  };
  var some = (dictAlternative) => {
    const apply4 = dictAlternative.Applicative0().Apply0().apply;
    const map1 = dictAlternative.Plus1().Alt0().Functor0().map;
    return (dictLazy) => (v) => apply4(map1(Cons)(v))(dictLazy.defer((v1) => many(dictAlternative)(dictLazy)(v)));
  };
  var many = (dictAlternative) => {
    const alt2 = dictAlternative.Plus1().Alt0().alt;
    const pure2 = dictAlternative.Applicative0().pure;
    return (dictLazy) => (v) => alt2(some(dictAlternative)(dictLazy)(v))(pure2(Nil));
  };
  var index = (index$a0$copy) => (index$a1$copy) => {
    let index$a0 = index$a0$copy, index$a1 = index$a1$copy, index$c = true, index$r;
    while (index$c) {
      const v = index$a0, v1 = index$a1;
      if (v.tag === "Nil") {
        index$c = false;
        index$r = Nothing;
        continue;
      }
      if (v.tag === "Cons") {
        if (v1 === 0) {
          index$c = false;
          index$r = $Maybe("Just", v._1);
          continue;
        }
        index$a0 = v._2;
        index$a1 = v1 - 1 | 0;
        continue;
      }
      fail();
    }
    ;
    return index$r;
  };
  var groupBy = (v) => (v1) => {
    if (v1.tag === "Nil") {
      return Nil;
    }
    if (v1.tag === "Cons") {
      const v2 = span(v(v1._1))(v1._2);
      return $List("Cons", $NonEmpty(v1._1, v2.init), groupBy(v)(v2.rest));
    }
    fail();
  };
  var deleteBy2 = (v) => (v1) => (v2) => {
    if (v2.tag === "Nil") {
      return Nil;
    }
    if (v2.tag === "Cons") {
      if (v(v1)(v2._1)) {
        return v2._2;
      }
      return $List("Cons", v2._1, deleteBy2(v)(v1)(v2._2));
    }
    fail();
  };
  var difference = (dictEq) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = deleteBy2(dictEq.eq)(v._1)(b);
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go;
  };

  // output-es/Data.Semigroup/foreign.js
  var concatString = function(s1) {
    return function(s2) {
      return s1 + s2;
    };
  };
  var concatArray = function(xs) {
    return function(ys) {
      if (xs.length === 0)
        return ys;
      if (ys.length === 0)
        return xs;
      return xs.concat(ys);
    };
  };

  // output-es/Data.Foldable/foreign.js
  var foldrArray = function(f) {
    return function(init2) {
      return function(xs) {
        var acc = init2;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };
  var foldlArray = function(f) {
    return function(init2) {
      return function(xs) {
        var acc = init2;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };

  // output-es/Data.Foldable/index.js
  var identity8 = (x2) => x2;
  var monoidEndo = /* @__PURE__ */ (() => {
    const semigroupEndo1 = { append: (v) => (v1) => (x2) => v(v1(x2)) };
    return { mempty: (x2) => x2, Semigroup0: () => semigroupEndo1 };
  })();
  var traverse_ = (dictApplicative) => {
    const $1 = dictApplicative.Apply0();
    const map6 = $1.Functor0().map;
    return (dictFoldable) => (f) => dictFoldable.foldr((x2) => {
      const $6 = f(x2);
      return (b) => $1.apply(map6((v) => identity4)($6))(b);
    })(dictApplicative.pure(unit2));
  };
  var foldableTuple = { foldr: (f) => (z) => (v) => f(v._2)(z), foldl: (f) => (z) => (v) => f(z)(v._2), foldMap: (dictMonoid) => (f) => (v) => f(v._2) };
  var foldableArray = {
    foldr: foldrArray,
    foldl: foldlArray,
    foldMap: (dictMonoid) => {
      const append = dictMonoid.Semigroup0().append;
      return (f) => foldableArray.foldr((x2) => (acc) => append(f(x2))(acc))(dictMonoid.mempty);
    }
  };
  var foldrDefault = (dictFoldable) => {
    const foldMap2 = dictFoldable.foldMap(monoidEndo);
    return (c) => (u) => (xs) => foldMap2((x2) => c(x2))(xs)(u);
  };

  // output-es/Data.Eq/foreign.js
  var refEq = function(r1) {
    return function(r2) {
      return r1 === r2;
    };
  };
  var eqIntImpl = refEq;
  var eqNumberImpl = refEq;
  var eqCharImpl = refEq;
  var eqStringImpl = refEq;
  var eqArrayImpl = function(f) {
    return function(xs) {
      return function(ys) {
        if (xs.length !== ys.length)
          return false;
        for (var i = 0; i < xs.length; i++) {
          if (!f(xs[i])(ys[i]))
            return false;
        }
        return true;
      };
    };
  };

  // output-es/Data.Eq/index.js
  var eqUnit = { eq: (v) => (v1) => true };
  var eqString = { eq: eqStringImpl };
  var eqNumber = { eq: eqNumberImpl };
  var eqInt = { eq: eqIntImpl };
  var eqChar = { eq: eqCharImpl };

  // output-es/Data.Lazy/foreign.js
  var defer = function(thunk) {
    var v = null;
    return function() {
      if (thunk === void 0)
        return v;
      v = thunk();
      thunk = void 0;
      return v;
    };
  };
  var force = function(l) {
    return l();
  };

  // output-es/Data.Ord/foreign.js
  var unsafeCompareImpl = function(lt) {
    return function(eq2) {
      return function(gt) {
        return function(x2) {
          return function(y2) {
            return x2 < y2 ? lt : x2 === y2 ? eq2 : gt;
          };
        };
      };
    };
  };
  var ordIntImpl = unsafeCompareImpl;
  var ordStringImpl = unsafeCompareImpl;

  // output-es/Data.Ord/index.js
  var ordString = { compare: /* @__PURE__ */ ordStringImpl(LT)(EQ)(GT), Eq0: () => eqString };
  var ordInt = { compare: /* @__PURE__ */ ordIntImpl(LT)(EQ)(GT), Eq0: () => eqInt };

  // output-es/Data.Unfoldable1/foreign.js
  var unfoldr1ArrayImpl = function(isNothing2) {
    return function(fromJust3) {
      return function(fst2) {
        return function(snd2) {
          return function(f) {
            return function(b) {
              var result = [];
              var value = b;
              while (true) {
                var tuple = f(value);
                result.push(fst2(tuple));
                var maybe = snd2(tuple);
                if (isNothing2(maybe))
                  return result;
                value = fromJust3(maybe);
              }
            };
          };
        };
      };
    };
  };

  // output-es/Data.Unfoldable1/index.js
  var fromJust = (v) => {
    if (v.tag === "Just") {
      return v._1;
    }
    fail();
  };
  var unfoldable1Array = { unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust)(fst)(snd) };

  // output-es/Data.Unfoldable/foreign.js
  var unfoldrArrayImpl = function(isNothing2) {
    return function(fromJust3) {
      return function(fst2) {
        return function(snd2) {
          return function(f) {
            return function(b) {
              var result = [];
              var value = b;
              while (true) {
                var maybe = f(value);
                if (isNothing2(maybe))
                  return result;
                var tuple = fromJust3(maybe);
                result.push(fst2(tuple));
                value = snd2(tuple);
              }
            };
          };
        };
      };
    };
  };

  // output-es/Data.Unfoldable/index.js
  var fromJust2 = (v) => {
    if (v.tag === "Just") {
      return v._1;
    }
    fail();
  };
  var unfoldableArray = {
    unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust2)(fst)(snd),
    Unfoldable10: () => unfoldable1Array
  };
  var replicate = (dictUnfoldable) => (n) => (v) => dictUnfoldable.unfoldr((i) => {
    if (i <= 0) {
      return Nothing;
    }
    return $Maybe("Just", $Tuple(v, i - 1 | 0));
  })(n);

  // output-es/Partial/foreign.js
  var _crashWith = function(msg) {
    throw new Error(msg);
  };

  // output-es/Data.Map.Internal/index.js
  var $KickUp = (_1, _2, _3, _4) => ({ tag: "KickUp", _1, _2, _3, _4 });
  var $Map = (tag, _1, _2, _3, _4, _5, _6, _7) => ({ tag, _1, _2, _3, _4, _5, _6, _7 });
  var $TreeContext = (tag, _1, _2, _3, _4, _5, _6) => ({ tag, _1, _2, _3, _4, _5, _6 });
  var Leaf2 = /* @__PURE__ */ $Map("Leaf");
  var toUnfoldable2 = (dictUnfoldable) => (m) => {
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        if (v.tag === "Cons") {
          if (v._1.tag === "Leaf") {
            go$a0 = v._2;
            continue;
          }
          if (v._1.tag === "Two") {
            if (v._1._1.tag === "Leaf") {
              if (v._1._4.tag === "Leaf") {
                go$c = false;
                go$r = $Maybe("Just", $Tuple($Tuple(v._1._2, v._1._3), v._2));
                continue;
              }
              go$c = false;
              go$r = $Maybe("Just", $Tuple($Tuple(v._1._2, v._1._3), $List("Cons", v._1._4, v._2)));
              continue;
            }
            go$a0 = $List(
              "Cons",
              v._1._1,
              $List("Cons", $Map("Two", Leaf2, v._1._2, v._1._3, Leaf2), $List("Cons", v._1._4, v._2))
            );
            continue;
          }
          if (v._1.tag === "Three") {
            go$a0 = $List(
              "Cons",
              v._1._1,
              $List(
                "Cons",
                $Map("Two", Leaf2, v._1._2, v._1._3, Leaf2),
                $List("Cons", v._1._4, $List("Cons", $Map("Two", Leaf2, v._1._5, v._1._6, Leaf2), $List("Cons", v._1._7, v._2)))
              )
            );
            continue;
          }
          fail();
        }
        fail();
      }
      ;
      return go$r;
    };
    return dictUnfoldable.unfoldr(go)($List("Cons", m, Nil));
  };
  var lookup = (dictOrd) => (k) => {
    const go = (go$a0$copy) => {
      let go$a0 = go$a0$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0;
        if (v.tag === "Leaf") {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        if (v.tag === "Two") {
          const v2 = dictOrd.compare(k)(v._2);
          if (v2.tag === "EQ") {
            go$c = false;
            go$r = $Maybe("Just", v._3);
            continue;
          }
          if (v2.tag === "LT") {
            go$a0 = v._1;
            continue;
          }
          go$a0 = v._4;
          continue;
        }
        if (v.tag === "Three") {
          const v3 = dictOrd.compare(k)(v._2);
          if (v3.tag === "EQ") {
            go$c = false;
            go$r = $Maybe("Just", v._3);
            continue;
          }
          const v4 = dictOrd.compare(k)(v._5);
          if (v4.tag === "EQ") {
            go$c = false;
            go$r = $Maybe("Just", v._6);
            continue;
          }
          if (v3.tag === "LT") {
            go$a0 = v._1;
            continue;
          }
          if (v4.tag === "GT") {
            go$a0 = v._7;
            continue;
          }
          go$a0 = v._4;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go;
  };
  var fromZipper = (fromZipper$a0$copy) => (fromZipper$a1$copy) => (fromZipper$a2$copy) => {
    let fromZipper$a0 = fromZipper$a0$copy, fromZipper$a1 = fromZipper$a1$copy, fromZipper$a2 = fromZipper$a2$copy, fromZipper$c = true, fromZipper$r;
    while (fromZipper$c) {
      const dictOrd = fromZipper$a0, v = fromZipper$a1, v1 = fromZipper$a2;
      if (v.tag === "Nil") {
        fromZipper$c = false;
        fromZipper$r = v1;
        continue;
      }
      if (v.tag === "Cons") {
        if (v._1.tag === "TwoLeft") {
          fromZipper$a0 = dictOrd;
          fromZipper$a1 = v._2;
          fromZipper$a2 = $Map("Two", v1, v._1._1, v._1._2, v._1._3);
          continue;
        }
        if (v._1.tag === "TwoRight") {
          fromZipper$a0 = dictOrd;
          fromZipper$a1 = v._2;
          fromZipper$a2 = $Map("Two", v._1._1, v._1._2, v._1._3, v1);
          continue;
        }
        if (v._1.tag === "ThreeLeft") {
          fromZipper$a0 = dictOrd;
          fromZipper$a1 = v._2;
          fromZipper$a2 = $Map("Three", v1, v._1._1, v._1._2, v._1._3, v._1._4, v._1._5, v._1._6);
          continue;
        }
        if (v._1.tag === "ThreeMiddle") {
          fromZipper$a0 = dictOrd;
          fromZipper$a1 = v._2;
          fromZipper$a2 = $Map("Three", v._1._1, v._1._2, v._1._3, v1, v._1._4, v._1._5, v._1._6);
          continue;
        }
        if (v._1.tag === "ThreeRight") {
          fromZipper$a0 = dictOrd;
          fromZipper$a1 = v._2;
          fromZipper$a2 = $Map("Three", v._1._1, v._1._2, v._1._3, v._1._4, v._1._5, v._1._6, v1);
          continue;
        }
        fail();
      }
      fail();
    }
    ;
    return fromZipper$r;
  };
  var insert2 = (dictOrd) => (k) => (v) => {
    const up = (up$a0$copy) => (up$a1$copy) => {
      let up$a0 = up$a0$copy, up$a1 = up$a1$copy, up$c = true, up$r;
      while (up$c) {
        const v1 = up$a0, v2 = up$a1;
        if (v1.tag === "Nil") {
          up$c = false;
          up$r = $Map("Two", v2._1, v2._2, v2._3, v2._4);
          continue;
        }
        if (v1.tag === "Cons") {
          if (v1._1.tag === "TwoLeft") {
            up$c = false;
            up$r = fromZipper(dictOrd)(v1._2)($Map("Three", v2._1, v2._2, v2._3, v2._4, v1._1._1, v1._1._2, v1._1._3));
            continue;
          }
          if (v1._1.tag === "TwoRight") {
            up$c = false;
            up$r = fromZipper(dictOrd)(v1._2)($Map("Three", v1._1._1, v1._1._2, v1._1._3, v2._1, v2._2, v2._3, v2._4));
            continue;
          }
          if (v1._1.tag === "ThreeLeft") {
            up$a0 = v1._2;
            up$a1 = $KickUp($Map("Two", v2._1, v2._2, v2._3, v2._4), v1._1._1, v1._1._2, $Map("Two", v1._1._3, v1._1._4, v1._1._5, v1._1._6));
            continue;
          }
          if (v1._1.tag === "ThreeMiddle") {
            up$a0 = v1._2;
            up$a1 = $KickUp($Map("Two", v1._1._1, v1._1._2, v1._1._3, v2._1), v2._2, v2._3, $Map("Two", v2._4, v1._1._4, v1._1._5, v1._1._6));
            continue;
          }
          if (v1._1.tag === "ThreeRight") {
            up$a0 = v1._2;
            up$a1 = $KickUp($Map("Two", v1._1._1, v1._1._2, v1._1._3, v1._1._4), v1._1._5, v1._1._6, $Map("Two", v2._1, v2._2, v2._3, v2._4));
            continue;
          }
          fail();
        }
        fail();
      }
      ;
      return up$r;
    };
    const down = (down$a0$copy) => (down$a1$copy) => {
      let down$a0 = down$a0$copy, down$a1 = down$a1$copy, down$c = true, down$r;
      while (down$c) {
        const v1 = down$a0, v2 = down$a1;
        if (v2.tag === "Leaf") {
          down$c = false;
          down$r = up(v1)($KickUp(Leaf2, k, v, Leaf2));
          continue;
        }
        if (v2.tag === "Two") {
          const v3 = dictOrd.compare(k)(v2._2);
          if (v3.tag === "EQ") {
            down$c = false;
            down$r = fromZipper(dictOrd)(v1)($Map("Two", v2._1, k, v, v2._4));
            continue;
          }
          if (v3.tag === "LT") {
            down$a0 = $List("Cons", $TreeContext("TwoLeft", v2._2, v2._3, v2._4), v1);
            down$a1 = v2._1;
            continue;
          }
          down$a0 = $List("Cons", $TreeContext("TwoRight", v2._1, v2._2, v2._3), v1);
          down$a1 = v2._4;
          continue;
        }
        if (v2.tag === "Three") {
          const v3 = dictOrd.compare(k)(v2._2);
          if (v3.tag === "EQ") {
            down$c = false;
            down$r = fromZipper(dictOrd)(v1)($Map("Three", v2._1, k, v, v2._4, v2._5, v2._6, v2._7));
            continue;
          }
          const v4 = dictOrd.compare(k)(v2._5);
          if (v4.tag === "EQ") {
            down$c = false;
            down$r = fromZipper(dictOrd)(v1)($Map("Three", v2._1, v2._2, v2._3, v2._4, k, v, v2._7));
            continue;
          }
          if (v3.tag === "LT") {
            down$a0 = $List("Cons", $TreeContext("ThreeLeft", v2._2, v2._3, v2._4, v2._5, v2._6, v2._7), v1);
            down$a1 = v2._1;
            continue;
          }
          if (v3.tag === "GT") {
            if (v4.tag === "LT") {
              down$a0 = $List("Cons", $TreeContext("ThreeMiddle", v2._1, v2._2, v2._3, v2._5, v2._6, v2._7), v1);
              down$a1 = v2._4;
              continue;
            }
            down$a0 = $List("Cons", $TreeContext("ThreeRight", v2._1, v2._2, v2._3, v2._4, v2._5, v2._6), v1);
            down$a1 = v2._7;
            continue;
          }
          down$a0 = $List("Cons", $TreeContext("ThreeRight", v2._1, v2._2, v2._3, v2._4, v2._5, v2._6), v1);
          down$a1 = v2._7;
          continue;
        }
        fail();
      }
      ;
      return down$r;
    };
    return down(Nil);
  };
  var pop = (dictOrd) => (k) => {
    const up = (up$a0$copy) => (up$a1$copy) => {
      let up$a0 = up$a0$copy, up$a1 = up$a1$copy, up$c = true, up$r;
      while (up$c) {
        const ctxs = up$a0, tree = up$a1;
        if (ctxs.tag === "Nil") {
          up$c = false;
          up$r = tree;
          continue;
        }
        if (ctxs.tag === "Cons") {
          const $5 = (a, b, c, d, k1, k2, k3, v1, v2, v3) => fromZipper(dictOrd)(ctxs._2)($Map("Two", $Map("Two", a, k1, v1, b), k2, v2, $Map("Two", c, k3, v3, d)));
          const $6 = (a, b, c, d, k1, k2, k3, v1, v2, v3) => fromZipper(dictOrd)(ctxs._2)($Map("Two", $Map("Two", a, k1, v1, b), k2, v2, $Map("Two", c, k3, v3, d)));
          const $7 = (a, b, c, d, k1, k2, k3, v1, v2, v3) => fromZipper(dictOrd)(ctxs._2)($Map("Two", $Map("Three", a, k1, v1, b, k2, v2, c), k3, v3, d));
          const $8 = (a, b, c, d, k1, k2, k3, v1, v2, v3) => fromZipper(dictOrd)(ctxs._2)($Map("Two", $Map("Three", a, k1, v1, b, k2, v2, c), k3, v3, d));
          const $9 = (a, b, c, d, k1, k2, k3, v1, v2, v3) => fromZipper(dictOrd)(ctxs._2)($Map("Two", a, k1, v1, $Map("Three", b, k2, v2, c, k3, v3, d)));
          const $10 = (a, b, c, d, k1, k2, k3, v1, v2, v3) => fromZipper(dictOrd)(ctxs._2)($Map("Two", a, k1, v1, $Map("Three", b, k2, v2, c, k3, v3, d)));
          const $11 = (a, b, c, d, e, k1, k2, k3, k4, v1, v2, v3, v4) => fromZipper(dictOrd)(ctxs._2)($Map(
            "Three",
            $Map("Two", a, k1, v1, b),
            k2,
            v2,
            $Map("Two", c, k3, v3, d),
            k4,
            v4,
            e
          ));
          const $12 = (a, b, c, d, e, k1, k2, k3, k4, v1, v2, v3, v4) => fromZipper(dictOrd)(ctxs._2)($Map(
            "Three",
            $Map("Two", a, k1, v1, b),
            k2,
            v2,
            $Map("Two", c, k3, v3, d),
            k4,
            v4,
            e
          ));
          const $13 = (a, b, c, d, e, k1, k2, k3, k4, v1, v2, v3, v4) => fromZipper(dictOrd)(ctxs._2)($Map(
            "Three",
            a,
            k1,
            v1,
            $Map("Two", b, k2, v2, c),
            k3,
            v3,
            $Map("Two", d, k4, v4, e)
          ));
          const $14 = (a, b, c, d, e, k1, k2, k3, k4, v1, v2, v3, v4) => fromZipper(dictOrd)(ctxs._2)($Map(
            "Three",
            a,
            k1,
            v1,
            $Map("Two", b, k2, v2, c),
            k3,
            v3,
            $Map("Two", d, k4, v4, e)
          ));
          if (tree.tag === "Leaf") {
            if (ctxs._1.tag === "TwoLeft") {
              if (ctxs._1._3.tag === "Leaf") {
                up$c = false;
                up$r = fromZipper(dictOrd)(ctxs._2)($Map("Two", Leaf2, ctxs._1._1, ctxs._1._2, Leaf2));
                continue;
              }
              if (ctxs._1._3.tag === "Two") {
                up$a0 = ctxs._2;
                up$a1 = $Map("Three", tree, ctxs._1._1, ctxs._1._2, ctxs._1._3._1, ctxs._1._3._2, ctxs._1._3._3, ctxs._1._3._4);
                continue;
              }
              if (ctxs._1._3.tag === "Three") {
                up$c = false;
                up$r = $5(tree, ctxs._1._3._1, ctxs._1._3._4, ctxs._1._3._7, ctxs._1._1, ctxs._1._3._2, ctxs._1._3._5, ctxs._1._2, ctxs._1._3._3, ctxs._1._3._6);
                continue;
              }
              up$c = false;
              up$r = _crashWith("The impossible happened in partial function `up`.");
              continue;
            }
            if (ctxs._1.tag === "TwoRight") {
              if (ctxs._1._1.tag === "Leaf") {
                up$c = false;
                up$r = fromZipper(dictOrd)(ctxs._2)($Map("Two", Leaf2, ctxs._1._2, ctxs._1._3, Leaf2));
                continue;
              }
              if (ctxs._1._1.tag === "Two") {
                up$a0 = ctxs._2;
                up$a1 = $Map("Three", ctxs._1._1._1, ctxs._1._1._2, ctxs._1._1._3, ctxs._1._1._4, ctxs._1._2, ctxs._1._3, tree);
                continue;
              }
              if (ctxs._1._1.tag === "Three") {
                up$c = false;
                up$r = $6(ctxs._1._1._1, ctxs._1._1._4, ctxs._1._1._7, tree, ctxs._1._1._2, ctxs._1._1._5, ctxs._1._2, ctxs._1._1._3, ctxs._1._1._6, ctxs._1._3);
                continue;
              }
              up$c = false;
              up$r = _crashWith("The impossible happened in partial function `up`.");
              continue;
            }
            if (ctxs._1.tag === "ThreeLeft") {
              if (ctxs._1._6.tag === "Leaf") {
                if (ctxs._1._3.tag === "Leaf") {
                  up$c = false;
                  up$r = fromZipper(dictOrd)(ctxs._2)($Map("Three", Leaf2, ctxs._1._1, ctxs._1._2, Leaf2, ctxs._1._4, ctxs._1._5, Leaf2));
                  continue;
                }
                if (ctxs._1._3.tag === "Two") {
                  up$c = false;
                  up$r = $7(tree, ctxs._1._3._1, ctxs._1._3._4, ctxs._1._6, ctxs._1._1, ctxs._1._3._2, ctxs._1._4, ctxs._1._2, ctxs._1._3._3, ctxs._1._5);
                  continue;
                }
                if (ctxs._1._3.tag === "Three") {
                  up$c = false;
                  up$r = $11(
                    tree,
                    ctxs._1._3._1,
                    ctxs._1._3._4,
                    ctxs._1._3._7,
                    ctxs._1._6,
                    ctxs._1._1,
                    ctxs._1._3._2,
                    ctxs._1._3._5,
                    ctxs._1._4,
                    ctxs._1._2,
                    ctxs._1._3._3,
                    ctxs._1._3._6,
                    ctxs._1._5
                  );
                  continue;
                }
                up$c = false;
                up$r = _crashWith("The impossible happened in partial function `up`.");
                continue;
              }
              if (ctxs._1._3.tag === "Two") {
                up$c = false;
                up$r = $7(tree, ctxs._1._3._1, ctxs._1._3._4, ctxs._1._6, ctxs._1._1, ctxs._1._3._2, ctxs._1._4, ctxs._1._2, ctxs._1._3._3, ctxs._1._5);
                continue;
              }
              if (ctxs._1._3.tag === "Three") {
                up$c = false;
                up$r = $11(
                  tree,
                  ctxs._1._3._1,
                  ctxs._1._3._4,
                  ctxs._1._3._7,
                  ctxs._1._6,
                  ctxs._1._1,
                  ctxs._1._3._2,
                  ctxs._1._3._5,
                  ctxs._1._4,
                  ctxs._1._2,
                  ctxs._1._3._3,
                  ctxs._1._3._6,
                  ctxs._1._5
                );
                continue;
              }
              up$c = false;
              up$r = _crashWith("The impossible happened in partial function `up`.");
              continue;
            }
            if (ctxs._1.tag === "ThreeMiddle") {
              if (ctxs._1._1.tag === "Leaf") {
                if (ctxs._1._6.tag === "Leaf") {
                  up$c = false;
                  up$r = fromZipper(dictOrd)(ctxs._2)($Map("Three", Leaf2, ctxs._1._2, ctxs._1._3, Leaf2, ctxs._1._4, ctxs._1._5, Leaf2));
                  continue;
                }
                if (ctxs._1._6.tag === "Two") {
                  up$c = false;
                  up$r = $9(ctxs._1._1, tree, ctxs._1._6._1, ctxs._1._6._4, ctxs._1._2, ctxs._1._4, ctxs._1._6._2, ctxs._1._3, ctxs._1._5, ctxs._1._6._3);
                  continue;
                }
                if (ctxs._1._6.tag === "Three") {
                  up$c = false;
                  up$r = $13(
                    ctxs._1._1,
                    tree,
                    ctxs._1._6._1,
                    ctxs._1._6._4,
                    ctxs._1._6._7,
                    ctxs._1._2,
                    ctxs._1._4,
                    ctxs._1._6._2,
                    ctxs._1._6._5,
                    ctxs._1._3,
                    ctxs._1._5,
                    ctxs._1._6._3,
                    ctxs._1._6._6
                  );
                  continue;
                }
                up$c = false;
                up$r = _crashWith("The impossible happened in partial function `up`.");
                continue;
              }
              if (ctxs._1._1.tag === "Two") {
                up$c = false;
                up$r = $8(ctxs._1._1._1, ctxs._1._1._4, tree, ctxs._1._6, ctxs._1._1._2, ctxs._1._2, ctxs._1._4, ctxs._1._1._3, ctxs._1._3, ctxs._1._5);
                continue;
              }
              if (ctxs._1._6.tag === "Two") {
                up$c = false;
                up$r = $9(ctxs._1._1, tree, ctxs._1._6._1, ctxs._1._6._4, ctxs._1._2, ctxs._1._4, ctxs._1._6._2, ctxs._1._3, ctxs._1._5, ctxs._1._6._3);
                continue;
              }
              if (ctxs._1._1.tag === "Three") {
                up$c = false;
                up$r = $12(
                  ctxs._1._1._1,
                  ctxs._1._1._4,
                  ctxs._1._1._7,
                  tree,
                  ctxs._1._6,
                  ctxs._1._1._2,
                  ctxs._1._1._5,
                  ctxs._1._2,
                  ctxs._1._4,
                  ctxs._1._1._3,
                  ctxs._1._1._6,
                  ctxs._1._3,
                  ctxs._1._5
                );
                continue;
              }
              if (ctxs._1._6.tag === "Three") {
                up$c = false;
                up$r = $13(
                  ctxs._1._1,
                  tree,
                  ctxs._1._6._1,
                  ctxs._1._6._4,
                  ctxs._1._6._7,
                  ctxs._1._2,
                  ctxs._1._4,
                  ctxs._1._6._2,
                  ctxs._1._6._5,
                  ctxs._1._3,
                  ctxs._1._5,
                  ctxs._1._6._3,
                  ctxs._1._6._6
                );
                continue;
              }
              up$c = false;
              up$r = _crashWith("The impossible happened in partial function `up`.");
              continue;
            }
            if (ctxs._1.tag === "ThreeRight") {
              if (ctxs._1._1.tag === "Leaf") {
                if (ctxs._1._4.tag === "Leaf") {
                  up$c = false;
                  up$r = fromZipper(dictOrd)(ctxs._2)($Map("Three", Leaf2, ctxs._1._2, ctxs._1._3, Leaf2, ctxs._1._5, ctxs._1._6, Leaf2));
                  continue;
                }
                if (ctxs._1._4.tag === "Two") {
                  up$c = false;
                  up$r = $10(ctxs._1._1, ctxs._1._4._1, ctxs._1._4._4, tree, ctxs._1._2, ctxs._1._4._2, ctxs._1._5, ctxs._1._3, ctxs._1._4._3, ctxs._1._6);
                  continue;
                }
                if (ctxs._1._4.tag === "Three") {
                  up$c = false;
                  up$r = $14(
                    ctxs._1._1,
                    ctxs._1._4._1,
                    ctxs._1._4._4,
                    ctxs._1._4._7,
                    tree,
                    ctxs._1._2,
                    ctxs._1._4._2,
                    ctxs._1._4._5,
                    ctxs._1._5,
                    ctxs._1._3,
                    ctxs._1._4._3,
                    ctxs._1._4._6,
                    ctxs._1._6
                  );
                  continue;
                }
                up$c = false;
                up$r = _crashWith("The impossible happened in partial function `up`.");
                continue;
              }
              if (ctxs._1._4.tag === "Two") {
                up$c = false;
                up$r = $10(ctxs._1._1, ctxs._1._4._1, ctxs._1._4._4, tree, ctxs._1._2, ctxs._1._4._2, ctxs._1._5, ctxs._1._3, ctxs._1._4._3, ctxs._1._6);
                continue;
              }
              if (ctxs._1._4.tag === "Three") {
                up$c = false;
                up$r = $14(
                  ctxs._1._1,
                  ctxs._1._4._1,
                  ctxs._1._4._4,
                  ctxs._1._4._7,
                  tree,
                  ctxs._1._2,
                  ctxs._1._4._2,
                  ctxs._1._4._5,
                  ctxs._1._5,
                  ctxs._1._3,
                  ctxs._1._4._3,
                  ctxs._1._4._6,
                  ctxs._1._6
                );
                continue;
              }
              up$c = false;
              up$r = _crashWith("The impossible happened in partial function `up`.");
              continue;
            }
            up$c = false;
            up$r = _crashWith("The impossible happened in partial function `up`.");
            continue;
          }
          if (ctxs._1.tag === "TwoLeft") {
            if (ctxs._1._3.tag === "Two") {
              up$a0 = ctxs._2;
              up$a1 = $Map("Three", tree, ctxs._1._1, ctxs._1._2, ctxs._1._3._1, ctxs._1._3._2, ctxs._1._3._3, ctxs._1._3._4);
              continue;
            }
            if (ctxs._1._3.tag === "Three") {
              up$c = false;
              up$r = $5(tree, ctxs._1._3._1, ctxs._1._3._4, ctxs._1._3._7, ctxs._1._1, ctxs._1._3._2, ctxs._1._3._5, ctxs._1._2, ctxs._1._3._3, ctxs._1._3._6);
              continue;
            }
            up$c = false;
            up$r = _crashWith("The impossible happened in partial function `up`.");
            continue;
          }
          if (ctxs._1.tag === "TwoRight") {
            if (ctxs._1._1.tag === "Two") {
              up$a0 = ctxs._2;
              up$a1 = $Map("Three", ctxs._1._1._1, ctxs._1._1._2, ctxs._1._1._3, ctxs._1._1._4, ctxs._1._2, ctxs._1._3, tree);
              continue;
            }
            if (ctxs._1._1.tag === "Three") {
              up$c = false;
              up$r = $6(ctxs._1._1._1, ctxs._1._1._4, ctxs._1._1._7, tree, ctxs._1._1._2, ctxs._1._1._5, ctxs._1._2, ctxs._1._1._3, ctxs._1._1._6, ctxs._1._3);
              continue;
            }
            up$c = false;
            up$r = _crashWith("The impossible happened in partial function `up`.");
            continue;
          }
          if (ctxs._1.tag === "ThreeLeft") {
            if (ctxs._1._3.tag === "Two") {
              up$c = false;
              up$r = $7(tree, ctxs._1._3._1, ctxs._1._3._4, ctxs._1._6, ctxs._1._1, ctxs._1._3._2, ctxs._1._4, ctxs._1._2, ctxs._1._3._3, ctxs._1._5);
              continue;
            }
            if (ctxs._1._3.tag === "Three") {
              up$c = false;
              up$r = $11(
                tree,
                ctxs._1._3._1,
                ctxs._1._3._4,
                ctxs._1._3._7,
                ctxs._1._6,
                ctxs._1._1,
                ctxs._1._3._2,
                ctxs._1._3._5,
                ctxs._1._4,
                ctxs._1._2,
                ctxs._1._3._3,
                ctxs._1._3._6,
                ctxs._1._5
              );
              continue;
            }
            up$c = false;
            up$r = _crashWith("The impossible happened in partial function `up`.");
            continue;
          }
          if (ctxs._1.tag === "ThreeMiddle") {
            if (ctxs._1._1.tag === "Two") {
              up$c = false;
              up$r = $8(ctxs._1._1._1, ctxs._1._1._4, tree, ctxs._1._6, ctxs._1._1._2, ctxs._1._2, ctxs._1._4, ctxs._1._1._3, ctxs._1._3, ctxs._1._5);
              continue;
            }
            if (ctxs._1._6.tag === "Two") {
              up$c = false;
              up$r = $9(ctxs._1._1, tree, ctxs._1._6._1, ctxs._1._6._4, ctxs._1._2, ctxs._1._4, ctxs._1._6._2, ctxs._1._3, ctxs._1._5, ctxs._1._6._3);
              continue;
            }
            if (ctxs._1._1.tag === "Three") {
              up$c = false;
              up$r = $12(
                ctxs._1._1._1,
                ctxs._1._1._4,
                ctxs._1._1._7,
                tree,
                ctxs._1._6,
                ctxs._1._1._2,
                ctxs._1._1._5,
                ctxs._1._2,
                ctxs._1._4,
                ctxs._1._1._3,
                ctxs._1._1._6,
                ctxs._1._3,
                ctxs._1._5
              );
              continue;
            }
            if (ctxs._1._6.tag === "Three") {
              up$c = false;
              up$r = $13(
                ctxs._1._1,
                tree,
                ctxs._1._6._1,
                ctxs._1._6._4,
                ctxs._1._6._7,
                ctxs._1._2,
                ctxs._1._4,
                ctxs._1._6._2,
                ctxs._1._6._5,
                ctxs._1._3,
                ctxs._1._5,
                ctxs._1._6._3,
                ctxs._1._6._6
              );
              continue;
            }
            up$c = false;
            up$r = _crashWith("The impossible happened in partial function `up`.");
            continue;
          }
          if (ctxs._1.tag === "ThreeRight") {
            if (ctxs._1._4.tag === "Two") {
              up$c = false;
              up$r = $10(ctxs._1._1, ctxs._1._4._1, ctxs._1._4._4, tree, ctxs._1._2, ctxs._1._4._2, ctxs._1._5, ctxs._1._3, ctxs._1._4._3, ctxs._1._6);
              continue;
            }
            if (ctxs._1._4.tag === "Three") {
              up$c = false;
              up$r = $14(
                ctxs._1._1,
                ctxs._1._4._1,
                ctxs._1._4._4,
                ctxs._1._4._7,
                tree,
                ctxs._1._2,
                ctxs._1._4._2,
                ctxs._1._4._5,
                ctxs._1._5,
                ctxs._1._3,
                ctxs._1._4._3,
                ctxs._1._4._6,
                ctxs._1._6
              );
              continue;
            }
            up$c = false;
            up$r = _crashWith("The impossible happened in partial function `up`.");
            continue;
          }
          up$c = false;
          up$r = _crashWith("The impossible happened in partial function `up`.");
          continue;
        }
        fail();
      }
      ;
      return up$r;
    };
    const removeMaxNode = (removeMaxNode$a0$copy) => (removeMaxNode$a1$copy) => {
      let removeMaxNode$a0 = removeMaxNode$a0$copy, removeMaxNode$a1 = removeMaxNode$a1$copy, removeMaxNode$c = true, removeMaxNode$r;
      while (removeMaxNode$c) {
        const ctx = removeMaxNode$a0, m = removeMaxNode$a1;
        if (m.tag === "Two") {
          if (m._1.tag === "Leaf") {
            if (m._4.tag === "Leaf") {
              removeMaxNode$c = false;
              removeMaxNode$r = up(ctx)(Leaf2);
              continue;
            }
            removeMaxNode$a0 = $List("Cons", $TreeContext("TwoRight", m._1, m._2, m._3), ctx);
            removeMaxNode$a1 = m._4;
            continue;
          }
          removeMaxNode$a0 = $List("Cons", $TreeContext("TwoRight", m._1, m._2, m._3), ctx);
          removeMaxNode$a1 = m._4;
          continue;
        }
        if (m.tag === "Three") {
          if (m._1.tag === "Leaf") {
            if (m._4.tag === "Leaf") {
              if (m._7.tag === "Leaf") {
                removeMaxNode$c = false;
                removeMaxNode$r = up($List("Cons", $TreeContext("TwoRight", Leaf2, m._2, m._3), ctx))(Leaf2);
                continue;
              }
              removeMaxNode$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
              removeMaxNode$a1 = m._7;
              continue;
            }
            removeMaxNode$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
            removeMaxNode$a1 = m._7;
            continue;
          }
          removeMaxNode$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
          removeMaxNode$a1 = m._7;
          continue;
        }
        removeMaxNode$c = false;
        removeMaxNode$r = _crashWith("The impossible happened in partial function `removeMaxNode`.");
        continue;
      }
      ;
      return removeMaxNode$r;
    };
    const maxNode = (maxNode$a0$copy) => {
      let maxNode$a0 = maxNode$a0$copy, maxNode$c = true, maxNode$r;
      while (maxNode$c) {
        const m = maxNode$a0;
        if (m.tag === "Two") {
          if (m._4.tag === "Leaf") {
            maxNode$c = false;
            maxNode$r = { key: m._2, value: m._3 };
            continue;
          }
          maxNode$a0 = m._4;
          continue;
        }
        if (m.tag === "Three") {
          if (m._7.tag === "Leaf") {
            maxNode$c = false;
            maxNode$r = { key: m._5, value: m._6 };
            continue;
          }
          maxNode$a0 = m._7;
          continue;
        }
        maxNode$c = false;
        maxNode$r = _crashWith("The impossible happened in partial function `maxNode`.");
        continue;
      }
      ;
      return maxNode$r;
    };
    const down = (down$a0$copy) => (down$a1$copy) => {
      let down$a0 = down$a0$copy, down$a1 = down$a1$copy, down$c = true, down$r;
      while (down$c) {
        const ctx = down$a0, m = down$a1;
        if (m.tag === "Leaf") {
          down$c = false;
          down$r = Nothing;
          continue;
        }
        if (m.tag === "Two") {
          const v = dictOrd.compare(k)(m._2);
          if (v.tag === "EQ") {
            if (m._4.tag === "Leaf") {
              down$c = false;
              down$r = $Maybe("Just", $Tuple(m._3, up(ctx)(Leaf2)));
              continue;
            }
            const max4 = maxNode(m._1);
            down$c = false;
            down$r = $Maybe(
              "Just",
              $Tuple(m._3, removeMaxNode($List("Cons", $TreeContext("TwoLeft", max4.key, max4.value, m._4), ctx))(m._1))
            );
            continue;
          }
          if (v.tag === "LT") {
            down$a0 = $List("Cons", $TreeContext("TwoLeft", m._2, m._3, m._4), ctx);
            down$a1 = m._1;
            continue;
          }
          down$a0 = $List("Cons", $TreeContext("TwoRight", m._1, m._2, m._3), ctx);
          down$a1 = m._4;
          continue;
        }
        if (m.tag === "Three") {
          const v = dictOrd.compare(k)(m._5);
          const v3 = dictOrd.compare(k)(m._2);
          if ((() => {
            if (m._1.tag === "Leaf") {
              if (m._4.tag === "Leaf") {
                return m._7.tag === "Leaf";
              }
              return false;
            }
            return false;
          })()) {
            if (v3.tag === "EQ") {
              down$c = false;
              down$r = $Maybe("Just", $Tuple(m._3, fromZipper(dictOrd)(ctx)($Map("Two", Leaf2, m._5, m._6, Leaf2))));
              continue;
            }
            if (v.tag === "EQ") {
              down$c = false;
              down$r = $Maybe("Just", $Tuple(m._6, fromZipper(dictOrd)(ctx)($Map("Two", Leaf2, m._2, m._3, Leaf2))));
              continue;
            }
            if (v3.tag === "LT") {
              down$a0 = $List("Cons", $TreeContext("ThreeLeft", m._2, m._3, m._4, m._5, m._6, m._7), ctx);
              down$a1 = m._1;
              continue;
            }
            if (v3.tag === "GT") {
              if (v.tag === "LT") {
                down$a0 = $List("Cons", $TreeContext("ThreeMiddle", m._1, m._2, m._3, m._5, m._6, m._7), ctx);
                down$a1 = m._4;
                continue;
              }
              down$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
              down$a1 = m._7;
              continue;
            }
            down$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
            down$a1 = m._7;
            continue;
          }
          if (v3.tag === "EQ") {
            const max4 = maxNode(m._1);
            down$c = false;
            down$r = $Maybe(
              "Just",
              $Tuple(m._3, removeMaxNode($List("Cons", $TreeContext("ThreeLeft", max4.key, max4.value, m._4, m._5, m._6, m._7), ctx))(m._1))
            );
            continue;
          }
          if (v.tag === "EQ") {
            const max4 = maxNode(m._4);
            down$c = false;
            down$r = $Maybe(
              "Just",
              $Tuple(m._6, removeMaxNode($List("Cons", $TreeContext("ThreeMiddle", m._1, m._2, m._3, max4.key, max4.value, m._7), ctx))(m._4))
            );
            continue;
          }
          if (v3.tag === "LT") {
            down$a0 = $List("Cons", $TreeContext("ThreeLeft", m._2, m._3, m._4, m._5, m._6, m._7), ctx);
            down$a1 = m._1;
            continue;
          }
          if (v3.tag === "GT") {
            if (v.tag === "LT") {
              down$a0 = $List("Cons", $TreeContext("ThreeMiddle", m._1, m._2, m._3, m._5, m._6, m._7), ctx);
              down$a1 = m._4;
              continue;
            }
            down$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
            down$a1 = m._7;
            continue;
          }
          down$a0 = $List("Cons", $TreeContext("ThreeRight", m._1, m._2, m._3, m._4, m._5, m._6), ctx);
          down$a1 = m._7;
          continue;
        }
        fail();
      }
      ;
      return down$r;
    };
    return down(Nil);
  };
  var foldableMap = {
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Leaf") {
        return z;
      }
      if (m.tag === "Two") {
        return foldableMap.foldr(f)(f(m._3)(foldableMap.foldr(f)(z)(m._4)))(m._1);
      }
      if (m.tag === "Three") {
        return foldableMap.foldr(f)(f(m._3)(foldableMap.foldr(f)(f(m._6)(foldableMap.foldr(f)(z)(m._7)))(m._4)))(m._1);
      }
      fail();
    },
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Leaf") {
        return z;
      }
      if (m.tag === "Two") {
        return foldableMap.foldl(f)(f(foldableMap.foldl(f)(z)(m._1))(m._3))(m._4);
      }
      if (m.tag === "Three") {
        return foldableMap.foldl(f)(f(foldableMap.foldl(f)(f(foldableMap.foldl(f)(z)(m._1))(m._3))(m._4))(m._6))(m._7);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const append2 = dictMonoid.Semigroup0().append;
      return (f) => (m) => {
        if (m.tag === "Leaf") {
          return dictMonoid.mempty;
        }
        if (m.tag === "Two") {
          return append2(foldableMap.foldMap(dictMonoid)(f)(m._1))(append2(f(m._3))(foldableMap.foldMap(dictMonoid)(f)(m._4)));
        }
        if (m.tag === "Three") {
          return append2(foldableMap.foldMap(dictMonoid)(f)(m._1))(append2(f(m._3))(append2(foldableMap.foldMap(dictMonoid)(f)(m._4))(append2(f(m._6))(foldableMap.foldMap(dictMonoid)(f)(m._7)))));
        }
        fail();
      };
    }
  };
  var foldableWithIndexMap = {
    foldrWithIndex: (f) => (z) => (m) => {
      if (m.tag === "Leaf") {
        return z;
      }
      if (m.tag === "Two") {
        return foldableWithIndexMap.foldrWithIndex(f)(f(m._2)(m._3)(foldableWithIndexMap.foldrWithIndex(f)(z)(m._4)))(m._1);
      }
      if (m.tag === "Three") {
        return foldableWithIndexMap.foldrWithIndex(f)(f(m._2)(m._3)(foldableWithIndexMap.foldrWithIndex(f)(f(m._5)(m._6)(foldableWithIndexMap.foldrWithIndex(f)(z)(m._7)))(m._4)))(m._1);
      }
      fail();
    },
    foldlWithIndex: (f) => (z) => (m) => {
      if (m.tag === "Leaf") {
        return z;
      }
      if (m.tag === "Two") {
        return foldableWithIndexMap.foldlWithIndex(f)(f(m._2)(foldableWithIndexMap.foldlWithIndex(f)(z)(m._1))(m._3))(m._4);
      }
      if (m.tag === "Three") {
        return foldableWithIndexMap.foldlWithIndex(f)(f(m._5)(foldableWithIndexMap.foldlWithIndex(f)(f(m._2)(foldableWithIndexMap.foldlWithIndex(f)(z)(m._1))(m._3))(m._4))(m._6))(m._7);
      }
      fail();
    },
    foldMapWithIndex: (dictMonoid) => {
      const append2 = dictMonoid.Semigroup0().append;
      return (f) => (m) => {
        if (m.tag === "Leaf") {
          return dictMonoid.mempty;
        }
        if (m.tag === "Two") {
          return append2(foldableWithIndexMap.foldMapWithIndex(dictMonoid)(f)(m._1))(append2(f(m._2)(m._3))(foldableWithIndexMap.foldMapWithIndex(dictMonoid)(f)(m._4)));
        }
        if (m.tag === "Three") {
          return append2(foldableWithIndexMap.foldMapWithIndex(dictMonoid)(f)(m._1))(append2(f(m._2)(m._3))(append2(foldableWithIndexMap.foldMapWithIndex(dictMonoid)(f)(m._4))(append2(f(m._5)(m._6))(foldableWithIndexMap.foldMapWithIndex(dictMonoid)(f)(m._7)))));
        }
        fail();
      };
    },
    Foldable0: () => foldableMap
  };
  var eqMap = (dictEq) => (dictEq1) => {
    const eq1 = eqArrayImpl((x2) => (y2) => dictEq.eq(x2._1)(y2._1) && dictEq1.eq(x2._2)(y2._2));
    return { eq: (m1) => (m2) => eq1(toUnfoldable2(unfoldableArray)(m1))(toUnfoldable2(unfoldableArray)(m2)) };
  };
  var fromFoldable = (dictOrd) => (dictFoldable) => dictFoldable.foldl((m) => (v) => insert2(dictOrd)(v._1)(v._2)(m))(Leaf2);
  var $$delete = (dictOrd) => (k) => (m) => {
    const $3 = pop(dictOrd)(k)(m);
    if ($3.tag === "Nothing") {
      return m;
    }
    if ($3.tag === "Just") {
      return $3._1._2;
    }
    fail();
  };
  var alter = (dictOrd) => (f) => (k) => (m) => {
    const v = f(lookup(dictOrd)(k)(m));
    if (v.tag === "Nothing") {
      return $$delete(dictOrd)(k)(m);
    }
    if (v.tag === "Just") {
      return insert2(dictOrd)(k)(v._1)(m);
    }
    fail();
  };
  var unionWith = (dictOrd) => (f) => (m1) => (m2) => foldableWithIndexMap.foldlWithIndex((k) => (m) => (v) => alter(dictOrd)((() => {
    const $7 = f(v);
    return (x2) => $Maybe(
      "Just",
      (() => {
        if (x2.tag === "Nothing") {
          return v;
        }
        if (x2.tag === "Just") {
          return $7(x2._1);
        }
        fail();
      })()
    );
  })())(k)(m))(m2)(m1);

  // output-es/Effect.Exception/foreign.js
  function showErrorImpl(err) {
    return err.stack || err.toString();
  }
  function error(msg) {
    return new Error(msg);
  }
  function message(e) {
    return e.message;
  }
  function throwException(e) {
    return function() {
      throw e;
    };
  }

  // output-es/Effect.Unsafe/foreign.js
  var unsafePerformEffect = function(f) {
    return f();
  };

  // output-es/Control.Monad.ST.Internal/foreign.js
  var map_ = function(f) {
    return function(a) {
      return function() {
        return f(a());
      };
    };
  };
  var pure_ = function(a) {
    return function() {
      return a;
    };
  };
  var bind_ = function(a) {
    return function(f) {
      return function() {
        return f(a())();
      };
    };
  };
  var run = function(f) {
    return f();
  };
  function whileST(f) {
    return function(a) {
      return function() {
        while (f()) {
          a();
        }
      };
    };
  }
  var foreach = function(as) {
    return function(f) {
      return function() {
        for (var i = 0, l = as.length; i < l; i++) {
          f(as[i])();
        }
      };
    };
  };
  function newSTRef(val) {
    return function() {
      return { value: val };
    };
  }

  // output-es/Control.Monad.ST.Internal/index.js
  var functorST = { map: map_ };
  var monadST = { Applicative0: () => applicativeST, Bind1: () => bindST };
  var bindST = { bind: bind_, Apply0: () => applyST };
  var applyST = {
    apply: (f) => (a) => () => {
      const f$p = f();
      const a$p = a();
      return applicativeST.pure(f$p(a$p))();
    },
    Functor0: () => functorST
  };
  var applicativeST = { pure: pure_, Apply0: () => applyST };
  var monadRecST = {
    tailRecM: (f) => (a) => {
      const $2 = bind_(f(a))(newSTRef);
      return () => {
        const r = $2();
        whileST(() => {
          const $4 = r.value;
          return $4.tag === "Loop";
        })(() => {
          const v = r.value;
          if (v.tag === "Loop") {
            const e = f(v._1)();
            r.value = e;
            return unit2;
          }
          if (v.tag === "Done") {
            return unit2;
          }
          fail();
        })();
        const $5 = r.value;
        return (() => {
          if ($5.tag === "Done") {
            return $5._1;
          }
          fail();
        })();
      };
    },
    Monad0: () => monadST
  };

  // output-es/Data.Array.ST/foreign.js
  function newSTArray() {
    return [];
  }
  var pushAll = function(as) {
    return function(xs) {
      return function() {
        return xs.push.apply(xs, as);
      };
    };
  };
  var unsafeFreeze = function(xs) {
    return function() {
      return xs;
    };
  };
  function copyImpl(xs) {
    return function() {
      return xs.slice();
    };
  }
  var thaw = copyImpl;
  var sortByImpl = function() {
    function mergeFromTo(compare2, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x2;
      var y2;
      var c;
      mid = from + (to - from >> 1);
      if (mid - from > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, mid, to);
      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x2 = xs2[i];
        y2 = xs2[j];
        c = fromOrdering(compare2(x2)(y2));
        if (c > 0) {
          xs1[k++] = y2;
          ++j;
        } else {
          xs1[k++] = x2;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }
    return function(compare2) {
      return function(fromOrdering) {
        return function(xs) {
          return function() {
            if (xs.length < 2)
              return xs;
            mergeFromTo(compare2, fromOrdering, xs, xs.slice(0), 0, xs.length);
            return xs;
          };
        };
      };
    };
  }();

  // output-es/Data.Array.ST/index.js
  var withArray = (f) => (xs) => {
    const $2 = thaw(xs);
    return () => {
      const result = $2();
      f(result)();
      return unsafeFreeze(result)();
    };
  };

  // output-es/Unsafe.Coerce/foreign.js
  var unsafeCoerce = function(x2) {
    return x2;
  };

  // output-es/Data.Bifunctor/index.js
  var bifunctorTuple = { bimap: (f) => (g) => (v) => $Tuple(f(v._1), g(v._2)) };
  var bifunctorEither = {
    bimap: (v) => (v1) => (v2) => {
      if (v2.tag === "Left") {
        return $Either("Left", v(v2._1));
      }
      if (v2.tag === "Right") {
        return $Either("Right", v1(v2._1));
      }
      fail();
    }
  };

  // output-es/Data.Traversable/foreign.js
  var traverseArrayImpl = function() {
    function array1(a) {
      return [a];
    }
    function array2(a) {
      return function(b) {
        return [a, b];
      };
    }
    function array3(a) {
      return function(b) {
        return function(c) {
          return [a, b, c];
        };
      };
    }
    function concat2(xs) {
      return function(ys) {
        return xs.concat(ys);
      };
    }
    return function(apply4) {
      return function(map6) {
        return function(pure2) {
          return function(f) {
            return function(array) {
              function go(bot, top3) {
                switch (top3 - bot) {
                  case 0:
                    return pure2([]);
                  case 1:
                    return map6(array1)(f(array[bot]));
                  case 2:
                    return apply4(map6(array2)(f(array[bot])))(f(array[bot + 1]));
                  case 3:
                    return apply4(apply4(map6(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                  default:
                    var pivot = bot + Math.floor((top3 - bot) / 4) * 2;
                    return apply4(map6(concat2)(go(bot, pivot)))(go(pivot, top3));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  }();

  // output-es/Data.Traversable/index.js
  var identity10 = (x2) => x2;
  var traversableTuple = {
    traverse: (dictApplicative) => {
      const map6 = dictApplicative.Apply0().Functor0().map;
      return (f) => (v) => map6(Tuple(v._1))(f(v._2));
    },
    sequence: (dictApplicative) => {
      const map6 = dictApplicative.Apply0().Functor0().map;
      return (v) => map6(Tuple(v._1))(v._2);
    },
    Functor0: () => functorTuple,
    Foldable1: () => foldableTuple
  };
  var traversableArray = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      return traverseArrayImpl(Apply0.apply)(Apply0.Functor0().map)(dictApplicative.pure);
    },
    sequence: (dictApplicative) => traversableArray.traverse(dictApplicative)(identity10),
    Functor0: () => functorArray,
    Foldable1: () => foldableArray
  };

  // output-es/Data.Array/foreign.js
  var range2 = function(start2) {
    return function(end) {
      var step = start2 > end ? -1 : 1;
      var result = new Array(step * (end - start2) + 1);
      var i = start2, n = 0;
      while (i !== end) {
        result[n++] = i;
        i += step;
      }
      result[n] = i;
      return result;
    };
  };
  var replicateFill = function(count) {
    return function(value) {
      if (count < 1) {
        return [];
      }
      var result = new Array(count);
      return result.fill(value);
    };
  };
  var replicatePolyfill = function(count) {
    return function(value) {
      var result = [];
      var n = 0;
      for (var i = 0; i < count; i++) {
        result[n++] = value;
      }
      return result;
    };
  };
  var replicate2 = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
  var fromFoldableImpl = function() {
    function Cons2(head, tail) {
      this.head = head;
      this.tail = tail;
    }
    var emptyList = {};
    function curryCons(head) {
      return function(tail) {
        return new Cons2(head, tail);
      };
    }
    function listToArray(list) {
      var result = [];
      var count = 0;
      var xs = list;
      while (xs !== emptyList) {
        result[count++] = xs.head;
        xs = xs.tail;
      }
      return result;
    }
    return function(foldr) {
      return function(xs) {
        return listToArray(foldr(curryCons)(emptyList)(xs));
      };
    };
  }();
  var unconsImpl = function(empty5) {
    return function(next) {
      return function(xs) {
        return xs.length === 0 ? empty5({}) : next(xs[0])(xs.slice(1));
      };
    };
  };
  var indexImpl = function(just) {
    return function(nothing) {
      return function(xs) {
        return function(i) {
          return i < 0 || i >= xs.length ? nothing : just(xs[i]);
        };
      };
    };
  };
  var findIndexImpl = function(just) {
    return function(nothing) {
      return function(f) {
        return function(xs) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (f(xs[i]))
              return just(i);
          }
          return nothing;
        };
      };
    };
  };
  var _updateAt = function(just) {
    return function(nothing) {
      return function(i) {
        return function(a) {
          return function(l) {
            if (i < 0 || i >= l.length)
              return nothing;
            var l1 = l.slice();
            l1[i] = a;
            return just(l1);
          };
        };
      };
    };
  };
  var filter3 = function(f) {
    return function(xs) {
      return xs.filter(f);
    };
  };
  var sortByImpl2 = function() {
    function mergeFromTo(compare2, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x2;
      var y2;
      var c;
      mid = from + (to - from >> 1);
      if (mid - from > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, mid, to);
      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x2 = xs2[i];
        y2 = xs2[j];
        c = fromOrdering(compare2(x2)(y2));
        if (c > 0) {
          xs1[k++] = y2;
          ++j;
        } else {
          xs1[k++] = x2;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }
    return function(compare2) {
      return function(fromOrdering) {
        return function(xs) {
          var out;
          if (xs.length < 2)
            return xs;
          out = xs.slice(0);
          mergeFromTo(compare2, fromOrdering, out, xs.slice(0), 0, xs.length);
          return out;
        };
      };
    };
  }();
  var slice3 = function(s) {
    return function(e) {
      return function(l) {
        return l.slice(s, e);
      };
    };
  };
  var zipWith2 = function(f) {
    return function(xs) {
      return function(ys) {
        var l = xs.length < ys.length ? xs.length : ys.length;
        var result = new Array(l);
        for (var i = 0; i < l; i++) {
          result[i] = f(xs[i])(ys[i]);
        }
        return result;
      };
    };
  };

  // output-es/Data.Array/index.js
  var zip = /* @__PURE__ */ zipWith2(Tuple);
  var updateAt2 = /* @__PURE__ */ _updateAt(Just)(Nothing);
  var uncons = /* @__PURE__ */ unconsImpl((v) => Nothing)((x2) => (xs) => $Maybe("Just", { head: x2, tail: xs }));
  var toUnfoldable3 = (dictUnfoldable) => (xs) => {
    const len = xs.length;
    return dictUnfoldable.unfoldr((i) => {
      if (i < len) {
        return $Maybe("Just", $Tuple(xs[i], i + 1 | 0));
      }
      return Nothing;
    })(0);
  };
  var sortBy2 = (comp) => sortByImpl2(comp)((v) => {
    if (v.tag === "GT") {
      return 1;
    }
    if (v.tag === "EQ") {
      return 0;
    }
    if (v.tag === "LT") {
      return -1;
    }
    fail();
  });
  var sortWith = (dictOrd) => (f) => sortBy2((x2) => (y2) => dictOrd.compare(f(x2))(f(y2)));
  var index2 = /* @__PURE__ */ indexImpl(Just)(Nothing);
  var findIndex = /* @__PURE__ */ findIndexImpl(Just)(Nothing);
  var notElem = (dictEq) => (a) => (arr) => {
    const $3 = findIndex((v) => dictEq.eq(v)(a))(arr);
    if ($3.tag === "Nothing") {
      return true;
    }
    if ($3.tag === "Just") {
      return false;
    }
    fail();
  };
  var elem = (dictEq) => (a) => (arr) => {
    const $3 = findIndex((v) => dictEq.eq(v)(a))(arr);
    if ($3.tag === "Nothing") {
      return false;
    }
    if ($3.tag === "Just") {
      return true;
    }
    fail();
  };
  var cons3 = (x2) => (xs) => concatArray([x2])(xs);
  var some2 = (dictAlternative) => {
    const apply1 = dictAlternative.Applicative0().Apply0().apply;
    const map32 = dictAlternative.Plus1().Alt0().Functor0().map;
    return (dictLazy) => (v) => apply1(map32(cons3)(v))(dictLazy.defer((v1) => many2(dictAlternative)(dictLazy)(v)));
  };
  var many2 = (dictAlternative) => {
    const alt2 = dictAlternative.Plus1().Alt0().alt;
    const pure1 = dictAlternative.Applicative0().pure;
    return (dictLazy) => (v) => alt2(some2(dictAlternative)(dictLazy)(v))(pure1([]));
  };

  // output-es/Foreign.Object.ST/foreign.js
  var newImpl = function() {
    return {};
  };
  function peekImpl2(just) {
    return function(nothing) {
      return function(k) {
        return function(m) {
          return function() {
            return {}.hasOwnProperty.call(m, k) ? just(m[k]) : nothing;
          };
        };
      };
    };
  }
  function poke3(k) {
    return function(v) {
      return function(m) {
        return function() {
          m[k] = v;
          return m;
        };
      };
    };
  }
  var deleteImpl = function(k) {
    return function(m) {
      return function() {
        delete m[k];
        return m;
      };
    };
  };

  // output-es/Foreign.Object.ST/index.js
  var peek = /* @__PURE__ */ peekImpl2(Just)(Nothing);

  // output-es/Foreign.Object/foreign.js
  function _copyST(m) {
    return function() {
      var r = {};
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r[k] = m[k];
        }
      }
      return r;
    };
  }
  var empty2 = {};
  function runST(f) {
    return f();
  }
  function _fmapObject(m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(m0[k]);
      }
    }
    return m;
  }
  function _mapWithKey(m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(k)(m0[k]);
      }
    }
    return m;
  }
  function _foldM(bind) {
    return function(f) {
      return function(mz) {
        return function(m) {
          var acc = mz;
          function g(k2) {
            return function(z) {
              return f(z)(k2)(m[k2]);
            };
          }
          for (var k in m) {
            if (hasOwnProperty.call(m, k)) {
              acc = bind(acc)(g(k));
            }
          }
          return acc;
        };
      };
    };
  }
  function all2(f) {
    return function(m) {
      for (var k in m) {
        if (hasOwnProperty.call(m, k) && !f(k)(m[k]))
          return false;
      }
      return true;
    };
  }
  function size(m) {
    var s = 0;
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        ++s;
      }
    }
    return s;
  }
  function _lookup(no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  }
  function toArrayWithKey(f) {
    return function(m) {
      var r = [];
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }
  var keys = Object.keys || toArrayWithKey(function(k) {
    return function() {
      return k;
    };
  });

  // output-es/Foreign.Object/index.js
  var identity11 = (x2) => x2;
  var values = /* @__PURE__ */ toArrayWithKey((v) => (v1) => v1);
  var toAscUnfoldable = (dictUnfoldable) => {
    const $1 = sortWith(ordString)(fst);
    const $2 = toArrayWithKey(Tuple);
    return (x2) => toUnfoldable3(dictUnfoldable)($1($2(x2)));
  };
  var mutate = (f) => (m) => runST((() => {
    const $2 = _copyST(m);
    return () => {
      const s = $2();
      f(s)();
      return s;
    };
  })());
  var mapWithKey = (f) => (m) => _mapWithKey(m, f);
  var isEmpty = /* @__PURE__ */ all2((v) => (v1) => false);
  var functorObject = { map: (f) => (m) => _fmapObject(m, f) };
  var functorWithIndexObject = { mapWithIndex: mapWithKey, Functor0: () => functorObject };
  var fromFoldable2 = (dictFoldable) => {
    const fromFoldable18 = fromFoldableImpl(dictFoldable.foldr);
    return (l) => runST(() => {
      const s = newImpl();
      foreach(fromFoldable18(l))((v) => () => {
        poke3(v._1)(v._2)(s)();
        return unit2;
      })();
      return s;
    });
  };
  var foldM = (dictMonad) => {
    const bind12 = dictMonad.Bind1().bind;
    const pure1 = dictMonad.Applicative0().pure;
    return (f) => (z) => _foldM(bind12)(f)(pure1(z));
  };
  var foldM1 = /* @__PURE__ */ foldM(monadST);
  var union = (m) => mutate((s) => foldM1((s$p) => (k) => (v) => poke3(k)(v)(s$p))(s)(m));
  var unionWith2 = (f) => (m1) => (m2) => mutate((s1) => foldM1((s2) => (k) => (v1) => poke3(k)(_lookup(v1, (v2) => f(v1)(v2), k, m2))(s2))(s1)(m1))(m2);
  var fold = /* @__PURE__ */ _foldM(applyFlipped);
  var foldMap = (dictMonoid) => {
    const append1 = dictMonoid.Semigroup0().append;
    return (f) => fold((acc) => (k) => (v) => append1(acc)(f(k)(v)))(dictMonoid.mempty);
  };
  var foldableObject = {
    foldl: (f) => fold((z) => (v) => f(z)),
    foldr: (f) => (z) => (m) => foldrArray(f)(z)(values(m)),
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => foldMap1((v) => f);
    }
  };
  var foldableWithIndexObject = {
    foldlWithIndex: (f) => fold((b) => (a) => f(a)(b)),
    foldrWithIndex: (f) => (z) => (m) => foldrArray((v) => f(v._1)(v._2))(z)(toArrayWithKey(Tuple)(m)),
    foldMapWithIndex: (dictMonoid) => foldMap(dictMonoid),
    Foldable0: () => foldableObject
  };
  var traversableWithIndexObject = {
    traverseWithIndex: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map6 = Apply0.Functor0().map;
      return (f) => (ms) => fold((acc) => (k) => (v) => Apply0.apply(map6((b) => (a) => mutate(poke3(k)(a))(b))(acc))(f(k)(v)))(dictApplicative.pure(empty2))(ms);
    },
    FunctorWithIndex0: () => functorWithIndexObject,
    FoldableWithIndex1: () => foldableWithIndexObject,
    Traversable2: () => traversableObject
  };
  var traversableObject = {
    traverse: (dictApplicative) => {
      const $1 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      return (x2) => $1((v) => x2);
    },
    sequence: (dictApplicative) => traversableObject.traverse(dictApplicative)(identity11),
    Functor0: () => functorObject,
    Foldable1: () => foldableObject
  };
  var filterWithKey = (predicate) => (m) => runST(() => {
    const m$p = newImpl();
    return foldM1((acc) => (k) => (v) => {
      if (predicate(k)(v)) {
        return poke3(k)(v)(acc);
      }
      return () => acc;
    })(m$p)(m)();
  });
  var alter2 = (f) => (k) => (m) => {
    const v = f(_lookup(Nothing, Just, k, m));
    if (v.tag === "Nothing") {
      return mutate(deleteImpl(k))(m);
    }
    if (v.tag === "Just") {
      return mutate(poke3(k)(v._1))(m);
    }
    fail();
  };
  var update2 = (f) => (k) => (m) => alter2((v2) => {
    if (v2.tag === "Nothing") {
      return Nothing;
    }
    if (v2.tag === "Just") {
      return f(v2._1);
    }
    fail();
  })(k)(m);

  // output-es/Control.Category/index.js
  var categoryFn = { identity: (x2) => x2, Semigroupoid0: () => semigroupoidFn };

  // output-es/Data.Profunctor/index.js
  var profunctorFn = { dimap: (a2b) => (c2d) => (b2c) => (x2) => c2d(b2c(a2b(x2))) };

  // output-es/Data.Profunctor.Strong/index.js
  var strongFn = /* @__PURE__ */ (() => ({ first: (a2b) => (v) => $Tuple(a2b(v._1), v._2), second: functorTuple.map, Profunctor0: () => profunctorFn }))();

  // output-es/Util/index.js
  var identity12 = (x2) => x2;
  var intercalate2 = (sep) => (xs) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = (() => {
            if (b.init) {
              return { init: false, acc: v._1 };
            }
            return { init: false, acc: foldableList.foldr(Cons)(foldableList.foldr(Cons)(v._1)(sep))(b.acc) };
          })();
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go({ init: true, acc: Nil })(xs).acc;
  };
  var $$with = (msg) => bifunctorEither.bimap((msg$p) => {
    if (msg === "") {
      return msg$p + "";
    }
    return msg$p + ("\n" + msg);
  })(identity12);
  var mayFailEq = (dictShow) => (dictEq) => (x2) => (x$p) => {
    const $4 = dictShow.show(x2) + (" \u2260 " + dictShow.show(x$p));
    const $5 = dictEq.eq(x2)(x$p);
    if (!$5) {
      return $Either("Left", $4);
    }
    if ($5) {
      return $Either("Right", x2);
    }
    fail();
  };
  var intersperse = (x2) => (xs) => intercalate2($List("Cons", x2, Nil))(listMap(applicativeList.pure)(xs));
  var successful = (v) => {
    if (v.tag === "Left") {
      return unsafePerformEffect(throwException(error(v._1)));
    }
    if (v.tag === "Right") {
      return v._1;
    }
    fail();
  };
  var definitely = (v) => (v1) => {
    if (v1.tag === "Just") {
      return v1._1;
    }
    if (v1.tag === "Nothing") {
      return unsafePerformEffect(throwException(error(v)));
    }
    fail();
  };
  var mustEq = (dictEq) => (dictShow) => (x2) => (x$p) => definitely(dictShow.show(x2) + (" equal to " + dictShow.show(x$p)))((() => {
    const $4 = dictEq.eq(x2)(x$p);
    if (!$4) {
      return Nothing;
    }
    if ($4) {
      return $Maybe("Just", x2);
    }
    fail();
  })());
  var unsafeUpdateAt = (i) => (x2) => {
    const $2 = updateAt2(i)(x2);
    return (x$1) => definitely("index within bounds")($2(x$1));
  };
  var bind2Flipped = (dictMonad) => {
    const Bind1 = dictMonad.Bind1();
    const $2 = Bind1.Apply0();
    const map6 = $2.Functor0().map;
    return (f) => (x2) => (y2) => Bind1.bind($2.apply(map6(f)(x2))(y2))(identity5);
  };
  var nonEmpty = (v) => {
    if (v.tag === "Nil") {
      return unsafePerformEffect(throwException(error("absurd")));
    }
    if (v.tag === "Cons") {
      return $NonEmpty(v._1, v._2);
    }
    fail();
  };

  // output-es/Dict/foreign.js
  function intersectionWith(f) {
    return function(m1) {
      return function(m2) {
        var m = {};
        for (var k in m1) {
          if (hasOwnProperty.call(m1, k) && hasOwnProperty.call(m2, k)) {
            m[k] = f(m1[k])(m2[k]);
          }
        }
        return m;
      };
    };
  }

  // output-es/Dict/index.js
  var toUnfoldable1 = /* @__PURE__ */ toAscUnfoldable(unfoldableList);
  var keys2 = /* @__PURE__ */ (() => {
    const $0 = foldlArray((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2);
    return (x2) => $0(keys(x2));
  })();
  var $$get = (k) => {
    const $1 = definitely('Key "' + (k + '" exists in dictionary'));
    return (x2) => $1(_lookup(Nothing, Just, k, x2));
  };
  var disjointUnion_inv = (ks) => (m) => $Tuple(
    filterWithKey((x2) => {
      const $3 = lookup(ordString)(x2)(ks);
      const $4 = (() => {
        if ($3.tag === "Nothing") {
          return false;
        }
        if ($3.tag === "Just") {
          return true;
        }
        fail();
      })();
      return (v) => $4;
    })(m),
    filterWithKey((x2) => {
      const $3 = lookup(ordString)(x2)(ks);
      const $4 = (() => {
        if ($3.tag === "Nothing") {
          return true;
        }
        if ($3.tag === "Just") {
          return false;
        }
        fail();
      })();
      return (v) => $4;
    })(m)
  );
  var difference2 = (m1) => (m2) => foldlArray((b) => (a) => mutate(deleteImpl(a))(b))(m1)(keys(m2));
  var asSingletonMap = (m) => (() => {
    if (size(m) === 1) {
      return identity12;
    }
    return (v1) => unsafePerformEffect(throwException(error("Assertion failure")));
  })()(definitely("singleton map")((() => {
    const $1 = toUnfoldable1(m);
    if ($1.tag === "Nil") {
      return Nothing;
    }
    if ($1.tag === "Cons") {
      return $Maybe("Just", $1._1);
    }
    fail();
  })()));

  // output-es/Data.HeytingAlgebra/foreign.js
  var boolConj = function(b1) {
    return function(b2) {
      return b1 && b2;
    };
  };
  var boolDisj = function(b1) {
    return function(b2) {
      return b1 || b2;
    };
  };
  var boolNot = function(b) {
    return !b;
  };

  // output-es/Data.Set/index.js
  var fromFoldable1 = /* @__PURE__ */ (() => fromFoldableImpl(foldableList.foldr))();
  var tailRecM2 = (f) => (a) => (b) => monadRecST.tailRecM((o) => f(o.a)(o.b))({ a, b });
  var union2 = (dictOrd) => (v) => (v1) => unionWith(dictOrd)($$const)(v)(v1);
  var toUnfoldable4 = (dictUnfoldable) => {
    const $1 = toUnfoldable(dictUnfoldable);
    return (x2) => $1(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(x2));
  };
  var toUnfoldable12 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
  var singleton = (a) => $Map("Two", Leaf2, a, unit2, Leaf2);
  var showSet = (dictShow) => {
    const show4 = showArrayImpl(dictShow.show);
    return { show: (s) => "(fromFoldable " + (show4(toUnfoldable12(s)) + ")") };
  };
  var member = (dictOrd) => (a) => (v) => {
    const $3 = lookup(dictOrd)(a)(v);
    if ($3.tag === "Nothing") {
      return false;
    }
    if ($3.tag === "Just") {
      return true;
    }
    fail();
  };
  var isEmpty2 = (v) => v.tag === "Leaf";
  var insert3 = (dictOrd) => (a) => (v) => insert2(dictOrd)(a)(unit2)(v);
  var foldableSet = {
    foldMap: (dictMonoid) => {
      const foldMap1 = foldableList.foldMap(dictMonoid);
      return (f) => {
        const $3 = foldMap1(f);
        return (x2) => $3(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(x2));
      };
    },
    foldl: (f) => (x2) => {
      const $2 = (() => {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = f(b)(v._1);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(x2);
      })();
      return (x$1) => $2(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(x$1));
    },
    foldr: (f) => (x2) => {
      const $2 = foldableList.foldr(f)(x2);
      return (x$1) => $2(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(x$1));
    }
  };
  var ordSet = (dictOrd) => {
    const compare2 = ordList(dictOrd).compare;
    const eq2 = eqMap(dictOrd.Eq0())(eqUnit).eq;
    const eqSet1 = { eq: (v) => (v1) => eq2(v)(v1) };
    return {
      compare: (s1) => (s2) => compare2(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(s1))(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List(
        "Cons",
        k,
        acc
      ))(Nil)(s2)),
      Eq0: () => eqSet1
    };
  };
  var intersection = (dictOrd) => {
    const fromFoldable32 = foldlArray((m) => (a) => insert2(dictOrd)(a)(unit2)(m))(Leaf2);
    return (s1) => (s2) => {
      const rs = fromFoldable1(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(s2));
      const rl = rs.length;
      const ls = fromFoldable1(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(s1));
      const ll = ls.length;
      return fromFoldable32(run(bind_(() => {
        const acc = newSTArray();
        return tailRecM2((l) => (r) => {
          if (l < ll && r < rl) {
            const v = dictOrd.compare(ls[l])(rs[r]);
            if (v.tag === "EQ") {
              return () => {
                pushAll([ls[l]])(acc)();
                return $Step("Loop", { a: l + 1 | 0, b: r + 1 | 0 });
              };
            }
            if (v.tag === "LT") {
              return () => $Step("Loop", { a: l + 1 | 0, b: r });
            }
            if (v.tag === "GT") {
              return () => $Step("Loop", { a: l, b: r + 1 | 0 });
            }
            fail();
          }
          return () => $Step("Done", acc);
        })(0)(0)();
      })(unsafeFreeze)));
    };
  };
  var map2 = (dictOrd) => (f) => foldableSet.foldl((m) => (a) => insert2(dictOrd)(f(a))(unit2)(m))(Leaf2);
  var $$delete2 = (dictOrd) => (a) => (v) => $$delete(dictOrd)(a)(v);
  var difference3 = (dictOrd) => (s1) => (s2) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = $$delete(dictOrd)(v._1)(b);
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go(s1)(foldableWithIndexMap.foldrWithIndex((k) => (v) => (acc) => $List("Cons", k, acc))(Nil)(s2));
  };
  var subset = (dictOrd) => (s1) => (s2) => difference3(dictOrd)(s1)(s2).tag === "Leaf";

  // output-es/Util.Pair/index.js
  var $Pair = (_1, _2) => ({ tag: "Pair", _1, _2 });
  var Pair = (value0) => (value1) => $Pair(value0, value1);
  var functorPair = { map: (f) => (v) => $Pair(f(v._1), f(v._2)) };
  var foldablePair = {
    foldl: (f) => (z) => (v) => f(f(z)(v._1))(v._2),
    foldr: (f) => foldrDefault(foldablePair)(f),
    foldMap: (dictMonoid) => (f) => {
      const append = dictMonoid.Semigroup0().append;
      return foldablePair.foldl((acc) => (x2) => append(acc)(f(x2)))(dictMonoid.mempty);
    }
  };
  var traversablePair = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map6 = Apply0.Functor0().map;
      return (f) => (v) => Apply0.apply(map6(Pair)(f(v._1)))(f(v._2));
    },
    sequence: (dictApplicative) => traversablePair.traverse(dictApplicative)(identity10),
    Functor0: () => functorPair,
    Foldable1: () => foldablePair
  };
  var toTuple = (v) => $Tuple(v._1, v._2);
  var unzip2 = (xys) => unzip(listMap(toTuple)(xys));
  var fromTuple = (v) => $Pair(v._1, v._2);

  // output-es/Lattice/index.js
  var identity13 = (x2) => x2;
  var foldM2 = (f) => (b0) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = bindEither.bind(b)((a) => f(a)(v._1));
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go($Either("Right", b0));
  };
  var toUnfoldable5 = /* @__PURE__ */ toAscUnfoldable(unfoldableList);
  var length2 = /* @__PURE__ */ foldlArray((c) => (v) => 1 + c | 0)(0);
  var sequence = /* @__PURE__ */ (() => traversableArray.traverse(applicativeEither)(identity10))();
  var sequence1 = /* @__PURE__ */ (() => traversableList.traverse(applicativeEither)(identity6))();
  var meetSemilatticeBoolean = { meet: boolConj };
  var boundedMeetSemilatticeBoo = { top: true, MeetSemilattice0: () => meetSemilatticeBoolean };
  var mayFailUpdate = (dictJoinSemilattice) => (m) => (v) => {
    const v2 = _lookup(Nothing, Just, v._1, m);
    if (v2.tag === "Nothing") {
      return $Either("Right", mutate(poke3(v._1)(v._2))(m));
    }
    if (v2.tag === "Just") {
      const $4 = dictJoinSemilattice.maybeJoin(v2._1)(v._2);
      if ($4.tag === "Left") {
        return $Either("Left", $4._1);
      }
      if ($4.tag === "Right") {
        return $Either("Right", update2((v$1) => $Maybe("Just", $4._1))(v._1)(m));
      }
      fail();
    }
    fail();
  };
  var joinSemilatticeBoolean = {
    join: boolDisj,
    maybeJoin: (x2) => (y2) => $Either("Right", joinSemilatticeBoolean.join(x2)(y2)),
    neg: boolNot
  };
  var boundedJoinSemilatticeBoo = { bot: false, JoinSemilattice0: () => joinSemilatticeBoolean };
  var boundedLatticeBoolean = { BoundedJoinSemilattice0: () => boundedJoinSemilatticeBoo, BoundedMeetSemilattice1: () => boundedMeetSemilatticeBoo };
  var joinSemilatticeDict = (dictJoinSemilattice) => ({
    join: unionWith2(dictJoinSemilattice.join),
    maybeJoin: (m) => (m$p) => foldM2(mayFailUpdate(dictJoinSemilattice))(m)(toUnfoldable5(m$p)),
    neg: functorObject.map(dictJoinSemilattice.neg)
  });
  var joinSemilatticeUnit = { join: (v) => identity13, maybeJoin: (x2) => (y2) => $Either("Right", joinSemilatticeUnit.join(x2)(y2)), neg: identity13 };
  var expandablePairPair = (dictExpandable) => ({ expand: (v) => (v1) => $Pair(dictExpandable.expand(v._1)(v1._1), dictExpandable.expand(v._2)(v1._2)) });
  var definedJoin = (dictJoinSemilattice) => (x2) => {
    const $2 = dictJoinSemilattice.maybeJoin(x2);
    return (x$1) => successful($$with("Join undefined")($2(x$1)));
  };
  var joinSemilatticeArray = (dictJoinSemilattice) => ({
    join: (xs) => definedJoin(joinSemilatticeArray(dictJoinSemilattice))(xs),
    maybeJoin: (xs) => (ys) => {
      if (length2(xs) === length2(ys)) {
        return sequence(zipWith2(dictJoinSemilattice.maybeJoin)(xs)(ys));
      }
      return $Either("Left", "Mismatched array lengths");
    },
    neg: arrayMap(dictJoinSemilattice.neg)
  });
  var joinSemilatticeList = (dictJoinSemilattice) => ({
    join: (xs) => definedJoin(joinSemilatticeList(dictJoinSemilattice))(xs),
    maybeJoin: (xs) => (ys) => {
      if ((() => {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = 1 + b | 0;
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        const go$1 = (go$1$a0$copy) => (go$1$a1$copy) => {
          let go$1$a0 = go$1$a0$copy, go$1$a1 = go$1$a1$copy, go$1$c = true, go$1$r;
          while (go$1$c) {
            const b = go$1$a0, v = go$1$a1;
            if (v.tag === "Nil") {
              go$1$c = false;
              go$1$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$1$a0 = 1 + b | 0;
              go$1$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$1$r;
        };
        return go(0)(xs) === go$1(0)(ys);
      })()) {
        return sequence1(zipWith(dictJoinSemilattice.maybeJoin)(xs)(ys));
      }
      return $Either("Left", "Mismatched list lengths");
    },
    neg: listMap(dictJoinSemilattice.neg)
  });
  var joinSemilatticePair = (dictJoinSemilattice) => ({
    join: (ab) => definedJoin(joinSemilatticePair(dictJoinSemilattice))(ab),
    maybeJoin: (v) => (v1) => applyEither.apply((() => {
      const $3 = dictJoinSemilattice.maybeJoin(v._1)(v1._1);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", Pair($3._1));
      }
      fail();
    })())(dictJoinSemilattice.maybeJoin(v._2)(v1._2)),
    neg: functorPair.map(dictJoinSemilattice.neg)
  });
  var joinSemilattice$x215 = (dictJoinSemilattice) => (dictJoinSemilattice1) => ({
    join: (ab) => definedJoin(joinSemilattice$x215(dictJoinSemilattice)(dictJoinSemilattice1))(ab),
    maybeJoin: (v) => (v1) => {
      const $4 = dictJoinSemilattice.maybeJoin(v._1)(v1._1);
      return applyEither.apply((() => {
        if ($4.tag === "Left") {
          return $Either("Left", $4._1);
        }
        if ($4.tag === "Right") {
          return $Either("Right", Tuple($4._1));
        }
        fail();
      })())(dictJoinSemilattice1.maybeJoin(v._2)(v1._2));
    },
    neg: functorTuple.map(dictJoinSemilattice1.neg)
  });
  var expandableDictDict = (dictBotOf) => (dictExpandable) => ({
    expand: (kvs) => (kvs$p) => (() => {
      if (difference3(ordString)(keys2(kvs))(keys2(kvs$p)).tag === "Leaf") {
        return identity12;
      }
      return (v1) => unsafePerformEffect(throwException(error("Assertion failure")));
    })()(union(intersectionWith(dictExpandable.expand)(kvs)(kvs$p))(_fmapObject(difference2(kvs$p)(kvs), dictBotOf.botOf)))
  });
  var botOfUnit$x215Raw$x215 = (dictFunctor) => (dictBoundedJoinSemilattice) => ({
    botOf: (() => {
      const $2 = dictFunctor.map((v) => dictBoundedJoinSemilattice.bot);
      return (x2) => $Tuple(dictBoundedJoinSemilattice.bot, $2(x2._2));
    })()
  });

  // output-es/Control.Monad.State.Trans/index.js
  var monadTransStateT = {
    lift: (dictMonad) => {
      const bind = dictMonad.Bind1().bind;
      const pure2 = dictMonad.Applicative0().pure;
      return (m) => (s) => bind(m)((x2) => pure2($Tuple(x2, s)));
    }
  };
  var functorStateT = (dictFunctor) => ({ map: (f) => (v) => (s) => dictFunctor.map((v1) => $Tuple(f(v1._1), v1._2))(v(s)) });
  var bindStateT = (dictMonad) => {
    const bind = dictMonad.Bind1().bind;
    return { bind: (v) => (f) => (s) => bind(v(s))((v1) => f(v1._1)(v1._2)), Apply0: () => applyStateT(dictMonad) };
  };
  var applyStateT = (dictMonad) => {
    const functorStateT1 = functorStateT(dictMonad.Bind1().Apply0().Functor0());
    return {
      apply: (() => {
        const bind = bindStateT(dictMonad).bind;
        const pure2 = applicativeStateT(dictMonad).pure;
        return (f) => (a) => bind(f)((f$p) => bind(a)((a$p) => pure2(f$p(a$p))));
      })(),
      Functor0: () => functorStateT1
    };
  };
  var applicativeStateT = (dictMonad) => {
    const pure2 = dictMonad.Applicative0().pure;
    return { pure: (a) => (s) => pure2($Tuple(a, s)), Apply0: () => applyStateT(dictMonad) };
  };
  var monadStateStateT = (dictMonad) => {
    const pure2 = dictMonad.Applicative0().pure;
    const monadStateT12 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    return { state: (f) => (x2) => pure2(f(x2)), Monad0: () => monadStateT12 };
  };

  // output-es/Data.Profunctor.Choice/index.js
  var identity14 = (x2) => x2;
  var fanin = (dictCategory) => {
    const $1 = dictCategory.Semigroupoid0();
    const $2 = dictCategory.Semigroupoid0();
    return (dictChoice) => {
      const dimap = dictChoice.Profunctor0().dimap;
      return (l) => (r) => $1.compose(dimap((v2) => {
        if (v2.tag === "Left") {
          return v2._1;
        }
        if (v2.tag === "Right") {
          return v2._1;
        }
        fail();
      })(identity14)(dictCategory.identity))($2.compose(dictChoice.right(r))(dictChoice.left(l)));
    };
  };
  var choiceFn = /* @__PURE__ */ (() => ({
    left: (v) => (v1) => {
      if (v1.tag === "Left") {
        return $Either("Left", v(v1._1));
      }
      if (v1.tag === "Right") {
        return $Either("Right", v1._1);
      }
      fail();
    },
    right: functorEither.map,
    Profunctor0: () => profunctorFn
  }))();

  // output-es/Control.Monad.Except.Trans/index.js
  var monadTransExceptT = {
    lift: (dictMonad) => {
      const bind = dictMonad.Bind1().bind;
      const pure2 = dictMonad.Applicative0().pure;
      return (m) => bind(m)((a) => pure2($Either("Right", a)));
    }
  };
  var bindExceptT = (dictMonad) => {
    const bind = dictMonad.Bind1().bind;
    const pure2 = dictMonad.Applicative0().pure;
    return {
      bind: (v) => (k) => bind(v)((v2) => {
        if (v2.tag === "Left") {
          return pure2($Either("Left", v2._1));
        }
        if (v2.tag === "Right") {
          return k(v2._1);
        }
        fail();
      }),
      Apply0: () => applyExceptT(dictMonad)
    };
  };
  var applyExceptT = (dictMonad) => {
    const $1 = dictMonad.Bind1().Apply0().Functor0();
    const functorExceptT1 = { map: (f) => $1.map(functorEither.map(f)) };
    return {
      apply: (() => {
        const bind = bindExceptT(dictMonad).bind;
        const pure2 = applicativeExceptT(dictMonad).pure;
        return (f) => (a) => bind(f)((f$p) => bind(a)((a$p) => pure2(f$p(a$p))));
      })(),
      Functor0: () => functorExceptT1
    };
  };
  var applicativeExceptT = (dictMonad) => ({
    pure: (() => {
      const $1 = dictMonad.Applicative0().pure;
      return (x2) => $1($Either("Right", x2));
    })(),
    Apply0: () => applyExceptT(dictMonad)
  });
  var monadStateExceptT = (dictMonadState) => {
    const Monad0 = dictMonadState.Monad0();
    const lift1 = monadTransExceptT.lift(Monad0);
    const monadExceptT1 = { Applicative0: () => applicativeExceptT(Monad0), Bind1: () => bindExceptT(Monad0) };
    return { state: (f) => lift1(dictMonadState.state(f)), Monad0: () => monadExceptT1 };
  };
  var monadThrowExceptT = (dictMonad) => {
    const monadExceptT1 = { Applicative0: () => applicativeExceptT(dictMonad), Bind1: () => bindExceptT(dictMonad) };
    return {
      throwError: (() => {
        const $2 = dictMonad.Applicative0().pure;
        return (x2) => $2($Either("Left", x2));
      })(),
      Monad0: () => monadExceptT1
    };
  };
  var altExceptT = (dictSemigroup) => (dictMonad) => {
    const Bind1 = dictMonad.Bind1();
    const pure2 = dictMonad.Applicative0().pure;
    const $4 = Bind1.Apply0().Functor0();
    const functorExceptT1 = { map: (f) => $4.map(functorEither.map(f)) };
    return {
      alt: (v) => (v1) => Bind1.bind(v)((rm) => {
        if (rm.tag === "Right") {
          return pure2($Either("Right", rm._1));
        }
        if (rm.tag === "Left") {
          return Bind1.bind(v1)((rn) => {
            if (rn.tag === "Right") {
              return pure2($Either("Right", rn._1));
            }
            if (rn.tag === "Left") {
              return pure2($Either("Left", dictSemigroup.append(rm._1)(rn._1)));
            }
            fail();
          });
        }
        fail();
      }),
      Functor0: () => functorExceptT1
    };
  };

  // output-es/Control.Monad.State.Class/index.js
  var modify_ = (dictMonadState) => (f) => dictMonadState.state((s) => $Tuple(unit2, f(s)));
  var modify2 = (dictMonadState) => (f) => dictMonadState.state((s) => {
    const s$p = f(s);
    return $Tuple(s$p, s$p);
  });

  // output-es/Graph.GraphWriter/index.js
  var monadGraphWithGraphT = (dictMonad) => {
    const $$void = functorStateT(dictMonad.Bind1().Apply0().Functor0()).map((v) => unit2);
    const modify_2 = modify_(monadStateStateT(dictMonad));
    const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    return { extend: (\u03B1) => (\u03B1s) => $$void(modify_2(Cons($Tuple(\u03B1, \u03B1s)))), Monad0: () => monadStateT2 };
  };
  var runWithGraphAllocT = (dictMonad) => {
    const bind = dictMonad.Bind1().bind;
    const pure2 = dictMonad.Applicative0().pure;
    return (dictGraph) => {
      const append = dictGraph.Semigroup0().append;
      const fromFoldable11 = dictGraph.fromFoldable(functorList)(foldableList);
      return (v) => (c) => bind(c(v._2)(Nil))((v1) => pure2((() => {
        if (v1._1._1.tag === "Left") {
          return $Either("Left", v1._1._1._1);
        }
        if (v1._1._1.tag === "Right") {
          return $Either("Right", $Tuple($Tuple(append(v._1)(fromFoldable11(v1._2)), v1._1._2), v1._1._1._1));
        }
        fail();
      })()));
    };
  };
  var monadGraphAllocWithGraphA = (dictMonad) => {
    const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
    const bindExceptT2 = bindExceptT(monadStateT12);
    const modify3 = modify2(monadStateExceptT(monadStateStateT(monadStateT2)));
    const pure2 = applicativeExceptT(monadStateT12).pure;
    return (dictMonadGraph) => ({
      fresh: bindExceptT2.bind(modify3(($7) => 1 + $7 | 0))((n) => pure2(showIntImpl(n))),
      new: (\u03B1s) => bindExceptT2.bind(monadGraphAllocWithGraphA(dictMonad)(dictMonadGraph).fresh)((\u03B1) => bindExceptT2.bind(dictMonadGraph.extend(\u03B1)(\u03B1s))(() => pure2(\u03B1))),
      MonadGraph0: () => dictMonadGraph
    });
  };
  var monadGraphWithGraphAllocT = (dictMonad) => {
    const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
    const lift22 = monadTransExceptT.lift(monadStateT12);
    const lift32 = monadTransStateT.lift(monadStateT2);
    const extend1 = monadGraphWithGraphT(dictMonad).extend;
    const monadExceptT = { Applicative0: () => applicativeExceptT(monadStateT12), Bind1: () => bindExceptT(monadStateT12) };
    return { extend: (\u03B1) => (\u03B1s) => lift22(lift32(extend1(\u03B1)(\u03B1s))), Monad0: () => monadExceptT };
  };
  var alloc = (dictMonad) => {
    const applicativeExceptT3 = applicativeExceptT((() => {
      const $1 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      return { Applicative0: () => applicativeStateT($1), Bind1: () => bindStateT($1) };
    })());
    const fresh1 = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).fresh;
    return (dictTraversable) => dictTraversable.traverse(applicativeExceptT3)((v) => fresh1);
  };

  // output-es/Data.List.NonEmpty/index.js
  var wrappedOperation = (name3) => (f) => (v) => {
    const v1 = f($List("Cons", v._1, v._2));
    if (v1.tag === "Cons") {
      return $NonEmpty(v1._1, v1._2);
    }
    if (v1.tag === "Nil") {
      return _crashWith("Impossible: empty list in NonEmptyList " + name3);
    }
    fail();
  };

  // output-es/Data.String.Unsafe/foreign.js
  var charAt = function(i) {
    return function(s) {
      if (i >= 0 && i < s.length)
        return s.charAt(i);
      throw new Error("Data.String.Unsafe.charAt: Invalid index.");
    };
  };

  // output-es/Data.String.CodeUnits/foreign.js
  var fromCharArray = function(a) {
    return a.join("");
  };
  var toCharArray = function(s) {
    return s.split("");
  };
  var singleton2 = function(c) {
    return c;
  };
  var _charAt = function(just) {
    return function(nothing) {
      return function(i) {
        return function(s) {
          return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
        };
      };
    };
  };
  var _toChar = function(just) {
    return function(nothing) {
      return function(s) {
        return s.length === 1 ? just(s) : nothing;
      };
    };
  };
  var length3 = function(s) {
    return s.length;
  };
  var _indexOf = function(just) {
    return function(nothing) {
      return function(x2) {
        return function(s) {
          var i = s.indexOf(x2);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };
  var drop2 = function(n) {
    return function(s) {
      return s.substring(n);
    };
  };
  var splitAt = function(i) {
    return function(s) {
      return { before: s.substring(0, i), after: s.substring(i) };
    };
  };

  // output-es/Data.String.CodeUnits/index.js
  var uncons2 = (v) => {
    if (v === "") {
      return Nothing;
    }
    return $Maybe("Just", { head: charAt(0)(v), tail: drop2(1)(v) });
  };
  var toChar = /* @__PURE__ */ _toChar(Just)(Nothing);
  var stripPrefix = (v) => (str) => {
    const v1 = splitAt(length3(v))(str);
    if (v1.before === v) {
      return $Maybe("Just", v1.after);
    }
    return Nothing;
  };
  var indexOf = /* @__PURE__ */ _indexOf(Just)(Nothing);
  var contains2 = (pat) => {
    const $1 = indexOf(pat);
    return (x2) => {
      const $3 = $1(x2);
      if ($3.tag === "Nothing") {
        return false;
      }
      if ($3.tag === "Just") {
        return true;
      }
      fail();
    };
  };
  var charAt2 = /* @__PURE__ */ _charAt(Just)(Nothing);

  // output-es/Data.CodePoint.Unicode.Internal/index.js
  var $UnicodeCategory = (tag) => ({ tag });
  var NUMCAT_LU = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LU");
  var NUMCAT_LL = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LL");
  var NUMCAT_LT = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LT");
  var NUMCAT_LM = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LM");
  var NUMCAT_LO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_LO");
  var NUMCAT_MN = /* @__PURE__ */ $UnicodeCategory("NUMCAT_MN");
  var NUMCAT_MC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_MC");
  var NUMCAT_ME = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ME");
  var NUMCAT_ND = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ND");
  var NUMCAT_NL = /* @__PURE__ */ $UnicodeCategory("NUMCAT_NL");
  var NUMCAT_NO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_NO");
  var NUMCAT_PC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PC");
  var NUMCAT_PD = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PD");
  var NUMCAT_PS = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PS");
  var NUMCAT_PE = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PE");
  var NUMCAT_PI = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PI");
  var NUMCAT_PF = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PF");
  var NUMCAT_PO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_PO");
  var NUMCAT_SM = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SM");
  var NUMCAT_SC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SC");
  var NUMCAT_SK = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SK");
  var NUMCAT_SO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_SO");
  var NUMCAT_ZS = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ZS");
  var NUMCAT_ZL = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ZL");
  var NUMCAT_ZP = /* @__PURE__ */ $UnicodeCategory("NUMCAT_ZP");
  var NUMCAT_CC = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CC");
  var NUMCAT_CF = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CF");
  var NUMCAT_CS = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CS");
  var NUMCAT_CO = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CO");
  var NUMCAT_CN = /* @__PURE__ */ $UnicodeCategory("NUMCAT_CN");
  var rule1 = { category: 2, unicodeCat: NUMCAT_ZS, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var spacechars = [
    { start: 32, length: 1, convRule: rule1 },
    { start: 160, length: 1, convRule: rule1 },
    { start: 5760, length: 1, convRule: rule1 },
    { start: 8192, length: 11, convRule: rule1 },
    { start: 8239, length: 1, convRule: rule1 },
    { start: 8287, length: 1, convRule: rule1 },
    { start: 12288, length: 1, convRule: rule1 }
  ];
  var rule162 = { category: 67108864, unicodeCat: NUMCAT_ZP, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule161 = { category: 33554432, unicodeCat: NUMCAT_ZL, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule13 = { category: 8192, unicodeCat: NUMCAT_SO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule170 = { category: 8192, unicodeCat: NUMCAT_SO, possible: 1, updist: 0, lowdist: 26, titledist: 0 };
  var rule171 = { category: 8192, unicodeCat: NUMCAT_SO, possible: 1, updist: -26, lowdist: 0, titledist: -26 };
  var rule6 = { category: 64, unicodeCat: NUMCAT_SM, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule10 = { category: 1024, unicodeCat: NUMCAT_SK, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule3 = { category: 8, unicodeCat: NUMCAT_SC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule4 = { category: 16, unicodeCat: NUMCAT_PS, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule2 = { category: 4, unicodeCat: NUMCAT_PO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule15 = { category: 32768, unicodeCat: NUMCAT_PI, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule19 = { category: 262144, unicodeCat: NUMCAT_PF, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule5 = { category: 32, unicodeCat: NUMCAT_PE, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule7 = { category: 128, unicodeCat: NUMCAT_PD, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule11 = { category: 2048, unicodeCat: NUMCAT_PC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule17 = { category: 131072, unicodeCat: NUMCAT_NO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule128 = { category: 16777216, unicodeCat: NUMCAT_NL, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule168 = { category: 16777216, unicodeCat: NUMCAT_NL, possible: 1, updist: 0, lowdist: 16, titledist: 0 };
  var rule169 = { category: 16777216, unicodeCat: NUMCAT_NL, possible: 1, updist: -16, lowdist: 0, titledist: -16 };
  var rule8 = { category: 256, unicodeCat: NUMCAT_ND, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule92 = { category: 2097152, unicodeCat: NUMCAT_MN, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule93 = { category: 2097152, unicodeCat: NUMCAT_MN, possible: 1, updist: 84, lowdist: 0, titledist: 84 };
  var rule119 = { category: 4194304, unicodeCat: NUMCAT_ME, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule124 = { category: 8388608, unicodeCat: NUMCAT_MC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var nullrule = { category: 512, unicodeCat: NUMCAT_CN, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule104 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 8, titledist: 0 };
  var rule107 = { category: 512, unicodeCat: NUMCAT_LU, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule115 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -60, titledist: 0 };
  var rule117 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -7, titledist: 0 };
  var rule118 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 80, titledist: 0 };
  var rule120 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 15, titledist: 0 };
  var rule122 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 48, titledist: 0 };
  var rule125 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 7264, titledist: 0 };
  var rule127 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 38864, titledist: 0 };
  var rule137 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -3008, titledist: 0 };
  var rule142 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -7615, titledist: 0 };
  var rule144 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -8, titledist: 0 };
  var rule153 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -74, titledist: 0 };
  var rule156 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -86, titledist: 0 };
  var rule157 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -100, titledist: 0 };
  var rule158 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -112, titledist: 0 };
  var rule159 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -128, titledist: 0 };
  var rule160 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -126, titledist: 0 };
  var rule163 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -7517, titledist: 0 };
  var rule164 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -8383, titledist: 0 };
  var rule165 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -8262, titledist: 0 };
  var rule166 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 28, titledist: 0 };
  var rule172 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10743, titledist: 0 };
  var rule173 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -3814, titledist: 0 };
  var rule174 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10727, titledist: 0 };
  var rule177 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10780, titledist: 0 };
  var rule178 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10749, titledist: 0 };
  var rule179 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10783, titledist: 0 };
  var rule180 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10782, titledist: 0 };
  var rule181 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -10815, titledist: 0 };
  var rule183 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -35332, titledist: 0 };
  var rule184 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42280, titledist: 0 };
  var rule186 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42308, titledist: 0 };
  var rule187 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42319, titledist: 0 };
  var rule188 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42315, titledist: 0 };
  var rule189 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42305, titledist: 0 };
  var rule190 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42258, titledist: 0 };
  var rule191 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42282, titledist: 0 };
  var rule192 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42261, titledist: 0 };
  var rule193 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 928, titledist: 0 };
  var rule194 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -48, titledist: 0 };
  var rule195 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -42307, titledist: 0 };
  var rule196 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -35384, titledist: 0 };
  var rule201 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 40, titledist: 0 };
  var rule203 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 34, titledist: 0 };
  var rule22 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 1, titledist: 0 };
  var rule24 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -199, titledist: 0 };
  var rule26 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -121, titledist: 0 };
  var rule29 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 210, titledist: 0 };
  var rule30 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 206, titledist: 0 };
  var rule31 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 205, titledist: 0 };
  var rule32 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 79, titledist: 0 };
  var rule33 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 202, titledist: 0 };
  var rule34 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 203, titledist: 0 };
  var rule35 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 207, titledist: 0 };
  var rule37 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 211, titledist: 0 };
  var rule38 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 209, titledist: 0 };
  var rule40 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 213, titledist: 0 };
  var rule42 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 214, titledist: 0 };
  var rule43 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 218, titledist: 0 };
  var rule44 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 217, titledist: 0 };
  var rule45 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 219, titledist: 0 };
  var rule47 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 2, titledist: 1 };
  var rule51 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -97, titledist: 0 };
  var rule52 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -56, titledist: 0 };
  var rule53 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -130, titledist: 0 };
  var rule54 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 10795, titledist: 0 };
  var rule55 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -163, titledist: 0 };
  var rule56 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 10792, titledist: 0 };
  var rule58 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: -195, titledist: 0 };
  var rule59 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 69, titledist: 0 };
  var rule60 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 71, titledist: 0 };
  var rule9 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 32, titledist: 0 };
  var rule94 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 116, titledist: 0 };
  var rule95 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 38, titledist: 0 };
  var rule96 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 37, titledist: 0 };
  var rule97 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 64, titledist: 0 };
  var rule98 = { category: 512, unicodeCat: NUMCAT_LU, possible: 1, updist: 0, lowdist: 63, titledist: 0 };
  var rule151 = { category: 524288, unicodeCat: NUMCAT_LT, possible: 1, updist: 0, lowdist: -8, titledist: 0 };
  var rule154 = { category: 524288, unicodeCat: NUMCAT_LT, possible: 1, updist: 0, lowdist: -9, titledist: 0 };
  var rule48 = { category: 524288, unicodeCat: NUMCAT_LT, possible: 1, updist: -1, lowdist: 1, titledist: 0 };
  var rule14 = { category: 16384, unicodeCat: NUMCAT_LO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule91 = { category: 1048576, unicodeCat: NUMCAT_LM, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule100 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -37, lowdist: 0, titledist: -37 };
  var rule101 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -31, lowdist: 0, titledist: -31 };
  var rule102 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -64, lowdist: 0, titledist: -64 };
  var rule103 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -63, lowdist: 0, titledist: -63 };
  var rule105 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -62, lowdist: 0, titledist: -62 };
  var rule106 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -57, lowdist: 0, titledist: -57 };
  var rule108 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -47, lowdist: 0, titledist: -47 };
  var rule109 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -54, lowdist: 0, titledist: -54 };
  var rule110 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -8, lowdist: 0, titledist: -8 };
  var rule111 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -86, lowdist: 0, titledist: -86 };
  var rule112 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -80, lowdist: 0, titledist: -80 };
  var rule113 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 7, lowdist: 0, titledist: 7 };
  var rule114 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -116, lowdist: 0, titledist: -116 };
  var rule116 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -96, lowdist: 0, titledist: -96 };
  var rule12 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -32, lowdist: 0, titledist: -32 };
  var rule121 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -15, lowdist: 0, titledist: -15 };
  var rule123 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -48, lowdist: 0, titledist: -48 };
  var rule126 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 3008, lowdist: 0, titledist: 0 };
  var rule129 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6254, lowdist: 0, titledist: -6254 };
  var rule130 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6253, lowdist: 0, titledist: -6253 };
  var rule131 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6244, lowdist: 0, titledist: -6244 };
  var rule132 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6242, lowdist: 0, titledist: -6242 };
  var rule133 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6243, lowdist: 0, titledist: -6243 };
  var rule134 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6236, lowdist: 0, titledist: -6236 };
  var rule135 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -6181, lowdist: 0, titledist: -6181 };
  var rule136 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 35266, lowdist: 0, titledist: 35266 };
  var rule138 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 35332, lowdist: 0, titledist: 35332 };
  var rule139 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 3814, lowdist: 0, titledist: 3814 };
  var rule140 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 35384, lowdist: 0, titledist: 35384 };
  var rule141 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -59, lowdist: 0, titledist: -59 };
  var rule143 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 8, lowdist: 0, titledist: 8 };
  var rule145 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 74, lowdist: 0, titledist: 74 };
  var rule146 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 86, lowdist: 0, titledist: 86 };
  var rule147 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 100, lowdist: 0, titledist: 100 };
  var rule148 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 128, lowdist: 0, titledist: 128 };
  var rule149 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 112, lowdist: 0, titledist: 112 };
  var rule150 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 126, lowdist: 0, titledist: 126 };
  var rule152 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 9, lowdist: 0, titledist: 9 };
  var rule155 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -7205, lowdist: 0, titledist: -7205 };
  var rule167 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -28, lowdist: 0, titledist: -28 };
  var rule175 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -10795, lowdist: 0, titledist: -10795 };
  var rule176 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -10792, lowdist: 0, titledist: -10792 };
  var rule18 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 743, lowdist: 0, titledist: 743 };
  var rule182 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -7264, lowdist: 0, titledist: -7264 };
  var rule185 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 48, lowdist: 0, titledist: 48 };
  var rule197 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -928, lowdist: 0, titledist: -928 };
  var rule198 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -38864, lowdist: 0, titledist: -38864 };
  var rule20 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule202 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -40, lowdist: 0, titledist: -40 };
  var rule204 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -34, lowdist: 0, titledist: -34 };
  var rule21 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 121, lowdist: 0, titledist: 121 };
  var rule23 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -1, lowdist: 0, titledist: -1 };
  var rule25 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -232, lowdist: 0, titledist: -232 };
  var rule27 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -300, lowdist: 0, titledist: -300 };
  var rule28 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 195, lowdist: 0, titledist: 195 };
  var rule36 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 97, lowdist: 0, titledist: 97 };
  var rule39 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 163, lowdist: 0, titledist: 163 };
  var rule41 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 130, lowdist: 0, titledist: 130 };
  var rule46 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 56, lowdist: 0, titledist: 56 };
  var rule49 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -2, lowdist: 0, titledist: -1 };
  var rule50 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -79, lowdist: 0, titledist: -79 };
  var rule57 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10815, lowdist: 0, titledist: 10815 };
  var rule61 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10783, lowdist: 0, titledist: 10783 };
  var rule62 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10780, lowdist: 0, titledist: 10780 };
  var rule63 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10782, lowdist: 0, titledist: 10782 };
  var rule64 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -210, lowdist: 0, titledist: -210 };
  var rule65 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -206, lowdist: 0, titledist: -206 };
  var rule66 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -205, lowdist: 0, titledist: -205 };
  var rule67 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -202, lowdist: 0, titledist: -202 };
  var rule68 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -203, lowdist: 0, titledist: -203 };
  var rule69 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42319, lowdist: 0, titledist: 42319 };
  var rule70 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42315, lowdist: 0, titledist: 42315 };
  var rule71 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -207, lowdist: 0, titledist: -207 };
  var rule72 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42280, lowdist: 0, titledist: 42280 };
  var rule73 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42308, lowdist: 0, titledist: 42308 };
  var rule74 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -209, lowdist: 0, titledist: -209 };
  var rule75 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -211, lowdist: 0, titledist: -211 };
  var rule76 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10743, lowdist: 0, titledist: 10743 };
  var rule77 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42305, lowdist: 0, titledist: 42305 };
  var rule78 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10749, lowdist: 0, titledist: 10749 };
  var rule79 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -213, lowdist: 0, titledist: -213 };
  var rule80 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -214, lowdist: 0, titledist: -214 };
  var rule81 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 10727, lowdist: 0, titledist: 10727 };
  var rule82 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -218, lowdist: 0, titledist: -218 };
  var rule83 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42307, lowdist: 0, titledist: 42307 };
  var rule84 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42282, lowdist: 0, titledist: 42282 };
  var rule85 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -69, lowdist: 0, titledist: -69 };
  var rule86 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -217, lowdist: 0, titledist: -217 };
  var rule87 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -71, lowdist: 0, titledist: -71 };
  var rule88 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -219, lowdist: 0, titledist: -219 };
  var rule89 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42261, lowdist: 0, titledist: 42261 };
  var rule90 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: 42258, lowdist: 0, titledist: 42258 };
  var rule99 = { category: 4096, unicodeCat: NUMCAT_LL, possible: 1, updist: -38, lowdist: 0, titledist: -38 };
  var rule199 = { category: 134217728, unicodeCat: NUMCAT_CS, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule200 = { category: 268435456, unicodeCat: NUMCAT_CO, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule16 = { category: 65536, unicodeCat: NUMCAT_CF, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var rule0 = { category: 1, unicodeCat: NUMCAT_CC, possible: 0, updist: 0, lowdist: 0, titledist: 0 };
  var convchars = [
    { start: 65, length: 26, convRule: rule9 },
    { start: 97, length: 26, convRule: rule12 },
    { start: 181, length: 1, convRule: rule18 },
    { start: 192, length: 23, convRule: rule9 },
    { start: 216, length: 7, convRule: rule9 },
    { start: 224, length: 23, convRule: rule12 },
    { start: 248, length: 7, convRule: rule12 },
    { start: 255, length: 1, convRule: rule21 },
    { start: 256, length: 1, convRule: rule22 },
    { start: 257, length: 1, convRule: rule23 },
    { start: 258, length: 1, convRule: rule22 },
    { start: 259, length: 1, convRule: rule23 },
    { start: 260, length: 1, convRule: rule22 },
    { start: 261, length: 1, convRule: rule23 },
    { start: 262, length: 1, convRule: rule22 },
    { start: 263, length: 1, convRule: rule23 },
    { start: 264, length: 1, convRule: rule22 },
    { start: 265, length: 1, convRule: rule23 },
    { start: 266, length: 1, convRule: rule22 },
    { start: 267, length: 1, convRule: rule23 },
    { start: 268, length: 1, convRule: rule22 },
    { start: 269, length: 1, convRule: rule23 },
    { start: 270, length: 1, convRule: rule22 },
    { start: 271, length: 1, convRule: rule23 },
    { start: 272, length: 1, convRule: rule22 },
    { start: 273, length: 1, convRule: rule23 },
    { start: 274, length: 1, convRule: rule22 },
    { start: 275, length: 1, convRule: rule23 },
    { start: 276, length: 1, convRule: rule22 },
    { start: 277, length: 1, convRule: rule23 },
    { start: 278, length: 1, convRule: rule22 },
    { start: 279, length: 1, convRule: rule23 },
    { start: 280, length: 1, convRule: rule22 },
    { start: 281, length: 1, convRule: rule23 },
    { start: 282, length: 1, convRule: rule22 },
    { start: 283, length: 1, convRule: rule23 },
    { start: 284, length: 1, convRule: rule22 },
    { start: 285, length: 1, convRule: rule23 },
    { start: 286, length: 1, convRule: rule22 },
    { start: 287, length: 1, convRule: rule23 },
    { start: 288, length: 1, convRule: rule22 },
    { start: 289, length: 1, convRule: rule23 },
    { start: 290, length: 1, convRule: rule22 },
    { start: 291, length: 1, convRule: rule23 },
    { start: 292, length: 1, convRule: rule22 },
    { start: 293, length: 1, convRule: rule23 },
    { start: 294, length: 1, convRule: rule22 },
    { start: 295, length: 1, convRule: rule23 },
    { start: 296, length: 1, convRule: rule22 },
    { start: 297, length: 1, convRule: rule23 },
    { start: 298, length: 1, convRule: rule22 },
    { start: 299, length: 1, convRule: rule23 },
    { start: 300, length: 1, convRule: rule22 },
    { start: 301, length: 1, convRule: rule23 },
    { start: 302, length: 1, convRule: rule22 },
    { start: 303, length: 1, convRule: rule23 },
    { start: 304, length: 1, convRule: rule24 },
    { start: 305, length: 1, convRule: rule25 },
    { start: 306, length: 1, convRule: rule22 },
    { start: 307, length: 1, convRule: rule23 },
    { start: 308, length: 1, convRule: rule22 },
    { start: 309, length: 1, convRule: rule23 },
    { start: 310, length: 1, convRule: rule22 },
    { start: 311, length: 1, convRule: rule23 },
    { start: 313, length: 1, convRule: rule22 },
    { start: 314, length: 1, convRule: rule23 },
    { start: 315, length: 1, convRule: rule22 },
    { start: 316, length: 1, convRule: rule23 },
    { start: 317, length: 1, convRule: rule22 },
    { start: 318, length: 1, convRule: rule23 },
    { start: 319, length: 1, convRule: rule22 },
    { start: 320, length: 1, convRule: rule23 },
    { start: 321, length: 1, convRule: rule22 },
    { start: 322, length: 1, convRule: rule23 },
    { start: 323, length: 1, convRule: rule22 },
    { start: 324, length: 1, convRule: rule23 },
    { start: 325, length: 1, convRule: rule22 },
    { start: 326, length: 1, convRule: rule23 },
    { start: 327, length: 1, convRule: rule22 },
    { start: 328, length: 1, convRule: rule23 },
    { start: 330, length: 1, convRule: rule22 },
    { start: 331, length: 1, convRule: rule23 },
    { start: 332, length: 1, convRule: rule22 },
    { start: 333, length: 1, convRule: rule23 },
    { start: 334, length: 1, convRule: rule22 },
    { start: 335, length: 1, convRule: rule23 },
    { start: 336, length: 1, convRule: rule22 },
    { start: 337, length: 1, convRule: rule23 },
    { start: 338, length: 1, convRule: rule22 },
    { start: 339, length: 1, convRule: rule23 },
    { start: 340, length: 1, convRule: rule22 },
    { start: 341, length: 1, convRule: rule23 },
    { start: 342, length: 1, convRule: rule22 },
    { start: 343, length: 1, convRule: rule23 },
    { start: 344, length: 1, convRule: rule22 },
    { start: 345, length: 1, convRule: rule23 },
    { start: 346, length: 1, convRule: rule22 },
    { start: 347, length: 1, convRule: rule23 },
    { start: 348, length: 1, convRule: rule22 },
    { start: 349, length: 1, convRule: rule23 },
    { start: 350, length: 1, convRule: rule22 },
    { start: 351, length: 1, convRule: rule23 },
    { start: 352, length: 1, convRule: rule22 },
    { start: 353, length: 1, convRule: rule23 },
    { start: 354, length: 1, convRule: rule22 },
    { start: 355, length: 1, convRule: rule23 },
    { start: 356, length: 1, convRule: rule22 },
    { start: 357, length: 1, convRule: rule23 },
    { start: 358, length: 1, convRule: rule22 },
    { start: 359, length: 1, convRule: rule23 },
    { start: 360, length: 1, convRule: rule22 },
    { start: 361, length: 1, convRule: rule23 },
    { start: 362, length: 1, convRule: rule22 },
    { start: 363, length: 1, convRule: rule23 },
    { start: 364, length: 1, convRule: rule22 },
    { start: 365, length: 1, convRule: rule23 },
    { start: 366, length: 1, convRule: rule22 },
    { start: 367, length: 1, convRule: rule23 },
    { start: 368, length: 1, convRule: rule22 },
    { start: 369, length: 1, convRule: rule23 },
    { start: 370, length: 1, convRule: rule22 },
    { start: 371, length: 1, convRule: rule23 },
    { start: 372, length: 1, convRule: rule22 },
    { start: 373, length: 1, convRule: rule23 },
    { start: 374, length: 1, convRule: rule22 },
    { start: 375, length: 1, convRule: rule23 },
    { start: 376, length: 1, convRule: rule26 },
    { start: 377, length: 1, convRule: rule22 },
    { start: 378, length: 1, convRule: rule23 },
    { start: 379, length: 1, convRule: rule22 },
    { start: 380, length: 1, convRule: rule23 },
    { start: 381, length: 1, convRule: rule22 },
    { start: 382, length: 1, convRule: rule23 },
    { start: 383, length: 1, convRule: rule27 },
    { start: 384, length: 1, convRule: rule28 },
    { start: 385, length: 1, convRule: rule29 },
    { start: 386, length: 1, convRule: rule22 },
    { start: 387, length: 1, convRule: rule23 },
    { start: 388, length: 1, convRule: rule22 },
    { start: 389, length: 1, convRule: rule23 },
    { start: 390, length: 1, convRule: rule30 },
    { start: 391, length: 1, convRule: rule22 },
    { start: 392, length: 1, convRule: rule23 },
    { start: 393, length: 2, convRule: rule31 },
    { start: 395, length: 1, convRule: rule22 },
    { start: 396, length: 1, convRule: rule23 },
    { start: 398, length: 1, convRule: rule32 },
    { start: 399, length: 1, convRule: rule33 },
    { start: 400, length: 1, convRule: rule34 },
    { start: 401, length: 1, convRule: rule22 },
    { start: 402, length: 1, convRule: rule23 },
    { start: 403, length: 1, convRule: rule31 },
    { start: 404, length: 1, convRule: rule35 },
    { start: 405, length: 1, convRule: rule36 },
    { start: 406, length: 1, convRule: rule37 },
    { start: 407, length: 1, convRule: rule38 },
    { start: 408, length: 1, convRule: rule22 },
    { start: 409, length: 1, convRule: rule23 },
    { start: 410, length: 1, convRule: rule39 },
    { start: 412, length: 1, convRule: rule37 },
    { start: 413, length: 1, convRule: rule40 },
    { start: 414, length: 1, convRule: rule41 },
    { start: 415, length: 1, convRule: rule42 },
    { start: 416, length: 1, convRule: rule22 },
    { start: 417, length: 1, convRule: rule23 },
    { start: 418, length: 1, convRule: rule22 },
    { start: 419, length: 1, convRule: rule23 },
    { start: 420, length: 1, convRule: rule22 },
    { start: 421, length: 1, convRule: rule23 },
    { start: 422, length: 1, convRule: rule43 },
    { start: 423, length: 1, convRule: rule22 },
    { start: 424, length: 1, convRule: rule23 },
    { start: 425, length: 1, convRule: rule43 },
    { start: 428, length: 1, convRule: rule22 },
    { start: 429, length: 1, convRule: rule23 },
    { start: 430, length: 1, convRule: rule43 },
    { start: 431, length: 1, convRule: rule22 },
    { start: 432, length: 1, convRule: rule23 },
    { start: 433, length: 2, convRule: rule44 },
    { start: 435, length: 1, convRule: rule22 },
    { start: 436, length: 1, convRule: rule23 },
    { start: 437, length: 1, convRule: rule22 },
    { start: 438, length: 1, convRule: rule23 },
    { start: 439, length: 1, convRule: rule45 },
    { start: 440, length: 1, convRule: rule22 },
    { start: 441, length: 1, convRule: rule23 },
    { start: 444, length: 1, convRule: rule22 },
    { start: 445, length: 1, convRule: rule23 },
    { start: 447, length: 1, convRule: rule46 },
    { start: 452, length: 1, convRule: rule47 },
    { start: 453, length: 1, convRule: rule48 },
    { start: 454, length: 1, convRule: rule49 },
    { start: 455, length: 1, convRule: rule47 },
    { start: 456, length: 1, convRule: rule48 },
    { start: 457, length: 1, convRule: rule49 },
    { start: 458, length: 1, convRule: rule47 },
    { start: 459, length: 1, convRule: rule48 },
    { start: 460, length: 1, convRule: rule49 },
    { start: 461, length: 1, convRule: rule22 },
    { start: 462, length: 1, convRule: rule23 },
    { start: 463, length: 1, convRule: rule22 },
    { start: 464, length: 1, convRule: rule23 },
    { start: 465, length: 1, convRule: rule22 },
    { start: 466, length: 1, convRule: rule23 },
    { start: 467, length: 1, convRule: rule22 },
    { start: 468, length: 1, convRule: rule23 },
    { start: 469, length: 1, convRule: rule22 },
    { start: 470, length: 1, convRule: rule23 },
    { start: 471, length: 1, convRule: rule22 },
    { start: 472, length: 1, convRule: rule23 },
    { start: 473, length: 1, convRule: rule22 },
    { start: 474, length: 1, convRule: rule23 },
    { start: 475, length: 1, convRule: rule22 },
    { start: 476, length: 1, convRule: rule23 },
    { start: 477, length: 1, convRule: rule50 },
    { start: 478, length: 1, convRule: rule22 },
    { start: 479, length: 1, convRule: rule23 },
    { start: 480, length: 1, convRule: rule22 },
    { start: 481, length: 1, convRule: rule23 },
    { start: 482, length: 1, convRule: rule22 },
    { start: 483, length: 1, convRule: rule23 },
    { start: 484, length: 1, convRule: rule22 },
    { start: 485, length: 1, convRule: rule23 },
    { start: 486, length: 1, convRule: rule22 },
    { start: 487, length: 1, convRule: rule23 },
    { start: 488, length: 1, convRule: rule22 },
    { start: 489, length: 1, convRule: rule23 },
    { start: 490, length: 1, convRule: rule22 },
    { start: 491, length: 1, convRule: rule23 },
    { start: 492, length: 1, convRule: rule22 },
    { start: 493, length: 1, convRule: rule23 },
    { start: 494, length: 1, convRule: rule22 },
    { start: 495, length: 1, convRule: rule23 },
    { start: 497, length: 1, convRule: rule47 },
    { start: 498, length: 1, convRule: rule48 },
    { start: 499, length: 1, convRule: rule49 },
    { start: 500, length: 1, convRule: rule22 },
    { start: 501, length: 1, convRule: rule23 },
    { start: 502, length: 1, convRule: rule51 },
    { start: 503, length: 1, convRule: rule52 },
    { start: 504, length: 1, convRule: rule22 },
    { start: 505, length: 1, convRule: rule23 },
    { start: 506, length: 1, convRule: rule22 },
    { start: 507, length: 1, convRule: rule23 },
    { start: 508, length: 1, convRule: rule22 },
    { start: 509, length: 1, convRule: rule23 },
    { start: 510, length: 1, convRule: rule22 },
    { start: 511, length: 1, convRule: rule23 },
    { start: 512, length: 1, convRule: rule22 },
    { start: 513, length: 1, convRule: rule23 },
    { start: 514, length: 1, convRule: rule22 },
    { start: 515, length: 1, convRule: rule23 },
    { start: 516, length: 1, convRule: rule22 },
    { start: 517, length: 1, convRule: rule23 },
    { start: 518, length: 1, convRule: rule22 },
    { start: 519, length: 1, convRule: rule23 },
    { start: 520, length: 1, convRule: rule22 },
    { start: 521, length: 1, convRule: rule23 },
    { start: 522, length: 1, convRule: rule22 },
    { start: 523, length: 1, convRule: rule23 },
    { start: 524, length: 1, convRule: rule22 },
    { start: 525, length: 1, convRule: rule23 },
    { start: 526, length: 1, convRule: rule22 },
    { start: 527, length: 1, convRule: rule23 },
    { start: 528, length: 1, convRule: rule22 },
    { start: 529, length: 1, convRule: rule23 },
    { start: 530, length: 1, convRule: rule22 },
    { start: 531, length: 1, convRule: rule23 },
    { start: 532, length: 1, convRule: rule22 },
    { start: 533, length: 1, convRule: rule23 },
    { start: 534, length: 1, convRule: rule22 },
    { start: 535, length: 1, convRule: rule23 },
    { start: 536, length: 1, convRule: rule22 },
    { start: 537, length: 1, convRule: rule23 },
    { start: 538, length: 1, convRule: rule22 },
    { start: 539, length: 1, convRule: rule23 },
    { start: 540, length: 1, convRule: rule22 },
    { start: 541, length: 1, convRule: rule23 },
    { start: 542, length: 1, convRule: rule22 },
    { start: 543, length: 1, convRule: rule23 },
    { start: 544, length: 1, convRule: rule53 },
    { start: 546, length: 1, convRule: rule22 },
    { start: 547, length: 1, convRule: rule23 },
    { start: 548, length: 1, convRule: rule22 },
    { start: 549, length: 1, convRule: rule23 },
    { start: 550, length: 1, convRule: rule22 },
    { start: 551, length: 1, convRule: rule23 },
    { start: 552, length: 1, convRule: rule22 },
    { start: 553, length: 1, convRule: rule23 },
    { start: 554, length: 1, convRule: rule22 },
    { start: 555, length: 1, convRule: rule23 },
    { start: 556, length: 1, convRule: rule22 },
    { start: 557, length: 1, convRule: rule23 },
    { start: 558, length: 1, convRule: rule22 },
    { start: 559, length: 1, convRule: rule23 },
    { start: 560, length: 1, convRule: rule22 },
    { start: 561, length: 1, convRule: rule23 },
    { start: 562, length: 1, convRule: rule22 },
    { start: 563, length: 1, convRule: rule23 },
    { start: 570, length: 1, convRule: rule54 },
    { start: 571, length: 1, convRule: rule22 },
    { start: 572, length: 1, convRule: rule23 },
    { start: 573, length: 1, convRule: rule55 },
    { start: 574, length: 1, convRule: rule56 },
    { start: 575, length: 2, convRule: rule57 },
    { start: 577, length: 1, convRule: rule22 },
    { start: 578, length: 1, convRule: rule23 },
    { start: 579, length: 1, convRule: rule58 },
    { start: 580, length: 1, convRule: rule59 },
    { start: 581, length: 1, convRule: rule60 },
    { start: 582, length: 1, convRule: rule22 },
    { start: 583, length: 1, convRule: rule23 },
    { start: 584, length: 1, convRule: rule22 },
    { start: 585, length: 1, convRule: rule23 },
    { start: 586, length: 1, convRule: rule22 },
    { start: 587, length: 1, convRule: rule23 },
    { start: 588, length: 1, convRule: rule22 },
    { start: 589, length: 1, convRule: rule23 },
    { start: 590, length: 1, convRule: rule22 },
    { start: 591, length: 1, convRule: rule23 },
    { start: 592, length: 1, convRule: rule61 },
    { start: 593, length: 1, convRule: rule62 },
    { start: 594, length: 1, convRule: rule63 },
    { start: 595, length: 1, convRule: rule64 },
    { start: 596, length: 1, convRule: rule65 },
    { start: 598, length: 2, convRule: rule66 },
    { start: 601, length: 1, convRule: rule67 },
    { start: 603, length: 1, convRule: rule68 },
    { start: 604, length: 1, convRule: rule69 },
    { start: 608, length: 1, convRule: rule66 },
    { start: 609, length: 1, convRule: rule70 },
    { start: 611, length: 1, convRule: rule71 },
    { start: 613, length: 1, convRule: rule72 },
    { start: 614, length: 1, convRule: rule73 },
    { start: 616, length: 1, convRule: rule74 },
    { start: 617, length: 1, convRule: rule75 },
    { start: 618, length: 1, convRule: rule73 },
    { start: 619, length: 1, convRule: rule76 },
    { start: 620, length: 1, convRule: rule77 },
    { start: 623, length: 1, convRule: rule75 },
    { start: 625, length: 1, convRule: rule78 },
    { start: 626, length: 1, convRule: rule79 },
    { start: 629, length: 1, convRule: rule80 },
    { start: 637, length: 1, convRule: rule81 },
    { start: 640, length: 1, convRule: rule82 },
    { start: 642, length: 1, convRule: rule83 },
    { start: 643, length: 1, convRule: rule82 },
    { start: 647, length: 1, convRule: rule84 },
    { start: 648, length: 1, convRule: rule82 },
    { start: 649, length: 1, convRule: rule85 },
    { start: 650, length: 2, convRule: rule86 },
    { start: 652, length: 1, convRule: rule87 },
    { start: 658, length: 1, convRule: rule88 },
    { start: 669, length: 1, convRule: rule89 },
    { start: 670, length: 1, convRule: rule90 },
    { start: 837, length: 1, convRule: rule93 },
    { start: 880, length: 1, convRule: rule22 },
    { start: 881, length: 1, convRule: rule23 },
    { start: 882, length: 1, convRule: rule22 },
    { start: 883, length: 1, convRule: rule23 },
    { start: 886, length: 1, convRule: rule22 },
    { start: 887, length: 1, convRule: rule23 },
    { start: 891, length: 3, convRule: rule41 },
    { start: 895, length: 1, convRule: rule94 },
    { start: 902, length: 1, convRule: rule95 },
    { start: 904, length: 3, convRule: rule96 },
    { start: 908, length: 1, convRule: rule97 },
    { start: 910, length: 2, convRule: rule98 },
    { start: 913, length: 17, convRule: rule9 },
    { start: 931, length: 9, convRule: rule9 },
    { start: 940, length: 1, convRule: rule99 },
    { start: 941, length: 3, convRule: rule100 },
    { start: 945, length: 17, convRule: rule12 },
    { start: 962, length: 1, convRule: rule101 },
    { start: 963, length: 9, convRule: rule12 },
    { start: 972, length: 1, convRule: rule102 },
    { start: 973, length: 2, convRule: rule103 },
    { start: 975, length: 1, convRule: rule104 },
    { start: 976, length: 1, convRule: rule105 },
    { start: 977, length: 1, convRule: rule106 },
    { start: 981, length: 1, convRule: rule108 },
    { start: 982, length: 1, convRule: rule109 },
    { start: 983, length: 1, convRule: rule110 },
    { start: 984, length: 1, convRule: rule22 },
    { start: 985, length: 1, convRule: rule23 },
    { start: 986, length: 1, convRule: rule22 },
    { start: 987, length: 1, convRule: rule23 },
    { start: 988, length: 1, convRule: rule22 },
    { start: 989, length: 1, convRule: rule23 },
    { start: 990, length: 1, convRule: rule22 },
    { start: 991, length: 1, convRule: rule23 },
    { start: 992, length: 1, convRule: rule22 },
    { start: 993, length: 1, convRule: rule23 },
    { start: 994, length: 1, convRule: rule22 },
    { start: 995, length: 1, convRule: rule23 },
    { start: 996, length: 1, convRule: rule22 },
    { start: 997, length: 1, convRule: rule23 },
    { start: 998, length: 1, convRule: rule22 },
    { start: 999, length: 1, convRule: rule23 },
    { start: 1e3, length: 1, convRule: rule22 },
    { start: 1001, length: 1, convRule: rule23 },
    { start: 1002, length: 1, convRule: rule22 },
    { start: 1003, length: 1, convRule: rule23 },
    { start: 1004, length: 1, convRule: rule22 },
    { start: 1005, length: 1, convRule: rule23 },
    { start: 1006, length: 1, convRule: rule22 },
    { start: 1007, length: 1, convRule: rule23 },
    { start: 1008, length: 1, convRule: rule111 },
    { start: 1009, length: 1, convRule: rule112 },
    { start: 1010, length: 1, convRule: rule113 },
    { start: 1011, length: 1, convRule: rule114 },
    { start: 1012, length: 1, convRule: rule115 },
    { start: 1013, length: 1, convRule: rule116 },
    { start: 1015, length: 1, convRule: rule22 },
    { start: 1016, length: 1, convRule: rule23 },
    { start: 1017, length: 1, convRule: rule117 },
    { start: 1018, length: 1, convRule: rule22 },
    { start: 1019, length: 1, convRule: rule23 },
    { start: 1021, length: 3, convRule: rule53 },
    { start: 1024, length: 16, convRule: rule118 },
    { start: 1040, length: 32, convRule: rule9 },
    { start: 1072, length: 32, convRule: rule12 },
    { start: 1104, length: 16, convRule: rule112 },
    { start: 1120, length: 1, convRule: rule22 },
    { start: 1121, length: 1, convRule: rule23 },
    { start: 1122, length: 1, convRule: rule22 },
    { start: 1123, length: 1, convRule: rule23 },
    { start: 1124, length: 1, convRule: rule22 },
    { start: 1125, length: 1, convRule: rule23 },
    { start: 1126, length: 1, convRule: rule22 },
    { start: 1127, length: 1, convRule: rule23 },
    { start: 1128, length: 1, convRule: rule22 },
    { start: 1129, length: 1, convRule: rule23 },
    { start: 1130, length: 1, convRule: rule22 },
    { start: 1131, length: 1, convRule: rule23 },
    { start: 1132, length: 1, convRule: rule22 },
    { start: 1133, length: 1, convRule: rule23 },
    { start: 1134, length: 1, convRule: rule22 },
    { start: 1135, length: 1, convRule: rule23 },
    { start: 1136, length: 1, convRule: rule22 },
    { start: 1137, length: 1, convRule: rule23 },
    { start: 1138, length: 1, convRule: rule22 },
    { start: 1139, length: 1, convRule: rule23 },
    { start: 1140, length: 1, convRule: rule22 },
    { start: 1141, length: 1, convRule: rule23 },
    { start: 1142, length: 1, convRule: rule22 },
    { start: 1143, length: 1, convRule: rule23 },
    { start: 1144, length: 1, convRule: rule22 },
    { start: 1145, length: 1, convRule: rule23 },
    { start: 1146, length: 1, convRule: rule22 },
    { start: 1147, length: 1, convRule: rule23 },
    { start: 1148, length: 1, convRule: rule22 },
    { start: 1149, length: 1, convRule: rule23 },
    { start: 1150, length: 1, convRule: rule22 },
    { start: 1151, length: 1, convRule: rule23 },
    { start: 1152, length: 1, convRule: rule22 },
    { start: 1153, length: 1, convRule: rule23 },
    { start: 1162, length: 1, convRule: rule22 },
    { start: 1163, length: 1, convRule: rule23 },
    { start: 1164, length: 1, convRule: rule22 },
    { start: 1165, length: 1, convRule: rule23 },
    { start: 1166, length: 1, convRule: rule22 },
    { start: 1167, length: 1, convRule: rule23 },
    { start: 1168, length: 1, convRule: rule22 },
    { start: 1169, length: 1, convRule: rule23 },
    { start: 1170, length: 1, convRule: rule22 },
    { start: 1171, length: 1, convRule: rule23 },
    { start: 1172, length: 1, convRule: rule22 },
    { start: 1173, length: 1, convRule: rule23 },
    { start: 1174, length: 1, convRule: rule22 },
    { start: 1175, length: 1, convRule: rule23 },
    { start: 1176, length: 1, convRule: rule22 },
    { start: 1177, length: 1, convRule: rule23 },
    { start: 1178, length: 1, convRule: rule22 },
    { start: 1179, length: 1, convRule: rule23 },
    { start: 1180, length: 1, convRule: rule22 },
    { start: 1181, length: 1, convRule: rule23 },
    { start: 1182, length: 1, convRule: rule22 },
    { start: 1183, length: 1, convRule: rule23 },
    { start: 1184, length: 1, convRule: rule22 },
    { start: 1185, length: 1, convRule: rule23 },
    { start: 1186, length: 1, convRule: rule22 },
    { start: 1187, length: 1, convRule: rule23 },
    { start: 1188, length: 1, convRule: rule22 },
    { start: 1189, length: 1, convRule: rule23 },
    { start: 1190, length: 1, convRule: rule22 },
    { start: 1191, length: 1, convRule: rule23 },
    { start: 1192, length: 1, convRule: rule22 },
    { start: 1193, length: 1, convRule: rule23 },
    { start: 1194, length: 1, convRule: rule22 },
    { start: 1195, length: 1, convRule: rule23 },
    { start: 1196, length: 1, convRule: rule22 },
    { start: 1197, length: 1, convRule: rule23 },
    { start: 1198, length: 1, convRule: rule22 },
    { start: 1199, length: 1, convRule: rule23 },
    { start: 1200, length: 1, convRule: rule22 },
    { start: 1201, length: 1, convRule: rule23 },
    { start: 1202, length: 1, convRule: rule22 },
    { start: 1203, length: 1, convRule: rule23 },
    { start: 1204, length: 1, convRule: rule22 },
    { start: 1205, length: 1, convRule: rule23 },
    { start: 1206, length: 1, convRule: rule22 },
    { start: 1207, length: 1, convRule: rule23 },
    { start: 1208, length: 1, convRule: rule22 },
    { start: 1209, length: 1, convRule: rule23 },
    { start: 1210, length: 1, convRule: rule22 },
    { start: 1211, length: 1, convRule: rule23 },
    { start: 1212, length: 1, convRule: rule22 },
    { start: 1213, length: 1, convRule: rule23 },
    { start: 1214, length: 1, convRule: rule22 },
    { start: 1215, length: 1, convRule: rule23 },
    { start: 1216, length: 1, convRule: rule120 },
    { start: 1217, length: 1, convRule: rule22 },
    { start: 1218, length: 1, convRule: rule23 },
    { start: 1219, length: 1, convRule: rule22 },
    { start: 1220, length: 1, convRule: rule23 },
    { start: 1221, length: 1, convRule: rule22 },
    { start: 1222, length: 1, convRule: rule23 },
    { start: 1223, length: 1, convRule: rule22 },
    { start: 1224, length: 1, convRule: rule23 },
    { start: 1225, length: 1, convRule: rule22 },
    { start: 1226, length: 1, convRule: rule23 },
    { start: 1227, length: 1, convRule: rule22 },
    { start: 1228, length: 1, convRule: rule23 },
    { start: 1229, length: 1, convRule: rule22 },
    { start: 1230, length: 1, convRule: rule23 },
    { start: 1231, length: 1, convRule: rule121 },
    { start: 1232, length: 1, convRule: rule22 },
    { start: 1233, length: 1, convRule: rule23 },
    { start: 1234, length: 1, convRule: rule22 },
    { start: 1235, length: 1, convRule: rule23 },
    { start: 1236, length: 1, convRule: rule22 },
    { start: 1237, length: 1, convRule: rule23 },
    { start: 1238, length: 1, convRule: rule22 },
    { start: 1239, length: 1, convRule: rule23 },
    { start: 1240, length: 1, convRule: rule22 },
    { start: 1241, length: 1, convRule: rule23 },
    { start: 1242, length: 1, convRule: rule22 },
    { start: 1243, length: 1, convRule: rule23 },
    { start: 1244, length: 1, convRule: rule22 },
    { start: 1245, length: 1, convRule: rule23 },
    { start: 1246, length: 1, convRule: rule22 },
    { start: 1247, length: 1, convRule: rule23 },
    { start: 1248, length: 1, convRule: rule22 },
    { start: 1249, length: 1, convRule: rule23 },
    { start: 1250, length: 1, convRule: rule22 },
    { start: 1251, length: 1, convRule: rule23 },
    { start: 1252, length: 1, convRule: rule22 },
    { start: 1253, length: 1, convRule: rule23 },
    { start: 1254, length: 1, convRule: rule22 },
    { start: 1255, length: 1, convRule: rule23 },
    { start: 1256, length: 1, convRule: rule22 },
    { start: 1257, length: 1, convRule: rule23 },
    { start: 1258, length: 1, convRule: rule22 },
    { start: 1259, length: 1, convRule: rule23 },
    { start: 1260, length: 1, convRule: rule22 },
    { start: 1261, length: 1, convRule: rule23 },
    { start: 1262, length: 1, convRule: rule22 },
    { start: 1263, length: 1, convRule: rule23 },
    { start: 1264, length: 1, convRule: rule22 },
    { start: 1265, length: 1, convRule: rule23 },
    { start: 1266, length: 1, convRule: rule22 },
    { start: 1267, length: 1, convRule: rule23 },
    { start: 1268, length: 1, convRule: rule22 },
    { start: 1269, length: 1, convRule: rule23 },
    { start: 1270, length: 1, convRule: rule22 },
    { start: 1271, length: 1, convRule: rule23 },
    { start: 1272, length: 1, convRule: rule22 },
    { start: 1273, length: 1, convRule: rule23 },
    { start: 1274, length: 1, convRule: rule22 },
    { start: 1275, length: 1, convRule: rule23 },
    { start: 1276, length: 1, convRule: rule22 },
    { start: 1277, length: 1, convRule: rule23 },
    { start: 1278, length: 1, convRule: rule22 },
    { start: 1279, length: 1, convRule: rule23 },
    { start: 1280, length: 1, convRule: rule22 },
    { start: 1281, length: 1, convRule: rule23 },
    { start: 1282, length: 1, convRule: rule22 },
    { start: 1283, length: 1, convRule: rule23 },
    { start: 1284, length: 1, convRule: rule22 },
    { start: 1285, length: 1, convRule: rule23 },
    { start: 1286, length: 1, convRule: rule22 },
    { start: 1287, length: 1, convRule: rule23 },
    { start: 1288, length: 1, convRule: rule22 },
    { start: 1289, length: 1, convRule: rule23 },
    { start: 1290, length: 1, convRule: rule22 },
    { start: 1291, length: 1, convRule: rule23 },
    { start: 1292, length: 1, convRule: rule22 },
    { start: 1293, length: 1, convRule: rule23 },
    { start: 1294, length: 1, convRule: rule22 },
    { start: 1295, length: 1, convRule: rule23 },
    { start: 1296, length: 1, convRule: rule22 },
    { start: 1297, length: 1, convRule: rule23 },
    { start: 1298, length: 1, convRule: rule22 },
    { start: 1299, length: 1, convRule: rule23 },
    { start: 1300, length: 1, convRule: rule22 },
    { start: 1301, length: 1, convRule: rule23 },
    { start: 1302, length: 1, convRule: rule22 },
    { start: 1303, length: 1, convRule: rule23 },
    { start: 1304, length: 1, convRule: rule22 },
    { start: 1305, length: 1, convRule: rule23 },
    { start: 1306, length: 1, convRule: rule22 },
    { start: 1307, length: 1, convRule: rule23 },
    { start: 1308, length: 1, convRule: rule22 },
    { start: 1309, length: 1, convRule: rule23 },
    { start: 1310, length: 1, convRule: rule22 },
    { start: 1311, length: 1, convRule: rule23 },
    { start: 1312, length: 1, convRule: rule22 },
    { start: 1313, length: 1, convRule: rule23 },
    { start: 1314, length: 1, convRule: rule22 },
    { start: 1315, length: 1, convRule: rule23 },
    { start: 1316, length: 1, convRule: rule22 },
    { start: 1317, length: 1, convRule: rule23 },
    { start: 1318, length: 1, convRule: rule22 },
    { start: 1319, length: 1, convRule: rule23 },
    { start: 1320, length: 1, convRule: rule22 },
    { start: 1321, length: 1, convRule: rule23 },
    { start: 1322, length: 1, convRule: rule22 },
    { start: 1323, length: 1, convRule: rule23 },
    { start: 1324, length: 1, convRule: rule22 },
    { start: 1325, length: 1, convRule: rule23 },
    { start: 1326, length: 1, convRule: rule22 },
    { start: 1327, length: 1, convRule: rule23 },
    { start: 1329, length: 38, convRule: rule122 },
    { start: 1377, length: 38, convRule: rule123 },
    { start: 4256, length: 38, convRule: rule125 },
    { start: 4295, length: 1, convRule: rule125 },
    { start: 4301, length: 1, convRule: rule125 },
    { start: 4304, length: 43, convRule: rule126 },
    { start: 4349, length: 3, convRule: rule126 },
    { start: 5024, length: 80, convRule: rule127 },
    { start: 5104, length: 6, convRule: rule104 },
    { start: 5112, length: 6, convRule: rule110 },
    { start: 7296, length: 1, convRule: rule129 },
    { start: 7297, length: 1, convRule: rule130 },
    { start: 7298, length: 1, convRule: rule131 },
    { start: 7299, length: 2, convRule: rule132 },
    { start: 7301, length: 1, convRule: rule133 },
    { start: 7302, length: 1, convRule: rule134 },
    { start: 7303, length: 1, convRule: rule135 },
    { start: 7304, length: 1, convRule: rule136 },
    { start: 7312, length: 43, convRule: rule137 },
    { start: 7357, length: 3, convRule: rule137 },
    { start: 7545, length: 1, convRule: rule138 },
    { start: 7549, length: 1, convRule: rule139 },
    { start: 7566, length: 1, convRule: rule140 },
    { start: 7680, length: 1, convRule: rule22 },
    { start: 7681, length: 1, convRule: rule23 },
    { start: 7682, length: 1, convRule: rule22 },
    { start: 7683, length: 1, convRule: rule23 },
    { start: 7684, length: 1, convRule: rule22 },
    { start: 7685, length: 1, convRule: rule23 },
    { start: 7686, length: 1, convRule: rule22 },
    { start: 7687, length: 1, convRule: rule23 },
    { start: 7688, length: 1, convRule: rule22 },
    { start: 7689, length: 1, convRule: rule23 },
    { start: 7690, length: 1, convRule: rule22 },
    { start: 7691, length: 1, convRule: rule23 },
    { start: 7692, length: 1, convRule: rule22 },
    { start: 7693, length: 1, convRule: rule23 },
    { start: 7694, length: 1, convRule: rule22 },
    { start: 7695, length: 1, convRule: rule23 },
    { start: 7696, length: 1, convRule: rule22 },
    { start: 7697, length: 1, convRule: rule23 },
    { start: 7698, length: 1, convRule: rule22 },
    { start: 7699, length: 1, convRule: rule23 },
    { start: 7700, length: 1, convRule: rule22 },
    { start: 7701, length: 1, convRule: rule23 },
    { start: 7702, length: 1, convRule: rule22 },
    { start: 7703, length: 1, convRule: rule23 },
    { start: 7704, length: 1, convRule: rule22 },
    { start: 7705, length: 1, convRule: rule23 },
    { start: 7706, length: 1, convRule: rule22 },
    { start: 7707, length: 1, convRule: rule23 },
    { start: 7708, length: 1, convRule: rule22 },
    { start: 7709, length: 1, convRule: rule23 },
    { start: 7710, length: 1, convRule: rule22 },
    { start: 7711, length: 1, convRule: rule23 },
    { start: 7712, length: 1, convRule: rule22 },
    { start: 7713, length: 1, convRule: rule23 },
    { start: 7714, length: 1, convRule: rule22 },
    { start: 7715, length: 1, convRule: rule23 },
    { start: 7716, length: 1, convRule: rule22 },
    { start: 7717, length: 1, convRule: rule23 },
    { start: 7718, length: 1, convRule: rule22 },
    { start: 7719, length: 1, convRule: rule23 },
    { start: 7720, length: 1, convRule: rule22 },
    { start: 7721, length: 1, convRule: rule23 },
    { start: 7722, length: 1, convRule: rule22 },
    { start: 7723, length: 1, convRule: rule23 },
    { start: 7724, length: 1, convRule: rule22 },
    { start: 7725, length: 1, convRule: rule23 },
    { start: 7726, length: 1, convRule: rule22 },
    { start: 7727, length: 1, convRule: rule23 },
    { start: 7728, length: 1, convRule: rule22 },
    { start: 7729, length: 1, convRule: rule23 },
    { start: 7730, length: 1, convRule: rule22 },
    { start: 7731, length: 1, convRule: rule23 },
    { start: 7732, length: 1, convRule: rule22 },
    { start: 7733, length: 1, convRule: rule23 },
    { start: 7734, length: 1, convRule: rule22 },
    { start: 7735, length: 1, convRule: rule23 },
    { start: 7736, length: 1, convRule: rule22 },
    { start: 7737, length: 1, convRule: rule23 },
    { start: 7738, length: 1, convRule: rule22 },
    { start: 7739, length: 1, convRule: rule23 },
    { start: 7740, length: 1, convRule: rule22 },
    { start: 7741, length: 1, convRule: rule23 },
    { start: 7742, length: 1, convRule: rule22 },
    { start: 7743, length: 1, convRule: rule23 },
    { start: 7744, length: 1, convRule: rule22 },
    { start: 7745, length: 1, convRule: rule23 },
    { start: 7746, length: 1, convRule: rule22 },
    { start: 7747, length: 1, convRule: rule23 },
    { start: 7748, length: 1, convRule: rule22 },
    { start: 7749, length: 1, convRule: rule23 },
    { start: 7750, length: 1, convRule: rule22 },
    { start: 7751, length: 1, convRule: rule23 },
    { start: 7752, length: 1, convRule: rule22 },
    { start: 7753, length: 1, convRule: rule23 },
    { start: 7754, length: 1, convRule: rule22 },
    { start: 7755, length: 1, convRule: rule23 },
    { start: 7756, length: 1, convRule: rule22 },
    { start: 7757, length: 1, convRule: rule23 },
    { start: 7758, length: 1, convRule: rule22 },
    { start: 7759, length: 1, convRule: rule23 },
    { start: 7760, length: 1, convRule: rule22 },
    { start: 7761, length: 1, convRule: rule23 },
    { start: 7762, length: 1, convRule: rule22 },
    { start: 7763, length: 1, convRule: rule23 },
    { start: 7764, length: 1, convRule: rule22 },
    { start: 7765, length: 1, convRule: rule23 },
    { start: 7766, length: 1, convRule: rule22 },
    { start: 7767, length: 1, convRule: rule23 },
    { start: 7768, length: 1, convRule: rule22 },
    { start: 7769, length: 1, convRule: rule23 },
    { start: 7770, length: 1, convRule: rule22 },
    { start: 7771, length: 1, convRule: rule23 },
    { start: 7772, length: 1, convRule: rule22 },
    { start: 7773, length: 1, convRule: rule23 },
    { start: 7774, length: 1, convRule: rule22 },
    { start: 7775, length: 1, convRule: rule23 },
    { start: 7776, length: 1, convRule: rule22 },
    { start: 7777, length: 1, convRule: rule23 },
    { start: 7778, length: 1, convRule: rule22 },
    { start: 7779, length: 1, convRule: rule23 },
    { start: 7780, length: 1, convRule: rule22 },
    { start: 7781, length: 1, convRule: rule23 },
    { start: 7782, length: 1, convRule: rule22 },
    { start: 7783, length: 1, convRule: rule23 },
    { start: 7784, length: 1, convRule: rule22 },
    { start: 7785, length: 1, convRule: rule23 },
    { start: 7786, length: 1, convRule: rule22 },
    { start: 7787, length: 1, convRule: rule23 },
    { start: 7788, length: 1, convRule: rule22 },
    { start: 7789, length: 1, convRule: rule23 },
    { start: 7790, length: 1, convRule: rule22 },
    { start: 7791, length: 1, convRule: rule23 },
    { start: 7792, length: 1, convRule: rule22 },
    { start: 7793, length: 1, convRule: rule23 },
    { start: 7794, length: 1, convRule: rule22 },
    { start: 7795, length: 1, convRule: rule23 },
    { start: 7796, length: 1, convRule: rule22 },
    { start: 7797, length: 1, convRule: rule23 },
    { start: 7798, length: 1, convRule: rule22 },
    { start: 7799, length: 1, convRule: rule23 },
    { start: 7800, length: 1, convRule: rule22 },
    { start: 7801, length: 1, convRule: rule23 },
    { start: 7802, length: 1, convRule: rule22 },
    { start: 7803, length: 1, convRule: rule23 },
    { start: 7804, length: 1, convRule: rule22 },
    { start: 7805, length: 1, convRule: rule23 },
    { start: 7806, length: 1, convRule: rule22 },
    { start: 7807, length: 1, convRule: rule23 },
    { start: 7808, length: 1, convRule: rule22 },
    { start: 7809, length: 1, convRule: rule23 },
    { start: 7810, length: 1, convRule: rule22 },
    { start: 7811, length: 1, convRule: rule23 },
    { start: 7812, length: 1, convRule: rule22 },
    { start: 7813, length: 1, convRule: rule23 },
    { start: 7814, length: 1, convRule: rule22 },
    { start: 7815, length: 1, convRule: rule23 },
    { start: 7816, length: 1, convRule: rule22 },
    { start: 7817, length: 1, convRule: rule23 },
    { start: 7818, length: 1, convRule: rule22 },
    { start: 7819, length: 1, convRule: rule23 },
    { start: 7820, length: 1, convRule: rule22 },
    { start: 7821, length: 1, convRule: rule23 },
    { start: 7822, length: 1, convRule: rule22 },
    { start: 7823, length: 1, convRule: rule23 },
    { start: 7824, length: 1, convRule: rule22 },
    { start: 7825, length: 1, convRule: rule23 },
    { start: 7826, length: 1, convRule: rule22 },
    { start: 7827, length: 1, convRule: rule23 },
    { start: 7828, length: 1, convRule: rule22 },
    { start: 7829, length: 1, convRule: rule23 },
    { start: 7835, length: 1, convRule: rule141 },
    { start: 7838, length: 1, convRule: rule142 },
    { start: 7840, length: 1, convRule: rule22 },
    { start: 7841, length: 1, convRule: rule23 },
    { start: 7842, length: 1, convRule: rule22 },
    { start: 7843, length: 1, convRule: rule23 },
    { start: 7844, length: 1, convRule: rule22 },
    { start: 7845, length: 1, convRule: rule23 },
    { start: 7846, length: 1, convRule: rule22 },
    { start: 7847, length: 1, convRule: rule23 },
    { start: 7848, length: 1, convRule: rule22 },
    { start: 7849, length: 1, convRule: rule23 },
    { start: 7850, length: 1, convRule: rule22 },
    { start: 7851, length: 1, convRule: rule23 },
    { start: 7852, length: 1, convRule: rule22 },
    { start: 7853, length: 1, convRule: rule23 },
    { start: 7854, length: 1, convRule: rule22 },
    { start: 7855, length: 1, convRule: rule23 },
    { start: 7856, length: 1, convRule: rule22 },
    { start: 7857, length: 1, convRule: rule23 },
    { start: 7858, length: 1, convRule: rule22 },
    { start: 7859, length: 1, convRule: rule23 },
    { start: 7860, length: 1, convRule: rule22 },
    { start: 7861, length: 1, convRule: rule23 },
    { start: 7862, length: 1, convRule: rule22 },
    { start: 7863, length: 1, convRule: rule23 },
    { start: 7864, length: 1, convRule: rule22 },
    { start: 7865, length: 1, convRule: rule23 },
    { start: 7866, length: 1, convRule: rule22 },
    { start: 7867, length: 1, convRule: rule23 },
    { start: 7868, length: 1, convRule: rule22 },
    { start: 7869, length: 1, convRule: rule23 },
    { start: 7870, length: 1, convRule: rule22 },
    { start: 7871, length: 1, convRule: rule23 },
    { start: 7872, length: 1, convRule: rule22 },
    { start: 7873, length: 1, convRule: rule23 },
    { start: 7874, length: 1, convRule: rule22 },
    { start: 7875, length: 1, convRule: rule23 },
    { start: 7876, length: 1, convRule: rule22 },
    { start: 7877, length: 1, convRule: rule23 },
    { start: 7878, length: 1, convRule: rule22 },
    { start: 7879, length: 1, convRule: rule23 },
    { start: 7880, length: 1, convRule: rule22 },
    { start: 7881, length: 1, convRule: rule23 },
    { start: 7882, length: 1, convRule: rule22 },
    { start: 7883, length: 1, convRule: rule23 },
    { start: 7884, length: 1, convRule: rule22 },
    { start: 7885, length: 1, convRule: rule23 },
    { start: 7886, length: 1, convRule: rule22 },
    { start: 7887, length: 1, convRule: rule23 },
    { start: 7888, length: 1, convRule: rule22 },
    { start: 7889, length: 1, convRule: rule23 },
    { start: 7890, length: 1, convRule: rule22 },
    { start: 7891, length: 1, convRule: rule23 },
    { start: 7892, length: 1, convRule: rule22 },
    { start: 7893, length: 1, convRule: rule23 },
    { start: 7894, length: 1, convRule: rule22 },
    { start: 7895, length: 1, convRule: rule23 },
    { start: 7896, length: 1, convRule: rule22 },
    { start: 7897, length: 1, convRule: rule23 },
    { start: 7898, length: 1, convRule: rule22 },
    { start: 7899, length: 1, convRule: rule23 },
    { start: 7900, length: 1, convRule: rule22 },
    { start: 7901, length: 1, convRule: rule23 },
    { start: 7902, length: 1, convRule: rule22 },
    { start: 7903, length: 1, convRule: rule23 },
    { start: 7904, length: 1, convRule: rule22 },
    { start: 7905, length: 1, convRule: rule23 },
    { start: 7906, length: 1, convRule: rule22 },
    { start: 7907, length: 1, convRule: rule23 },
    { start: 7908, length: 1, convRule: rule22 },
    { start: 7909, length: 1, convRule: rule23 },
    { start: 7910, length: 1, convRule: rule22 },
    { start: 7911, length: 1, convRule: rule23 },
    { start: 7912, length: 1, convRule: rule22 },
    { start: 7913, length: 1, convRule: rule23 },
    { start: 7914, length: 1, convRule: rule22 },
    { start: 7915, length: 1, convRule: rule23 },
    { start: 7916, length: 1, convRule: rule22 },
    { start: 7917, length: 1, convRule: rule23 },
    { start: 7918, length: 1, convRule: rule22 },
    { start: 7919, length: 1, convRule: rule23 },
    { start: 7920, length: 1, convRule: rule22 },
    { start: 7921, length: 1, convRule: rule23 },
    { start: 7922, length: 1, convRule: rule22 },
    { start: 7923, length: 1, convRule: rule23 },
    { start: 7924, length: 1, convRule: rule22 },
    { start: 7925, length: 1, convRule: rule23 },
    { start: 7926, length: 1, convRule: rule22 },
    { start: 7927, length: 1, convRule: rule23 },
    { start: 7928, length: 1, convRule: rule22 },
    { start: 7929, length: 1, convRule: rule23 },
    { start: 7930, length: 1, convRule: rule22 },
    { start: 7931, length: 1, convRule: rule23 },
    { start: 7932, length: 1, convRule: rule22 },
    { start: 7933, length: 1, convRule: rule23 },
    { start: 7934, length: 1, convRule: rule22 },
    { start: 7935, length: 1, convRule: rule23 },
    { start: 7936, length: 8, convRule: rule143 },
    { start: 7944, length: 8, convRule: rule144 },
    { start: 7952, length: 6, convRule: rule143 },
    { start: 7960, length: 6, convRule: rule144 },
    { start: 7968, length: 8, convRule: rule143 },
    { start: 7976, length: 8, convRule: rule144 },
    { start: 7984, length: 8, convRule: rule143 },
    { start: 7992, length: 8, convRule: rule144 },
    { start: 8e3, length: 6, convRule: rule143 },
    { start: 8008, length: 6, convRule: rule144 },
    { start: 8017, length: 1, convRule: rule143 },
    { start: 8019, length: 1, convRule: rule143 },
    { start: 8021, length: 1, convRule: rule143 },
    { start: 8023, length: 1, convRule: rule143 },
    { start: 8025, length: 1, convRule: rule144 },
    { start: 8027, length: 1, convRule: rule144 },
    { start: 8029, length: 1, convRule: rule144 },
    { start: 8031, length: 1, convRule: rule144 },
    { start: 8032, length: 8, convRule: rule143 },
    { start: 8040, length: 8, convRule: rule144 },
    { start: 8048, length: 2, convRule: rule145 },
    { start: 8050, length: 4, convRule: rule146 },
    { start: 8054, length: 2, convRule: rule147 },
    { start: 8056, length: 2, convRule: rule148 },
    { start: 8058, length: 2, convRule: rule149 },
    { start: 8060, length: 2, convRule: rule150 },
    { start: 8064, length: 8, convRule: rule143 },
    { start: 8072, length: 8, convRule: rule151 },
    { start: 8080, length: 8, convRule: rule143 },
    { start: 8088, length: 8, convRule: rule151 },
    { start: 8096, length: 8, convRule: rule143 },
    { start: 8104, length: 8, convRule: rule151 },
    { start: 8112, length: 2, convRule: rule143 },
    { start: 8115, length: 1, convRule: rule152 },
    { start: 8120, length: 2, convRule: rule144 },
    { start: 8122, length: 2, convRule: rule153 },
    { start: 8124, length: 1, convRule: rule154 },
    { start: 8126, length: 1, convRule: rule155 },
    { start: 8131, length: 1, convRule: rule152 },
    { start: 8136, length: 4, convRule: rule156 },
    { start: 8140, length: 1, convRule: rule154 },
    { start: 8144, length: 2, convRule: rule143 },
    { start: 8152, length: 2, convRule: rule144 },
    { start: 8154, length: 2, convRule: rule157 },
    { start: 8160, length: 2, convRule: rule143 },
    { start: 8165, length: 1, convRule: rule113 },
    { start: 8168, length: 2, convRule: rule144 },
    { start: 8170, length: 2, convRule: rule158 },
    { start: 8172, length: 1, convRule: rule117 },
    { start: 8179, length: 1, convRule: rule152 },
    { start: 8184, length: 2, convRule: rule159 },
    { start: 8186, length: 2, convRule: rule160 },
    { start: 8188, length: 1, convRule: rule154 },
    { start: 8486, length: 1, convRule: rule163 },
    { start: 8490, length: 1, convRule: rule164 },
    { start: 8491, length: 1, convRule: rule165 },
    { start: 8498, length: 1, convRule: rule166 },
    { start: 8526, length: 1, convRule: rule167 },
    { start: 8544, length: 16, convRule: rule168 },
    { start: 8560, length: 16, convRule: rule169 },
    { start: 8579, length: 1, convRule: rule22 },
    { start: 8580, length: 1, convRule: rule23 },
    { start: 9398, length: 26, convRule: rule170 },
    { start: 9424, length: 26, convRule: rule171 },
    { start: 11264, length: 47, convRule: rule122 },
    { start: 11312, length: 47, convRule: rule123 },
    { start: 11360, length: 1, convRule: rule22 },
    { start: 11361, length: 1, convRule: rule23 },
    { start: 11362, length: 1, convRule: rule172 },
    { start: 11363, length: 1, convRule: rule173 },
    { start: 11364, length: 1, convRule: rule174 },
    { start: 11365, length: 1, convRule: rule175 },
    { start: 11366, length: 1, convRule: rule176 },
    { start: 11367, length: 1, convRule: rule22 },
    { start: 11368, length: 1, convRule: rule23 },
    { start: 11369, length: 1, convRule: rule22 },
    { start: 11370, length: 1, convRule: rule23 },
    { start: 11371, length: 1, convRule: rule22 },
    { start: 11372, length: 1, convRule: rule23 },
    { start: 11373, length: 1, convRule: rule177 },
    { start: 11374, length: 1, convRule: rule178 },
    { start: 11375, length: 1, convRule: rule179 },
    { start: 11376, length: 1, convRule: rule180 },
    { start: 11378, length: 1, convRule: rule22 },
    { start: 11379, length: 1, convRule: rule23 },
    { start: 11381, length: 1, convRule: rule22 },
    { start: 11382, length: 1, convRule: rule23 },
    { start: 11390, length: 2, convRule: rule181 },
    { start: 11392, length: 1, convRule: rule22 },
    { start: 11393, length: 1, convRule: rule23 },
    { start: 11394, length: 1, convRule: rule22 },
    { start: 11395, length: 1, convRule: rule23 },
    { start: 11396, length: 1, convRule: rule22 },
    { start: 11397, length: 1, convRule: rule23 },
    { start: 11398, length: 1, convRule: rule22 },
    { start: 11399, length: 1, convRule: rule23 },
    { start: 11400, length: 1, convRule: rule22 },
    { start: 11401, length: 1, convRule: rule23 },
    { start: 11402, length: 1, convRule: rule22 },
    { start: 11403, length: 1, convRule: rule23 },
    { start: 11404, length: 1, convRule: rule22 },
    { start: 11405, length: 1, convRule: rule23 },
    { start: 11406, length: 1, convRule: rule22 },
    { start: 11407, length: 1, convRule: rule23 },
    { start: 11408, length: 1, convRule: rule22 },
    { start: 11409, length: 1, convRule: rule23 },
    { start: 11410, length: 1, convRule: rule22 },
    { start: 11411, length: 1, convRule: rule23 },
    { start: 11412, length: 1, convRule: rule22 },
    { start: 11413, length: 1, convRule: rule23 },
    { start: 11414, length: 1, convRule: rule22 },
    { start: 11415, length: 1, convRule: rule23 },
    { start: 11416, length: 1, convRule: rule22 },
    { start: 11417, length: 1, convRule: rule23 },
    { start: 11418, length: 1, convRule: rule22 },
    { start: 11419, length: 1, convRule: rule23 },
    { start: 11420, length: 1, convRule: rule22 },
    { start: 11421, length: 1, convRule: rule23 },
    { start: 11422, length: 1, convRule: rule22 },
    { start: 11423, length: 1, convRule: rule23 },
    { start: 11424, length: 1, convRule: rule22 },
    { start: 11425, length: 1, convRule: rule23 },
    { start: 11426, length: 1, convRule: rule22 },
    { start: 11427, length: 1, convRule: rule23 },
    { start: 11428, length: 1, convRule: rule22 },
    { start: 11429, length: 1, convRule: rule23 },
    { start: 11430, length: 1, convRule: rule22 },
    { start: 11431, length: 1, convRule: rule23 },
    { start: 11432, length: 1, convRule: rule22 },
    { start: 11433, length: 1, convRule: rule23 },
    { start: 11434, length: 1, convRule: rule22 },
    { start: 11435, length: 1, convRule: rule23 },
    { start: 11436, length: 1, convRule: rule22 },
    { start: 11437, length: 1, convRule: rule23 },
    { start: 11438, length: 1, convRule: rule22 },
    { start: 11439, length: 1, convRule: rule23 },
    { start: 11440, length: 1, convRule: rule22 },
    { start: 11441, length: 1, convRule: rule23 },
    { start: 11442, length: 1, convRule: rule22 },
    { start: 11443, length: 1, convRule: rule23 },
    { start: 11444, length: 1, convRule: rule22 },
    { start: 11445, length: 1, convRule: rule23 },
    { start: 11446, length: 1, convRule: rule22 },
    { start: 11447, length: 1, convRule: rule23 },
    { start: 11448, length: 1, convRule: rule22 },
    { start: 11449, length: 1, convRule: rule23 },
    { start: 11450, length: 1, convRule: rule22 },
    { start: 11451, length: 1, convRule: rule23 },
    { start: 11452, length: 1, convRule: rule22 },
    { start: 11453, length: 1, convRule: rule23 },
    { start: 11454, length: 1, convRule: rule22 },
    { start: 11455, length: 1, convRule: rule23 },
    { start: 11456, length: 1, convRule: rule22 },
    { start: 11457, length: 1, convRule: rule23 },
    { start: 11458, length: 1, convRule: rule22 },
    { start: 11459, length: 1, convRule: rule23 },
    { start: 11460, length: 1, convRule: rule22 },
    { start: 11461, length: 1, convRule: rule23 },
    { start: 11462, length: 1, convRule: rule22 },
    { start: 11463, length: 1, convRule: rule23 },
    { start: 11464, length: 1, convRule: rule22 },
    { start: 11465, length: 1, convRule: rule23 },
    { start: 11466, length: 1, convRule: rule22 },
    { start: 11467, length: 1, convRule: rule23 },
    { start: 11468, length: 1, convRule: rule22 },
    { start: 11469, length: 1, convRule: rule23 },
    { start: 11470, length: 1, convRule: rule22 },
    { start: 11471, length: 1, convRule: rule23 },
    { start: 11472, length: 1, convRule: rule22 },
    { start: 11473, length: 1, convRule: rule23 },
    { start: 11474, length: 1, convRule: rule22 },
    { start: 11475, length: 1, convRule: rule23 },
    { start: 11476, length: 1, convRule: rule22 },
    { start: 11477, length: 1, convRule: rule23 },
    { start: 11478, length: 1, convRule: rule22 },
    { start: 11479, length: 1, convRule: rule23 },
    { start: 11480, length: 1, convRule: rule22 },
    { start: 11481, length: 1, convRule: rule23 },
    { start: 11482, length: 1, convRule: rule22 },
    { start: 11483, length: 1, convRule: rule23 },
    { start: 11484, length: 1, convRule: rule22 },
    { start: 11485, length: 1, convRule: rule23 },
    { start: 11486, length: 1, convRule: rule22 },
    { start: 11487, length: 1, convRule: rule23 },
    { start: 11488, length: 1, convRule: rule22 },
    { start: 11489, length: 1, convRule: rule23 },
    { start: 11490, length: 1, convRule: rule22 },
    { start: 11491, length: 1, convRule: rule23 },
    { start: 11499, length: 1, convRule: rule22 },
    { start: 11500, length: 1, convRule: rule23 },
    { start: 11501, length: 1, convRule: rule22 },
    { start: 11502, length: 1, convRule: rule23 },
    { start: 11506, length: 1, convRule: rule22 },
    { start: 11507, length: 1, convRule: rule23 },
    { start: 11520, length: 38, convRule: rule182 },
    { start: 11559, length: 1, convRule: rule182 },
    { start: 11565, length: 1, convRule: rule182 },
    { start: 42560, length: 1, convRule: rule22 },
    { start: 42561, length: 1, convRule: rule23 },
    { start: 42562, length: 1, convRule: rule22 },
    { start: 42563, length: 1, convRule: rule23 },
    { start: 42564, length: 1, convRule: rule22 },
    { start: 42565, length: 1, convRule: rule23 },
    { start: 42566, length: 1, convRule: rule22 },
    { start: 42567, length: 1, convRule: rule23 },
    { start: 42568, length: 1, convRule: rule22 },
    { start: 42569, length: 1, convRule: rule23 },
    { start: 42570, length: 1, convRule: rule22 },
    { start: 42571, length: 1, convRule: rule23 },
    { start: 42572, length: 1, convRule: rule22 },
    { start: 42573, length: 1, convRule: rule23 },
    { start: 42574, length: 1, convRule: rule22 },
    { start: 42575, length: 1, convRule: rule23 },
    { start: 42576, length: 1, convRule: rule22 },
    { start: 42577, length: 1, convRule: rule23 },
    { start: 42578, length: 1, convRule: rule22 },
    { start: 42579, length: 1, convRule: rule23 },
    { start: 42580, length: 1, convRule: rule22 },
    { start: 42581, length: 1, convRule: rule23 },
    { start: 42582, length: 1, convRule: rule22 },
    { start: 42583, length: 1, convRule: rule23 },
    { start: 42584, length: 1, convRule: rule22 },
    { start: 42585, length: 1, convRule: rule23 },
    { start: 42586, length: 1, convRule: rule22 },
    { start: 42587, length: 1, convRule: rule23 },
    { start: 42588, length: 1, convRule: rule22 },
    { start: 42589, length: 1, convRule: rule23 },
    { start: 42590, length: 1, convRule: rule22 },
    { start: 42591, length: 1, convRule: rule23 },
    { start: 42592, length: 1, convRule: rule22 },
    { start: 42593, length: 1, convRule: rule23 },
    { start: 42594, length: 1, convRule: rule22 },
    { start: 42595, length: 1, convRule: rule23 },
    { start: 42596, length: 1, convRule: rule22 },
    { start: 42597, length: 1, convRule: rule23 },
    { start: 42598, length: 1, convRule: rule22 },
    { start: 42599, length: 1, convRule: rule23 },
    { start: 42600, length: 1, convRule: rule22 },
    { start: 42601, length: 1, convRule: rule23 },
    { start: 42602, length: 1, convRule: rule22 },
    { start: 42603, length: 1, convRule: rule23 },
    { start: 42604, length: 1, convRule: rule22 },
    { start: 42605, length: 1, convRule: rule23 },
    { start: 42624, length: 1, convRule: rule22 },
    { start: 42625, length: 1, convRule: rule23 },
    { start: 42626, length: 1, convRule: rule22 },
    { start: 42627, length: 1, convRule: rule23 },
    { start: 42628, length: 1, convRule: rule22 },
    { start: 42629, length: 1, convRule: rule23 },
    { start: 42630, length: 1, convRule: rule22 },
    { start: 42631, length: 1, convRule: rule23 },
    { start: 42632, length: 1, convRule: rule22 },
    { start: 42633, length: 1, convRule: rule23 },
    { start: 42634, length: 1, convRule: rule22 },
    { start: 42635, length: 1, convRule: rule23 },
    { start: 42636, length: 1, convRule: rule22 },
    { start: 42637, length: 1, convRule: rule23 },
    { start: 42638, length: 1, convRule: rule22 },
    { start: 42639, length: 1, convRule: rule23 },
    { start: 42640, length: 1, convRule: rule22 },
    { start: 42641, length: 1, convRule: rule23 },
    { start: 42642, length: 1, convRule: rule22 },
    { start: 42643, length: 1, convRule: rule23 },
    { start: 42644, length: 1, convRule: rule22 },
    { start: 42645, length: 1, convRule: rule23 },
    { start: 42646, length: 1, convRule: rule22 },
    { start: 42647, length: 1, convRule: rule23 },
    { start: 42648, length: 1, convRule: rule22 },
    { start: 42649, length: 1, convRule: rule23 },
    { start: 42650, length: 1, convRule: rule22 },
    { start: 42651, length: 1, convRule: rule23 },
    { start: 42786, length: 1, convRule: rule22 },
    { start: 42787, length: 1, convRule: rule23 },
    { start: 42788, length: 1, convRule: rule22 },
    { start: 42789, length: 1, convRule: rule23 },
    { start: 42790, length: 1, convRule: rule22 },
    { start: 42791, length: 1, convRule: rule23 },
    { start: 42792, length: 1, convRule: rule22 },
    { start: 42793, length: 1, convRule: rule23 },
    { start: 42794, length: 1, convRule: rule22 },
    { start: 42795, length: 1, convRule: rule23 },
    { start: 42796, length: 1, convRule: rule22 },
    { start: 42797, length: 1, convRule: rule23 },
    { start: 42798, length: 1, convRule: rule22 },
    { start: 42799, length: 1, convRule: rule23 },
    { start: 42802, length: 1, convRule: rule22 },
    { start: 42803, length: 1, convRule: rule23 },
    { start: 42804, length: 1, convRule: rule22 },
    { start: 42805, length: 1, convRule: rule23 },
    { start: 42806, length: 1, convRule: rule22 },
    { start: 42807, length: 1, convRule: rule23 },
    { start: 42808, length: 1, convRule: rule22 },
    { start: 42809, length: 1, convRule: rule23 },
    { start: 42810, length: 1, convRule: rule22 },
    { start: 42811, length: 1, convRule: rule23 },
    { start: 42812, length: 1, convRule: rule22 },
    { start: 42813, length: 1, convRule: rule23 },
    { start: 42814, length: 1, convRule: rule22 },
    { start: 42815, length: 1, convRule: rule23 },
    { start: 42816, length: 1, convRule: rule22 },
    { start: 42817, length: 1, convRule: rule23 },
    { start: 42818, length: 1, convRule: rule22 },
    { start: 42819, length: 1, convRule: rule23 },
    { start: 42820, length: 1, convRule: rule22 },
    { start: 42821, length: 1, convRule: rule23 },
    { start: 42822, length: 1, convRule: rule22 },
    { start: 42823, length: 1, convRule: rule23 },
    { start: 42824, length: 1, convRule: rule22 },
    { start: 42825, length: 1, convRule: rule23 },
    { start: 42826, length: 1, convRule: rule22 },
    { start: 42827, length: 1, convRule: rule23 },
    { start: 42828, length: 1, convRule: rule22 },
    { start: 42829, length: 1, convRule: rule23 },
    { start: 42830, length: 1, convRule: rule22 },
    { start: 42831, length: 1, convRule: rule23 },
    { start: 42832, length: 1, convRule: rule22 },
    { start: 42833, length: 1, convRule: rule23 },
    { start: 42834, length: 1, convRule: rule22 },
    { start: 42835, length: 1, convRule: rule23 },
    { start: 42836, length: 1, convRule: rule22 },
    { start: 42837, length: 1, convRule: rule23 },
    { start: 42838, length: 1, convRule: rule22 },
    { start: 42839, length: 1, convRule: rule23 },
    { start: 42840, length: 1, convRule: rule22 },
    { start: 42841, length: 1, convRule: rule23 },
    { start: 42842, length: 1, convRule: rule22 },
    { start: 42843, length: 1, convRule: rule23 },
    { start: 42844, length: 1, convRule: rule22 },
    { start: 42845, length: 1, convRule: rule23 },
    { start: 42846, length: 1, convRule: rule22 },
    { start: 42847, length: 1, convRule: rule23 },
    { start: 42848, length: 1, convRule: rule22 },
    { start: 42849, length: 1, convRule: rule23 },
    { start: 42850, length: 1, convRule: rule22 },
    { start: 42851, length: 1, convRule: rule23 },
    { start: 42852, length: 1, convRule: rule22 },
    { start: 42853, length: 1, convRule: rule23 },
    { start: 42854, length: 1, convRule: rule22 },
    { start: 42855, length: 1, convRule: rule23 },
    { start: 42856, length: 1, convRule: rule22 },
    { start: 42857, length: 1, convRule: rule23 },
    { start: 42858, length: 1, convRule: rule22 },
    { start: 42859, length: 1, convRule: rule23 },
    { start: 42860, length: 1, convRule: rule22 },
    { start: 42861, length: 1, convRule: rule23 },
    { start: 42862, length: 1, convRule: rule22 },
    { start: 42863, length: 1, convRule: rule23 },
    { start: 42873, length: 1, convRule: rule22 },
    { start: 42874, length: 1, convRule: rule23 },
    { start: 42875, length: 1, convRule: rule22 },
    { start: 42876, length: 1, convRule: rule23 },
    { start: 42877, length: 1, convRule: rule183 },
    { start: 42878, length: 1, convRule: rule22 },
    { start: 42879, length: 1, convRule: rule23 },
    { start: 42880, length: 1, convRule: rule22 },
    { start: 42881, length: 1, convRule: rule23 },
    { start: 42882, length: 1, convRule: rule22 },
    { start: 42883, length: 1, convRule: rule23 },
    { start: 42884, length: 1, convRule: rule22 },
    { start: 42885, length: 1, convRule: rule23 },
    { start: 42886, length: 1, convRule: rule22 },
    { start: 42887, length: 1, convRule: rule23 },
    { start: 42891, length: 1, convRule: rule22 },
    { start: 42892, length: 1, convRule: rule23 },
    { start: 42893, length: 1, convRule: rule184 },
    { start: 42896, length: 1, convRule: rule22 },
    { start: 42897, length: 1, convRule: rule23 },
    { start: 42898, length: 1, convRule: rule22 },
    { start: 42899, length: 1, convRule: rule23 },
    { start: 42900, length: 1, convRule: rule185 },
    { start: 42902, length: 1, convRule: rule22 },
    { start: 42903, length: 1, convRule: rule23 },
    { start: 42904, length: 1, convRule: rule22 },
    { start: 42905, length: 1, convRule: rule23 },
    { start: 42906, length: 1, convRule: rule22 },
    { start: 42907, length: 1, convRule: rule23 },
    { start: 42908, length: 1, convRule: rule22 },
    { start: 42909, length: 1, convRule: rule23 },
    { start: 42910, length: 1, convRule: rule22 },
    { start: 42911, length: 1, convRule: rule23 },
    { start: 42912, length: 1, convRule: rule22 },
    { start: 42913, length: 1, convRule: rule23 },
    { start: 42914, length: 1, convRule: rule22 },
    { start: 42915, length: 1, convRule: rule23 },
    { start: 42916, length: 1, convRule: rule22 },
    { start: 42917, length: 1, convRule: rule23 },
    { start: 42918, length: 1, convRule: rule22 },
    { start: 42919, length: 1, convRule: rule23 },
    { start: 42920, length: 1, convRule: rule22 },
    { start: 42921, length: 1, convRule: rule23 },
    { start: 42922, length: 1, convRule: rule186 },
    { start: 42923, length: 1, convRule: rule187 },
    { start: 42924, length: 1, convRule: rule188 },
    { start: 42925, length: 1, convRule: rule189 },
    { start: 42926, length: 1, convRule: rule186 },
    { start: 42928, length: 1, convRule: rule190 },
    { start: 42929, length: 1, convRule: rule191 },
    { start: 42930, length: 1, convRule: rule192 },
    { start: 42931, length: 1, convRule: rule193 },
    { start: 42932, length: 1, convRule: rule22 },
    { start: 42933, length: 1, convRule: rule23 },
    { start: 42934, length: 1, convRule: rule22 },
    { start: 42935, length: 1, convRule: rule23 },
    { start: 42936, length: 1, convRule: rule22 },
    { start: 42937, length: 1, convRule: rule23 },
    { start: 42938, length: 1, convRule: rule22 },
    { start: 42939, length: 1, convRule: rule23 },
    { start: 42940, length: 1, convRule: rule22 },
    { start: 42941, length: 1, convRule: rule23 },
    { start: 42942, length: 1, convRule: rule22 },
    { start: 42943, length: 1, convRule: rule23 },
    { start: 42946, length: 1, convRule: rule22 },
    { start: 42947, length: 1, convRule: rule23 },
    { start: 42948, length: 1, convRule: rule194 },
    { start: 42949, length: 1, convRule: rule195 },
    { start: 42950, length: 1, convRule: rule196 },
    { start: 42951, length: 1, convRule: rule22 },
    { start: 42952, length: 1, convRule: rule23 },
    { start: 42953, length: 1, convRule: rule22 },
    { start: 42954, length: 1, convRule: rule23 },
    { start: 42997, length: 1, convRule: rule22 },
    { start: 42998, length: 1, convRule: rule23 },
    { start: 43859, length: 1, convRule: rule197 },
    { start: 43888, length: 80, convRule: rule198 },
    { start: 65313, length: 26, convRule: rule9 },
    { start: 65345, length: 26, convRule: rule12 },
    { start: 66560, length: 40, convRule: rule201 },
    { start: 66600, length: 40, convRule: rule202 },
    { start: 66736, length: 36, convRule: rule201 },
    { start: 66776, length: 36, convRule: rule202 },
    { start: 68736, length: 51, convRule: rule97 },
    { start: 68800, length: 51, convRule: rule102 },
    { start: 71840, length: 32, convRule: rule9 },
    { start: 71872, length: 32, convRule: rule12 },
    { start: 93760, length: 32, convRule: rule9 },
    { start: 93792, length: 32, convRule: rule12 },
    { start: 125184, length: 34, convRule: rule203 },
    { start: 125218, length: 34, convRule: rule204 }
  ];
  var bsearch = (a) => (array) => (size3) => (compare2) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const i = go$a0, k = go$a1;
        if (i > k || i >= array.length) {
          go$c = false;
          go$r = Nothing;
          continue;
        }
        const j = unsafeClamp(floor(toNumber(i + k | 0) / 2));
        const b = array[j];
        const v = compare2(a)(b);
        if (v.tag === "EQ") {
          go$c = false;
          go$r = $Maybe("Just", b);
          continue;
        }
        if (v.tag === "GT") {
          go$a0 = j + 1 | 0;
          go$a1 = k;
          continue;
        }
        go$a0 = i;
        go$a1 = j - 1 | 0;
        continue;
      }
      ;
      return go$r;
    };
    return go(0)(size3);
  };
  var blkCmp = (v) => (v1) => {
    if (v.start >= v1.start && v.start < (v1.start + v1.length | 0)) {
      return EQ;
    }
    if (v.start > v1.start) {
      return GT;
    }
    return LT;
  };
  var getRule = (blocks) => (unichar) => (size3) => {
    const maybeCharBlock = bsearch({ start: unichar, length: 1, convRule: nullrule })(blocks)(size3)(blkCmp);
    if (maybeCharBlock.tag === "Nothing") {
      return Nothing;
    }
    if (maybeCharBlock.tag === "Just") {
      return $Maybe("Just", maybeCharBlock._1.convRule);
    }
    fail();
  };
  var caseConv = (f) => ($$char2) => {
    const maybeConversionRule = getRule(convchars)($$char2)(1332);
    if (maybeConversionRule.tag === "Nothing") {
      return $$char2;
    }
    if (maybeConversionRule.tag === "Just") {
      return $$char2 + f(maybeConversionRule._1) | 0;
    }
    fail();
  };
  var uTowlower = /* @__PURE__ */ caseConv((v) => v.lowdist);
  var uTowupper = /* @__PURE__ */ caseConv((v) => v.updist);
  var checkAttrS = (categories) => ($$char2) => {
    const maybeConversionRule = getRule(spacechars)($$char2)(7);
    if (maybeConversionRule.tag === "Nothing") {
      return false;
    }
    if (maybeConversionRule.tag === "Just") {
      const $3 = findIndex((v) => v === maybeConversionRule._1.category)(categories);
      if ($3.tag === "Nothing") {
        return false;
      }
      if ($3.tag === "Just") {
        return true;
      }
      fail();
    }
    fail();
  };
  var allchars = [
    { start: 0, length: 32, convRule: rule0 },
    { start: 32, length: 1, convRule: rule1 },
    { start: 33, length: 3, convRule: rule2 },
    { start: 36, length: 1, convRule: rule3 },
    { start: 37, length: 3, convRule: rule2 },
    { start: 40, length: 1, convRule: rule4 },
    { start: 41, length: 1, convRule: rule5 },
    { start: 42, length: 1, convRule: rule2 },
    { start: 43, length: 1, convRule: rule6 },
    { start: 44, length: 1, convRule: rule2 },
    { start: 45, length: 1, convRule: rule7 },
    { start: 46, length: 2, convRule: rule2 },
    { start: 48, length: 10, convRule: rule8 },
    { start: 58, length: 2, convRule: rule2 },
    { start: 60, length: 3, convRule: rule6 },
    { start: 63, length: 2, convRule: rule2 },
    { start: 65, length: 26, convRule: rule9 },
    { start: 91, length: 1, convRule: rule4 },
    { start: 92, length: 1, convRule: rule2 },
    { start: 93, length: 1, convRule: rule5 },
    { start: 94, length: 1, convRule: rule10 },
    { start: 95, length: 1, convRule: rule11 },
    { start: 96, length: 1, convRule: rule10 },
    { start: 97, length: 26, convRule: rule12 },
    { start: 123, length: 1, convRule: rule4 },
    { start: 124, length: 1, convRule: rule6 },
    { start: 125, length: 1, convRule: rule5 },
    { start: 126, length: 1, convRule: rule6 },
    { start: 127, length: 33, convRule: rule0 },
    { start: 160, length: 1, convRule: rule1 },
    { start: 161, length: 1, convRule: rule2 },
    { start: 162, length: 4, convRule: rule3 },
    { start: 166, length: 1, convRule: rule13 },
    { start: 167, length: 1, convRule: rule2 },
    { start: 168, length: 1, convRule: rule10 },
    { start: 169, length: 1, convRule: rule13 },
    { start: 170, length: 1, convRule: rule14 },
    { start: 171, length: 1, convRule: rule15 },
    { start: 172, length: 1, convRule: rule6 },
    { start: 173, length: 1, convRule: rule16 },
    { start: 174, length: 1, convRule: rule13 },
    { start: 175, length: 1, convRule: rule10 },
    { start: 176, length: 1, convRule: rule13 },
    { start: 177, length: 1, convRule: rule6 },
    { start: 178, length: 2, convRule: rule17 },
    { start: 180, length: 1, convRule: rule10 },
    { start: 181, length: 1, convRule: rule18 },
    { start: 182, length: 2, convRule: rule2 },
    { start: 184, length: 1, convRule: rule10 },
    { start: 185, length: 1, convRule: rule17 },
    { start: 186, length: 1, convRule: rule14 },
    { start: 187, length: 1, convRule: rule19 },
    { start: 188, length: 3, convRule: rule17 },
    { start: 191, length: 1, convRule: rule2 },
    { start: 192, length: 23, convRule: rule9 },
    { start: 215, length: 1, convRule: rule6 },
    { start: 216, length: 7, convRule: rule9 },
    { start: 223, length: 1, convRule: rule20 },
    { start: 224, length: 23, convRule: rule12 },
    { start: 247, length: 1, convRule: rule6 },
    { start: 248, length: 7, convRule: rule12 },
    { start: 255, length: 1, convRule: rule21 },
    { start: 256, length: 1, convRule: rule22 },
    { start: 257, length: 1, convRule: rule23 },
    { start: 258, length: 1, convRule: rule22 },
    { start: 259, length: 1, convRule: rule23 },
    { start: 260, length: 1, convRule: rule22 },
    { start: 261, length: 1, convRule: rule23 },
    { start: 262, length: 1, convRule: rule22 },
    { start: 263, length: 1, convRule: rule23 },
    { start: 264, length: 1, convRule: rule22 },
    { start: 265, length: 1, convRule: rule23 },
    { start: 266, length: 1, convRule: rule22 },
    { start: 267, length: 1, convRule: rule23 },
    { start: 268, length: 1, convRule: rule22 },
    { start: 269, length: 1, convRule: rule23 },
    { start: 270, length: 1, convRule: rule22 },
    { start: 271, length: 1, convRule: rule23 },
    { start: 272, length: 1, convRule: rule22 },
    { start: 273, length: 1, convRule: rule23 },
    { start: 274, length: 1, convRule: rule22 },
    { start: 275, length: 1, convRule: rule23 },
    { start: 276, length: 1, convRule: rule22 },
    { start: 277, length: 1, convRule: rule23 },
    { start: 278, length: 1, convRule: rule22 },
    { start: 279, length: 1, convRule: rule23 },
    { start: 280, length: 1, convRule: rule22 },
    { start: 281, length: 1, convRule: rule23 },
    { start: 282, length: 1, convRule: rule22 },
    { start: 283, length: 1, convRule: rule23 },
    { start: 284, length: 1, convRule: rule22 },
    { start: 285, length: 1, convRule: rule23 },
    { start: 286, length: 1, convRule: rule22 },
    { start: 287, length: 1, convRule: rule23 },
    { start: 288, length: 1, convRule: rule22 },
    { start: 289, length: 1, convRule: rule23 },
    { start: 290, length: 1, convRule: rule22 },
    { start: 291, length: 1, convRule: rule23 },
    { start: 292, length: 1, convRule: rule22 },
    { start: 293, length: 1, convRule: rule23 },
    { start: 294, length: 1, convRule: rule22 },
    { start: 295, length: 1, convRule: rule23 },
    { start: 296, length: 1, convRule: rule22 },
    { start: 297, length: 1, convRule: rule23 },
    { start: 298, length: 1, convRule: rule22 },
    { start: 299, length: 1, convRule: rule23 },
    { start: 300, length: 1, convRule: rule22 },
    { start: 301, length: 1, convRule: rule23 },
    { start: 302, length: 1, convRule: rule22 },
    { start: 303, length: 1, convRule: rule23 },
    { start: 304, length: 1, convRule: rule24 },
    { start: 305, length: 1, convRule: rule25 },
    { start: 306, length: 1, convRule: rule22 },
    { start: 307, length: 1, convRule: rule23 },
    { start: 308, length: 1, convRule: rule22 },
    { start: 309, length: 1, convRule: rule23 },
    { start: 310, length: 1, convRule: rule22 },
    { start: 311, length: 1, convRule: rule23 },
    { start: 312, length: 1, convRule: rule20 },
    { start: 313, length: 1, convRule: rule22 },
    { start: 314, length: 1, convRule: rule23 },
    { start: 315, length: 1, convRule: rule22 },
    { start: 316, length: 1, convRule: rule23 },
    { start: 317, length: 1, convRule: rule22 },
    { start: 318, length: 1, convRule: rule23 },
    { start: 319, length: 1, convRule: rule22 },
    { start: 320, length: 1, convRule: rule23 },
    { start: 321, length: 1, convRule: rule22 },
    { start: 322, length: 1, convRule: rule23 },
    { start: 323, length: 1, convRule: rule22 },
    { start: 324, length: 1, convRule: rule23 },
    { start: 325, length: 1, convRule: rule22 },
    { start: 326, length: 1, convRule: rule23 },
    { start: 327, length: 1, convRule: rule22 },
    { start: 328, length: 1, convRule: rule23 },
    { start: 329, length: 1, convRule: rule20 },
    { start: 330, length: 1, convRule: rule22 },
    { start: 331, length: 1, convRule: rule23 },
    { start: 332, length: 1, convRule: rule22 },
    { start: 333, length: 1, convRule: rule23 },
    { start: 334, length: 1, convRule: rule22 },
    { start: 335, length: 1, convRule: rule23 },
    { start: 336, length: 1, convRule: rule22 },
    { start: 337, length: 1, convRule: rule23 },
    { start: 338, length: 1, convRule: rule22 },
    { start: 339, length: 1, convRule: rule23 },
    { start: 340, length: 1, convRule: rule22 },
    { start: 341, length: 1, convRule: rule23 },
    { start: 342, length: 1, convRule: rule22 },
    { start: 343, length: 1, convRule: rule23 },
    { start: 344, length: 1, convRule: rule22 },
    { start: 345, length: 1, convRule: rule23 },
    { start: 346, length: 1, convRule: rule22 },
    { start: 347, length: 1, convRule: rule23 },
    { start: 348, length: 1, convRule: rule22 },
    { start: 349, length: 1, convRule: rule23 },
    { start: 350, length: 1, convRule: rule22 },
    { start: 351, length: 1, convRule: rule23 },
    { start: 352, length: 1, convRule: rule22 },
    { start: 353, length: 1, convRule: rule23 },
    { start: 354, length: 1, convRule: rule22 },
    { start: 355, length: 1, convRule: rule23 },
    { start: 356, length: 1, convRule: rule22 },
    { start: 357, length: 1, convRule: rule23 },
    { start: 358, length: 1, convRule: rule22 },
    { start: 359, length: 1, convRule: rule23 },
    { start: 360, length: 1, convRule: rule22 },
    { start: 361, length: 1, convRule: rule23 },
    { start: 362, length: 1, convRule: rule22 },
    { start: 363, length: 1, convRule: rule23 },
    { start: 364, length: 1, convRule: rule22 },
    { start: 365, length: 1, convRule: rule23 },
    { start: 366, length: 1, convRule: rule22 },
    { start: 367, length: 1, convRule: rule23 },
    { start: 368, length: 1, convRule: rule22 },
    { start: 369, length: 1, convRule: rule23 },
    { start: 370, length: 1, convRule: rule22 },
    { start: 371, length: 1, convRule: rule23 },
    { start: 372, length: 1, convRule: rule22 },
    { start: 373, length: 1, convRule: rule23 },
    { start: 374, length: 1, convRule: rule22 },
    { start: 375, length: 1, convRule: rule23 },
    { start: 376, length: 1, convRule: rule26 },
    { start: 377, length: 1, convRule: rule22 },
    { start: 378, length: 1, convRule: rule23 },
    { start: 379, length: 1, convRule: rule22 },
    { start: 380, length: 1, convRule: rule23 },
    { start: 381, length: 1, convRule: rule22 },
    { start: 382, length: 1, convRule: rule23 },
    { start: 383, length: 1, convRule: rule27 },
    { start: 384, length: 1, convRule: rule28 },
    { start: 385, length: 1, convRule: rule29 },
    { start: 386, length: 1, convRule: rule22 },
    { start: 387, length: 1, convRule: rule23 },
    { start: 388, length: 1, convRule: rule22 },
    { start: 389, length: 1, convRule: rule23 },
    { start: 390, length: 1, convRule: rule30 },
    { start: 391, length: 1, convRule: rule22 },
    { start: 392, length: 1, convRule: rule23 },
    { start: 393, length: 2, convRule: rule31 },
    { start: 395, length: 1, convRule: rule22 },
    { start: 396, length: 1, convRule: rule23 },
    { start: 397, length: 1, convRule: rule20 },
    { start: 398, length: 1, convRule: rule32 },
    { start: 399, length: 1, convRule: rule33 },
    { start: 400, length: 1, convRule: rule34 },
    { start: 401, length: 1, convRule: rule22 },
    { start: 402, length: 1, convRule: rule23 },
    { start: 403, length: 1, convRule: rule31 },
    { start: 404, length: 1, convRule: rule35 },
    { start: 405, length: 1, convRule: rule36 },
    { start: 406, length: 1, convRule: rule37 },
    { start: 407, length: 1, convRule: rule38 },
    { start: 408, length: 1, convRule: rule22 },
    { start: 409, length: 1, convRule: rule23 },
    { start: 410, length: 1, convRule: rule39 },
    { start: 411, length: 1, convRule: rule20 },
    { start: 412, length: 1, convRule: rule37 },
    { start: 413, length: 1, convRule: rule40 },
    { start: 414, length: 1, convRule: rule41 },
    { start: 415, length: 1, convRule: rule42 },
    { start: 416, length: 1, convRule: rule22 },
    { start: 417, length: 1, convRule: rule23 },
    { start: 418, length: 1, convRule: rule22 },
    { start: 419, length: 1, convRule: rule23 },
    { start: 420, length: 1, convRule: rule22 },
    { start: 421, length: 1, convRule: rule23 },
    { start: 422, length: 1, convRule: rule43 },
    { start: 423, length: 1, convRule: rule22 },
    { start: 424, length: 1, convRule: rule23 },
    { start: 425, length: 1, convRule: rule43 },
    { start: 426, length: 2, convRule: rule20 },
    { start: 428, length: 1, convRule: rule22 },
    { start: 429, length: 1, convRule: rule23 },
    { start: 430, length: 1, convRule: rule43 },
    { start: 431, length: 1, convRule: rule22 },
    { start: 432, length: 1, convRule: rule23 },
    { start: 433, length: 2, convRule: rule44 },
    { start: 435, length: 1, convRule: rule22 },
    { start: 436, length: 1, convRule: rule23 },
    { start: 437, length: 1, convRule: rule22 },
    { start: 438, length: 1, convRule: rule23 },
    { start: 439, length: 1, convRule: rule45 },
    { start: 440, length: 1, convRule: rule22 },
    { start: 441, length: 1, convRule: rule23 },
    { start: 442, length: 1, convRule: rule20 },
    { start: 443, length: 1, convRule: rule14 },
    { start: 444, length: 1, convRule: rule22 },
    { start: 445, length: 1, convRule: rule23 },
    { start: 446, length: 1, convRule: rule20 },
    { start: 447, length: 1, convRule: rule46 },
    { start: 448, length: 4, convRule: rule14 },
    { start: 452, length: 1, convRule: rule47 },
    { start: 453, length: 1, convRule: rule48 },
    { start: 454, length: 1, convRule: rule49 },
    { start: 455, length: 1, convRule: rule47 },
    { start: 456, length: 1, convRule: rule48 },
    { start: 457, length: 1, convRule: rule49 },
    { start: 458, length: 1, convRule: rule47 },
    { start: 459, length: 1, convRule: rule48 },
    { start: 460, length: 1, convRule: rule49 },
    { start: 461, length: 1, convRule: rule22 },
    { start: 462, length: 1, convRule: rule23 },
    { start: 463, length: 1, convRule: rule22 },
    { start: 464, length: 1, convRule: rule23 },
    { start: 465, length: 1, convRule: rule22 },
    { start: 466, length: 1, convRule: rule23 },
    { start: 467, length: 1, convRule: rule22 },
    { start: 468, length: 1, convRule: rule23 },
    { start: 469, length: 1, convRule: rule22 },
    { start: 470, length: 1, convRule: rule23 },
    { start: 471, length: 1, convRule: rule22 },
    { start: 472, length: 1, convRule: rule23 },
    { start: 473, length: 1, convRule: rule22 },
    { start: 474, length: 1, convRule: rule23 },
    { start: 475, length: 1, convRule: rule22 },
    { start: 476, length: 1, convRule: rule23 },
    { start: 477, length: 1, convRule: rule50 },
    { start: 478, length: 1, convRule: rule22 },
    { start: 479, length: 1, convRule: rule23 },
    { start: 480, length: 1, convRule: rule22 },
    { start: 481, length: 1, convRule: rule23 },
    { start: 482, length: 1, convRule: rule22 },
    { start: 483, length: 1, convRule: rule23 },
    { start: 484, length: 1, convRule: rule22 },
    { start: 485, length: 1, convRule: rule23 },
    { start: 486, length: 1, convRule: rule22 },
    { start: 487, length: 1, convRule: rule23 },
    { start: 488, length: 1, convRule: rule22 },
    { start: 489, length: 1, convRule: rule23 },
    { start: 490, length: 1, convRule: rule22 },
    { start: 491, length: 1, convRule: rule23 },
    { start: 492, length: 1, convRule: rule22 },
    { start: 493, length: 1, convRule: rule23 },
    { start: 494, length: 1, convRule: rule22 },
    { start: 495, length: 1, convRule: rule23 },
    { start: 496, length: 1, convRule: rule20 },
    { start: 497, length: 1, convRule: rule47 },
    { start: 498, length: 1, convRule: rule48 },
    { start: 499, length: 1, convRule: rule49 },
    { start: 500, length: 1, convRule: rule22 },
    { start: 501, length: 1, convRule: rule23 },
    { start: 502, length: 1, convRule: rule51 },
    { start: 503, length: 1, convRule: rule52 },
    { start: 504, length: 1, convRule: rule22 },
    { start: 505, length: 1, convRule: rule23 },
    { start: 506, length: 1, convRule: rule22 },
    { start: 507, length: 1, convRule: rule23 },
    { start: 508, length: 1, convRule: rule22 },
    { start: 509, length: 1, convRule: rule23 },
    { start: 510, length: 1, convRule: rule22 },
    { start: 511, length: 1, convRule: rule23 },
    { start: 512, length: 1, convRule: rule22 },
    { start: 513, length: 1, convRule: rule23 },
    { start: 514, length: 1, convRule: rule22 },
    { start: 515, length: 1, convRule: rule23 },
    { start: 516, length: 1, convRule: rule22 },
    { start: 517, length: 1, convRule: rule23 },
    { start: 518, length: 1, convRule: rule22 },
    { start: 519, length: 1, convRule: rule23 },
    { start: 520, length: 1, convRule: rule22 },
    { start: 521, length: 1, convRule: rule23 },
    { start: 522, length: 1, convRule: rule22 },
    { start: 523, length: 1, convRule: rule23 },
    { start: 524, length: 1, convRule: rule22 },
    { start: 525, length: 1, convRule: rule23 },
    { start: 526, length: 1, convRule: rule22 },
    { start: 527, length: 1, convRule: rule23 },
    { start: 528, length: 1, convRule: rule22 },
    { start: 529, length: 1, convRule: rule23 },
    { start: 530, length: 1, convRule: rule22 },
    { start: 531, length: 1, convRule: rule23 },
    { start: 532, length: 1, convRule: rule22 },
    { start: 533, length: 1, convRule: rule23 },
    { start: 534, length: 1, convRule: rule22 },
    { start: 535, length: 1, convRule: rule23 },
    { start: 536, length: 1, convRule: rule22 },
    { start: 537, length: 1, convRule: rule23 },
    { start: 538, length: 1, convRule: rule22 },
    { start: 539, length: 1, convRule: rule23 },
    { start: 540, length: 1, convRule: rule22 },
    { start: 541, length: 1, convRule: rule23 },
    { start: 542, length: 1, convRule: rule22 },
    { start: 543, length: 1, convRule: rule23 },
    { start: 544, length: 1, convRule: rule53 },
    { start: 545, length: 1, convRule: rule20 },
    { start: 546, length: 1, convRule: rule22 },
    { start: 547, length: 1, convRule: rule23 },
    { start: 548, length: 1, convRule: rule22 },
    { start: 549, length: 1, convRule: rule23 },
    { start: 550, length: 1, convRule: rule22 },
    { start: 551, length: 1, convRule: rule23 },
    { start: 552, length: 1, convRule: rule22 },
    { start: 553, length: 1, convRule: rule23 },
    { start: 554, length: 1, convRule: rule22 },
    { start: 555, length: 1, convRule: rule23 },
    { start: 556, length: 1, convRule: rule22 },
    { start: 557, length: 1, convRule: rule23 },
    { start: 558, length: 1, convRule: rule22 },
    { start: 559, length: 1, convRule: rule23 },
    { start: 560, length: 1, convRule: rule22 },
    { start: 561, length: 1, convRule: rule23 },
    { start: 562, length: 1, convRule: rule22 },
    { start: 563, length: 1, convRule: rule23 },
    { start: 564, length: 6, convRule: rule20 },
    { start: 570, length: 1, convRule: rule54 },
    { start: 571, length: 1, convRule: rule22 },
    { start: 572, length: 1, convRule: rule23 },
    { start: 573, length: 1, convRule: rule55 },
    { start: 574, length: 1, convRule: rule56 },
    { start: 575, length: 2, convRule: rule57 },
    { start: 577, length: 1, convRule: rule22 },
    { start: 578, length: 1, convRule: rule23 },
    { start: 579, length: 1, convRule: rule58 },
    { start: 580, length: 1, convRule: rule59 },
    { start: 581, length: 1, convRule: rule60 },
    { start: 582, length: 1, convRule: rule22 },
    { start: 583, length: 1, convRule: rule23 },
    { start: 584, length: 1, convRule: rule22 },
    { start: 585, length: 1, convRule: rule23 },
    { start: 586, length: 1, convRule: rule22 },
    { start: 587, length: 1, convRule: rule23 },
    { start: 588, length: 1, convRule: rule22 },
    { start: 589, length: 1, convRule: rule23 },
    { start: 590, length: 1, convRule: rule22 },
    { start: 591, length: 1, convRule: rule23 },
    { start: 592, length: 1, convRule: rule61 },
    { start: 593, length: 1, convRule: rule62 },
    { start: 594, length: 1, convRule: rule63 },
    { start: 595, length: 1, convRule: rule64 },
    { start: 596, length: 1, convRule: rule65 },
    { start: 597, length: 1, convRule: rule20 },
    { start: 598, length: 2, convRule: rule66 },
    { start: 600, length: 1, convRule: rule20 },
    { start: 601, length: 1, convRule: rule67 },
    { start: 602, length: 1, convRule: rule20 },
    { start: 603, length: 1, convRule: rule68 },
    { start: 604, length: 1, convRule: rule69 },
    { start: 605, length: 3, convRule: rule20 },
    { start: 608, length: 1, convRule: rule66 },
    { start: 609, length: 1, convRule: rule70 },
    { start: 610, length: 1, convRule: rule20 },
    { start: 611, length: 1, convRule: rule71 },
    { start: 612, length: 1, convRule: rule20 },
    { start: 613, length: 1, convRule: rule72 },
    { start: 614, length: 1, convRule: rule73 },
    { start: 615, length: 1, convRule: rule20 },
    { start: 616, length: 1, convRule: rule74 },
    { start: 617, length: 1, convRule: rule75 },
    { start: 618, length: 1, convRule: rule73 },
    { start: 619, length: 1, convRule: rule76 },
    { start: 620, length: 1, convRule: rule77 },
    { start: 621, length: 2, convRule: rule20 },
    { start: 623, length: 1, convRule: rule75 },
    { start: 624, length: 1, convRule: rule20 },
    { start: 625, length: 1, convRule: rule78 },
    { start: 626, length: 1, convRule: rule79 },
    { start: 627, length: 2, convRule: rule20 },
    { start: 629, length: 1, convRule: rule80 },
    { start: 630, length: 7, convRule: rule20 },
    { start: 637, length: 1, convRule: rule81 },
    { start: 638, length: 2, convRule: rule20 },
    { start: 640, length: 1, convRule: rule82 },
    { start: 641, length: 1, convRule: rule20 },
    { start: 642, length: 1, convRule: rule83 },
    { start: 643, length: 1, convRule: rule82 },
    { start: 644, length: 3, convRule: rule20 },
    { start: 647, length: 1, convRule: rule84 },
    { start: 648, length: 1, convRule: rule82 },
    { start: 649, length: 1, convRule: rule85 },
    { start: 650, length: 2, convRule: rule86 },
    { start: 652, length: 1, convRule: rule87 },
    { start: 653, length: 5, convRule: rule20 },
    { start: 658, length: 1, convRule: rule88 },
    { start: 659, length: 1, convRule: rule20 },
    { start: 660, length: 1, convRule: rule14 },
    { start: 661, length: 8, convRule: rule20 },
    { start: 669, length: 1, convRule: rule89 },
    { start: 670, length: 1, convRule: rule90 },
    { start: 671, length: 17, convRule: rule20 },
    { start: 688, length: 18, convRule: rule91 },
    { start: 706, length: 4, convRule: rule10 },
    { start: 710, length: 12, convRule: rule91 },
    { start: 722, length: 14, convRule: rule10 },
    { start: 736, length: 5, convRule: rule91 },
    { start: 741, length: 7, convRule: rule10 },
    { start: 748, length: 1, convRule: rule91 },
    { start: 749, length: 1, convRule: rule10 },
    { start: 750, length: 1, convRule: rule91 },
    { start: 751, length: 17, convRule: rule10 },
    { start: 768, length: 69, convRule: rule92 },
    { start: 837, length: 1, convRule: rule93 },
    { start: 838, length: 42, convRule: rule92 },
    { start: 880, length: 1, convRule: rule22 },
    { start: 881, length: 1, convRule: rule23 },
    { start: 882, length: 1, convRule: rule22 },
    { start: 883, length: 1, convRule: rule23 },
    { start: 884, length: 1, convRule: rule91 },
    { start: 885, length: 1, convRule: rule10 },
    { start: 886, length: 1, convRule: rule22 },
    { start: 887, length: 1, convRule: rule23 },
    { start: 890, length: 1, convRule: rule91 },
    { start: 891, length: 3, convRule: rule41 },
    { start: 894, length: 1, convRule: rule2 },
    { start: 895, length: 1, convRule: rule94 },
    { start: 900, length: 2, convRule: rule10 },
    { start: 902, length: 1, convRule: rule95 },
    { start: 903, length: 1, convRule: rule2 },
    { start: 904, length: 3, convRule: rule96 },
    { start: 908, length: 1, convRule: rule97 },
    { start: 910, length: 2, convRule: rule98 },
    { start: 912, length: 1, convRule: rule20 },
    { start: 913, length: 17, convRule: rule9 },
    { start: 931, length: 9, convRule: rule9 },
    { start: 940, length: 1, convRule: rule99 },
    { start: 941, length: 3, convRule: rule100 },
    { start: 944, length: 1, convRule: rule20 },
    { start: 945, length: 17, convRule: rule12 },
    { start: 962, length: 1, convRule: rule101 },
    { start: 963, length: 9, convRule: rule12 },
    { start: 972, length: 1, convRule: rule102 },
    { start: 973, length: 2, convRule: rule103 },
    { start: 975, length: 1, convRule: rule104 },
    { start: 976, length: 1, convRule: rule105 },
    { start: 977, length: 1, convRule: rule106 },
    { start: 978, length: 3, convRule: rule107 },
    { start: 981, length: 1, convRule: rule108 },
    { start: 982, length: 1, convRule: rule109 },
    { start: 983, length: 1, convRule: rule110 },
    { start: 984, length: 1, convRule: rule22 },
    { start: 985, length: 1, convRule: rule23 },
    { start: 986, length: 1, convRule: rule22 },
    { start: 987, length: 1, convRule: rule23 },
    { start: 988, length: 1, convRule: rule22 },
    { start: 989, length: 1, convRule: rule23 },
    { start: 990, length: 1, convRule: rule22 },
    { start: 991, length: 1, convRule: rule23 },
    { start: 992, length: 1, convRule: rule22 },
    { start: 993, length: 1, convRule: rule23 },
    { start: 994, length: 1, convRule: rule22 },
    { start: 995, length: 1, convRule: rule23 },
    { start: 996, length: 1, convRule: rule22 },
    { start: 997, length: 1, convRule: rule23 },
    { start: 998, length: 1, convRule: rule22 },
    { start: 999, length: 1, convRule: rule23 },
    { start: 1e3, length: 1, convRule: rule22 },
    { start: 1001, length: 1, convRule: rule23 },
    { start: 1002, length: 1, convRule: rule22 },
    { start: 1003, length: 1, convRule: rule23 },
    { start: 1004, length: 1, convRule: rule22 },
    { start: 1005, length: 1, convRule: rule23 },
    { start: 1006, length: 1, convRule: rule22 },
    { start: 1007, length: 1, convRule: rule23 },
    { start: 1008, length: 1, convRule: rule111 },
    { start: 1009, length: 1, convRule: rule112 },
    { start: 1010, length: 1, convRule: rule113 },
    { start: 1011, length: 1, convRule: rule114 },
    { start: 1012, length: 1, convRule: rule115 },
    { start: 1013, length: 1, convRule: rule116 },
    { start: 1014, length: 1, convRule: rule6 },
    { start: 1015, length: 1, convRule: rule22 },
    { start: 1016, length: 1, convRule: rule23 },
    { start: 1017, length: 1, convRule: rule117 },
    { start: 1018, length: 1, convRule: rule22 },
    { start: 1019, length: 1, convRule: rule23 },
    { start: 1020, length: 1, convRule: rule20 },
    { start: 1021, length: 3, convRule: rule53 },
    { start: 1024, length: 16, convRule: rule118 },
    { start: 1040, length: 32, convRule: rule9 },
    { start: 1072, length: 32, convRule: rule12 },
    { start: 1104, length: 16, convRule: rule112 },
    { start: 1120, length: 1, convRule: rule22 },
    { start: 1121, length: 1, convRule: rule23 },
    { start: 1122, length: 1, convRule: rule22 },
    { start: 1123, length: 1, convRule: rule23 },
    { start: 1124, length: 1, convRule: rule22 },
    { start: 1125, length: 1, convRule: rule23 },
    { start: 1126, length: 1, convRule: rule22 },
    { start: 1127, length: 1, convRule: rule23 },
    { start: 1128, length: 1, convRule: rule22 },
    { start: 1129, length: 1, convRule: rule23 },
    { start: 1130, length: 1, convRule: rule22 },
    { start: 1131, length: 1, convRule: rule23 },
    { start: 1132, length: 1, convRule: rule22 },
    { start: 1133, length: 1, convRule: rule23 },
    { start: 1134, length: 1, convRule: rule22 },
    { start: 1135, length: 1, convRule: rule23 },
    { start: 1136, length: 1, convRule: rule22 },
    { start: 1137, length: 1, convRule: rule23 },
    { start: 1138, length: 1, convRule: rule22 },
    { start: 1139, length: 1, convRule: rule23 },
    { start: 1140, length: 1, convRule: rule22 },
    { start: 1141, length: 1, convRule: rule23 },
    { start: 1142, length: 1, convRule: rule22 },
    { start: 1143, length: 1, convRule: rule23 },
    { start: 1144, length: 1, convRule: rule22 },
    { start: 1145, length: 1, convRule: rule23 },
    { start: 1146, length: 1, convRule: rule22 },
    { start: 1147, length: 1, convRule: rule23 },
    { start: 1148, length: 1, convRule: rule22 },
    { start: 1149, length: 1, convRule: rule23 },
    { start: 1150, length: 1, convRule: rule22 },
    { start: 1151, length: 1, convRule: rule23 },
    { start: 1152, length: 1, convRule: rule22 },
    { start: 1153, length: 1, convRule: rule23 },
    { start: 1154, length: 1, convRule: rule13 },
    { start: 1155, length: 5, convRule: rule92 },
    { start: 1160, length: 2, convRule: rule119 },
    { start: 1162, length: 1, convRule: rule22 },
    { start: 1163, length: 1, convRule: rule23 },
    { start: 1164, length: 1, convRule: rule22 },
    { start: 1165, length: 1, convRule: rule23 },
    { start: 1166, length: 1, convRule: rule22 },
    { start: 1167, length: 1, convRule: rule23 },
    { start: 1168, length: 1, convRule: rule22 },
    { start: 1169, length: 1, convRule: rule23 },
    { start: 1170, length: 1, convRule: rule22 },
    { start: 1171, length: 1, convRule: rule23 },
    { start: 1172, length: 1, convRule: rule22 },
    { start: 1173, length: 1, convRule: rule23 },
    { start: 1174, length: 1, convRule: rule22 },
    { start: 1175, length: 1, convRule: rule23 },
    { start: 1176, length: 1, convRule: rule22 },
    { start: 1177, length: 1, convRule: rule23 },
    { start: 1178, length: 1, convRule: rule22 },
    { start: 1179, length: 1, convRule: rule23 },
    { start: 1180, length: 1, convRule: rule22 },
    { start: 1181, length: 1, convRule: rule23 },
    { start: 1182, length: 1, convRule: rule22 },
    { start: 1183, length: 1, convRule: rule23 },
    { start: 1184, length: 1, convRule: rule22 },
    { start: 1185, length: 1, convRule: rule23 },
    { start: 1186, length: 1, convRule: rule22 },
    { start: 1187, length: 1, convRule: rule23 },
    { start: 1188, length: 1, convRule: rule22 },
    { start: 1189, length: 1, convRule: rule23 },
    { start: 1190, length: 1, convRule: rule22 },
    { start: 1191, length: 1, convRule: rule23 },
    { start: 1192, length: 1, convRule: rule22 },
    { start: 1193, length: 1, convRule: rule23 },
    { start: 1194, length: 1, convRule: rule22 },
    { start: 1195, length: 1, convRule: rule23 },
    { start: 1196, length: 1, convRule: rule22 },
    { start: 1197, length: 1, convRule: rule23 },
    { start: 1198, length: 1, convRule: rule22 },
    { start: 1199, length: 1, convRule: rule23 },
    { start: 1200, length: 1, convRule: rule22 },
    { start: 1201, length: 1, convRule: rule23 },
    { start: 1202, length: 1, convRule: rule22 },
    { start: 1203, length: 1, convRule: rule23 },
    { start: 1204, length: 1, convRule: rule22 },
    { start: 1205, length: 1, convRule: rule23 },
    { start: 1206, length: 1, convRule: rule22 },
    { start: 1207, length: 1, convRule: rule23 },
    { start: 1208, length: 1, convRule: rule22 },
    { start: 1209, length: 1, convRule: rule23 },
    { start: 1210, length: 1, convRule: rule22 },
    { start: 1211, length: 1, convRule: rule23 },
    { start: 1212, length: 1, convRule: rule22 },
    { start: 1213, length: 1, convRule: rule23 },
    { start: 1214, length: 1, convRule: rule22 },
    { start: 1215, length: 1, convRule: rule23 },
    { start: 1216, length: 1, convRule: rule120 },
    { start: 1217, length: 1, convRule: rule22 },
    { start: 1218, length: 1, convRule: rule23 },
    { start: 1219, length: 1, convRule: rule22 },
    { start: 1220, length: 1, convRule: rule23 },
    { start: 1221, length: 1, convRule: rule22 },
    { start: 1222, length: 1, convRule: rule23 },
    { start: 1223, length: 1, convRule: rule22 },
    { start: 1224, length: 1, convRule: rule23 },
    { start: 1225, length: 1, convRule: rule22 },
    { start: 1226, length: 1, convRule: rule23 },
    { start: 1227, length: 1, convRule: rule22 },
    { start: 1228, length: 1, convRule: rule23 },
    { start: 1229, length: 1, convRule: rule22 },
    { start: 1230, length: 1, convRule: rule23 },
    { start: 1231, length: 1, convRule: rule121 },
    { start: 1232, length: 1, convRule: rule22 },
    { start: 1233, length: 1, convRule: rule23 },
    { start: 1234, length: 1, convRule: rule22 },
    { start: 1235, length: 1, convRule: rule23 },
    { start: 1236, length: 1, convRule: rule22 },
    { start: 1237, length: 1, convRule: rule23 },
    { start: 1238, length: 1, convRule: rule22 },
    { start: 1239, length: 1, convRule: rule23 },
    { start: 1240, length: 1, convRule: rule22 },
    { start: 1241, length: 1, convRule: rule23 },
    { start: 1242, length: 1, convRule: rule22 },
    { start: 1243, length: 1, convRule: rule23 },
    { start: 1244, length: 1, convRule: rule22 },
    { start: 1245, length: 1, convRule: rule23 },
    { start: 1246, length: 1, convRule: rule22 },
    { start: 1247, length: 1, convRule: rule23 },
    { start: 1248, length: 1, convRule: rule22 },
    { start: 1249, length: 1, convRule: rule23 },
    { start: 1250, length: 1, convRule: rule22 },
    { start: 1251, length: 1, convRule: rule23 },
    { start: 1252, length: 1, convRule: rule22 },
    { start: 1253, length: 1, convRule: rule23 },
    { start: 1254, length: 1, convRule: rule22 },
    { start: 1255, length: 1, convRule: rule23 },
    { start: 1256, length: 1, convRule: rule22 },
    { start: 1257, length: 1, convRule: rule23 },
    { start: 1258, length: 1, convRule: rule22 },
    { start: 1259, length: 1, convRule: rule23 },
    { start: 1260, length: 1, convRule: rule22 },
    { start: 1261, length: 1, convRule: rule23 },
    { start: 1262, length: 1, convRule: rule22 },
    { start: 1263, length: 1, convRule: rule23 },
    { start: 1264, length: 1, convRule: rule22 },
    { start: 1265, length: 1, convRule: rule23 },
    { start: 1266, length: 1, convRule: rule22 },
    { start: 1267, length: 1, convRule: rule23 },
    { start: 1268, length: 1, convRule: rule22 },
    { start: 1269, length: 1, convRule: rule23 },
    { start: 1270, length: 1, convRule: rule22 },
    { start: 1271, length: 1, convRule: rule23 },
    { start: 1272, length: 1, convRule: rule22 },
    { start: 1273, length: 1, convRule: rule23 },
    { start: 1274, length: 1, convRule: rule22 },
    { start: 1275, length: 1, convRule: rule23 },
    { start: 1276, length: 1, convRule: rule22 },
    { start: 1277, length: 1, convRule: rule23 },
    { start: 1278, length: 1, convRule: rule22 },
    { start: 1279, length: 1, convRule: rule23 },
    { start: 1280, length: 1, convRule: rule22 },
    { start: 1281, length: 1, convRule: rule23 },
    { start: 1282, length: 1, convRule: rule22 },
    { start: 1283, length: 1, convRule: rule23 },
    { start: 1284, length: 1, convRule: rule22 },
    { start: 1285, length: 1, convRule: rule23 },
    { start: 1286, length: 1, convRule: rule22 },
    { start: 1287, length: 1, convRule: rule23 },
    { start: 1288, length: 1, convRule: rule22 },
    { start: 1289, length: 1, convRule: rule23 },
    { start: 1290, length: 1, convRule: rule22 },
    { start: 1291, length: 1, convRule: rule23 },
    { start: 1292, length: 1, convRule: rule22 },
    { start: 1293, length: 1, convRule: rule23 },
    { start: 1294, length: 1, convRule: rule22 },
    { start: 1295, length: 1, convRule: rule23 },
    { start: 1296, length: 1, convRule: rule22 },
    { start: 1297, length: 1, convRule: rule23 },
    { start: 1298, length: 1, convRule: rule22 },
    { start: 1299, length: 1, convRule: rule23 },
    { start: 1300, length: 1, convRule: rule22 },
    { start: 1301, length: 1, convRule: rule23 },
    { start: 1302, length: 1, convRule: rule22 },
    { start: 1303, length: 1, convRule: rule23 },
    { start: 1304, length: 1, convRule: rule22 },
    { start: 1305, length: 1, convRule: rule23 },
    { start: 1306, length: 1, convRule: rule22 },
    { start: 1307, length: 1, convRule: rule23 },
    { start: 1308, length: 1, convRule: rule22 },
    { start: 1309, length: 1, convRule: rule23 },
    { start: 1310, length: 1, convRule: rule22 },
    { start: 1311, length: 1, convRule: rule23 },
    { start: 1312, length: 1, convRule: rule22 },
    { start: 1313, length: 1, convRule: rule23 },
    { start: 1314, length: 1, convRule: rule22 },
    { start: 1315, length: 1, convRule: rule23 },
    { start: 1316, length: 1, convRule: rule22 },
    { start: 1317, length: 1, convRule: rule23 },
    { start: 1318, length: 1, convRule: rule22 },
    { start: 1319, length: 1, convRule: rule23 },
    { start: 1320, length: 1, convRule: rule22 },
    { start: 1321, length: 1, convRule: rule23 },
    { start: 1322, length: 1, convRule: rule22 },
    { start: 1323, length: 1, convRule: rule23 },
    { start: 1324, length: 1, convRule: rule22 },
    { start: 1325, length: 1, convRule: rule23 },
    { start: 1326, length: 1, convRule: rule22 },
    { start: 1327, length: 1, convRule: rule23 },
    { start: 1329, length: 38, convRule: rule122 },
    { start: 1369, length: 1, convRule: rule91 },
    { start: 1370, length: 6, convRule: rule2 },
    { start: 1376, length: 1, convRule: rule20 },
    { start: 1377, length: 38, convRule: rule123 },
    { start: 1415, length: 2, convRule: rule20 },
    { start: 1417, length: 1, convRule: rule2 },
    { start: 1418, length: 1, convRule: rule7 },
    { start: 1421, length: 2, convRule: rule13 },
    { start: 1423, length: 1, convRule: rule3 },
    { start: 1425, length: 45, convRule: rule92 },
    { start: 1470, length: 1, convRule: rule7 },
    { start: 1471, length: 1, convRule: rule92 },
    { start: 1472, length: 1, convRule: rule2 },
    { start: 1473, length: 2, convRule: rule92 },
    { start: 1475, length: 1, convRule: rule2 },
    { start: 1476, length: 2, convRule: rule92 },
    { start: 1478, length: 1, convRule: rule2 },
    { start: 1479, length: 1, convRule: rule92 },
    { start: 1488, length: 27, convRule: rule14 },
    { start: 1519, length: 4, convRule: rule14 },
    { start: 1523, length: 2, convRule: rule2 },
    { start: 1536, length: 6, convRule: rule16 },
    { start: 1542, length: 3, convRule: rule6 },
    { start: 1545, length: 2, convRule: rule2 },
    { start: 1547, length: 1, convRule: rule3 },
    { start: 1548, length: 2, convRule: rule2 },
    { start: 1550, length: 2, convRule: rule13 },
    { start: 1552, length: 11, convRule: rule92 },
    { start: 1563, length: 1, convRule: rule2 },
    { start: 1564, length: 1, convRule: rule16 },
    { start: 1566, length: 2, convRule: rule2 },
    { start: 1568, length: 32, convRule: rule14 },
    { start: 1600, length: 1, convRule: rule91 },
    { start: 1601, length: 10, convRule: rule14 },
    { start: 1611, length: 21, convRule: rule92 },
    { start: 1632, length: 10, convRule: rule8 },
    { start: 1642, length: 4, convRule: rule2 },
    { start: 1646, length: 2, convRule: rule14 },
    { start: 1648, length: 1, convRule: rule92 },
    { start: 1649, length: 99, convRule: rule14 },
    { start: 1748, length: 1, convRule: rule2 },
    { start: 1749, length: 1, convRule: rule14 },
    { start: 1750, length: 7, convRule: rule92 },
    { start: 1757, length: 1, convRule: rule16 },
    { start: 1758, length: 1, convRule: rule13 },
    { start: 1759, length: 6, convRule: rule92 },
    { start: 1765, length: 2, convRule: rule91 },
    { start: 1767, length: 2, convRule: rule92 },
    { start: 1769, length: 1, convRule: rule13 },
    { start: 1770, length: 4, convRule: rule92 },
    { start: 1774, length: 2, convRule: rule14 },
    { start: 1776, length: 10, convRule: rule8 },
    { start: 1786, length: 3, convRule: rule14 },
    { start: 1789, length: 2, convRule: rule13 },
    { start: 1791, length: 1, convRule: rule14 },
    { start: 1792, length: 14, convRule: rule2 },
    { start: 1807, length: 1, convRule: rule16 },
    { start: 1808, length: 1, convRule: rule14 },
    { start: 1809, length: 1, convRule: rule92 },
    { start: 1810, length: 30, convRule: rule14 },
    { start: 1840, length: 27, convRule: rule92 },
    { start: 1869, length: 89, convRule: rule14 },
    { start: 1958, length: 11, convRule: rule92 },
    { start: 1969, length: 1, convRule: rule14 },
    { start: 1984, length: 10, convRule: rule8 },
    { start: 1994, length: 33, convRule: rule14 },
    { start: 2027, length: 9, convRule: rule92 },
    { start: 2036, length: 2, convRule: rule91 },
    { start: 2038, length: 1, convRule: rule13 },
    { start: 2039, length: 3, convRule: rule2 },
    { start: 2042, length: 1, convRule: rule91 },
    { start: 2045, length: 1, convRule: rule92 },
    { start: 2046, length: 2, convRule: rule3 },
    { start: 2048, length: 22, convRule: rule14 },
    { start: 2070, length: 4, convRule: rule92 },
    { start: 2074, length: 1, convRule: rule91 },
    { start: 2075, length: 9, convRule: rule92 },
    { start: 2084, length: 1, convRule: rule91 },
    { start: 2085, length: 3, convRule: rule92 },
    { start: 2088, length: 1, convRule: rule91 },
    { start: 2089, length: 5, convRule: rule92 },
    { start: 2096, length: 15, convRule: rule2 },
    { start: 2112, length: 25, convRule: rule14 },
    { start: 2137, length: 3, convRule: rule92 },
    { start: 2142, length: 1, convRule: rule2 },
    { start: 2144, length: 11, convRule: rule14 },
    { start: 2208, length: 21, convRule: rule14 },
    { start: 2230, length: 18, convRule: rule14 },
    { start: 2259, length: 15, convRule: rule92 },
    { start: 2274, length: 1, convRule: rule16 },
    { start: 2275, length: 32, convRule: rule92 },
    { start: 2307, length: 1, convRule: rule124 },
    { start: 2308, length: 54, convRule: rule14 },
    { start: 2362, length: 1, convRule: rule92 },
    { start: 2363, length: 1, convRule: rule124 },
    { start: 2364, length: 1, convRule: rule92 },
    { start: 2365, length: 1, convRule: rule14 },
    { start: 2366, length: 3, convRule: rule124 },
    { start: 2369, length: 8, convRule: rule92 },
    { start: 2377, length: 4, convRule: rule124 },
    { start: 2381, length: 1, convRule: rule92 },
    { start: 2382, length: 2, convRule: rule124 },
    { start: 2384, length: 1, convRule: rule14 },
    { start: 2385, length: 7, convRule: rule92 },
    { start: 2392, length: 10, convRule: rule14 },
    { start: 2402, length: 2, convRule: rule92 },
    { start: 2404, length: 2, convRule: rule2 },
    { start: 2406, length: 10, convRule: rule8 },
    { start: 2416, length: 1, convRule: rule2 },
    { start: 2417, length: 1, convRule: rule91 },
    { start: 2418, length: 15, convRule: rule14 },
    { start: 2433, length: 1, convRule: rule92 },
    { start: 2434, length: 2, convRule: rule124 },
    { start: 2437, length: 8, convRule: rule14 },
    { start: 2447, length: 2, convRule: rule14 },
    { start: 2451, length: 22, convRule: rule14 },
    { start: 2474, length: 7, convRule: rule14 },
    { start: 2482, length: 1, convRule: rule14 },
    { start: 2486, length: 4, convRule: rule14 },
    { start: 2492, length: 1, convRule: rule92 },
    { start: 2493, length: 1, convRule: rule14 },
    { start: 2494, length: 3, convRule: rule124 },
    { start: 2497, length: 4, convRule: rule92 },
    { start: 2503, length: 2, convRule: rule124 },
    { start: 2507, length: 2, convRule: rule124 },
    { start: 2509, length: 1, convRule: rule92 },
    { start: 2510, length: 1, convRule: rule14 },
    { start: 2519, length: 1, convRule: rule124 },
    { start: 2524, length: 2, convRule: rule14 },
    { start: 2527, length: 3, convRule: rule14 },
    { start: 2530, length: 2, convRule: rule92 },
    { start: 2534, length: 10, convRule: rule8 },
    { start: 2544, length: 2, convRule: rule14 },
    { start: 2546, length: 2, convRule: rule3 },
    { start: 2548, length: 6, convRule: rule17 },
    { start: 2554, length: 1, convRule: rule13 },
    { start: 2555, length: 1, convRule: rule3 },
    { start: 2556, length: 1, convRule: rule14 },
    { start: 2557, length: 1, convRule: rule2 },
    { start: 2558, length: 1, convRule: rule92 },
    { start: 2561, length: 2, convRule: rule92 },
    { start: 2563, length: 1, convRule: rule124 },
    { start: 2565, length: 6, convRule: rule14 },
    { start: 2575, length: 2, convRule: rule14 },
    { start: 2579, length: 22, convRule: rule14 },
    { start: 2602, length: 7, convRule: rule14 },
    { start: 2610, length: 2, convRule: rule14 },
    { start: 2613, length: 2, convRule: rule14 },
    { start: 2616, length: 2, convRule: rule14 },
    { start: 2620, length: 1, convRule: rule92 },
    { start: 2622, length: 3, convRule: rule124 },
    { start: 2625, length: 2, convRule: rule92 },
    { start: 2631, length: 2, convRule: rule92 },
    { start: 2635, length: 3, convRule: rule92 },
    { start: 2641, length: 1, convRule: rule92 },
    { start: 2649, length: 4, convRule: rule14 },
    { start: 2654, length: 1, convRule: rule14 },
    { start: 2662, length: 10, convRule: rule8 },
    { start: 2672, length: 2, convRule: rule92 },
    { start: 2674, length: 3, convRule: rule14 },
    { start: 2677, length: 1, convRule: rule92 },
    { start: 2678, length: 1, convRule: rule2 },
    { start: 2689, length: 2, convRule: rule92 },
    { start: 2691, length: 1, convRule: rule124 },
    { start: 2693, length: 9, convRule: rule14 },
    { start: 2703, length: 3, convRule: rule14 },
    { start: 2707, length: 22, convRule: rule14 },
    { start: 2730, length: 7, convRule: rule14 },
    { start: 2738, length: 2, convRule: rule14 },
    { start: 2741, length: 5, convRule: rule14 },
    { start: 2748, length: 1, convRule: rule92 },
    { start: 2749, length: 1, convRule: rule14 },
    { start: 2750, length: 3, convRule: rule124 },
    { start: 2753, length: 5, convRule: rule92 },
    { start: 2759, length: 2, convRule: rule92 },
    { start: 2761, length: 1, convRule: rule124 },
    { start: 2763, length: 2, convRule: rule124 },
    { start: 2765, length: 1, convRule: rule92 },
    { start: 2768, length: 1, convRule: rule14 },
    { start: 2784, length: 2, convRule: rule14 },
    { start: 2786, length: 2, convRule: rule92 },
    { start: 2790, length: 10, convRule: rule8 },
    { start: 2800, length: 1, convRule: rule2 },
    { start: 2801, length: 1, convRule: rule3 },
    { start: 2809, length: 1, convRule: rule14 },
    { start: 2810, length: 6, convRule: rule92 },
    { start: 2817, length: 1, convRule: rule92 },
    { start: 2818, length: 2, convRule: rule124 },
    { start: 2821, length: 8, convRule: rule14 },
    { start: 2831, length: 2, convRule: rule14 },
    { start: 2835, length: 22, convRule: rule14 },
    { start: 2858, length: 7, convRule: rule14 },
    { start: 2866, length: 2, convRule: rule14 },
    { start: 2869, length: 5, convRule: rule14 },
    { start: 2876, length: 1, convRule: rule92 },
    { start: 2877, length: 1, convRule: rule14 },
    { start: 2878, length: 1, convRule: rule124 },
    { start: 2879, length: 1, convRule: rule92 },
    { start: 2880, length: 1, convRule: rule124 },
    { start: 2881, length: 4, convRule: rule92 },
    { start: 2887, length: 2, convRule: rule124 },
    { start: 2891, length: 2, convRule: rule124 },
    { start: 2893, length: 1, convRule: rule92 },
    { start: 2901, length: 2, convRule: rule92 },
    { start: 2903, length: 1, convRule: rule124 },
    { start: 2908, length: 2, convRule: rule14 },
    { start: 2911, length: 3, convRule: rule14 },
    { start: 2914, length: 2, convRule: rule92 },
    { start: 2918, length: 10, convRule: rule8 },
    { start: 2928, length: 1, convRule: rule13 },
    { start: 2929, length: 1, convRule: rule14 },
    { start: 2930, length: 6, convRule: rule17 },
    { start: 2946, length: 1, convRule: rule92 },
    { start: 2947, length: 1, convRule: rule14 },
    { start: 2949, length: 6, convRule: rule14 },
    { start: 2958, length: 3, convRule: rule14 },
    { start: 2962, length: 4, convRule: rule14 },
    { start: 2969, length: 2, convRule: rule14 },
    { start: 2972, length: 1, convRule: rule14 },
    { start: 2974, length: 2, convRule: rule14 },
    { start: 2979, length: 2, convRule: rule14 },
    { start: 2984, length: 3, convRule: rule14 },
    { start: 2990, length: 12, convRule: rule14 },
    { start: 3006, length: 2, convRule: rule124 },
    { start: 3008, length: 1, convRule: rule92 },
    { start: 3009, length: 2, convRule: rule124 },
    { start: 3014, length: 3, convRule: rule124 },
    { start: 3018, length: 3, convRule: rule124 },
    { start: 3021, length: 1, convRule: rule92 },
    { start: 3024, length: 1, convRule: rule14 },
    { start: 3031, length: 1, convRule: rule124 },
    { start: 3046, length: 10, convRule: rule8 },
    { start: 3056, length: 3, convRule: rule17 },
    { start: 3059, length: 6, convRule: rule13 },
    { start: 3065, length: 1, convRule: rule3 },
    { start: 3066, length: 1, convRule: rule13 },
    { start: 3072, length: 1, convRule: rule92 },
    { start: 3073, length: 3, convRule: rule124 },
    { start: 3076, length: 1, convRule: rule92 },
    { start: 3077, length: 8, convRule: rule14 },
    { start: 3086, length: 3, convRule: rule14 },
    { start: 3090, length: 23, convRule: rule14 },
    { start: 3114, length: 16, convRule: rule14 },
    { start: 3133, length: 1, convRule: rule14 },
    { start: 3134, length: 3, convRule: rule92 },
    { start: 3137, length: 4, convRule: rule124 },
    { start: 3142, length: 3, convRule: rule92 },
    { start: 3146, length: 4, convRule: rule92 },
    { start: 3157, length: 2, convRule: rule92 },
    { start: 3160, length: 3, convRule: rule14 },
    { start: 3168, length: 2, convRule: rule14 },
    { start: 3170, length: 2, convRule: rule92 },
    { start: 3174, length: 10, convRule: rule8 },
    { start: 3191, length: 1, convRule: rule2 },
    { start: 3192, length: 7, convRule: rule17 },
    { start: 3199, length: 1, convRule: rule13 },
    { start: 3200, length: 1, convRule: rule14 },
    { start: 3201, length: 1, convRule: rule92 },
    { start: 3202, length: 2, convRule: rule124 },
    { start: 3204, length: 1, convRule: rule2 },
    { start: 3205, length: 8, convRule: rule14 },
    { start: 3214, length: 3, convRule: rule14 },
    { start: 3218, length: 23, convRule: rule14 },
    { start: 3242, length: 10, convRule: rule14 },
    { start: 3253, length: 5, convRule: rule14 },
    { start: 3260, length: 1, convRule: rule92 },
    { start: 3261, length: 1, convRule: rule14 },
    { start: 3262, length: 1, convRule: rule124 },
    { start: 3263, length: 1, convRule: rule92 },
    { start: 3264, length: 5, convRule: rule124 },
    { start: 3270, length: 1, convRule: rule92 },
    { start: 3271, length: 2, convRule: rule124 },
    { start: 3274, length: 2, convRule: rule124 },
    { start: 3276, length: 2, convRule: rule92 },
    { start: 3285, length: 2, convRule: rule124 },
    { start: 3294, length: 1, convRule: rule14 },
    { start: 3296, length: 2, convRule: rule14 },
    { start: 3298, length: 2, convRule: rule92 },
    { start: 3302, length: 10, convRule: rule8 },
    { start: 3313, length: 2, convRule: rule14 },
    { start: 3328, length: 2, convRule: rule92 },
    { start: 3330, length: 2, convRule: rule124 },
    { start: 3332, length: 9, convRule: rule14 },
    { start: 3342, length: 3, convRule: rule14 },
    { start: 3346, length: 41, convRule: rule14 },
    { start: 3387, length: 2, convRule: rule92 },
    { start: 3389, length: 1, convRule: rule14 },
    { start: 3390, length: 3, convRule: rule124 },
    { start: 3393, length: 4, convRule: rule92 },
    { start: 3398, length: 3, convRule: rule124 },
    { start: 3402, length: 3, convRule: rule124 },
    { start: 3405, length: 1, convRule: rule92 },
    { start: 3406, length: 1, convRule: rule14 },
    { start: 3407, length: 1, convRule: rule13 },
    { start: 3412, length: 3, convRule: rule14 },
    { start: 3415, length: 1, convRule: rule124 },
    { start: 3416, length: 7, convRule: rule17 },
    { start: 3423, length: 3, convRule: rule14 },
    { start: 3426, length: 2, convRule: rule92 },
    { start: 3430, length: 10, convRule: rule8 },
    { start: 3440, length: 9, convRule: rule17 },
    { start: 3449, length: 1, convRule: rule13 },
    { start: 3450, length: 6, convRule: rule14 },
    { start: 3457, length: 1, convRule: rule92 },
    { start: 3458, length: 2, convRule: rule124 },
    { start: 3461, length: 18, convRule: rule14 },
    { start: 3482, length: 24, convRule: rule14 },
    { start: 3507, length: 9, convRule: rule14 },
    { start: 3517, length: 1, convRule: rule14 },
    { start: 3520, length: 7, convRule: rule14 },
    { start: 3530, length: 1, convRule: rule92 },
    { start: 3535, length: 3, convRule: rule124 },
    { start: 3538, length: 3, convRule: rule92 },
    { start: 3542, length: 1, convRule: rule92 },
    { start: 3544, length: 8, convRule: rule124 },
    { start: 3558, length: 10, convRule: rule8 },
    { start: 3570, length: 2, convRule: rule124 },
    { start: 3572, length: 1, convRule: rule2 },
    { start: 3585, length: 48, convRule: rule14 },
    { start: 3633, length: 1, convRule: rule92 },
    { start: 3634, length: 2, convRule: rule14 },
    { start: 3636, length: 7, convRule: rule92 },
    { start: 3647, length: 1, convRule: rule3 },
    { start: 3648, length: 6, convRule: rule14 },
    { start: 3654, length: 1, convRule: rule91 },
    { start: 3655, length: 8, convRule: rule92 },
    { start: 3663, length: 1, convRule: rule2 },
    { start: 3664, length: 10, convRule: rule8 },
    { start: 3674, length: 2, convRule: rule2 },
    { start: 3713, length: 2, convRule: rule14 },
    { start: 3716, length: 1, convRule: rule14 },
    { start: 3718, length: 5, convRule: rule14 },
    { start: 3724, length: 24, convRule: rule14 },
    { start: 3749, length: 1, convRule: rule14 },
    { start: 3751, length: 10, convRule: rule14 },
    { start: 3761, length: 1, convRule: rule92 },
    { start: 3762, length: 2, convRule: rule14 },
    { start: 3764, length: 9, convRule: rule92 },
    { start: 3773, length: 1, convRule: rule14 },
    { start: 3776, length: 5, convRule: rule14 },
    { start: 3782, length: 1, convRule: rule91 },
    { start: 3784, length: 6, convRule: rule92 },
    { start: 3792, length: 10, convRule: rule8 },
    { start: 3804, length: 4, convRule: rule14 },
    { start: 3840, length: 1, convRule: rule14 },
    { start: 3841, length: 3, convRule: rule13 },
    { start: 3844, length: 15, convRule: rule2 },
    { start: 3859, length: 1, convRule: rule13 },
    { start: 3860, length: 1, convRule: rule2 },
    { start: 3861, length: 3, convRule: rule13 },
    { start: 3864, length: 2, convRule: rule92 },
    { start: 3866, length: 6, convRule: rule13 },
    { start: 3872, length: 10, convRule: rule8 },
    { start: 3882, length: 10, convRule: rule17 },
    { start: 3892, length: 1, convRule: rule13 },
    { start: 3893, length: 1, convRule: rule92 },
    { start: 3894, length: 1, convRule: rule13 },
    { start: 3895, length: 1, convRule: rule92 },
    { start: 3896, length: 1, convRule: rule13 },
    { start: 3897, length: 1, convRule: rule92 },
    { start: 3898, length: 1, convRule: rule4 },
    { start: 3899, length: 1, convRule: rule5 },
    { start: 3900, length: 1, convRule: rule4 },
    { start: 3901, length: 1, convRule: rule5 },
    { start: 3902, length: 2, convRule: rule124 },
    { start: 3904, length: 8, convRule: rule14 },
    { start: 3913, length: 36, convRule: rule14 },
    { start: 3953, length: 14, convRule: rule92 },
    { start: 3967, length: 1, convRule: rule124 },
    { start: 3968, length: 5, convRule: rule92 },
    { start: 3973, length: 1, convRule: rule2 },
    { start: 3974, length: 2, convRule: rule92 },
    { start: 3976, length: 5, convRule: rule14 },
    { start: 3981, length: 11, convRule: rule92 },
    { start: 3993, length: 36, convRule: rule92 },
    { start: 4030, length: 8, convRule: rule13 },
    { start: 4038, length: 1, convRule: rule92 },
    { start: 4039, length: 6, convRule: rule13 },
    { start: 4046, length: 2, convRule: rule13 },
    { start: 4048, length: 5, convRule: rule2 },
    { start: 4053, length: 4, convRule: rule13 },
    { start: 4057, length: 2, convRule: rule2 },
    { start: 4096, length: 43, convRule: rule14 },
    { start: 4139, length: 2, convRule: rule124 },
    { start: 4141, length: 4, convRule: rule92 },
    { start: 4145, length: 1, convRule: rule124 },
    { start: 4146, length: 6, convRule: rule92 },
    { start: 4152, length: 1, convRule: rule124 },
    { start: 4153, length: 2, convRule: rule92 },
    { start: 4155, length: 2, convRule: rule124 },
    { start: 4157, length: 2, convRule: rule92 },
    { start: 4159, length: 1, convRule: rule14 },
    { start: 4160, length: 10, convRule: rule8 },
    { start: 4170, length: 6, convRule: rule2 },
    { start: 4176, length: 6, convRule: rule14 },
    { start: 4182, length: 2, convRule: rule124 },
    { start: 4184, length: 2, convRule: rule92 },
    { start: 4186, length: 4, convRule: rule14 },
    { start: 4190, length: 3, convRule: rule92 },
    { start: 4193, length: 1, convRule: rule14 },
    { start: 4194, length: 3, convRule: rule124 },
    { start: 4197, length: 2, convRule: rule14 },
    { start: 4199, length: 7, convRule: rule124 },
    { start: 4206, length: 3, convRule: rule14 },
    { start: 4209, length: 4, convRule: rule92 },
    { start: 4213, length: 13, convRule: rule14 },
    { start: 4226, length: 1, convRule: rule92 },
    { start: 4227, length: 2, convRule: rule124 },
    { start: 4229, length: 2, convRule: rule92 },
    { start: 4231, length: 6, convRule: rule124 },
    { start: 4237, length: 1, convRule: rule92 },
    { start: 4238, length: 1, convRule: rule14 },
    { start: 4239, length: 1, convRule: rule124 },
    { start: 4240, length: 10, convRule: rule8 },
    { start: 4250, length: 3, convRule: rule124 },
    { start: 4253, length: 1, convRule: rule92 },
    { start: 4254, length: 2, convRule: rule13 },
    { start: 4256, length: 38, convRule: rule125 },
    { start: 4295, length: 1, convRule: rule125 },
    { start: 4301, length: 1, convRule: rule125 },
    { start: 4304, length: 43, convRule: rule126 },
    { start: 4347, length: 1, convRule: rule2 },
    { start: 4348, length: 1, convRule: rule91 },
    { start: 4349, length: 3, convRule: rule126 },
    { start: 4352, length: 329, convRule: rule14 },
    { start: 4682, length: 4, convRule: rule14 },
    { start: 4688, length: 7, convRule: rule14 },
    { start: 4696, length: 1, convRule: rule14 },
    { start: 4698, length: 4, convRule: rule14 },
    { start: 4704, length: 41, convRule: rule14 },
    { start: 4746, length: 4, convRule: rule14 },
    { start: 4752, length: 33, convRule: rule14 },
    { start: 4786, length: 4, convRule: rule14 },
    { start: 4792, length: 7, convRule: rule14 },
    { start: 4800, length: 1, convRule: rule14 },
    { start: 4802, length: 4, convRule: rule14 },
    { start: 4808, length: 15, convRule: rule14 },
    { start: 4824, length: 57, convRule: rule14 },
    { start: 4882, length: 4, convRule: rule14 },
    { start: 4888, length: 67, convRule: rule14 },
    { start: 4957, length: 3, convRule: rule92 },
    { start: 4960, length: 9, convRule: rule2 },
    { start: 4969, length: 20, convRule: rule17 },
    { start: 4992, length: 16, convRule: rule14 },
    { start: 5008, length: 10, convRule: rule13 },
    { start: 5024, length: 80, convRule: rule127 },
    { start: 5104, length: 6, convRule: rule104 },
    { start: 5112, length: 6, convRule: rule110 },
    { start: 5120, length: 1, convRule: rule7 },
    { start: 5121, length: 620, convRule: rule14 },
    { start: 5741, length: 1, convRule: rule13 },
    { start: 5742, length: 1, convRule: rule2 },
    { start: 5743, length: 17, convRule: rule14 },
    { start: 5760, length: 1, convRule: rule1 },
    { start: 5761, length: 26, convRule: rule14 },
    { start: 5787, length: 1, convRule: rule4 },
    { start: 5788, length: 1, convRule: rule5 },
    { start: 5792, length: 75, convRule: rule14 },
    { start: 5867, length: 3, convRule: rule2 },
    { start: 5870, length: 3, convRule: rule128 },
    { start: 5873, length: 8, convRule: rule14 },
    { start: 5888, length: 13, convRule: rule14 },
    { start: 5902, length: 4, convRule: rule14 },
    { start: 5906, length: 3, convRule: rule92 },
    { start: 5920, length: 18, convRule: rule14 },
    { start: 5938, length: 3, convRule: rule92 },
    { start: 5941, length: 2, convRule: rule2 },
    { start: 5952, length: 18, convRule: rule14 },
    { start: 5970, length: 2, convRule: rule92 },
    { start: 5984, length: 13, convRule: rule14 },
    { start: 5998, length: 3, convRule: rule14 },
    { start: 6002, length: 2, convRule: rule92 },
    { start: 6016, length: 52, convRule: rule14 },
    { start: 6068, length: 2, convRule: rule92 },
    { start: 6070, length: 1, convRule: rule124 },
    { start: 6071, length: 7, convRule: rule92 },
    { start: 6078, length: 8, convRule: rule124 },
    { start: 6086, length: 1, convRule: rule92 },
    { start: 6087, length: 2, convRule: rule124 },
    { start: 6089, length: 11, convRule: rule92 },
    { start: 6100, length: 3, convRule: rule2 },
    { start: 6103, length: 1, convRule: rule91 },
    { start: 6104, length: 3, convRule: rule2 },
    { start: 6107, length: 1, convRule: rule3 },
    { start: 6108, length: 1, convRule: rule14 },
    { start: 6109, length: 1, convRule: rule92 },
    { start: 6112, length: 10, convRule: rule8 },
    { start: 6128, length: 10, convRule: rule17 },
    { start: 6144, length: 6, convRule: rule2 },
    { start: 6150, length: 1, convRule: rule7 },
    { start: 6151, length: 4, convRule: rule2 },
    { start: 6155, length: 3, convRule: rule92 },
    { start: 6158, length: 1, convRule: rule16 },
    { start: 6160, length: 10, convRule: rule8 },
    { start: 6176, length: 35, convRule: rule14 },
    { start: 6211, length: 1, convRule: rule91 },
    { start: 6212, length: 53, convRule: rule14 },
    { start: 6272, length: 5, convRule: rule14 },
    { start: 6277, length: 2, convRule: rule92 },
    { start: 6279, length: 34, convRule: rule14 },
    { start: 6313, length: 1, convRule: rule92 },
    { start: 6314, length: 1, convRule: rule14 },
    { start: 6320, length: 70, convRule: rule14 },
    { start: 6400, length: 31, convRule: rule14 },
    { start: 6432, length: 3, convRule: rule92 },
    { start: 6435, length: 4, convRule: rule124 },
    { start: 6439, length: 2, convRule: rule92 },
    { start: 6441, length: 3, convRule: rule124 },
    { start: 6448, length: 2, convRule: rule124 },
    { start: 6450, length: 1, convRule: rule92 },
    { start: 6451, length: 6, convRule: rule124 },
    { start: 6457, length: 3, convRule: rule92 },
    { start: 6464, length: 1, convRule: rule13 },
    { start: 6468, length: 2, convRule: rule2 },
    { start: 6470, length: 10, convRule: rule8 },
    { start: 6480, length: 30, convRule: rule14 },
    { start: 6512, length: 5, convRule: rule14 },
    { start: 6528, length: 44, convRule: rule14 },
    { start: 6576, length: 26, convRule: rule14 },
    { start: 6608, length: 10, convRule: rule8 },
    { start: 6618, length: 1, convRule: rule17 },
    { start: 6622, length: 34, convRule: rule13 },
    { start: 6656, length: 23, convRule: rule14 },
    { start: 6679, length: 2, convRule: rule92 },
    { start: 6681, length: 2, convRule: rule124 },
    { start: 6683, length: 1, convRule: rule92 },
    { start: 6686, length: 2, convRule: rule2 },
    { start: 6688, length: 53, convRule: rule14 },
    { start: 6741, length: 1, convRule: rule124 },
    { start: 6742, length: 1, convRule: rule92 },
    { start: 6743, length: 1, convRule: rule124 },
    { start: 6744, length: 7, convRule: rule92 },
    { start: 6752, length: 1, convRule: rule92 },
    { start: 6753, length: 1, convRule: rule124 },
    { start: 6754, length: 1, convRule: rule92 },
    { start: 6755, length: 2, convRule: rule124 },
    { start: 6757, length: 8, convRule: rule92 },
    { start: 6765, length: 6, convRule: rule124 },
    { start: 6771, length: 10, convRule: rule92 },
    { start: 6783, length: 1, convRule: rule92 },
    { start: 6784, length: 10, convRule: rule8 },
    { start: 6800, length: 10, convRule: rule8 },
    { start: 6816, length: 7, convRule: rule2 },
    { start: 6823, length: 1, convRule: rule91 },
    { start: 6824, length: 6, convRule: rule2 },
    { start: 6832, length: 14, convRule: rule92 },
    { start: 6846, length: 1, convRule: rule119 },
    { start: 6847, length: 2, convRule: rule92 },
    { start: 6912, length: 4, convRule: rule92 },
    { start: 6916, length: 1, convRule: rule124 },
    { start: 6917, length: 47, convRule: rule14 },
    { start: 6964, length: 1, convRule: rule92 },
    { start: 6965, length: 1, convRule: rule124 },
    { start: 6966, length: 5, convRule: rule92 },
    { start: 6971, length: 1, convRule: rule124 },
    { start: 6972, length: 1, convRule: rule92 },
    { start: 6973, length: 5, convRule: rule124 },
    { start: 6978, length: 1, convRule: rule92 },
    { start: 6979, length: 2, convRule: rule124 },
    { start: 6981, length: 7, convRule: rule14 },
    { start: 6992, length: 10, convRule: rule8 },
    { start: 7002, length: 7, convRule: rule2 },
    { start: 7009, length: 10, convRule: rule13 },
    { start: 7019, length: 9, convRule: rule92 },
    { start: 7028, length: 9, convRule: rule13 },
    { start: 7040, length: 2, convRule: rule92 },
    { start: 7042, length: 1, convRule: rule124 },
    { start: 7043, length: 30, convRule: rule14 },
    { start: 7073, length: 1, convRule: rule124 },
    { start: 7074, length: 4, convRule: rule92 },
    { start: 7078, length: 2, convRule: rule124 },
    { start: 7080, length: 2, convRule: rule92 },
    { start: 7082, length: 1, convRule: rule124 },
    { start: 7083, length: 3, convRule: rule92 },
    { start: 7086, length: 2, convRule: rule14 },
    { start: 7088, length: 10, convRule: rule8 },
    { start: 7098, length: 44, convRule: rule14 },
    { start: 7142, length: 1, convRule: rule92 },
    { start: 7143, length: 1, convRule: rule124 },
    { start: 7144, length: 2, convRule: rule92 },
    { start: 7146, length: 3, convRule: rule124 },
    { start: 7149, length: 1, convRule: rule92 },
    { start: 7150, length: 1, convRule: rule124 },
    { start: 7151, length: 3, convRule: rule92 },
    { start: 7154, length: 2, convRule: rule124 },
    { start: 7164, length: 4, convRule: rule2 },
    { start: 7168, length: 36, convRule: rule14 },
    { start: 7204, length: 8, convRule: rule124 },
    { start: 7212, length: 8, convRule: rule92 },
    { start: 7220, length: 2, convRule: rule124 },
    { start: 7222, length: 2, convRule: rule92 },
    { start: 7227, length: 5, convRule: rule2 },
    { start: 7232, length: 10, convRule: rule8 },
    { start: 7245, length: 3, convRule: rule14 },
    { start: 7248, length: 10, convRule: rule8 },
    { start: 7258, length: 30, convRule: rule14 },
    { start: 7288, length: 6, convRule: rule91 },
    { start: 7294, length: 2, convRule: rule2 },
    { start: 7296, length: 1, convRule: rule129 },
    { start: 7297, length: 1, convRule: rule130 },
    { start: 7298, length: 1, convRule: rule131 },
    { start: 7299, length: 2, convRule: rule132 },
    { start: 7301, length: 1, convRule: rule133 },
    { start: 7302, length: 1, convRule: rule134 },
    { start: 7303, length: 1, convRule: rule135 },
    { start: 7304, length: 1, convRule: rule136 },
    { start: 7312, length: 43, convRule: rule137 },
    { start: 7357, length: 3, convRule: rule137 },
    { start: 7360, length: 8, convRule: rule2 },
    { start: 7376, length: 3, convRule: rule92 },
    { start: 7379, length: 1, convRule: rule2 },
    { start: 7380, length: 13, convRule: rule92 },
    { start: 7393, length: 1, convRule: rule124 },
    { start: 7394, length: 7, convRule: rule92 },
    { start: 7401, length: 4, convRule: rule14 },
    { start: 7405, length: 1, convRule: rule92 },
    { start: 7406, length: 6, convRule: rule14 },
    { start: 7412, length: 1, convRule: rule92 },
    { start: 7413, length: 2, convRule: rule14 },
    { start: 7415, length: 1, convRule: rule124 },
    { start: 7416, length: 2, convRule: rule92 },
    { start: 7418, length: 1, convRule: rule14 },
    { start: 7424, length: 44, convRule: rule20 },
    { start: 7468, length: 63, convRule: rule91 },
    { start: 7531, length: 13, convRule: rule20 },
    { start: 7544, length: 1, convRule: rule91 },
    { start: 7545, length: 1, convRule: rule138 },
    { start: 7546, length: 3, convRule: rule20 },
    { start: 7549, length: 1, convRule: rule139 },
    { start: 7550, length: 16, convRule: rule20 },
    { start: 7566, length: 1, convRule: rule140 },
    { start: 7567, length: 12, convRule: rule20 },
    { start: 7579, length: 37, convRule: rule91 },
    { start: 7616, length: 58, convRule: rule92 },
    { start: 7675, length: 5, convRule: rule92 },
    { start: 7680, length: 1, convRule: rule22 },
    { start: 7681, length: 1, convRule: rule23 },
    { start: 7682, length: 1, convRule: rule22 },
    { start: 7683, length: 1, convRule: rule23 },
    { start: 7684, length: 1, convRule: rule22 },
    { start: 7685, length: 1, convRule: rule23 },
    { start: 7686, length: 1, convRule: rule22 },
    { start: 7687, length: 1, convRule: rule23 },
    { start: 7688, length: 1, convRule: rule22 },
    { start: 7689, length: 1, convRule: rule23 },
    { start: 7690, length: 1, convRule: rule22 },
    { start: 7691, length: 1, convRule: rule23 },
    { start: 7692, length: 1, convRule: rule22 },
    { start: 7693, length: 1, convRule: rule23 },
    { start: 7694, length: 1, convRule: rule22 },
    { start: 7695, length: 1, convRule: rule23 },
    { start: 7696, length: 1, convRule: rule22 },
    { start: 7697, length: 1, convRule: rule23 },
    { start: 7698, length: 1, convRule: rule22 },
    { start: 7699, length: 1, convRule: rule23 },
    { start: 7700, length: 1, convRule: rule22 },
    { start: 7701, length: 1, convRule: rule23 },
    { start: 7702, length: 1, convRule: rule22 },
    { start: 7703, length: 1, convRule: rule23 },
    { start: 7704, length: 1, convRule: rule22 },
    { start: 7705, length: 1, convRule: rule23 },
    { start: 7706, length: 1, convRule: rule22 },
    { start: 7707, length: 1, convRule: rule23 },
    { start: 7708, length: 1, convRule: rule22 },
    { start: 7709, length: 1, convRule: rule23 },
    { start: 7710, length: 1, convRule: rule22 },
    { start: 7711, length: 1, convRule: rule23 },
    { start: 7712, length: 1, convRule: rule22 },
    { start: 7713, length: 1, convRule: rule23 },
    { start: 7714, length: 1, convRule: rule22 },
    { start: 7715, length: 1, convRule: rule23 },
    { start: 7716, length: 1, convRule: rule22 },
    { start: 7717, length: 1, convRule: rule23 },
    { start: 7718, length: 1, convRule: rule22 },
    { start: 7719, length: 1, convRule: rule23 },
    { start: 7720, length: 1, convRule: rule22 },
    { start: 7721, length: 1, convRule: rule23 },
    { start: 7722, length: 1, convRule: rule22 },
    { start: 7723, length: 1, convRule: rule23 },
    { start: 7724, length: 1, convRule: rule22 },
    { start: 7725, length: 1, convRule: rule23 },
    { start: 7726, length: 1, convRule: rule22 },
    { start: 7727, length: 1, convRule: rule23 },
    { start: 7728, length: 1, convRule: rule22 },
    { start: 7729, length: 1, convRule: rule23 },
    { start: 7730, length: 1, convRule: rule22 },
    { start: 7731, length: 1, convRule: rule23 },
    { start: 7732, length: 1, convRule: rule22 },
    { start: 7733, length: 1, convRule: rule23 },
    { start: 7734, length: 1, convRule: rule22 },
    { start: 7735, length: 1, convRule: rule23 },
    { start: 7736, length: 1, convRule: rule22 },
    { start: 7737, length: 1, convRule: rule23 },
    { start: 7738, length: 1, convRule: rule22 },
    { start: 7739, length: 1, convRule: rule23 },
    { start: 7740, length: 1, convRule: rule22 },
    { start: 7741, length: 1, convRule: rule23 },
    { start: 7742, length: 1, convRule: rule22 },
    { start: 7743, length: 1, convRule: rule23 },
    { start: 7744, length: 1, convRule: rule22 },
    { start: 7745, length: 1, convRule: rule23 },
    { start: 7746, length: 1, convRule: rule22 },
    { start: 7747, length: 1, convRule: rule23 },
    { start: 7748, length: 1, convRule: rule22 },
    { start: 7749, length: 1, convRule: rule23 },
    { start: 7750, length: 1, convRule: rule22 },
    { start: 7751, length: 1, convRule: rule23 },
    { start: 7752, length: 1, convRule: rule22 },
    { start: 7753, length: 1, convRule: rule23 },
    { start: 7754, length: 1, convRule: rule22 },
    { start: 7755, length: 1, convRule: rule23 },
    { start: 7756, length: 1, convRule: rule22 },
    { start: 7757, length: 1, convRule: rule23 },
    { start: 7758, length: 1, convRule: rule22 },
    { start: 7759, length: 1, convRule: rule23 },
    { start: 7760, length: 1, convRule: rule22 },
    { start: 7761, length: 1, convRule: rule23 },
    { start: 7762, length: 1, convRule: rule22 },
    { start: 7763, length: 1, convRule: rule23 },
    { start: 7764, length: 1, convRule: rule22 },
    { start: 7765, length: 1, convRule: rule23 },
    { start: 7766, length: 1, convRule: rule22 },
    { start: 7767, length: 1, convRule: rule23 },
    { start: 7768, length: 1, convRule: rule22 },
    { start: 7769, length: 1, convRule: rule23 },
    { start: 7770, length: 1, convRule: rule22 },
    { start: 7771, length: 1, convRule: rule23 },
    { start: 7772, length: 1, convRule: rule22 },
    { start: 7773, length: 1, convRule: rule23 },
    { start: 7774, length: 1, convRule: rule22 },
    { start: 7775, length: 1, convRule: rule23 },
    { start: 7776, length: 1, convRule: rule22 },
    { start: 7777, length: 1, convRule: rule23 },
    { start: 7778, length: 1, convRule: rule22 },
    { start: 7779, length: 1, convRule: rule23 },
    { start: 7780, length: 1, convRule: rule22 },
    { start: 7781, length: 1, convRule: rule23 },
    { start: 7782, length: 1, convRule: rule22 },
    { start: 7783, length: 1, convRule: rule23 },
    { start: 7784, length: 1, convRule: rule22 },
    { start: 7785, length: 1, convRule: rule23 },
    { start: 7786, length: 1, convRule: rule22 },
    { start: 7787, length: 1, convRule: rule23 },
    { start: 7788, length: 1, convRule: rule22 },
    { start: 7789, length: 1, convRule: rule23 },
    { start: 7790, length: 1, convRule: rule22 },
    { start: 7791, length: 1, convRule: rule23 },
    { start: 7792, length: 1, convRule: rule22 },
    { start: 7793, length: 1, convRule: rule23 },
    { start: 7794, length: 1, convRule: rule22 },
    { start: 7795, length: 1, convRule: rule23 },
    { start: 7796, length: 1, convRule: rule22 },
    { start: 7797, length: 1, convRule: rule23 },
    { start: 7798, length: 1, convRule: rule22 },
    { start: 7799, length: 1, convRule: rule23 },
    { start: 7800, length: 1, convRule: rule22 },
    { start: 7801, length: 1, convRule: rule23 },
    { start: 7802, length: 1, convRule: rule22 },
    { start: 7803, length: 1, convRule: rule23 },
    { start: 7804, length: 1, convRule: rule22 },
    { start: 7805, length: 1, convRule: rule23 },
    { start: 7806, length: 1, convRule: rule22 },
    { start: 7807, length: 1, convRule: rule23 },
    { start: 7808, length: 1, convRule: rule22 },
    { start: 7809, length: 1, convRule: rule23 },
    { start: 7810, length: 1, convRule: rule22 },
    { start: 7811, length: 1, convRule: rule23 },
    { start: 7812, length: 1, convRule: rule22 },
    { start: 7813, length: 1, convRule: rule23 },
    { start: 7814, length: 1, convRule: rule22 },
    { start: 7815, length: 1, convRule: rule23 },
    { start: 7816, length: 1, convRule: rule22 },
    { start: 7817, length: 1, convRule: rule23 },
    { start: 7818, length: 1, convRule: rule22 },
    { start: 7819, length: 1, convRule: rule23 },
    { start: 7820, length: 1, convRule: rule22 },
    { start: 7821, length: 1, convRule: rule23 },
    { start: 7822, length: 1, convRule: rule22 },
    { start: 7823, length: 1, convRule: rule23 },
    { start: 7824, length: 1, convRule: rule22 },
    { start: 7825, length: 1, convRule: rule23 },
    { start: 7826, length: 1, convRule: rule22 },
    { start: 7827, length: 1, convRule: rule23 },
    { start: 7828, length: 1, convRule: rule22 },
    { start: 7829, length: 1, convRule: rule23 },
    { start: 7830, length: 5, convRule: rule20 },
    { start: 7835, length: 1, convRule: rule141 },
    { start: 7836, length: 2, convRule: rule20 },
    { start: 7838, length: 1, convRule: rule142 },
    { start: 7839, length: 1, convRule: rule20 },
    { start: 7840, length: 1, convRule: rule22 },
    { start: 7841, length: 1, convRule: rule23 },
    { start: 7842, length: 1, convRule: rule22 },
    { start: 7843, length: 1, convRule: rule23 },
    { start: 7844, length: 1, convRule: rule22 },
    { start: 7845, length: 1, convRule: rule23 },
    { start: 7846, length: 1, convRule: rule22 },
    { start: 7847, length: 1, convRule: rule23 },
    { start: 7848, length: 1, convRule: rule22 },
    { start: 7849, length: 1, convRule: rule23 },
    { start: 7850, length: 1, convRule: rule22 },
    { start: 7851, length: 1, convRule: rule23 },
    { start: 7852, length: 1, convRule: rule22 },
    { start: 7853, length: 1, convRule: rule23 },
    { start: 7854, length: 1, convRule: rule22 },
    { start: 7855, length: 1, convRule: rule23 },
    { start: 7856, length: 1, convRule: rule22 },
    { start: 7857, length: 1, convRule: rule23 },
    { start: 7858, length: 1, convRule: rule22 },
    { start: 7859, length: 1, convRule: rule23 },
    { start: 7860, length: 1, convRule: rule22 },
    { start: 7861, length: 1, convRule: rule23 },
    { start: 7862, length: 1, convRule: rule22 },
    { start: 7863, length: 1, convRule: rule23 },
    { start: 7864, length: 1, convRule: rule22 },
    { start: 7865, length: 1, convRule: rule23 },
    { start: 7866, length: 1, convRule: rule22 },
    { start: 7867, length: 1, convRule: rule23 },
    { start: 7868, length: 1, convRule: rule22 },
    { start: 7869, length: 1, convRule: rule23 },
    { start: 7870, length: 1, convRule: rule22 },
    { start: 7871, length: 1, convRule: rule23 },
    { start: 7872, length: 1, convRule: rule22 },
    { start: 7873, length: 1, convRule: rule23 },
    { start: 7874, length: 1, convRule: rule22 },
    { start: 7875, length: 1, convRule: rule23 },
    { start: 7876, length: 1, convRule: rule22 },
    { start: 7877, length: 1, convRule: rule23 },
    { start: 7878, length: 1, convRule: rule22 },
    { start: 7879, length: 1, convRule: rule23 },
    { start: 7880, length: 1, convRule: rule22 },
    { start: 7881, length: 1, convRule: rule23 },
    { start: 7882, length: 1, convRule: rule22 },
    { start: 7883, length: 1, convRule: rule23 },
    { start: 7884, length: 1, convRule: rule22 },
    { start: 7885, length: 1, convRule: rule23 },
    { start: 7886, length: 1, convRule: rule22 },
    { start: 7887, length: 1, convRule: rule23 },
    { start: 7888, length: 1, convRule: rule22 },
    { start: 7889, length: 1, convRule: rule23 },
    { start: 7890, length: 1, convRule: rule22 },
    { start: 7891, length: 1, convRule: rule23 },
    { start: 7892, length: 1, convRule: rule22 },
    { start: 7893, length: 1, convRule: rule23 },
    { start: 7894, length: 1, convRule: rule22 },
    { start: 7895, length: 1, convRule: rule23 },
    { start: 7896, length: 1, convRule: rule22 },
    { start: 7897, length: 1, convRule: rule23 },
    { start: 7898, length: 1, convRule: rule22 },
    { start: 7899, length: 1, convRule: rule23 },
    { start: 7900, length: 1, convRule: rule22 },
    { start: 7901, length: 1, convRule: rule23 },
    { start: 7902, length: 1, convRule: rule22 },
    { start: 7903, length: 1, convRule: rule23 },
    { start: 7904, length: 1, convRule: rule22 },
    { start: 7905, length: 1, convRule: rule23 },
    { start: 7906, length: 1, convRule: rule22 },
    { start: 7907, length: 1, convRule: rule23 },
    { start: 7908, length: 1, convRule: rule22 },
    { start: 7909, length: 1, convRule: rule23 },
    { start: 7910, length: 1, convRule: rule22 },
    { start: 7911, length: 1, convRule: rule23 },
    { start: 7912, length: 1, convRule: rule22 },
    { start: 7913, length: 1, convRule: rule23 },
    { start: 7914, length: 1, convRule: rule22 },
    { start: 7915, length: 1, convRule: rule23 },
    { start: 7916, length: 1, convRule: rule22 },
    { start: 7917, length: 1, convRule: rule23 },
    { start: 7918, length: 1, convRule: rule22 },
    { start: 7919, length: 1, convRule: rule23 },
    { start: 7920, length: 1, convRule: rule22 },
    { start: 7921, length: 1, convRule: rule23 },
    { start: 7922, length: 1, convRule: rule22 },
    { start: 7923, length: 1, convRule: rule23 },
    { start: 7924, length: 1, convRule: rule22 },
    { start: 7925, length: 1, convRule: rule23 },
    { start: 7926, length: 1, convRule: rule22 },
    { start: 7927, length: 1, convRule: rule23 },
    { start: 7928, length: 1, convRule: rule22 },
    { start: 7929, length: 1, convRule: rule23 },
    { start: 7930, length: 1, convRule: rule22 },
    { start: 7931, length: 1, convRule: rule23 },
    { start: 7932, length: 1, convRule: rule22 },
    { start: 7933, length: 1, convRule: rule23 },
    { start: 7934, length: 1, convRule: rule22 },
    { start: 7935, length: 1, convRule: rule23 },
    { start: 7936, length: 8, convRule: rule143 },
    { start: 7944, length: 8, convRule: rule144 },
    { start: 7952, length: 6, convRule: rule143 },
    { start: 7960, length: 6, convRule: rule144 },
    { start: 7968, length: 8, convRule: rule143 },
    { start: 7976, length: 8, convRule: rule144 },
    { start: 7984, length: 8, convRule: rule143 },
    { start: 7992, length: 8, convRule: rule144 },
    { start: 8e3, length: 6, convRule: rule143 },
    { start: 8008, length: 6, convRule: rule144 },
    { start: 8016, length: 1, convRule: rule20 },
    { start: 8017, length: 1, convRule: rule143 },
    { start: 8018, length: 1, convRule: rule20 },
    { start: 8019, length: 1, convRule: rule143 },
    { start: 8020, length: 1, convRule: rule20 },
    { start: 8021, length: 1, convRule: rule143 },
    { start: 8022, length: 1, convRule: rule20 },
    { start: 8023, length: 1, convRule: rule143 },
    { start: 8025, length: 1, convRule: rule144 },
    { start: 8027, length: 1, convRule: rule144 },
    { start: 8029, length: 1, convRule: rule144 },
    { start: 8031, length: 1, convRule: rule144 },
    { start: 8032, length: 8, convRule: rule143 },
    { start: 8040, length: 8, convRule: rule144 },
    { start: 8048, length: 2, convRule: rule145 },
    { start: 8050, length: 4, convRule: rule146 },
    { start: 8054, length: 2, convRule: rule147 },
    { start: 8056, length: 2, convRule: rule148 },
    { start: 8058, length: 2, convRule: rule149 },
    { start: 8060, length: 2, convRule: rule150 },
    { start: 8064, length: 8, convRule: rule143 },
    { start: 8072, length: 8, convRule: rule151 },
    { start: 8080, length: 8, convRule: rule143 },
    { start: 8088, length: 8, convRule: rule151 },
    { start: 8096, length: 8, convRule: rule143 },
    { start: 8104, length: 8, convRule: rule151 },
    { start: 8112, length: 2, convRule: rule143 },
    { start: 8114, length: 1, convRule: rule20 },
    { start: 8115, length: 1, convRule: rule152 },
    { start: 8116, length: 1, convRule: rule20 },
    { start: 8118, length: 2, convRule: rule20 },
    { start: 8120, length: 2, convRule: rule144 },
    { start: 8122, length: 2, convRule: rule153 },
    { start: 8124, length: 1, convRule: rule154 },
    { start: 8125, length: 1, convRule: rule10 },
    { start: 8126, length: 1, convRule: rule155 },
    { start: 8127, length: 3, convRule: rule10 },
    { start: 8130, length: 1, convRule: rule20 },
    { start: 8131, length: 1, convRule: rule152 },
    { start: 8132, length: 1, convRule: rule20 },
    { start: 8134, length: 2, convRule: rule20 },
    { start: 8136, length: 4, convRule: rule156 },
    { start: 8140, length: 1, convRule: rule154 },
    { start: 8141, length: 3, convRule: rule10 },
    { start: 8144, length: 2, convRule: rule143 },
    { start: 8146, length: 2, convRule: rule20 },
    { start: 8150, length: 2, convRule: rule20 },
    { start: 8152, length: 2, convRule: rule144 },
    { start: 8154, length: 2, convRule: rule157 },
    { start: 8157, length: 3, convRule: rule10 },
    { start: 8160, length: 2, convRule: rule143 },
    { start: 8162, length: 3, convRule: rule20 },
    { start: 8165, length: 1, convRule: rule113 },
    { start: 8166, length: 2, convRule: rule20 },
    { start: 8168, length: 2, convRule: rule144 },
    { start: 8170, length: 2, convRule: rule158 },
    { start: 8172, length: 1, convRule: rule117 },
    { start: 8173, length: 3, convRule: rule10 },
    { start: 8178, length: 1, convRule: rule20 },
    { start: 8179, length: 1, convRule: rule152 },
    { start: 8180, length: 1, convRule: rule20 },
    { start: 8182, length: 2, convRule: rule20 },
    { start: 8184, length: 2, convRule: rule159 },
    { start: 8186, length: 2, convRule: rule160 },
    { start: 8188, length: 1, convRule: rule154 },
    { start: 8189, length: 2, convRule: rule10 },
    { start: 8192, length: 11, convRule: rule1 },
    { start: 8203, length: 5, convRule: rule16 },
    { start: 8208, length: 6, convRule: rule7 },
    { start: 8214, length: 2, convRule: rule2 },
    { start: 8216, length: 1, convRule: rule15 },
    { start: 8217, length: 1, convRule: rule19 },
    { start: 8218, length: 1, convRule: rule4 },
    { start: 8219, length: 2, convRule: rule15 },
    { start: 8221, length: 1, convRule: rule19 },
    { start: 8222, length: 1, convRule: rule4 },
    { start: 8223, length: 1, convRule: rule15 },
    { start: 8224, length: 8, convRule: rule2 },
    { start: 8232, length: 1, convRule: rule161 },
    { start: 8233, length: 1, convRule: rule162 },
    { start: 8234, length: 5, convRule: rule16 },
    { start: 8239, length: 1, convRule: rule1 },
    { start: 8240, length: 9, convRule: rule2 },
    { start: 8249, length: 1, convRule: rule15 },
    { start: 8250, length: 1, convRule: rule19 },
    { start: 8251, length: 4, convRule: rule2 },
    { start: 8255, length: 2, convRule: rule11 },
    { start: 8257, length: 3, convRule: rule2 },
    { start: 8260, length: 1, convRule: rule6 },
    { start: 8261, length: 1, convRule: rule4 },
    { start: 8262, length: 1, convRule: rule5 },
    { start: 8263, length: 11, convRule: rule2 },
    { start: 8274, length: 1, convRule: rule6 },
    { start: 8275, length: 1, convRule: rule2 },
    { start: 8276, length: 1, convRule: rule11 },
    { start: 8277, length: 10, convRule: rule2 },
    { start: 8287, length: 1, convRule: rule1 },
    { start: 8288, length: 5, convRule: rule16 },
    { start: 8294, length: 10, convRule: rule16 },
    { start: 8304, length: 1, convRule: rule17 },
    { start: 8305, length: 1, convRule: rule91 },
    { start: 8308, length: 6, convRule: rule17 },
    { start: 8314, length: 3, convRule: rule6 },
    { start: 8317, length: 1, convRule: rule4 },
    { start: 8318, length: 1, convRule: rule5 },
    { start: 8319, length: 1, convRule: rule91 },
    { start: 8320, length: 10, convRule: rule17 },
    { start: 8330, length: 3, convRule: rule6 },
    { start: 8333, length: 1, convRule: rule4 },
    { start: 8334, length: 1, convRule: rule5 },
    { start: 8336, length: 13, convRule: rule91 },
    { start: 8352, length: 32, convRule: rule3 },
    { start: 8400, length: 13, convRule: rule92 },
    { start: 8413, length: 4, convRule: rule119 },
    { start: 8417, length: 1, convRule: rule92 },
    { start: 8418, length: 3, convRule: rule119 },
    { start: 8421, length: 12, convRule: rule92 },
    { start: 8448, length: 2, convRule: rule13 },
    { start: 8450, length: 1, convRule: rule107 },
    { start: 8451, length: 4, convRule: rule13 },
    { start: 8455, length: 1, convRule: rule107 },
    { start: 8456, length: 2, convRule: rule13 },
    { start: 8458, length: 1, convRule: rule20 },
    { start: 8459, length: 3, convRule: rule107 },
    { start: 8462, length: 2, convRule: rule20 },
    { start: 8464, length: 3, convRule: rule107 },
    { start: 8467, length: 1, convRule: rule20 },
    { start: 8468, length: 1, convRule: rule13 },
    { start: 8469, length: 1, convRule: rule107 },
    { start: 8470, length: 2, convRule: rule13 },
    { start: 8472, length: 1, convRule: rule6 },
    { start: 8473, length: 5, convRule: rule107 },
    { start: 8478, length: 6, convRule: rule13 },
    { start: 8484, length: 1, convRule: rule107 },
    { start: 8485, length: 1, convRule: rule13 },
    { start: 8486, length: 1, convRule: rule163 },
    { start: 8487, length: 1, convRule: rule13 },
    { start: 8488, length: 1, convRule: rule107 },
    { start: 8489, length: 1, convRule: rule13 },
    { start: 8490, length: 1, convRule: rule164 },
    { start: 8491, length: 1, convRule: rule165 },
    { start: 8492, length: 2, convRule: rule107 },
    { start: 8494, length: 1, convRule: rule13 },
    { start: 8495, length: 1, convRule: rule20 },
    { start: 8496, length: 2, convRule: rule107 },
    { start: 8498, length: 1, convRule: rule166 },
    { start: 8499, length: 1, convRule: rule107 },
    { start: 8500, length: 1, convRule: rule20 },
    { start: 8501, length: 4, convRule: rule14 },
    { start: 8505, length: 1, convRule: rule20 },
    { start: 8506, length: 2, convRule: rule13 },
    { start: 8508, length: 2, convRule: rule20 },
    { start: 8510, length: 2, convRule: rule107 },
    { start: 8512, length: 5, convRule: rule6 },
    { start: 8517, length: 1, convRule: rule107 },
    { start: 8518, length: 4, convRule: rule20 },
    { start: 8522, length: 1, convRule: rule13 },
    { start: 8523, length: 1, convRule: rule6 },
    { start: 8524, length: 2, convRule: rule13 },
    { start: 8526, length: 1, convRule: rule167 },
    { start: 8527, length: 1, convRule: rule13 },
    { start: 8528, length: 16, convRule: rule17 },
    { start: 8544, length: 16, convRule: rule168 },
    { start: 8560, length: 16, convRule: rule169 },
    { start: 8576, length: 3, convRule: rule128 },
    { start: 8579, length: 1, convRule: rule22 },
    { start: 8580, length: 1, convRule: rule23 },
    { start: 8581, length: 4, convRule: rule128 },
    { start: 8585, length: 1, convRule: rule17 },
    { start: 8586, length: 2, convRule: rule13 },
    { start: 8592, length: 5, convRule: rule6 },
    { start: 8597, length: 5, convRule: rule13 },
    { start: 8602, length: 2, convRule: rule6 },
    { start: 8604, length: 4, convRule: rule13 },
    { start: 8608, length: 1, convRule: rule6 },
    { start: 8609, length: 2, convRule: rule13 },
    { start: 8611, length: 1, convRule: rule6 },
    { start: 8612, length: 2, convRule: rule13 },
    { start: 8614, length: 1, convRule: rule6 },
    { start: 8615, length: 7, convRule: rule13 },
    { start: 8622, length: 1, convRule: rule6 },
    { start: 8623, length: 31, convRule: rule13 },
    { start: 8654, length: 2, convRule: rule6 },
    { start: 8656, length: 2, convRule: rule13 },
    { start: 8658, length: 1, convRule: rule6 },
    { start: 8659, length: 1, convRule: rule13 },
    { start: 8660, length: 1, convRule: rule6 },
    { start: 8661, length: 31, convRule: rule13 },
    { start: 8692, length: 268, convRule: rule6 },
    { start: 8960, length: 8, convRule: rule13 },
    { start: 8968, length: 1, convRule: rule4 },
    { start: 8969, length: 1, convRule: rule5 },
    { start: 8970, length: 1, convRule: rule4 },
    { start: 8971, length: 1, convRule: rule5 },
    { start: 8972, length: 20, convRule: rule13 },
    { start: 8992, length: 2, convRule: rule6 },
    { start: 8994, length: 7, convRule: rule13 },
    { start: 9001, length: 1, convRule: rule4 },
    { start: 9002, length: 1, convRule: rule5 },
    { start: 9003, length: 81, convRule: rule13 },
    { start: 9084, length: 1, convRule: rule6 },
    { start: 9085, length: 30, convRule: rule13 },
    { start: 9115, length: 25, convRule: rule6 },
    { start: 9140, length: 40, convRule: rule13 },
    { start: 9180, length: 6, convRule: rule6 },
    { start: 9186, length: 69, convRule: rule13 },
    { start: 9280, length: 11, convRule: rule13 },
    { start: 9312, length: 60, convRule: rule17 },
    { start: 9372, length: 26, convRule: rule13 },
    { start: 9398, length: 26, convRule: rule170 },
    { start: 9424, length: 26, convRule: rule171 },
    { start: 9450, length: 22, convRule: rule17 },
    { start: 9472, length: 183, convRule: rule13 },
    { start: 9655, length: 1, convRule: rule6 },
    { start: 9656, length: 9, convRule: rule13 },
    { start: 9665, length: 1, convRule: rule6 },
    { start: 9666, length: 54, convRule: rule13 },
    { start: 9720, length: 8, convRule: rule6 },
    { start: 9728, length: 111, convRule: rule13 },
    { start: 9839, length: 1, convRule: rule6 },
    { start: 9840, length: 248, convRule: rule13 },
    { start: 10088, length: 1, convRule: rule4 },
    { start: 10089, length: 1, convRule: rule5 },
    { start: 10090, length: 1, convRule: rule4 },
    { start: 10091, length: 1, convRule: rule5 },
    { start: 10092, length: 1, convRule: rule4 },
    { start: 10093, length: 1, convRule: rule5 },
    { start: 10094, length: 1, convRule: rule4 },
    { start: 10095, length: 1, convRule: rule5 },
    { start: 10096, length: 1, convRule: rule4 },
    { start: 10097, length: 1, convRule: rule5 },
    { start: 10098, length: 1, convRule: rule4 },
    { start: 10099, length: 1, convRule: rule5 },
    { start: 10100, length: 1, convRule: rule4 },
    { start: 10101, length: 1, convRule: rule5 },
    { start: 10102, length: 30, convRule: rule17 },
    { start: 10132, length: 44, convRule: rule13 },
    { start: 10176, length: 5, convRule: rule6 },
    { start: 10181, length: 1, convRule: rule4 },
    { start: 10182, length: 1, convRule: rule5 },
    { start: 10183, length: 31, convRule: rule6 },
    { start: 10214, length: 1, convRule: rule4 },
    { start: 10215, length: 1, convRule: rule5 },
    { start: 10216, length: 1, convRule: rule4 },
    { start: 10217, length: 1, convRule: rule5 },
    { start: 10218, length: 1, convRule: rule4 },
    { start: 10219, length: 1, convRule: rule5 },
    { start: 10220, length: 1, convRule: rule4 },
    { start: 10221, length: 1, convRule: rule5 },
    { start: 10222, length: 1, convRule: rule4 },
    { start: 10223, length: 1, convRule: rule5 },
    { start: 10224, length: 16, convRule: rule6 },
    { start: 10240, length: 256, convRule: rule13 },
    { start: 10496, length: 131, convRule: rule6 },
    { start: 10627, length: 1, convRule: rule4 },
    { start: 10628, length: 1, convRule: rule5 },
    { start: 10629, length: 1, convRule: rule4 },
    { start: 10630, length: 1, convRule: rule5 },
    { start: 10631, length: 1, convRule: rule4 },
    { start: 10632, length: 1, convRule: rule5 },
    { start: 10633, length: 1, convRule: rule4 },
    { start: 10634, length: 1, convRule: rule5 },
    { start: 10635, length: 1, convRule: rule4 },
    { start: 10636, length: 1, convRule: rule5 },
    { start: 10637, length: 1, convRule: rule4 },
    { start: 10638, length: 1, convRule: rule5 },
    { start: 10639, length: 1, convRule: rule4 },
    { start: 10640, length: 1, convRule: rule5 },
    { start: 10641, length: 1, convRule: rule4 },
    { start: 10642, length: 1, convRule: rule5 },
    { start: 10643, length: 1, convRule: rule4 },
    { start: 10644, length: 1, convRule: rule5 },
    { start: 10645, length: 1, convRule: rule4 },
    { start: 10646, length: 1, convRule: rule5 },
    { start: 10647, length: 1, convRule: rule4 },
    { start: 10648, length: 1, convRule: rule5 },
    { start: 10649, length: 63, convRule: rule6 },
    { start: 10712, length: 1, convRule: rule4 },
    { start: 10713, length: 1, convRule: rule5 },
    { start: 10714, length: 1, convRule: rule4 },
    { start: 10715, length: 1, convRule: rule5 },
    { start: 10716, length: 32, convRule: rule6 },
    { start: 10748, length: 1, convRule: rule4 },
    { start: 10749, length: 1, convRule: rule5 },
    { start: 10750, length: 258, convRule: rule6 },
    { start: 11008, length: 48, convRule: rule13 },
    { start: 11056, length: 21, convRule: rule6 },
    { start: 11077, length: 2, convRule: rule13 },
    { start: 11079, length: 6, convRule: rule6 },
    { start: 11085, length: 39, convRule: rule13 },
    { start: 11126, length: 32, convRule: rule13 },
    { start: 11159, length: 105, convRule: rule13 },
    { start: 11264, length: 47, convRule: rule122 },
    { start: 11312, length: 47, convRule: rule123 },
    { start: 11360, length: 1, convRule: rule22 },
    { start: 11361, length: 1, convRule: rule23 },
    { start: 11362, length: 1, convRule: rule172 },
    { start: 11363, length: 1, convRule: rule173 },
    { start: 11364, length: 1, convRule: rule174 },
    { start: 11365, length: 1, convRule: rule175 },
    { start: 11366, length: 1, convRule: rule176 },
    { start: 11367, length: 1, convRule: rule22 },
    { start: 11368, length: 1, convRule: rule23 },
    { start: 11369, length: 1, convRule: rule22 },
    { start: 11370, length: 1, convRule: rule23 },
    { start: 11371, length: 1, convRule: rule22 },
    { start: 11372, length: 1, convRule: rule23 },
    { start: 11373, length: 1, convRule: rule177 },
    { start: 11374, length: 1, convRule: rule178 },
    { start: 11375, length: 1, convRule: rule179 },
    { start: 11376, length: 1, convRule: rule180 },
    { start: 11377, length: 1, convRule: rule20 },
    { start: 11378, length: 1, convRule: rule22 },
    { start: 11379, length: 1, convRule: rule23 },
    { start: 11380, length: 1, convRule: rule20 },
    { start: 11381, length: 1, convRule: rule22 },
    { start: 11382, length: 1, convRule: rule23 },
    { start: 11383, length: 5, convRule: rule20 },
    { start: 11388, length: 2, convRule: rule91 },
    { start: 11390, length: 2, convRule: rule181 },
    { start: 11392, length: 1, convRule: rule22 },
    { start: 11393, length: 1, convRule: rule23 },
    { start: 11394, length: 1, convRule: rule22 },
    { start: 11395, length: 1, convRule: rule23 },
    { start: 11396, length: 1, convRule: rule22 },
    { start: 11397, length: 1, convRule: rule23 },
    { start: 11398, length: 1, convRule: rule22 },
    { start: 11399, length: 1, convRule: rule23 },
    { start: 11400, length: 1, convRule: rule22 },
    { start: 11401, length: 1, convRule: rule23 },
    { start: 11402, length: 1, convRule: rule22 },
    { start: 11403, length: 1, convRule: rule23 },
    { start: 11404, length: 1, convRule: rule22 },
    { start: 11405, length: 1, convRule: rule23 },
    { start: 11406, length: 1, convRule: rule22 },
    { start: 11407, length: 1, convRule: rule23 },
    { start: 11408, length: 1, convRule: rule22 },
    { start: 11409, length: 1, convRule: rule23 },
    { start: 11410, length: 1, convRule: rule22 },
    { start: 11411, length: 1, convRule: rule23 },
    { start: 11412, length: 1, convRule: rule22 },
    { start: 11413, length: 1, convRule: rule23 },
    { start: 11414, length: 1, convRule: rule22 },
    { start: 11415, length: 1, convRule: rule23 },
    { start: 11416, length: 1, convRule: rule22 },
    { start: 11417, length: 1, convRule: rule23 },
    { start: 11418, length: 1, convRule: rule22 },
    { start: 11419, length: 1, convRule: rule23 },
    { start: 11420, length: 1, convRule: rule22 },
    { start: 11421, length: 1, convRule: rule23 },
    { start: 11422, length: 1, convRule: rule22 },
    { start: 11423, length: 1, convRule: rule23 },
    { start: 11424, length: 1, convRule: rule22 },
    { start: 11425, length: 1, convRule: rule23 },
    { start: 11426, length: 1, convRule: rule22 },
    { start: 11427, length: 1, convRule: rule23 },
    { start: 11428, length: 1, convRule: rule22 },
    { start: 11429, length: 1, convRule: rule23 },
    { start: 11430, length: 1, convRule: rule22 },
    { start: 11431, length: 1, convRule: rule23 },
    { start: 11432, length: 1, convRule: rule22 },
    { start: 11433, length: 1, convRule: rule23 },
    { start: 11434, length: 1, convRule: rule22 },
    { start: 11435, length: 1, convRule: rule23 },
    { start: 11436, length: 1, convRule: rule22 },
    { start: 11437, length: 1, convRule: rule23 },
    { start: 11438, length: 1, convRule: rule22 },
    { start: 11439, length: 1, convRule: rule23 },
    { start: 11440, length: 1, convRule: rule22 },
    { start: 11441, length: 1, convRule: rule23 },
    { start: 11442, length: 1, convRule: rule22 },
    { start: 11443, length: 1, convRule: rule23 },
    { start: 11444, length: 1, convRule: rule22 },
    { start: 11445, length: 1, convRule: rule23 },
    { start: 11446, length: 1, convRule: rule22 },
    { start: 11447, length: 1, convRule: rule23 },
    { start: 11448, length: 1, convRule: rule22 },
    { start: 11449, length: 1, convRule: rule23 },
    { start: 11450, length: 1, convRule: rule22 },
    { start: 11451, length: 1, convRule: rule23 },
    { start: 11452, length: 1, convRule: rule22 },
    { start: 11453, length: 1, convRule: rule23 },
    { start: 11454, length: 1, convRule: rule22 },
    { start: 11455, length: 1, convRule: rule23 },
    { start: 11456, length: 1, convRule: rule22 },
    { start: 11457, length: 1, convRule: rule23 },
    { start: 11458, length: 1, convRule: rule22 },
    { start: 11459, length: 1, convRule: rule23 },
    { start: 11460, length: 1, convRule: rule22 },
    { start: 11461, length: 1, convRule: rule23 },
    { start: 11462, length: 1, convRule: rule22 },
    { start: 11463, length: 1, convRule: rule23 },
    { start: 11464, length: 1, convRule: rule22 },
    { start: 11465, length: 1, convRule: rule23 },
    { start: 11466, length: 1, convRule: rule22 },
    { start: 11467, length: 1, convRule: rule23 },
    { start: 11468, length: 1, convRule: rule22 },
    { start: 11469, length: 1, convRule: rule23 },
    { start: 11470, length: 1, convRule: rule22 },
    { start: 11471, length: 1, convRule: rule23 },
    { start: 11472, length: 1, convRule: rule22 },
    { start: 11473, length: 1, convRule: rule23 },
    { start: 11474, length: 1, convRule: rule22 },
    { start: 11475, length: 1, convRule: rule23 },
    { start: 11476, length: 1, convRule: rule22 },
    { start: 11477, length: 1, convRule: rule23 },
    { start: 11478, length: 1, convRule: rule22 },
    { start: 11479, length: 1, convRule: rule23 },
    { start: 11480, length: 1, convRule: rule22 },
    { start: 11481, length: 1, convRule: rule23 },
    { start: 11482, length: 1, convRule: rule22 },
    { start: 11483, length: 1, convRule: rule23 },
    { start: 11484, length: 1, convRule: rule22 },
    { start: 11485, length: 1, convRule: rule23 },
    { start: 11486, length: 1, convRule: rule22 },
    { start: 11487, length: 1, convRule: rule23 },
    { start: 11488, length: 1, convRule: rule22 },
    { start: 11489, length: 1, convRule: rule23 },
    { start: 11490, length: 1, convRule: rule22 },
    { start: 11491, length: 1, convRule: rule23 },
    { start: 11492, length: 1, convRule: rule20 },
    { start: 11493, length: 6, convRule: rule13 },
    { start: 11499, length: 1, convRule: rule22 },
    { start: 11500, length: 1, convRule: rule23 },
    { start: 11501, length: 1, convRule: rule22 },
    { start: 11502, length: 1, convRule: rule23 },
    { start: 11503, length: 3, convRule: rule92 },
    { start: 11506, length: 1, convRule: rule22 },
    { start: 11507, length: 1, convRule: rule23 },
    { start: 11513, length: 4, convRule: rule2 },
    { start: 11517, length: 1, convRule: rule17 },
    { start: 11518, length: 2, convRule: rule2 },
    { start: 11520, length: 38, convRule: rule182 },
    { start: 11559, length: 1, convRule: rule182 },
    { start: 11565, length: 1, convRule: rule182 },
    { start: 11568, length: 56, convRule: rule14 },
    { start: 11631, length: 1, convRule: rule91 },
    { start: 11632, length: 1, convRule: rule2 },
    { start: 11647, length: 1, convRule: rule92 },
    { start: 11648, length: 23, convRule: rule14 },
    { start: 11680, length: 7, convRule: rule14 },
    { start: 11688, length: 7, convRule: rule14 },
    { start: 11696, length: 7, convRule: rule14 },
    { start: 11704, length: 7, convRule: rule14 },
    { start: 11712, length: 7, convRule: rule14 },
    { start: 11720, length: 7, convRule: rule14 },
    { start: 11728, length: 7, convRule: rule14 },
    { start: 11736, length: 7, convRule: rule14 },
    { start: 11744, length: 32, convRule: rule92 },
    { start: 11776, length: 2, convRule: rule2 },
    { start: 11778, length: 1, convRule: rule15 },
    { start: 11779, length: 1, convRule: rule19 },
    { start: 11780, length: 1, convRule: rule15 },
    { start: 11781, length: 1, convRule: rule19 },
    { start: 11782, length: 3, convRule: rule2 },
    { start: 11785, length: 1, convRule: rule15 },
    { start: 11786, length: 1, convRule: rule19 },
    { start: 11787, length: 1, convRule: rule2 },
    { start: 11788, length: 1, convRule: rule15 },
    { start: 11789, length: 1, convRule: rule19 },
    { start: 11790, length: 9, convRule: rule2 },
    { start: 11799, length: 1, convRule: rule7 },
    { start: 11800, length: 2, convRule: rule2 },
    { start: 11802, length: 1, convRule: rule7 },
    { start: 11803, length: 1, convRule: rule2 },
    { start: 11804, length: 1, convRule: rule15 },
    { start: 11805, length: 1, convRule: rule19 },
    { start: 11806, length: 2, convRule: rule2 },
    { start: 11808, length: 1, convRule: rule15 },
    { start: 11809, length: 1, convRule: rule19 },
    { start: 11810, length: 1, convRule: rule4 },
    { start: 11811, length: 1, convRule: rule5 },
    { start: 11812, length: 1, convRule: rule4 },
    { start: 11813, length: 1, convRule: rule5 },
    { start: 11814, length: 1, convRule: rule4 },
    { start: 11815, length: 1, convRule: rule5 },
    { start: 11816, length: 1, convRule: rule4 },
    { start: 11817, length: 1, convRule: rule5 },
    { start: 11818, length: 5, convRule: rule2 },
    { start: 11823, length: 1, convRule: rule91 },
    { start: 11824, length: 10, convRule: rule2 },
    { start: 11834, length: 2, convRule: rule7 },
    { start: 11836, length: 4, convRule: rule2 },
    { start: 11840, length: 1, convRule: rule7 },
    { start: 11841, length: 1, convRule: rule2 },
    { start: 11842, length: 1, convRule: rule4 },
    { start: 11843, length: 13, convRule: rule2 },
    { start: 11856, length: 2, convRule: rule13 },
    { start: 11858, length: 1, convRule: rule2 },
    { start: 11904, length: 26, convRule: rule13 },
    { start: 11931, length: 89, convRule: rule13 },
    { start: 12032, length: 214, convRule: rule13 },
    { start: 12272, length: 12, convRule: rule13 },
    { start: 12288, length: 1, convRule: rule1 },
    { start: 12289, length: 3, convRule: rule2 },
    { start: 12292, length: 1, convRule: rule13 },
    { start: 12293, length: 1, convRule: rule91 },
    { start: 12294, length: 1, convRule: rule14 },
    { start: 12295, length: 1, convRule: rule128 },
    { start: 12296, length: 1, convRule: rule4 },
    { start: 12297, length: 1, convRule: rule5 },
    { start: 12298, length: 1, convRule: rule4 },
    { start: 12299, length: 1, convRule: rule5 },
    { start: 12300, length: 1, convRule: rule4 },
    { start: 12301, length: 1, convRule: rule5 },
    { start: 12302, length: 1, convRule: rule4 },
    { start: 12303, length: 1, convRule: rule5 },
    { start: 12304, length: 1, convRule: rule4 },
    { start: 12305, length: 1, convRule: rule5 },
    { start: 12306, length: 2, convRule: rule13 },
    { start: 12308, length: 1, convRule: rule4 },
    { start: 12309, length: 1, convRule: rule5 },
    { start: 12310, length: 1, convRule: rule4 },
    { start: 12311, length: 1, convRule: rule5 },
    { start: 12312, length: 1, convRule: rule4 },
    { start: 12313, length: 1, convRule: rule5 },
    { start: 12314, length: 1, convRule: rule4 },
    { start: 12315, length: 1, convRule: rule5 },
    { start: 12316, length: 1, convRule: rule7 },
    { start: 12317, length: 1, convRule: rule4 },
    { start: 12318, length: 2, convRule: rule5 },
    { start: 12320, length: 1, convRule: rule13 },
    { start: 12321, length: 9, convRule: rule128 },
    { start: 12330, length: 4, convRule: rule92 },
    { start: 12334, length: 2, convRule: rule124 },
    { start: 12336, length: 1, convRule: rule7 },
    { start: 12337, length: 5, convRule: rule91 },
    { start: 12342, length: 2, convRule: rule13 },
    { start: 12344, length: 3, convRule: rule128 },
    { start: 12347, length: 1, convRule: rule91 },
    { start: 12348, length: 1, convRule: rule14 },
    { start: 12349, length: 1, convRule: rule2 },
    { start: 12350, length: 2, convRule: rule13 },
    { start: 12353, length: 86, convRule: rule14 },
    { start: 12441, length: 2, convRule: rule92 },
    { start: 12443, length: 2, convRule: rule10 },
    { start: 12445, length: 2, convRule: rule91 },
    { start: 12447, length: 1, convRule: rule14 },
    { start: 12448, length: 1, convRule: rule7 },
    { start: 12449, length: 90, convRule: rule14 },
    { start: 12539, length: 1, convRule: rule2 },
    { start: 12540, length: 3, convRule: rule91 },
    { start: 12543, length: 1, convRule: rule14 },
    { start: 12549, length: 43, convRule: rule14 },
    { start: 12593, length: 94, convRule: rule14 },
    { start: 12688, length: 2, convRule: rule13 },
    { start: 12690, length: 4, convRule: rule17 },
    { start: 12694, length: 10, convRule: rule13 },
    { start: 12704, length: 32, convRule: rule14 },
    { start: 12736, length: 36, convRule: rule13 },
    { start: 12784, length: 16, convRule: rule14 },
    { start: 12800, length: 31, convRule: rule13 },
    { start: 12832, length: 10, convRule: rule17 },
    { start: 12842, length: 30, convRule: rule13 },
    { start: 12872, length: 8, convRule: rule17 },
    { start: 12880, length: 1, convRule: rule13 },
    { start: 12881, length: 15, convRule: rule17 },
    { start: 12896, length: 32, convRule: rule13 },
    { start: 12928, length: 10, convRule: rule17 },
    { start: 12938, length: 39, convRule: rule13 },
    { start: 12977, length: 15, convRule: rule17 },
    { start: 12992, length: 320, convRule: rule13 },
    { start: 13312, length: 6592, convRule: rule14 },
    { start: 19904, length: 64, convRule: rule13 },
    { start: 19968, length: 20989, convRule: rule14 },
    { start: 40960, length: 21, convRule: rule14 },
    { start: 40981, length: 1, convRule: rule91 },
    { start: 40982, length: 1143, convRule: rule14 },
    { start: 42128, length: 55, convRule: rule13 },
    { start: 42192, length: 40, convRule: rule14 },
    { start: 42232, length: 6, convRule: rule91 },
    { start: 42238, length: 2, convRule: rule2 },
    { start: 42240, length: 268, convRule: rule14 },
    { start: 42508, length: 1, convRule: rule91 },
    { start: 42509, length: 3, convRule: rule2 },
    { start: 42512, length: 16, convRule: rule14 },
    { start: 42528, length: 10, convRule: rule8 },
    { start: 42538, length: 2, convRule: rule14 },
    { start: 42560, length: 1, convRule: rule22 },
    { start: 42561, length: 1, convRule: rule23 },
    { start: 42562, length: 1, convRule: rule22 },
    { start: 42563, length: 1, convRule: rule23 },
    { start: 42564, length: 1, convRule: rule22 },
    { start: 42565, length: 1, convRule: rule23 },
    { start: 42566, length: 1, convRule: rule22 },
    { start: 42567, length: 1, convRule: rule23 },
    { start: 42568, length: 1, convRule: rule22 },
    { start: 42569, length: 1, convRule: rule23 },
    { start: 42570, length: 1, convRule: rule22 },
    { start: 42571, length: 1, convRule: rule23 },
    { start: 42572, length: 1, convRule: rule22 },
    { start: 42573, length: 1, convRule: rule23 },
    { start: 42574, length: 1, convRule: rule22 },
    { start: 42575, length: 1, convRule: rule23 },
    { start: 42576, length: 1, convRule: rule22 },
    { start: 42577, length: 1, convRule: rule23 },
    { start: 42578, length: 1, convRule: rule22 },
    { start: 42579, length: 1, convRule: rule23 },
    { start: 42580, length: 1, convRule: rule22 },
    { start: 42581, length: 1, convRule: rule23 },
    { start: 42582, length: 1, convRule: rule22 },
    { start: 42583, length: 1, convRule: rule23 },
    { start: 42584, length: 1, convRule: rule22 },
    { start: 42585, length: 1, convRule: rule23 },
    { start: 42586, length: 1, convRule: rule22 },
    { start: 42587, length: 1, convRule: rule23 },
    { start: 42588, length: 1, convRule: rule22 },
    { start: 42589, length: 1, convRule: rule23 },
    { start: 42590, length: 1, convRule: rule22 },
    { start: 42591, length: 1, convRule: rule23 },
    { start: 42592, length: 1, convRule: rule22 },
    { start: 42593, length: 1, convRule: rule23 },
    { start: 42594, length: 1, convRule: rule22 },
    { start: 42595, length: 1, convRule: rule23 },
    { start: 42596, length: 1, convRule: rule22 },
    { start: 42597, length: 1, convRule: rule23 },
    { start: 42598, length: 1, convRule: rule22 },
    { start: 42599, length: 1, convRule: rule23 },
    { start: 42600, length: 1, convRule: rule22 },
    { start: 42601, length: 1, convRule: rule23 },
    { start: 42602, length: 1, convRule: rule22 },
    { start: 42603, length: 1, convRule: rule23 },
    { start: 42604, length: 1, convRule: rule22 },
    { start: 42605, length: 1, convRule: rule23 },
    { start: 42606, length: 1, convRule: rule14 },
    { start: 42607, length: 1, convRule: rule92 },
    { start: 42608, length: 3, convRule: rule119 },
    { start: 42611, length: 1, convRule: rule2 },
    { start: 42612, length: 10, convRule: rule92 },
    { start: 42622, length: 1, convRule: rule2 },
    { start: 42623, length: 1, convRule: rule91 },
    { start: 42624, length: 1, convRule: rule22 },
    { start: 42625, length: 1, convRule: rule23 },
    { start: 42626, length: 1, convRule: rule22 },
    { start: 42627, length: 1, convRule: rule23 },
    { start: 42628, length: 1, convRule: rule22 },
    { start: 42629, length: 1, convRule: rule23 },
    { start: 42630, length: 1, convRule: rule22 },
    { start: 42631, length: 1, convRule: rule23 },
    { start: 42632, length: 1, convRule: rule22 },
    { start: 42633, length: 1, convRule: rule23 },
    { start: 42634, length: 1, convRule: rule22 },
    { start: 42635, length: 1, convRule: rule23 },
    { start: 42636, length: 1, convRule: rule22 },
    { start: 42637, length: 1, convRule: rule23 },
    { start: 42638, length: 1, convRule: rule22 },
    { start: 42639, length: 1, convRule: rule23 },
    { start: 42640, length: 1, convRule: rule22 },
    { start: 42641, length: 1, convRule: rule23 },
    { start: 42642, length: 1, convRule: rule22 },
    { start: 42643, length: 1, convRule: rule23 },
    { start: 42644, length: 1, convRule: rule22 },
    { start: 42645, length: 1, convRule: rule23 },
    { start: 42646, length: 1, convRule: rule22 },
    { start: 42647, length: 1, convRule: rule23 },
    { start: 42648, length: 1, convRule: rule22 },
    { start: 42649, length: 1, convRule: rule23 },
    { start: 42650, length: 1, convRule: rule22 },
    { start: 42651, length: 1, convRule: rule23 },
    { start: 42652, length: 2, convRule: rule91 },
    { start: 42654, length: 2, convRule: rule92 },
    { start: 42656, length: 70, convRule: rule14 },
    { start: 42726, length: 10, convRule: rule128 },
    { start: 42736, length: 2, convRule: rule92 },
    { start: 42738, length: 6, convRule: rule2 },
    { start: 42752, length: 23, convRule: rule10 },
    { start: 42775, length: 9, convRule: rule91 },
    { start: 42784, length: 2, convRule: rule10 },
    { start: 42786, length: 1, convRule: rule22 },
    { start: 42787, length: 1, convRule: rule23 },
    { start: 42788, length: 1, convRule: rule22 },
    { start: 42789, length: 1, convRule: rule23 },
    { start: 42790, length: 1, convRule: rule22 },
    { start: 42791, length: 1, convRule: rule23 },
    { start: 42792, length: 1, convRule: rule22 },
    { start: 42793, length: 1, convRule: rule23 },
    { start: 42794, length: 1, convRule: rule22 },
    { start: 42795, length: 1, convRule: rule23 },
    { start: 42796, length: 1, convRule: rule22 },
    { start: 42797, length: 1, convRule: rule23 },
    { start: 42798, length: 1, convRule: rule22 },
    { start: 42799, length: 1, convRule: rule23 },
    { start: 42800, length: 2, convRule: rule20 },
    { start: 42802, length: 1, convRule: rule22 },
    { start: 42803, length: 1, convRule: rule23 },
    { start: 42804, length: 1, convRule: rule22 },
    { start: 42805, length: 1, convRule: rule23 },
    { start: 42806, length: 1, convRule: rule22 },
    { start: 42807, length: 1, convRule: rule23 },
    { start: 42808, length: 1, convRule: rule22 },
    { start: 42809, length: 1, convRule: rule23 },
    { start: 42810, length: 1, convRule: rule22 },
    { start: 42811, length: 1, convRule: rule23 },
    { start: 42812, length: 1, convRule: rule22 },
    { start: 42813, length: 1, convRule: rule23 },
    { start: 42814, length: 1, convRule: rule22 },
    { start: 42815, length: 1, convRule: rule23 },
    { start: 42816, length: 1, convRule: rule22 },
    { start: 42817, length: 1, convRule: rule23 },
    { start: 42818, length: 1, convRule: rule22 },
    { start: 42819, length: 1, convRule: rule23 },
    { start: 42820, length: 1, convRule: rule22 },
    { start: 42821, length: 1, convRule: rule23 },
    { start: 42822, length: 1, convRule: rule22 },
    { start: 42823, length: 1, convRule: rule23 },
    { start: 42824, length: 1, convRule: rule22 },
    { start: 42825, length: 1, convRule: rule23 },
    { start: 42826, length: 1, convRule: rule22 },
    { start: 42827, length: 1, convRule: rule23 },
    { start: 42828, length: 1, convRule: rule22 },
    { start: 42829, length: 1, convRule: rule23 },
    { start: 42830, length: 1, convRule: rule22 },
    { start: 42831, length: 1, convRule: rule23 },
    { start: 42832, length: 1, convRule: rule22 },
    { start: 42833, length: 1, convRule: rule23 },
    { start: 42834, length: 1, convRule: rule22 },
    { start: 42835, length: 1, convRule: rule23 },
    { start: 42836, length: 1, convRule: rule22 },
    { start: 42837, length: 1, convRule: rule23 },
    { start: 42838, length: 1, convRule: rule22 },
    { start: 42839, length: 1, convRule: rule23 },
    { start: 42840, length: 1, convRule: rule22 },
    { start: 42841, length: 1, convRule: rule23 },
    { start: 42842, length: 1, convRule: rule22 },
    { start: 42843, length: 1, convRule: rule23 },
    { start: 42844, length: 1, convRule: rule22 },
    { start: 42845, length: 1, convRule: rule23 },
    { start: 42846, length: 1, convRule: rule22 },
    { start: 42847, length: 1, convRule: rule23 },
    { start: 42848, length: 1, convRule: rule22 },
    { start: 42849, length: 1, convRule: rule23 },
    { start: 42850, length: 1, convRule: rule22 },
    { start: 42851, length: 1, convRule: rule23 },
    { start: 42852, length: 1, convRule: rule22 },
    { start: 42853, length: 1, convRule: rule23 },
    { start: 42854, length: 1, convRule: rule22 },
    { start: 42855, length: 1, convRule: rule23 },
    { start: 42856, length: 1, convRule: rule22 },
    { start: 42857, length: 1, convRule: rule23 },
    { start: 42858, length: 1, convRule: rule22 },
    { start: 42859, length: 1, convRule: rule23 },
    { start: 42860, length: 1, convRule: rule22 },
    { start: 42861, length: 1, convRule: rule23 },
    { start: 42862, length: 1, convRule: rule22 },
    { start: 42863, length: 1, convRule: rule23 },
    { start: 42864, length: 1, convRule: rule91 },
    { start: 42865, length: 8, convRule: rule20 },
    { start: 42873, length: 1, convRule: rule22 },
    { start: 42874, length: 1, convRule: rule23 },
    { start: 42875, length: 1, convRule: rule22 },
    { start: 42876, length: 1, convRule: rule23 },
    { start: 42877, length: 1, convRule: rule183 },
    { start: 42878, length: 1, convRule: rule22 },
    { start: 42879, length: 1, convRule: rule23 },
    { start: 42880, length: 1, convRule: rule22 },
    { start: 42881, length: 1, convRule: rule23 },
    { start: 42882, length: 1, convRule: rule22 },
    { start: 42883, length: 1, convRule: rule23 },
    { start: 42884, length: 1, convRule: rule22 },
    { start: 42885, length: 1, convRule: rule23 },
    { start: 42886, length: 1, convRule: rule22 },
    { start: 42887, length: 1, convRule: rule23 },
    { start: 42888, length: 1, convRule: rule91 },
    { start: 42889, length: 2, convRule: rule10 },
    { start: 42891, length: 1, convRule: rule22 },
    { start: 42892, length: 1, convRule: rule23 },
    { start: 42893, length: 1, convRule: rule184 },
    { start: 42894, length: 1, convRule: rule20 },
    { start: 42895, length: 1, convRule: rule14 },
    { start: 42896, length: 1, convRule: rule22 },
    { start: 42897, length: 1, convRule: rule23 },
    { start: 42898, length: 1, convRule: rule22 },
    { start: 42899, length: 1, convRule: rule23 },
    { start: 42900, length: 1, convRule: rule185 },
    { start: 42901, length: 1, convRule: rule20 },
    { start: 42902, length: 1, convRule: rule22 },
    { start: 42903, length: 1, convRule: rule23 },
    { start: 42904, length: 1, convRule: rule22 },
    { start: 42905, length: 1, convRule: rule23 },
    { start: 42906, length: 1, convRule: rule22 },
    { start: 42907, length: 1, convRule: rule23 },
    { start: 42908, length: 1, convRule: rule22 },
    { start: 42909, length: 1, convRule: rule23 },
    { start: 42910, length: 1, convRule: rule22 },
    { start: 42911, length: 1, convRule: rule23 },
    { start: 42912, length: 1, convRule: rule22 },
    { start: 42913, length: 1, convRule: rule23 },
    { start: 42914, length: 1, convRule: rule22 },
    { start: 42915, length: 1, convRule: rule23 },
    { start: 42916, length: 1, convRule: rule22 },
    { start: 42917, length: 1, convRule: rule23 },
    { start: 42918, length: 1, convRule: rule22 },
    { start: 42919, length: 1, convRule: rule23 },
    { start: 42920, length: 1, convRule: rule22 },
    { start: 42921, length: 1, convRule: rule23 },
    { start: 42922, length: 1, convRule: rule186 },
    { start: 42923, length: 1, convRule: rule187 },
    { start: 42924, length: 1, convRule: rule188 },
    { start: 42925, length: 1, convRule: rule189 },
    { start: 42926, length: 1, convRule: rule186 },
    { start: 42927, length: 1, convRule: rule20 },
    { start: 42928, length: 1, convRule: rule190 },
    { start: 42929, length: 1, convRule: rule191 },
    { start: 42930, length: 1, convRule: rule192 },
    { start: 42931, length: 1, convRule: rule193 },
    { start: 42932, length: 1, convRule: rule22 },
    { start: 42933, length: 1, convRule: rule23 },
    { start: 42934, length: 1, convRule: rule22 },
    { start: 42935, length: 1, convRule: rule23 },
    { start: 42936, length: 1, convRule: rule22 },
    { start: 42937, length: 1, convRule: rule23 },
    { start: 42938, length: 1, convRule: rule22 },
    { start: 42939, length: 1, convRule: rule23 },
    { start: 42940, length: 1, convRule: rule22 },
    { start: 42941, length: 1, convRule: rule23 },
    { start: 42942, length: 1, convRule: rule22 },
    { start: 42943, length: 1, convRule: rule23 },
    { start: 42946, length: 1, convRule: rule22 },
    { start: 42947, length: 1, convRule: rule23 },
    { start: 42948, length: 1, convRule: rule194 },
    { start: 42949, length: 1, convRule: rule195 },
    { start: 42950, length: 1, convRule: rule196 },
    { start: 42951, length: 1, convRule: rule22 },
    { start: 42952, length: 1, convRule: rule23 },
    { start: 42953, length: 1, convRule: rule22 },
    { start: 42954, length: 1, convRule: rule23 },
    { start: 42997, length: 1, convRule: rule22 },
    { start: 42998, length: 1, convRule: rule23 },
    { start: 42999, length: 1, convRule: rule14 },
    { start: 43e3, length: 2, convRule: rule91 },
    { start: 43002, length: 1, convRule: rule20 },
    { start: 43003, length: 7, convRule: rule14 },
    { start: 43010, length: 1, convRule: rule92 },
    { start: 43011, length: 3, convRule: rule14 },
    { start: 43014, length: 1, convRule: rule92 },
    { start: 43015, length: 4, convRule: rule14 },
    { start: 43019, length: 1, convRule: rule92 },
    { start: 43020, length: 23, convRule: rule14 },
    { start: 43043, length: 2, convRule: rule124 },
    { start: 43045, length: 2, convRule: rule92 },
    { start: 43047, length: 1, convRule: rule124 },
    { start: 43048, length: 4, convRule: rule13 },
    { start: 43052, length: 1, convRule: rule92 },
    { start: 43056, length: 6, convRule: rule17 },
    { start: 43062, length: 2, convRule: rule13 },
    { start: 43064, length: 1, convRule: rule3 },
    { start: 43065, length: 1, convRule: rule13 },
    { start: 43072, length: 52, convRule: rule14 },
    { start: 43124, length: 4, convRule: rule2 },
    { start: 43136, length: 2, convRule: rule124 },
    { start: 43138, length: 50, convRule: rule14 },
    { start: 43188, length: 16, convRule: rule124 },
    { start: 43204, length: 2, convRule: rule92 },
    { start: 43214, length: 2, convRule: rule2 },
    { start: 43216, length: 10, convRule: rule8 },
    { start: 43232, length: 18, convRule: rule92 },
    { start: 43250, length: 6, convRule: rule14 },
    { start: 43256, length: 3, convRule: rule2 },
    { start: 43259, length: 1, convRule: rule14 },
    { start: 43260, length: 1, convRule: rule2 },
    { start: 43261, length: 2, convRule: rule14 },
    { start: 43263, length: 1, convRule: rule92 },
    { start: 43264, length: 10, convRule: rule8 },
    { start: 43274, length: 28, convRule: rule14 },
    { start: 43302, length: 8, convRule: rule92 },
    { start: 43310, length: 2, convRule: rule2 },
    { start: 43312, length: 23, convRule: rule14 },
    { start: 43335, length: 11, convRule: rule92 },
    { start: 43346, length: 2, convRule: rule124 },
    { start: 43359, length: 1, convRule: rule2 },
    { start: 43360, length: 29, convRule: rule14 },
    { start: 43392, length: 3, convRule: rule92 },
    { start: 43395, length: 1, convRule: rule124 },
    { start: 43396, length: 47, convRule: rule14 },
    { start: 43443, length: 1, convRule: rule92 },
    { start: 43444, length: 2, convRule: rule124 },
    { start: 43446, length: 4, convRule: rule92 },
    { start: 43450, length: 2, convRule: rule124 },
    { start: 43452, length: 2, convRule: rule92 },
    { start: 43454, length: 3, convRule: rule124 },
    { start: 43457, length: 13, convRule: rule2 },
    { start: 43471, length: 1, convRule: rule91 },
    { start: 43472, length: 10, convRule: rule8 },
    { start: 43486, length: 2, convRule: rule2 },
    { start: 43488, length: 5, convRule: rule14 },
    { start: 43493, length: 1, convRule: rule92 },
    { start: 43494, length: 1, convRule: rule91 },
    { start: 43495, length: 9, convRule: rule14 },
    { start: 43504, length: 10, convRule: rule8 },
    { start: 43514, length: 5, convRule: rule14 },
    { start: 43520, length: 41, convRule: rule14 },
    { start: 43561, length: 6, convRule: rule92 },
    { start: 43567, length: 2, convRule: rule124 },
    { start: 43569, length: 2, convRule: rule92 },
    { start: 43571, length: 2, convRule: rule124 },
    { start: 43573, length: 2, convRule: rule92 },
    { start: 43584, length: 3, convRule: rule14 },
    { start: 43587, length: 1, convRule: rule92 },
    { start: 43588, length: 8, convRule: rule14 },
    { start: 43596, length: 1, convRule: rule92 },
    { start: 43597, length: 1, convRule: rule124 },
    { start: 43600, length: 10, convRule: rule8 },
    { start: 43612, length: 4, convRule: rule2 },
    { start: 43616, length: 16, convRule: rule14 },
    { start: 43632, length: 1, convRule: rule91 },
    { start: 43633, length: 6, convRule: rule14 },
    { start: 43639, length: 3, convRule: rule13 },
    { start: 43642, length: 1, convRule: rule14 },
    { start: 43643, length: 1, convRule: rule124 },
    { start: 43644, length: 1, convRule: rule92 },
    { start: 43645, length: 1, convRule: rule124 },
    { start: 43646, length: 50, convRule: rule14 },
    { start: 43696, length: 1, convRule: rule92 },
    { start: 43697, length: 1, convRule: rule14 },
    { start: 43698, length: 3, convRule: rule92 },
    { start: 43701, length: 2, convRule: rule14 },
    { start: 43703, length: 2, convRule: rule92 },
    { start: 43705, length: 5, convRule: rule14 },
    { start: 43710, length: 2, convRule: rule92 },
    { start: 43712, length: 1, convRule: rule14 },
    { start: 43713, length: 1, convRule: rule92 },
    { start: 43714, length: 1, convRule: rule14 },
    { start: 43739, length: 2, convRule: rule14 },
    { start: 43741, length: 1, convRule: rule91 },
    { start: 43742, length: 2, convRule: rule2 },
    { start: 43744, length: 11, convRule: rule14 },
    { start: 43755, length: 1, convRule: rule124 },
    { start: 43756, length: 2, convRule: rule92 },
    { start: 43758, length: 2, convRule: rule124 },
    { start: 43760, length: 2, convRule: rule2 },
    { start: 43762, length: 1, convRule: rule14 },
    { start: 43763, length: 2, convRule: rule91 },
    { start: 43765, length: 1, convRule: rule124 },
    { start: 43766, length: 1, convRule: rule92 },
    { start: 43777, length: 6, convRule: rule14 },
    { start: 43785, length: 6, convRule: rule14 },
    { start: 43793, length: 6, convRule: rule14 },
    { start: 43808, length: 7, convRule: rule14 },
    { start: 43816, length: 7, convRule: rule14 },
    { start: 43824, length: 35, convRule: rule20 },
    { start: 43859, length: 1, convRule: rule197 },
    { start: 43860, length: 7, convRule: rule20 },
    { start: 43867, length: 1, convRule: rule10 },
    { start: 43868, length: 4, convRule: rule91 },
    { start: 43872, length: 9, convRule: rule20 },
    { start: 43881, length: 1, convRule: rule91 },
    { start: 43882, length: 2, convRule: rule10 },
    { start: 43888, length: 80, convRule: rule198 },
    { start: 43968, length: 35, convRule: rule14 },
    { start: 44003, length: 2, convRule: rule124 },
    { start: 44005, length: 1, convRule: rule92 },
    { start: 44006, length: 2, convRule: rule124 },
    { start: 44008, length: 1, convRule: rule92 },
    { start: 44009, length: 2, convRule: rule124 },
    { start: 44011, length: 1, convRule: rule2 },
    { start: 44012, length: 1, convRule: rule124 },
    { start: 44013, length: 1, convRule: rule92 },
    { start: 44016, length: 10, convRule: rule8 },
    { start: 44032, length: 11172, convRule: rule14 },
    { start: 55216, length: 23, convRule: rule14 },
    { start: 55243, length: 49, convRule: rule14 },
    { start: 55296, length: 896, convRule: rule199 },
    { start: 56192, length: 128, convRule: rule199 },
    { start: 56320, length: 1024, convRule: rule199 },
    { start: 57344, length: 6400, convRule: rule200 },
    { start: 63744, length: 366, convRule: rule14 },
    { start: 64112, length: 106, convRule: rule14 },
    { start: 64256, length: 7, convRule: rule20 },
    { start: 64275, length: 5, convRule: rule20 },
    { start: 64285, length: 1, convRule: rule14 },
    { start: 64286, length: 1, convRule: rule92 },
    { start: 64287, length: 10, convRule: rule14 },
    { start: 64297, length: 1, convRule: rule6 },
    { start: 64298, length: 13, convRule: rule14 },
    { start: 64312, length: 5, convRule: rule14 },
    { start: 64318, length: 1, convRule: rule14 },
    { start: 64320, length: 2, convRule: rule14 },
    { start: 64323, length: 2, convRule: rule14 },
    { start: 64326, length: 108, convRule: rule14 },
    { start: 64434, length: 16, convRule: rule10 },
    { start: 64467, length: 363, convRule: rule14 },
    { start: 64830, length: 1, convRule: rule5 },
    { start: 64831, length: 1, convRule: rule4 },
    { start: 64848, length: 64, convRule: rule14 },
    { start: 64914, length: 54, convRule: rule14 },
    { start: 65008, length: 12, convRule: rule14 },
    { start: 65020, length: 1, convRule: rule3 },
    { start: 65021, length: 1, convRule: rule13 },
    { start: 65024, length: 16, convRule: rule92 },
    { start: 65040, length: 7, convRule: rule2 },
    { start: 65047, length: 1, convRule: rule4 },
    { start: 65048, length: 1, convRule: rule5 },
    { start: 65049, length: 1, convRule: rule2 },
    { start: 65056, length: 16, convRule: rule92 },
    { start: 65072, length: 1, convRule: rule2 },
    { start: 65073, length: 2, convRule: rule7 },
    { start: 65075, length: 2, convRule: rule11 },
    { start: 65077, length: 1, convRule: rule4 },
    { start: 65078, length: 1, convRule: rule5 },
    { start: 65079, length: 1, convRule: rule4 },
    { start: 65080, length: 1, convRule: rule5 },
    { start: 65081, length: 1, convRule: rule4 },
    { start: 65082, length: 1, convRule: rule5 },
    { start: 65083, length: 1, convRule: rule4 },
    { start: 65084, length: 1, convRule: rule5 },
    { start: 65085, length: 1, convRule: rule4 },
    { start: 65086, length: 1, convRule: rule5 },
    { start: 65087, length: 1, convRule: rule4 },
    { start: 65088, length: 1, convRule: rule5 },
    { start: 65089, length: 1, convRule: rule4 },
    { start: 65090, length: 1, convRule: rule5 },
    { start: 65091, length: 1, convRule: rule4 },
    { start: 65092, length: 1, convRule: rule5 },
    { start: 65093, length: 2, convRule: rule2 },
    { start: 65095, length: 1, convRule: rule4 },
    { start: 65096, length: 1, convRule: rule5 },
    { start: 65097, length: 4, convRule: rule2 },
    { start: 65101, length: 3, convRule: rule11 },
    { start: 65104, length: 3, convRule: rule2 },
    { start: 65108, length: 4, convRule: rule2 },
    { start: 65112, length: 1, convRule: rule7 },
    { start: 65113, length: 1, convRule: rule4 },
    { start: 65114, length: 1, convRule: rule5 },
    { start: 65115, length: 1, convRule: rule4 },
    { start: 65116, length: 1, convRule: rule5 },
    { start: 65117, length: 1, convRule: rule4 },
    { start: 65118, length: 1, convRule: rule5 },
    { start: 65119, length: 3, convRule: rule2 },
    { start: 65122, length: 1, convRule: rule6 },
    { start: 65123, length: 1, convRule: rule7 },
    { start: 65124, length: 3, convRule: rule6 },
    { start: 65128, length: 1, convRule: rule2 },
    { start: 65129, length: 1, convRule: rule3 },
    { start: 65130, length: 2, convRule: rule2 },
    { start: 65136, length: 5, convRule: rule14 },
    { start: 65142, length: 135, convRule: rule14 },
    { start: 65279, length: 1, convRule: rule16 },
    { start: 65281, length: 3, convRule: rule2 },
    { start: 65284, length: 1, convRule: rule3 },
    { start: 65285, length: 3, convRule: rule2 },
    { start: 65288, length: 1, convRule: rule4 },
    { start: 65289, length: 1, convRule: rule5 },
    { start: 65290, length: 1, convRule: rule2 },
    { start: 65291, length: 1, convRule: rule6 },
    { start: 65292, length: 1, convRule: rule2 },
    { start: 65293, length: 1, convRule: rule7 },
    { start: 65294, length: 2, convRule: rule2 },
    { start: 65296, length: 10, convRule: rule8 },
    { start: 65306, length: 2, convRule: rule2 },
    { start: 65308, length: 3, convRule: rule6 },
    { start: 65311, length: 2, convRule: rule2 },
    { start: 65313, length: 26, convRule: rule9 },
    { start: 65339, length: 1, convRule: rule4 },
    { start: 65340, length: 1, convRule: rule2 },
    { start: 65341, length: 1, convRule: rule5 },
    { start: 65342, length: 1, convRule: rule10 },
    { start: 65343, length: 1, convRule: rule11 },
    { start: 65344, length: 1, convRule: rule10 },
    { start: 65345, length: 26, convRule: rule12 },
    { start: 65371, length: 1, convRule: rule4 },
    { start: 65372, length: 1, convRule: rule6 },
    { start: 65373, length: 1, convRule: rule5 },
    { start: 65374, length: 1, convRule: rule6 },
    { start: 65375, length: 1, convRule: rule4 },
    { start: 65376, length: 1, convRule: rule5 },
    { start: 65377, length: 1, convRule: rule2 },
    { start: 65378, length: 1, convRule: rule4 },
    { start: 65379, length: 1, convRule: rule5 },
    { start: 65380, length: 2, convRule: rule2 },
    { start: 65382, length: 10, convRule: rule14 },
    { start: 65392, length: 1, convRule: rule91 },
    { start: 65393, length: 45, convRule: rule14 },
    { start: 65438, length: 2, convRule: rule91 },
    { start: 65440, length: 31, convRule: rule14 },
    { start: 65474, length: 6, convRule: rule14 },
    { start: 65482, length: 6, convRule: rule14 },
    { start: 65490, length: 6, convRule: rule14 },
    { start: 65498, length: 3, convRule: rule14 },
    { start: 65504, length: 2, convRule: rule3 },
    { start: 65506, length: 1, convRule: rule6 },
    { start: 65507, length: 1, convRule: rule10 },
    { start: 65508, length: 1, convRule: rule13 },
    { start: 65509, length: 2, convRule: rule3 },
    { start: 65512, length: 1, convRule: rule13 },
    { start: 65513, length: 4, convRule: rule6 },
    { start: 65517, length: 2, convRule: rule13 },
    { start: 65529, length: 3, convRule: rule16 },
    { start: 65532, length: 2, convRule: rule13 },
    { start: 65536, length: 12, convRule: rule14 },
    { start: 65549, length: 26, convRule: rule14 },
    { start: 65576, length: 19, convRule: rule14 },
    { start: 65596, length: 2, convRule: rule14 },
    { start: 65599, length: 15, convRule: rule14 },
    { start: 65616, length: 14, convRule: rule14 },
    { start: 65664, length: 123, convRule: rule14 },
    { start: 65792, length: 3, convRule: rule2 },
    { start: 65799, length: 45, convRule: rule17 },
    { start: 65847, length: 9, convRule: rule13 },
    { start: 65856, length: 53, convRule: rule128 },
    { start: 65909, length: 4, convRule: rule17 },
    { start: 65913, length: 17, convRule: rule13 },
    { start: 65930, length: 2, convRule: rule17 },
    { start: 65932, length: 3, convRule: rule13 },
    { start: 65936, length: 13, convRule: rule13 },
    { start: 65952, length: 1, convRule: rule13 },
    { start: 66e3, length: 45, convRule: rule13 },
    { start: 66045, length: 1, convRule: rule92 },
    { start: 66176, length: 29, convRule: rule14 },
    { start: 66208, length: 49, convRule: rule14 },
    { start: 66272, length: 1, convRule: rule92 },
    { start: 66273, length: 27, convRule: rule17 },
    { start: 66304, length: 32, convRule: rule14 },
    { start: 66336, length: 4, convRule: rule17 },
    { start: 66349, length: 20, convRule: rule14 },
    { start: 66369, length: 1, convRule: rule128 },
    { start: 66370, length: 8, convRule: rule14 },
    { start: 66378, length: 1, convRule: rule128 },
    { start: 66384, length: 38, convRule: rule14 },
    { start: 66422, length: 5, convRule: rule92 },
    { start: 66432, length: 30, convRule: rule14 },
    { start: 66463, length: 1, convRule: rule2 },
    { start: 66464, length: 36, convRule: rule14 },
    { start: 66504, length: 8, convRule: rule14 },
    { start: 66512, length: 1, convRule: rule2 },
    { start: 66513, length: 5, convRule: rule128 },
    { start: 66560, length: 40, convRule: rule201 },
    { start: 66600, length: 40, convRule: rule202 },
    { start: 66640, length: 78, convRule: rule14 },
    { start: 66720, length: 10, convRule: rule8 },
    { start: 66736, length: 36, convRule: rule201 },
    { start: 66776, length: 36, convRule: rule202 },
    { start: 66816, length: 40, convRule: rule14 },
    { start: 66864, length: 52, convRule: rule14 },
    { start: 66927, length: 1, convRule: rule2 },
    { start: 67072, length: 311, convRule: rule14 },
    { start: 67392, length: 22, convRule: rule14 },
    { start: 67424, length: 8, convRule: rule14 },
    { start: 67584, length: 6, convRule: rule14 },
    { start: 67592, length: 1, convRule: rule14 },
    { start: 67594, length: 44, convRule: rule14 },
    { start: 67639, length: 2, convRule: rule14 },
    { start: 67644, length: 1, convRule: rule14 },
    { start: 67647, length: 23, convRule: rule14 },
    { start: 67671, length: 1, convRule: rule2 },
    { start: 67672, length: 8, convRule: rule17 },
    { start: 67680, length: 23, convRule: rule14 },
    { start: 67703, length: 2, convRule: rule13 },
    { start: 67705, length: 7, convRule: rule17 },
    { start: 67712, length: 31, convRule: rule14 },
    { start: 67751, length: 9, convRule: rule17 },
    { start: 67808, length: 19, convRule: rule14 },
    { start: 67828, length: 2, convRule: rule14 },
    { start: 67835, length: 5, convRule: rule17 },
    { start: 67840, length: 22, convRule: rule14 },
    { start: 67862, length: 6, convRule: rule17 },
    { start: 67871, length: 1, convRule: rule2 },
    { start: 67872, length: 26, convRule: rule14 },
    { start: 67903, length: 1, convRule: rule2 },
    { start: 67968, length: 56, convRule: rule14 },
    { start: 68028, length: 2, convRule: rule17 },
    { start: 68030, length: 2, convRule: rule14 },
    { start: 68032, length: 16, convRule: rule17 },
    { start: 68050, length: 46, convRule: rule17 },
    { start: 68096, length: 1, convRule: rule14 },
    { start: 68097, length: 3, convRule: rule92 },
    { start: 68101, length: 2, convRule: rule92 },
    { start: 68108, length: 4, convRule: rule92 },
    { start: 68112, length: 4, convRule: rule14 },
    { start: 68117, length: 3, convRule: rule14 },
    { start: 68121, length: 29, convRule: rule14 },
    { start: 68152, length: 3, convRule: rule92 },
    { start: 68159, length: 1, convRule: rule92 },
    { start: 68160, length: 9, convRule: rule17 },
    { start: 68176, length: 9, convRule: rule2 },
    { start: 68192, length: 29, convRule: rule14 },
    { start: 68221, length: 2, convRule: rule17 },
    { start: 68223, length: 1, convRule: rule2 },
    { start: 68224, length: 29, convRule: rule14 },
    { start: 68253, length: 3, convRule: rule17 },
    { start: 68288, length: 8, convRule: rule14 },
    { start: 68296, length: 1, convRule: rule13 },
    { start: 68297, length: 28, convRule: rule14 },
    { start: 68325, length: 2, convRule: rule92 },
    { start: 68331, length: 5, convRule: rule17 },
    { start: 68336, length: 7, convRule: rule2 },
    { start: 68352, length: 54, convRule: rule14 },
    { start: 68409, length: 7, convRule: rule2 },
    { start: 68416, length: 22, convRule: rule14 },
    { start: 68440, length: 8, convRule: rule17 },
    { start: 68448, length: 19, convRule: rule14 },
    { start: 68472, length: 8, convRule: rule17 },
    { start: 68480, length: 18, convRule: rule14 },
    { start: 68505, length: 4, convRule: rule2 },
    { start: 68521, length: 7, convRule: rule17 },
    { start: 68608, length: 73, convRule: rule14 },
    { start: 68736, length: 51, convRule: rule97 },
    { start: 68800, length: 51, convRule: rule102 },
    { start: 68858, length: 6, convRule: rule17 },
    { start: 68864, length: 36, convRule: rule14 },
    { start: 68900, length: 4, convRule: rule92 },
    { start: 68912, length: 10, convRule: rule8 },
    { start: 69216, length: 31, convRule: rule17 },
    { start: 69248, length: 42, convRule: rule14 },
    { start: 69291, length: 2, convRule: rule92 },
    { start: 69293, length: 1, convRule: rule7 },
    { start: 69296, length: 2, convRule: rule14 },
    { start: 69376, length: 29, convRule: rule14 },
    { start: 69405, length: 10, convRule: rule17 },
    { start: 69415, length: 1, convRule: rule14 },
    { start: 69424, length: 22, convRule: rule14 },
    { start: 69446, length: 11, convRule: rule92 },
    { start: 69457, length: 4, convRule: rule17 },
    { start: 69461, length: 5, convRule: rule2 },
    { start: 69552, length: 21, convRule: rule14 },
    { start: 69573, length: 7, convRule: rule17 },
    { start: 69600, length: 23, convRule: rule14 },
    { start: 69632, length: 1, convRule: rule124 },
    { start: 69633, length: 1, convRule: rule92 },
    { start: 69634, length: 1, convRule: rule124 },
    { start: 69635, length: 53, convRule: rule14 },
    { start: 69688, length: 15, convRule: rule92 },
    { start: 69703, length: 7, convRule: rule2 },
    { start: 69714, length: 20, convRule: rule17 },
    { start: 69734, length: 10, convRule: rule8 },
    { start: 69759, length: 3, convRule: rule92 },
    { start: 69762, length: 1, convRule: rule124 },
    { start: 69763, length: 45, convRule: rule14 },
    { start: 69808, length: 3, convRule: rule124 },
    { start: 69811, length: 4, convRule: rule92 },
    { start: 69815, length: 2, convRule: rule124 },
    { start: 69817, length: 2, convRule: rule92 },
    { start: 69819, length: 2, convRule: rule2 },
    { start: 69821, length: 1, convRule: rule16 },
    { start: 69822, length: 4, convRule: rule2 },
    { start: 69837, length: 1, convRule: rule16 },
    { start: 69840, length: 25, convRule: rule14 },
    { start: 69872, length: 10, convRule: rule8 },
    { start: 69888, length: 3, convRule: rule92 },
    { start: 69891, length: 36, convRule: rule14 },
    { start: 69927, length: 5, convRule: rule92 },
    { start: 69932, length: 1, convRule: rule124 },
    { start: 69933, length: 8, convRule: rule92 },
    { start: 69942, length: 10, convRule: rule8 },
    { start: 69952, length: 4, convRule: rule2 },
    { start: 69956, length: 1, convRule: rule14 },
    { start: 69957, length: 2, convRule: rule124 },
    { start: 69959, length: 1, convRule: rule14 },
    { start: 69968, length: 35, convRule: rule14 },
    { start: 70003, length: 1, convRule: rule92 },
    { start: 70004, length: 2, convRule: rule2 },
    { start: 70006, length: 1, convRule: rule14 },
    { start: 70016, length: 2, convRule: rule92 },
    { start: 70018, length: 1, convRule: rule124 },
    { start: 70019, length: 48, convRule: rule14 },
    { start: 70067, length: 3, convRule: rule124 },
    { start: 70070, length: 9, convRule: rule92 },
    { start: 70079, length: 2, convRule: rule124 },
    { start: 70081, length: 4, convRule: rule14 },
    { start: 70085, length: 4, convRule: rule2 },
    { start: 70089, length: 4, convRule: rule92 },
    { start: 70093, length: 1, convRule: rule2 },
    { start: 70094, length: 1, convRule: rule124 },
    { start: 70095, length: 1, convRule: rule92 },
    { start: 70096, length: 10, convRule: rule8 },
    { start: 70106, length: 1, convRule: rule14 },
    { start: 70107, length: 1, convRule: rule2 },
    { start: 70108, length: 1, convRule: rule14 },
    { start: 70109, length: 3, convRule: rule2 },
    { start: 70113, length: 20, convRule: rule17 },
    { start: 70144, length: 18, convRule: rule14 },
    { start: 70163, length: 25, convRule: rule14 },
    { start: 70188, length: 3, convRule: rule124 },
    { start: 70191, length: 3, convRule: rule92 },
    { start: 70194, length: 2, convRule: rule124 },
    { start: 70196, length: 1, convRule: rule92 },
    { start: 70197, length: 1, convRule: rule124 },
    { start: 70198, length: 2, convRule: rule92 },
    { start: 70200, length: 6, convRule: rule2 },
    { start: 70206, length: 1, convRule: rule92 },
    { start: 70272, length: 7, convRule: rule14 },
    { start: 70280, length: 1, convRule: rule14 },
    { start: 70282, length: 4, convRule: rule14 },
    { start: 70287, length: 15, convRule: rule14 },
    { start: 70303, length: 10, convRule: rule14 },
    { start: 70313, length: 1, convRule: rule2 },
    { start: 70320, length: 47, convRule: rule14 },
    { start: 70367, length: 1, convRule: rule92 },
    { start: 70368, length: 3, convRule: rule124 },
    { start: 70371, length: 8, convRule: rule92 },
    { start: 70384, length: 10, convRule: rule8 },
    { start: 70400, length: 2, convRule: rule92 },
    { start: 70402, length: 2, convRule: rule124 },
    { start: 70405, length: 8, convRule: rule14 },
    { start: 70415, length: 2, convRule: rule14 },
    { start: 70419, length: 22, convRule: rule14 },
    { start: 70442, length: 7, convRule: rule14 },
    { start: 70450, length: 2, convRule: rule14 },
    { start: 70453, length: 5, convRule: rule14 },
    { start: 70459, length: 2, convRule: rule92 },
    { start: 70461, length: 1, convRule: rule14 },
    { start: 70462, length: 2, convRule: rule124 },
    { start: 70464, length: 1, convRule: rule92 },
    { start: 70465, length: 4, convRule: rule124 },
    { start: 70471, length: 2, convRule: rule124 },
    { start: 70475, length: 3, convRule: rule124 },
    { start: 70480, length: 1, convRule: rule14 },
    { start: 70487, length: 1, convRule: rule124 },
    { start: 70493, length: 5, convRule: rule14 },
    { start: 70498, length: 2, convRule: rule124 },
    { start: 70502, length: 7, convRule: rule92 },
    { start: 70512, length: 5, convRule: rule92 },
    { start: 70656, length: 53, convRule: rule14 },
    { start: 70709, length: 3, convRule: rule124 },
    { start: 70712, length: 8, convRule: rule92 },
    { start: 70720, length: 2, convRule: rule124 },
    { start: 70722, length: 3, convRule: rule92 },
    { start: 70725, length: 1, convRule: rule124 },
    { start: 70726, length: 1, convRule: rule92 },
    { start: 70727, length: 4, convRule: rule14 },
    { start: 70731, length: 5, convRule: rule2 },
    { start: 70736, length: 10, convRule: rule8 },
    { start: 70746, length: 2, convRule: rule2 },
    { start: 70749, length: 1, convRule: rule2 },
    { start: 70750, length: 1, convRule: rule92 },
    { start: 70751, length: 3, convRule: rule14 },
    { start: 70784, length: 48, convRule: rule14 },
    { start: 70832, length: 3, convRule: rule124 },
    { start: 70835, length: 6, convRule: rule92 },
    { start: 70841, length: 1, convRule: rule124 },
    { start: 70842, length: 1, convRule: rule92 },
    { start: 70843, length: 4, convRule: rule124 },
    { start: 70847, length: 2, convRule: rule92 },
    { start: 70849, length: 1, convRule: rule124 },
    { start: 70850, length: 2, convRule: rule92 },
    { start: 70852, length: 2, convRule: rule14 },
    { start: 70854, length: 1, convRule: rule2 },
    { start: 70855, length: 1, convRule: rule14 },
    { start: 70864, length: 10, convRule: rule8 },
    { start: 71040, length: 47, convRule: rule14 },
    { start: 71087, length: 3, convRule: rule124 },
    { start: 71090, length: 4, convRule: rule92 },
    { start: 71096, length: 4, convRule: rule124 },
    { start: 71100, length: 2, convRule: rule92 },
    { start: 71102, length: 1, convRule: rule124 },
    { start: 71103, length: 2, convRule: rule92 },
    { start: 71105, length: 23, convRule: rule2 },
    { start: 71128, length: 4, convRule: rule14 },
    { start: 71132, length: 2, convRule: rule92 },
    { start: 71168, length: 48, convRule: rule14 },
    { start: 71216, length: 3, convRule: rule124 },
    { start: 71219, length: 8, convRule: rule92 },
    { start: 71227, length: 2, convRule: rule124 },
    { start: 71229, length: 1, convRule: rule92 },
    { start: 71230, length: 1, convRule: rule124 },
    { start: 71231, length: 2, convRule: rule92 },
    { start: 71233, length: 3, convRule: rule2 },
    { start: 71236, length: 1, convRule: rule14 },
    { start: 71248, length: 10, convRule: rule8 },
    { start: 71264, length: 13, convRule: rule2 },
    { start: 71296, length: 43, convRule: rule14 },
    { start: 71339, length: 1, convRule: rule92 },
    { start: 71340, length: 1, convRule: rule124 },
    { start: 71341, length: 1, convRule: rule92 },
    { start: 71342, length: 2, convRule: rule124 },
    { start: 71344, length: 6, convRule: rule92 },
    { start: 71350, length: 1, convRule: rule124 },
    { start: 71351, length: 1, convRule: rule92 },
    { start: 71352, length: 1, convRule: rule14 },
    { start: 71360, length: 10, convRule: rule8 },
    { start: 71424, length: 27, convRule: rule14 },
    { start: 71453, length: 3, convRule: rule92 },
    { start: 71456, length: 2, convRule: rule124 },
    { start: 71458, length: 4, convRule: rule92 },
    { start: 71462, length: 1, convRule: rule124 },
    { start: 71463, length: 5, convRule: rule92 },
    { start: 71472, length: 10, convRule: rule8 },
    { start: 71482, length: 2, convRule: rule17 },
    { start: 71484, length: 3, convRule: rule2 },
    { start: 71487, length: 1, convRule: rule13 },
    { start: 71680, length: 44, convRule: rule14 },
    { start: 71724, length: 3, convRule: rule124 },
    { start: 71727, length: 9, convRule: rule92 },
    { start: 71736, length: 1, convRule: rule124 },
    { start: 71737, length: 2, convRule: rule92 },
    { start: 71739, length: 1, convRule: rule2 },
    { start: 71840, length: 32, convRule: rule9 },
    { start: 71872, length: 32, convRule: rule12 },
    { start: 71904, length: 10, convRule: rule8 },
    { start: 71914, length: 9, convRule: rule17 },
    { start: 71935, length: 8, convRule: rule14 },
    { start: 71945, length: 1, convRule: rule14 },
    { start: 71948, length: 8, convRule: rule14 },
    { start: 71957, length: 2, convRule: rule14 },
    { start: 71960, length: 24, convRule: rule14 },
    { start: 71984, length: 6, convRule: rule124 },
    { start: 71991, length: 2, convRule: rule124 },
    { start: 71995, length: 2, convRule: rule92 },
    { start: 71997, length: 1, convRule: rule124 },
    { start: 71998, length: 1, convRule: rule92 },
    { start: 71999, length: 1, convRule: rule14 },
    { start: 72e3, length: 1, convRule: rule124 },
    { start: 72001, length: 1, convRule: rule14 },
    { start: 72002, length: 1, convRule: rule124 },
    { start: 72003, length: 1, convRule: rule92 },
    { start: 72004, length: 3, convRule: rule2 },
    { start: 72016, length: 10, convRule: rule8 },
    { start: 72096, length: 8, convRule: rule14 },
    { start: 72106, length: 39, convRule: rule14 },
    { start: 72145, length: 3, convRule: rule124 },
    { start: 72148, length: 4, convRule: rule92 },
    { start: 72154, length: 2, convRule: rule92 },
    { start: 72156, length: 4, convRule: rule124 },
    { start: 72160, length: 1, convRule: rule92 },
    { start: 72161, length: 1, convRule: rule14 },
    { start: 72162, length: 1, convRule: rule2 },
    { start: 72163, length: 1, convRule: rule14 },
    { start: 72164, length: 1, convRule: rule124 },
    { start: 72192, length: 1, convRule: rule14 },
    { start: 72193, length: 10, convRule: rule92 },
    { start: 72203, length: 40, convRule: rule14 },
    { start: 72243, length: 6, convRule: rule92 },
    { start: 72249, length: 1, convRule: rule124 },
    { start: 72250, length: 1, convRule: rule14 },
    { start: 72251, length: 4, convRule: rule92 },
    { start: 72255, length: 8, convRule: rule2 },
    { start: 72263, length: 1, convRule: rule92 },
    { start: 72272, length: 1, convRule: rule14 },
    { start: 72273, length: 6, convRule: rule92 },
    { start: 72279, length: 2, convRule: rule124 },
    { start: 72281, length: 3, convRule: rule92 },
    { start: 72284, length: 46, convRule: rule14 },
    { start: 72330, length: 13, convRule: rule92 },
    { start: 72343, length: 1, convRule: rule124 },
    { start: 72344, length: 2, convRule: rule92 },
    { start: 72346, length: 3, convRule: rule2 },
    { start: 72349, length: 1, convRule: rule14 },
    { start: 72350, length: 5, convRule: rule2 },
    { start: 72384, length: 57, convRule: rule14 },
    { start: 72704, length: 9, convRule: rule14 },
    { start: 72714, length: 37, convRule: rule14 },
    { start: 72751, length: 1, convRule: rule124 },
    { start: 72752, length: 7, convRule: rule92 },
    { start: 72760, length: 6, convRule: rule92 },
    { start: 72766, length: 1, convRule: rule124 },
    { start: 72767, length: 1, convRule: rule92 },
    { start: 72768, length: 1, convRule: rule14 },
    { start: 72769, length: 5, convRule: rule2 },
    { start: 72784, length: 10, convRule: rule8 },
    { start: 72794, length: 19, convRule: rule17 },
    { start: 72816, length: 2, convRule: rule2 },
    { start: 72818, length: 30, convRule: rule14 },
    { start: 72850, length: 22, convRule: rule92 },
    { start: 72873, length: 1, convRule: rule124 },
    { start: 72874, length: 7, convRule: rule92 },
    { start: 72881, length: 1, convRule: rule124 },
    { start: 72882, length: 2, convRule: rule92 },
    { start: 72884, length: 1, convRule: rule124 },
    { start: 72885, length: 2, convRule: rule92 },
    { start: 72960, length: 7, convRule: rule14 },
    { start: 72968, length: 2, convRule: rule14 },
    { start: 72971, length: 38, convRule: rule14 },
    { start: 73009, length: 6, convRule: rule92 },
    { start: 73018, length: 1, convRule: rule92 },
    { start: 73020, length: 2, convRule: rule92 },
    { start: 73023, length: 7, convRule: rule92 },
    { start: 73030, length: 1, convRule: rule14 },
    { start: 73031, length: 1, convRule: rule92 },
    { start: 73040, length: 10, convRule: rule8 },
    { start: 73056, length: 6, convRule: rule14 },
    { start: 73063, length: 2, convRule: rule14 },
    { start: 73066, length: 32, convRule: rule14 },
    { start: 73098, length: 5, convRule: rule124 },
    { start: 73104, length: 2, convRule: rule92 },
    { start: 73107, length: 2, convRule: rule124 },
    { start: 73109, length: 1, convRule: rule92 },
    { start: 73110, length: 1, convRule: rule124 },
    { start: 73111, length: 1, convRule: rule92 },
    { start: 73112, length: 1, convRule: rule14 },
    { start: 73120, length: 10, convRule: rule8 },
    { start: 73440, length: 19, convRule: rule14 },
    { start: 73459, length: 2, convRule: rule92 },
    { start: 73461, length: 2, convRule: rule124 },
    { start: 73463, length: 2, convRule: rule2 },
    { start: 73648, length: 1, convRule: rule14 },
    { start: 73664, length: 21, convRule: rule17 },
    { start: 73685, length: 8, convRule: rule13 },
    { start: 73693, length: 4, convRule: rule3 },
    { start: 73697, length: 17, convRule: rule13 },
    { start: 73727, length: 1, convRule: rule2 },
    { start: 73728, length: 922, convRule: rule14 },
    { start: 74752, length: 111, convRule: rule128 },
    { start: 74864, length: 5, convRule: rule2 },
    { start: 74880, length: 196, convRule: rule14 },
    { start: 77824, length: 1071, convRule: rule14 },
    { start: 78896, length: 9, convRule: rule16 },
    { start: 82944, length: 583, convRule: rule14 },
    { start: 92160, length: 569, convRule: rule14 },
    { start: 92736, length: 31, convRule: rule14 },
    { start: 92768, length: 10, convRule: rule8 },
    { start: 92782, length: 2, convRule: rule2 },
    { start: 92880, length: 30, convRule: rule14 },
    { start: 92912, length: 5, convRule: rule92 },
    { start: 92917, length: 1, convRule: rule2 },
    { start: 92928, length: 48, convRule: rule14 },
    { start: 92976, length: 7, convRule: rule92 },
    { start: 92983, length: 5, convRule: rule2 },
    { start: 92988, length: 4, convRule: rule13 },
    { start: 92992, length: 4, convRule: rule91 },
    { start: 92996, length: 1, convRule: rule2 },
    { start: 92997, length: 1, convRule: rule13 },
    { start: 93008, length: 10, convRule: rule8 },
    { start: 93019, length: 7, convRule: rule17 },
    { start: 93027, length: 21, convRule: rule14 },
    { start: 93053, length: 19, convRule: rule14 },
    { start: 93760, length: 32, convRule: rule9 },
    { start: 93792, length: 32, convRule: rule12 },
    { start: 93824, length: 23, convRule: rule17 },
    { start: 93847, length: 4, convRule: rule2 },
    { start: 93952, length: 75, convRule: rule14 },
    { start: 94031, length: 1, convRule: rule92 },
    { start: 94032, length: 1, convRule: rule14 },
    { start: 94033, length: 55, convRule: rule124 },
    { start: 94095, length: 4, convRule: rule92 },
    { start: 94099, length: 13, convRule: rule91 },
    { start: 94176, length: 2, convRule: rule91 },
    { start: 94178, length: 1, convRule: rule2 },
    { start: 94179, length: 1, convRule: rule91 },
    { start: 94180, length: 1, convRule: rule92 },
    { start: 94192, length: 2, convRule: rule124 },
    { start: 94208, length: 6136, convRule: rule14 },
    { start: 100352, length: 1238, convRule: rule14 },
    { start: 101632, length: 9, convRule: rule14 },
    { start: 110592, length: 287, convRule: rule14 },
    { start: 110928, length: 3, convRule: rule14 },
    { start: 110948, length: 4, convRule: rule14 },
    { start: 110960, length: 396, convRule: rule14 },
    { start: 113664, length: 107, convRule: rule14 },
    { start: 113776, length: 13, convRule: rule14 },
    { start: 113792, length: 9, convRule: rule14 },
    { start: 113808, length: 10, convRule: rule14 },
    { start: 113820, length: 1, convRule: rule13 },
    { start: 113821, length: 2, convRule: rule92 },
    { start: 113823, length: 1, convRule: rule2 },
    { start: 113824, length: 4, convRule: rule16 },
    { start: 118784, length: 246, convRule: rule13 },
    { start: 119040, length: 39, convRule: rule13 },
    { start: 119081, length: 60, convRule: rule13 },
    { start: 119141, length: 2, convRule: rule124 },
    { start: 119143, length: 3, convRule: rule92 },
    { start: 119146, length: 3, convRule: rule13 },
    { start: 119149, length: 6, convRule: rule124 },
    { start: 119155, length: 8, convRule: rule16 },
    { start: 119163, length: 8, convRule: rule92 },
    { start: 119171, length: 2, convRule: rule13 },
    { start: 119173, length: 7, convRule: rule92 },
    { start: 119180, length: 30, convRule: rule13 },
    { start: 119210, length: 4, convRule: rule92 },
    { start: 119214, length: 59, convRule: rule13 },
    { start: 119296, length: 66, convRule: rule13 },
    { start: 119362, length: 3, convRule: rule92 },
    { start: 119365, length: 1, convRule: rule13 },
    { start: 119520, length: 20, convRule: rule17 },
    { start: 119552, length: 87, convRule: rule13 },
    { start: 119648, length: 25, convRule: rule17 },
    { start: 119808, length: 26, convRule: rule107 },
    { start: 119834, length: 26, convRule: rule20 },
    { start: 119860, length: 26, convRule: rule107 },
    { start: 119886, length: 7, convRule: rule20 },
    { start: 119894, length: 18, convRule: rule20 },
    { start: 119912, length: 26, convRule: rule107 },
    { start: 119938, length: 26, convRule: rule20 },
    { start: 119964, length: 1, convRule: rule107 },
    { start: 119966, length: 2, convRule: rule107 },
    { start: 119970, length: 1, convRule: rule107 },
    { start: 119973, length: 2, convRule: rule107 },
    { start: 119977, length: 4, convRule: rule107 },
    { start: 119982, length: 8, convRule: rule107 },
    { start: 119990, length: 4, convRule: rule20 },
    { start: 119995, length: 1, convRule: rule20 },
    { start: 119997, length: 7, convRule: rule20 },
    { start: 120005, length: 11, convRule: rule20 },
    { start: 120016, length: 26, convRule: rule107 },
    { start: 120042, length: 26, convRule: rule20 },
    { start: 120068, length: 2, convRule: rule107 },
    { start: 120071, length: 4, convRule: rule107 },
    { start: 120077, length: 8, convRule: rule107 },
    { start: 120086, length: 7, convRule: rule107 },
    { start: 120094, length: 26, convRule: rule20 },
    { start: 120120, length: 2, convRule: rule107 },
    { start: 120123, length: 4, convRule: rule107 },
    { start: 120128, length: 5, convRule: rule107 },
    { start: 120134, length: 1, convRule: rule107 },
    { start: 120138, length: 7, convRule: rule107 },
    { start: 120146, length: 26, convRule: rule20 },
    { start: 120172, length: 26, convRule: rule107 },
    { start: 120198, length: 26, convRule: rule20 },
    { start: 120224, length: 26, convRule: rule107 },
    { start: 120250, length: 26, convRule: rule20 },
    { start: 120276, length: 26, convRule: rule107 },
    { start: 120302, length: 26, convRule: rule20 },
    { start: 120328, length: 26, convRule: rule107 },
    { start: 120354, length: 26, convRule: rule20 },
    { start: 120380, length: 26, convRule: rule107 },
    { start: 120406, length: 26, convRule: rule20 },
    { start: 120432, length: 26, convRule: rule107 },
    { start: 120458, length: 28, convRule: rule20 },
    { start: 120488, length: 25, convRule: rule107 },
    { start: 120513, length: 1, convRule: rule6 },
    { start: 120514, length: 25, convRule: rule20 },
    { start: 120539, length: 1, convRule: rule6 },
    { start: 120540, length: 6, convRule: rule20 },
    { start: 120546, length: 25, convRule: rule107 },
    { start: 120571, length: 1, convRule: rule6 },
    { start: 120572, length: 25, convRule: rule20 },
    { start: 120597, length: 1, convRule: rule6 },
    { start: 120598, length: 6, convRule: rule20 },
    { start: 120604, length: 25, convRule: rule107 },
    { start: 120629, length: 1, convRule: rule6 },
    { start: 120630, length: 25, convRule: rule20 },
    { start: 120655, length: 1, convRule: rule6 },
    { start: 120656, length: 6, convRule: rule20 },
    { start: 120662, length: 25, convRule: rule107 },
    { start: 120687, length: 1, convRule: rule6 },
    { start: 120688, length: 25, convRule: rule20 },
    { start: 120713, length: 1, convRule: rule6 },
    { start: 120714, length: 6, convRule: rule20 },
    { start: 120720, length: 25, convRule: rule107 },
    { start: 120745, length: 1, convRule: rule6 },
    { start: 120746, length: 25, convRule: rule20 },
    { start: 120771, length: 1, convRule: rule6 },
    { start: 120772, length: 6, convRule: rule20 },
    { start: 120778, length: 1, convRule: rule107 },
    { start: 120779, length: 1, convRule: rule20 },
    { start: 120782, length: 50, convRule: rule8 },
    { start: 120832, length: 512, convRule: rule13 },
    { start: 121344, length: 55, convRule: rule92 },
    { start: 121399, length: 4, convRule: rule13 },
    { start: 121403, length: 50, convRule: rule92 },
    { start: 121453, length: 8, convRule: rule13 },
    { start: 121461, length: 1, convRule: rule92 },
    { start: 121462, length: 14, convRule: rule13 },
    { start: 121476, length: 1, convRule: rule92 },
    { start: 121477, length: 2, convRule: rule13 },
    { start: 121479, length: 5, convRule: rule2 },
    { start: 121499, length: 5, convRule: rule92 },
    { start: 121505, length: 15, convRule: rule92 },
    { start: 122880, length: 7, convRule: rule92 },
    { start: 122888, length: 17, convRule: rule92 },
    { start: 122907, length: 7, convRule: rule92 },
    { start: 122915, length: 2, convRule: rule92 },
    { start: 122918, length: 5, convRule: rule92 },
    { start: 123136, length: 45, convRule: rule14 },
    { start: 123184, length: 7, convRule: rule92 },
    { start: 123191, length: 7, convRule: rule91 },
    { start: 123200, length: 10, convRule: rule8 },
    { start: 123214, length: 1, convRule: rule14 },
    { start: 123215, length: 1, convRule: rule13 },
    { start: 123584, length: 44, convRule: rule14 },
    { start: 123628, length: 4, convRule: rule92 },
    { start: 123632, length: 10, convRule: rule8 },
    { start: 123647, length: 1, convRule: rule3 },
    { start: 124928, length: 197, convRule: rule14 },
    { start: 125127, length: 9, convRule: rule17 },
    { start: 125136, length: 7, convRule: rule92 },
    { start: 125184, length: 34, convRule: rule203 },
    { start: 125218, length: 34, convRule: rule204 },
    { start: 125252, length: 7, convRule: rule92 },
    { start: 125259, length: 1, convRule: rule91 },
    { start: 125264, length: 10, convRule: rule8 },
    { start: 125278, length: 2, convRule: rule2 },
    { start: 126065, length: 59, convRule: rule17 },
    { start: 126124, length: 1, convRule: rule13 },
    { start: 126125, length: 3, convRule: rule17 },
    { start: 126128, length: 1, convRule: rule3 },
    { start: 126129, length: 4, convRule: rule17 },
    { start: 126209, length: 45, convRule: rule17 },
    { start: 126254, length: 1, convRule: rule13 },
    { start: 126255, length: 15, convRule: rule17 },
    { start: 126464, length: 4, convRule: rule14 },
    { start: 126469, length: 27, convRule: rule14 },
    { start: 126497, length: 2, convRule: rule14 },
    { start: 126500, length: 1, convRule: rule14 },
    { start: 126503, length: 1, convRule: rule14 },
    { start: 126505, length: 10, convRule: rule14 },
    { start: 126516, length: 4, convRule: rule14 },
    { start: 126521, length: 1, convRule: rule14 },
    { start: 126523, length: 1, convRule: rule14 },
    { start: 126530, length: 1, convRule: rule14 },
    { start: 126535, length: 1, convRule: rule14 },
    { start: 126537, length: 1, convRule: rule14 },
    { start: 126539, length: 1, convRule: rule14 },
    { start: 126541, length: 3, convRule: rule14 },
    { start: 126545, length: 2, convRule: rule14 },
    { start: 126548, length: 1, convRule: rule14 },
    { start: 126551, length: 1, convRule: rule14 },
    { start: 126553, length: 1, convRule: rule14 },
    { start: 126555, length: 1, convRule: rule14 },
    { start: 126557, length: 1, convRule: rule14 },
    { start: 126559, length: 1, convRule: rule14 },
    { start: 126561, length: 2, convRule: rule14 },
    { start: 126564, length: 1, convRule: rule14 },
    { start: 126567, length: 4, convRule: rule14 },
    { start: 126572, length: 7, convRule: rule14 },
    { start: 126580, length: 4, convRule: rule14 },
    { start: 126585, length: 4, convRule: rule14 },
    { start: 126590, length: 1, convRule: rule14 },
    { start: 126592, length: 10, convRule: rule14 },
    { start: 126603, length: 17, convRule: rule14 },
    { start: 126625, length: 3, convRule: rule14 },
    { start: 126629, length: 5, convRule: rule14 },
    { start: 126635, length: 17, convRule: rule14 },
    { start: 126704, length: 2, convRule: rule6 },
    { start: 126976, length: 44, convRule: rule13 },
    { start: 127024, length: 100, convRule: rule13 },
    { start: 127136, length: 15, convRule: rule13 },
    { start: 127153, length: 15, convRule: rule13 },
    { start: 127169, length: 15, convRule: rule13 },
    { start: 127185, length: 37, convRule: rule13 },
    { start: 127232, length: 13, convRule: rule17 },
    { start: 127245, length: 161, convRule: rule13 },
    { start: 127462, length: 29, convRule: rule13 },
    { start: 127504, length: 44, convRule: rule13 },
    { start: 127552, length: 9, convRule: rule13 },
    { start: 127568, length: 2, convRule: rule13 },
    { start: 127584, length: 6, convRule: rule13 },
    { start: 127744, length: 251, convRule: rule13 },
    { start: 127995, length: 5, convRule: rule10 },
    { start: 128e3, length: 728, convRule: rule13 },
    { start: 128736, length: 13, convRule: rule13 },
    { start: 128752, length: 13, convRule: rule13 },
    { start: 128768, length: 116, convRule: rule13 },
    { start: 128896, length: 89, convRule: rule13 },
    { start: 128992, length: 12, convRule: rule13 },
    { start: 129024, length: 12, convRule: rule13 },
    { start: 129040, length: 56, convRule: rule13 },
    { start: 129104, length: 10, convRule: rule13 },
    { start: 129120, length: 40, convRule: rule13 },
    { start: 129168, length: 30, convRule: rule13 },
    { start: 129200, length: 2, convRule: rule13 },
    { start: 129280, length: 121, convRule: rule13 },
    { start: 129402, length: 82, convRule: rule13 },
    { start: 129485, length: 135, convRule: rule13 },
    { start: 129632, length: 14, convRule: rule13 },
    { start: 129648, length: 5, convRule: rule13 },
    { start: 129656, length: 3, convRule: rule13 },
    { start: 129664, length: 7, convRule: rule13 },
    { start: 129680, length: 25, convRule: rule13 },
    { start: 129712, length: 7, convRule: rule13 },
    { start: 129728, length: 3, convRule: rule13 },
    { start: 129744, length: 7, convRule: rule13 },
    { start: 129792, length: 147, convRule: rule13 },
    { start: 129940, length: 55, convRule: rule13 },
    { start: 130032, length: 10, convRule: rule8 },
    { start: 131072, length: 42718, convRule: rule14 },
    { start: 173824, length: 4149, convRule: rule14 },
    { start: 177984, length: 222, convRule: rule14 },
    { start: 178208, length: 5762, convRule: rule14 },
    { start: 183984, length: 7473, convRule: rule14 },
    { start: 194560, length: 542, convRule: rule14 },
    { start: 196608, length: 4939, convRule: rule14 },
    { start: 917505, length: 1, convRule: rule16 },
    { start: 917536, length: 96, convRule: rule16 },
    { start: 917760, length: 240, convRule: rule92 },
    { start: 983040, length: 65534, convRule: rule200 },
    { start: 1048576, length: 65534, convRule: rule200 }
  ];
  var checkAttr = (categories) => ($$char2) => {
    const maybeConversionRule = getRule(allchars)($$char2)((() => {
      if ($$char2 < 256) {
        return 63;
      }
      return 3396;
    })());
    if (maybeConversionRule.tag === "Nothing") {
      return false;
    }
    if (maybeConversionRule.tag === "Just") {
      const $3 = findIndex((v) => v === maybeConversionRule._1.category)(categories);
      if ($3.tag === "Nothing") {
        return false;
      }
      if ($3.tag === "Just") {
        return true;
      }
      fail();
    }
    fail();
  };

  // output-es/Data.Bounded/foreign.js
  var topChar = String.fromCharCode(65535);
  var bottomChar = String.fromCharCode(0);
  var topNumber = Number.POSITIVE_INFINITY;
  var bottomNumber = Number.NEGATIVE_INFINITY;

  // output-es/Data.Enum/foreign.js
  function toCharCode(c) {
    return c.charCodeAt(0);
  }
  function fromCharCode(c) {
    return String.fromCharCode(c);
  }

  // output-es/DataType/index.js
  var $DataType$p = (_1, _2) => ({ tag: "DataType", _1, _2 });
  var fromFoldable3 = /* @__PURE__ */ fromFoldable2(foldableArray);
  var fromFoldable12 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2))();
  var toUnfoldable6 = /* @__PURE__ */ toUnfoldable4(unfoldableList);
  var show = /* @__PURE__ */ (() => showSet(showString).show)();
  var bind2Flipped2 = /* @__PURE__ */ bind2Flipped(monadEither);
  var DataType = (value0) => (value1) => $DataType$p(value0, value1);
  var typeName2 = (v) => v._1;
  var eqDataType$pInt = { eq: (x2) => (y2) => x2._1 === y2._1 };
  var showDataType$pInt = { show: typeName2 };
  var isCtrName = (str) => checkAttr([512, 524288])(toCharCode(definitely("absurd")(charAt2(0)(str))));
  var showCtr = (c) => {
    if (isCtrName(c)) {
      return c;
    }
    if (":" === definitely("absurd")(charAt2(0)(c))) {
      return "(" + (c + ")");
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var dataType = (name3) => {
    const $1 = arrayMap((v) => $Tuple(v._1, v._2));
    const $2 = DataType(name3);
    return (x2) => $2(fromFoldable3($1(x2)));
  };
  var dataTypes = /* @__PURE__ */ foldrArray(Cons)(Nil)([
    /* @__PURE__ */ dataType("Bool")([/* @__PURE__ */ $Tuple("True", 0), /* @__PURE__ */ $Tuple("False", 0)]),
    /* @__PURE__ */ dataType("List")([/* @__PURE__ */ $Tuple("Nil", 0), /* @__PURE__ */ $Tuple(":", 2)]),
    /* @__PURE__ */ dataType("Option")([/* @__PURE__ */ $Tuple("None", 0), /* @__PURE__ */ $Tuple("Some", 1)]),
    /* @__PURE__ */ dataType("Ordering")([/* @__PURE__ */ $Tuple("GT", 0), /* @__PURE__ */ $Tuple("LT", 0), /* @__PURE__ */ $Tuple("EQ", 0)]),
    /* @__PURE__ */ dataType("Pair")([/* @__PURE__ */ $Tuple("Pair", 2)]),
    /* @__PURE__ */ dataType("Tree")([/* @__PURE__ */ $Tuple("Empty", 0), /* @__PURE__ */ $Tuple("NonEmpty", 3)]),
    /* @__PURE__ */ dataType("Point")([/* @__PURE__ */ $Tuple("Point", 2)]),
    /* @__PURE__ */ dataType("Orient")([/* @__PURE__ */ $Tuple("Horiz", 0), /* @__PURE__ */ $Tuple("Vert", 0)]),
    /* @__PURE__ */ dataType("Plot")([
      /* @__PURE__ */ $Tuple("BarChart", 1),
      /* @__PURE__ */ $Tuple("LineChart", 1),
      /* @__PURE__ */ $Tuple("LinePlot", 1)
    ]),
    /* @__PURE__ */ dataType("GraphicsElement")([
      /* @__PURE__ */ $Tuple("Circle", 4),
      /* @__PURE__ */ $Tuple("Group", 1),
      /* @__PURE__ */ $Tuple("Line", 4),
      /* @__PURE__ */ $Tuple("Polyline", 3),
      /* @__PURE__ */ $Tuple("Polymarkers", 2),
      /* @__PURE__ */ $Tuple("Rect", 5),
      /* @__PURE__ */ $Tuple("Text", 5),
      /* @__PURE__ */ $Tuple("Viewport", 9)
    ]),
    /* @__PURE__ */ dataType("Transform")([/* @__PURE__ */ $Tuple("Scale", 2), /* @__PURE__ */ $Tuple("Translate", 2)]),
    /* @__PURE__ */ dataType("Marker")([/* @__PURE__ */ $Tuple("Arrowhead", 0)])
  ]);
  var ctrToDataType = /* @__PURE__ */ (() => fromFoldable2(foldableList)(bindList.bind(listMap((d) => listMap((v) => $Tuple(
    v,
    d
  ))(toUnfoldable6(fromFoldable12(keys2(d._2)))))(dataTypes))(identity7)))();
  var dataTypeForCtr = {
    dataTypeFor: (c) => {
      const $1 = "Unknown constructor " + showCtr(c);
      const $2 = _lookup(Nothing, Just, c, ctrToDataType);
      if ($2.tag === "Nothing") {
        return $Either("Left", $1);
      }
      if ($2.tag === "Just") {
        return $Either("Right", $2._1);
      }
      fail();
    }
  };
  var consistentWith = (cs) => (cs$p) => {
    const $2 = bindEither.bind((() => {
      const v = toUnfoldable6(cs$p);
      if (v.tag === "Cons") {
        return dataTypeForCtr.dataTypeFor(v._1);
      }
      fail();
    })())((d) => bindEither.bind((() => {
      const v = toUnfoldable6(cs$p);
      if (v.tag === "Cons") {
        return dataTypeForCtr.dataTypeFor(v._1);
      }
      fail();
    })())((d$p) => $$with("constructors of " + (d$p._1 + (" do not include " + show(map2(ordString)(showCtr)(cs)))))(mayFailEq(showDataType$pInt)(eqDataType$pInt)(d)(d$p))));
    if ($2.tag === "Left") {
      return $Either("Left", $2._1);
    }
    if ($2.tag === "Right") {
      return $Either("Right", unit2);
    }
    fail();
  };
  var arity = (c) => bindEither.bind(dataTypeForCtr.dataTypeFor(c))((v) => {
    const $2 = _lookup(Nothing, Just, c, v._2);
    if ($2.tag === "Nothing") {
      return $Either("Left", "absurd");
    }
    if ($2.tag === "Just") {
      return $Either("Right", $2._1);
    }
    fail();
  });
  var checkArity = (c) => (n) => {
    const $2 = $$with("Checking arity of " + showCtr(c))(bind2Flipped2(mayFailEq(showInt)(eqInt))(arity(c))($Either("Right", n)));
    if ($2.tag === "Left") {
      return $Either("Left", $2._1);
    }
    if ($2.tag === "Right") {
      return $Either("Right", unit2);
    }
    fail();
  };

  // output-es/Data.Show.Generic/foreign.js
  var intercalate3 = function(separator) {
    return function(xs) {
      return xs.join(separator);
    };
  };

  // output-es/Data.Show.Generic/index.js
  var genericShowConstructor = (dictGenericShowArgs) => (dictIsSymbol) => ({
    "genericShow'": (v) => {
      const ctor = dictIsSymbol.reflectSymbol($$Proxy);
      const v1 = dictGenericShowArgs.genericShowArgs(v);
      if (v1.length === 0) {
        return ctor;
      }
      return "(" + (intercalate3(" ")(concatArray([ctor])(v1)) + ")");
    }
  });

  // output-es/Parsing/index.js
  var $ParseError = (_1, _2) => ({ tag: "ParseError", _1, _2 });
  var $ParseState = (_1, _2, _3) => ({ tag: "ParseState", _1, _2, _3 });
  var $RunParser = (tag, _1, _2) => ({ tag, _1, _2 });
  var More = (value0) => $RunParser("More", value0);
  var Lift = (value0) => $RunParser("Lift", value0);
  var lazyParserT = {
    defer: (f) => {
      const m = defer(f);
      return (state1, more, lift1, $$throw, done) => force(m)(state1, more, lift1, $$throw, done);
    }
  };
  var genericShow = /* @__PURE__ */ (() => {
    const $0 = genericShowConstructor({
      genericShowArgs: (v) => [
        (() => {
          const v$1 = cons(intercalate(": ")(["column", showIntImpl(v.column)]))(cons(intercalate(": ")([
            "index",
            showIntImpl(v.index)
          ]))(cons(intercalate(": ")(["line", showIntImpl(v.line)]))([])));
          if (v$1.length === 0) {
            return "{}";
          }
          return intercalate(" ")(["{", intercalate(", ")(v$1), "}"]);
        })()
      ]
    })({ reflectSymbol: () => "Position" });
    return (x2) => $0["genericShow'"](x2);
  })();
  var functorParserT = { map: (f) => (v) => (state1, more, lift1, $$throw, done) => more((v1) => v(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, f(a))))) };
  var applyParserT = {
    apply: (v) => (v1) => (state1, more, lift1, $$throw, done) => more((v2) => v(
      state1,
      more,
      lift1,
      $$throw,
      (state2, f) => more((v3) => v1(state2, more, lift1, $$throw, (state3, a) => more((v4) => done(state3, f(a)))))
    )),
    Functor0: () => functorParserT
  };
  var bindParserT = {
    bind: (v) => (next) => (state1, more, lift1, $$throw, done) => more((v1) => v(state1, more, lift1, $$throw, (state2, a) => more((v2) => next(a)(state2, more, lift1, $$throw, done)))),
    Apply0: () => applyParserT
  };
  var applicativeParserT = { pure: (a) => (state1, v, v1, v2, done) => done(state1, a), Apply0: () => applyParserT };
  var monadParserT = { Applicative0: () => applicativeParserT, Bind1: () => bindParserT };
  var monadRecParserT = {
    tailRecM: (next) => (initArg) => (state1, more, lift1, $$throw, done) => {
      const loop = (state2, arg, gas) => next(arg)(
        state2,
        more,
        lift1,
        $$throw,
        (state3, step) => {
          if (step.tag === "Loop") {
            if (gas === 0) {
              return more((v1) => loop(state3, step._1, 30));
            }
            return loop(state3, step._1, gas - 1 | 0);
          }
          if (step.tag === "Done") {
            return done(state3, step._1);
          }
          fail();
        }
      );
      return loop(state1, initArg, 30);
    },
    Monad0: () => monadParserT
  };
  var altParserT = {
    alt: (v) => (v1) => (v2, $3, $4, $5, $6) => $3((v3) => v(
      $ParseState(v2._1, v2._2, false),
      $3,
      $4,
      (v4, $9) => $3((v5) => {
        if (v4._3) {
          return $5(v4, $9);
        }
        return v1(v2, $3, $4, $5, $6);
      }),
      $6
    )),
    Functor0: () => functorParserT
  };
  var showParseError = { show: (v) => "(ParseError " + (showStringImpl(v._1) + (" " + (genericShow(v._2) + ")"))) };
  var runParserT$p = (dictMonadRec) => {
    const Monad0 = dictMonadRec.Monad0();
    const map6 = Monad0.Bind1().Apply0().Functor0().map;
    const pure1 = Monad0.Applicative0().pure;
    return (state1) => (v) => {
      const go = (go$a0$copy) => {
        let go$a0 = go$a0$copy, go$c = true, go$r;
        while (go$c) {
          const step = go$a0;
          const v1 = step(unit2);
          if (v1.tag === "More") {
            go$a0 = v1._1;
            continue;
          }
          if (v1.tag === "Lift") {
            go$c = false;
            go$r = map6(Loop)(v1._1);
            continue;
          }
          if (v1.tag === "Stop") {
            go$c = false;
            go$r = pure1($Step("Done", $Tuple(v1._2, v1._1)));
            continue;
          }
          fail();
        }
        ;
        return go$r;
      };
      return dictMonadRec.tailRecM(go)((v1) => v(
        state1,
        More,
        Lift,
        (state2, err) => $RunParser("Stop", state2, $Either("Left", err)),
        (state2, res) => $RunParser("Stop", state2, $Either("Right", res))
      ));
    };
  };
  var position = (state1, v, v1, v2, done) => done(state1, state1._2);
  var initialPos = { index: 0, line: 1, column: 1 };
  var runParserT = (dictMonadRec) => {
    const map6 = dictMonadRec.Monad0().Bind1().Apply0().Functor0().map;
    const runParserT$p1 = runParserT$p(dictMonadRec);
    return (s) => (p) => map6(fst)(runParserT$p1($ParseState(s, initialPos, false))(p));
  };
  var runParserT1 = /* @__PURE__ */ runParserT(monadRecIdentity);
  var failWithPosition = (message2) => (pos) => (state1, v, v1, $$throw, v2) => $$throw(state1, $ParseError(message2, pos));
  var fail2 = (message2) => (state1, more, lift1, $$throw, done) => more((v1) => position(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => failWithPosition(message2)(a)(state2, more, lift1, $$throw, done))
  ));
  var plusParserT = { empty: /* @__PURE__ */ fail2("No alternative"), Alt0: () => altParserT };
  var alternativeParserT = { Applicative0: () => applicativeParserT, Plus1: () => plusParserT };

  // output-es/Parsing.Combinators/index.js
  var manyRec2 = /* @__PURE__ */ manyRec(monadRecParserT)(alternativeParserT);
  var withLazyErrorMessage = (p) => (msg) => altParserT.alt(p)(lazyParserT.defer((v) => fail2("Expected " + msg(unit2))));
  var withErrorMessage = (p) => (msg) => altParserT.alt(p)(fail2("Expected " + msg));
  var $$try = (v) => (v1, $2, $3, $4, $5) => v(v1, $2, $3, (v2, $7) => $4($ParseState(v2._1, v2._2, v1._3), $7), $5);
  var skipMany1 = (p) => (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => p(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$1) => more((v3) => {
      const loop = (state2$1, arg, gas) => altParserT.alt((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v1$1) => p(
        state1$1,
        more$1,
        lift1$1,
        throw$1,
        (state2$2, a$1) => more$1((v2$2) => done$1(state2$2, $Step("Loop", unit2)))
      )))((state1$1, v, v1$1, v2$2, done$1) => done$1(state1$1, $Step("Done", unit2)))(
        state2$1,
        more,
        lift1,
        $$throw,
        (state3, step) => {
          if (step.tag === "Loop") {
            if (gas === 0) {
              return more((v1$1) => loop(state3, step._1, 30));
            }
            return loop(state3, step._1, gas - 1 | 0);
          }
          if (step.tag === "Done") {
            return more((v4) => done(state3, step._1));
          }
          fail();
        }
      );
      return loop(state2, unit2, 30);
    }))
  )));
  var skipMany = (p) => altParserT.alt(skipMany1(p))((state1, v, v1, v2, done) => done(state1, unit2));
  var sepBy1 = (p) => (sep) => (state1, more, lift1, $$throw, done) => more((v1) => p(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => {
      const $11 = manyRec2((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v2$1) => more$1((v1$1) => sep(
        state1$1,
        more$1,
        lift1$1,
        throw$1,
        (state2$1, a$1) => more$1((v2$2) => more$1((v3) => p(state2$1, more$1, lift1$1, throw$1, (state3, a$2) => more$1((v4) => done$1(state3, a$2)))))
      ))));
      return more((v1$1) => $11(state2, more, lift1, $$throw, (state2$1, a$1) => more((v2$1) => done(state2$1, $NonEmpty(a, a$1)))));
    })
  ));
  var sepBy = (p) => (sep) => altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => sepBy1(p)(sep)(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => done(state2, $List("Cons", a._1, a._2)))
  )))((state1, v, v1, v2, done) => done(state1, Nil));
  var option = (a) => (p) => altParserT.alt(p)((state1, v, v1, v2, done) => done(state1, a));
  var notFollowedBy = (p) => $$try(altParserT.alt((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$try(p)(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$1) => more((v3) => fail2("Negated parser succeeded")(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
  ))))((state1, v, v1, v2, done) => done(state1, unit2)));
  var choice = (dictFoldable) => {
    const $1 = dictFoldable.foldr((p1) => (v) => {
      if (v.tag === "Nothing") {
        return $Maybe("Just", p1);
      }
      if (v.tag === "Just") {
        return $Maybe("Just", altParserT.alt(p1)(v._1));
      }
      fail();
    })(Nothing);
    return (x2) => {
      const $3 = $1(x2);
      if ($3.tag === "Nothing") {
        return fail2("No alternative");
      }
      if ($3.tag === "Just") {
        return $3._1;
      }
      fail();
    };
  };
  var between = (open) => (close) => (p) => (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => open(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$2) => more((v3) => p(
      state2,
      more,
      lift1,
      $$throw,
      (state3, a$1) => more((v4) => more((v2$3) => more((v3$1) => close(state3, more, lift1, $$throw, (state3$1, a$2) => more((v4$1) => done(state3$1, a$1))))))
    )))
  )))));
  var asErrorMessage = (b) => (a) => withErrorMessage(a)(b);

  // output-es/Parsing.Expr/index.js
  var $Assoc = (tag) => ({ tag });
  var $Operator = (tag, _1, _2) => ({ tag, _1, _2 });
  var choice2 = /* @__PURE__ */ choice(foldableList);
  var identity15 = (x2) => x2;
  var AssocNone = /* @__PURE__ */ $Assoc("AssocNone");
  var AssocLeft = /* @__PURE__ */ $Assoc("AssocLeft");
  var AssocRight = /* @__PURE__ */ $Assoc("AssocRight");
  var splitOp = (v) => (v1) => {
    if (v.tag === "Infix") {
      if (v._2.tag === "AssocNone") {
        return { rassoc: v1.rassoc, lassoc: v1.lassoc, nassoc: $List("Cons", v._1, v1.nassoc), prefix: v1.prefix, postfix: v1.postfix };
      }
      if (v._2.tag === "AssocLeft") {
        return { rassoc: v1.rassoc, lassoc: $List("Cons", v._1, v1.lassoc), nassoc: v1.nassoc, prefix: v1.prefix, postfix: v1.postfix };
      }
      if (v._2.tag === "AssocRight") {
        return { rassoc: $List("Cons", v._1, v1.rassoc), lassoc: v1.lassoc, nassoc: v1.nassoc, prefix: v1.prefix, postfix: v1.postfix };
      }
      fail();
    }
    if (v.tag === "Prefix") {
      return { rassoc: v1.rassoc, lassoc: v1.lassoc, nassoc: v1.nassoc, prefix: $List("Cons", v._1, v1.prefix), postfix: v1.postfix };
    }
    if (v.tag === "Postfix") {
      return { rassoc: v1.rassoc, lassoc: v1.lassoc, nassoc: v1.nassoc, prefix: v1.prefix, postfix: $List("Cons", v._1, v1.postfix) };
    }
    fail();
  };
  var rassocP1 = (x2) => (rassocOp) => (prefixP) => (term) => (postfixP) => altParserT.alt(rassocP(x2)(rassocOp)(prefixP)(term)(postfixP))((state1, v, v1, v2, done) => done(state1, x2));
  var rassocP = (x2) => (rassocOp) => (prefixP) => (term) => (postfixP) => (state1, more, lift1, $$throw, done) => more((v1) => rassocOp(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => more((v1$1) => more((v1$2) => more((v1$3) => prefixP(
      state2,
      more,
      lift1,
      $$throw,
      (state2$1, a$1) => more((v2$1) => more((v1$4) => term(
        state2$1,
        more,
        lift1,
        $$throw,
        (state2$2, a$2) => more((v2$2) => more((v1$5) => postfixP(
          state2$2,
          more,
          lift1,
          $$throw,
          (state2$3, a$3) => more((v2$3) => {
            const $28 = a$3(a$1(a$2));
            return more((v2$4) => rassocP1($28)(rassocOp)(prefixP)(term)(postfixP)(state2$3, more, lift1, $$throw, (state2$4, a$4) => more((v2$5) => done(state2$4, a(x2)(a$4)))));
          })
        )))
      )))
    )))))
  ));
  var nassocP = (x2) => (nassocOp) => (prefixP) => (term) => (postfixP) => (state1, more, lift1, $$throw, done) => more((v1) => nassocOp(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => more((v1$1) => more((v1$2) => prefixP(
      state2,
      more,
      lift1,
      $$throw,
      (state2$1, a$1) => more((v2$1) => more((v1$3) => term(
        state2$1,
        more,
        lift1,
        $$throw,
        (state2$2, a$2) => more((v2$2) => more((v1$4) => postfixP(
          state2$2,
          more,
          lift1,
          $$throw,
          (state2$3, a$3) => more((v2$3) => {
            const $27 = a$3(a$1(a$2));
            return more((v2$4) => done(state2$3, a(x2)($27)));
          })
        )))
      )))
    ))))
  ));
  var lassocP1 = (x2) => (lassocOp) => (prefixP) => (term) => (postfixP) => altParserT.alt(lassocP(x2)(lassocOp)(prefixP)(term)(postfixP))((state1, v, v1, v2, done) => done(state1, x2));
  var lassocP = (x2) => (lassocOp) => (prefixP) => (term) => (postfixP) => (state1, more, lift1, $$throw, done) => more((v1) => lassocOp(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => more((v1$1) => more((v1$2) => prefixP(
      state2,
      more,
      lift1,
      $$throw,
      (state2$1, a$1) => more((v2$1) => more((v1$3) => term(
        state2$1,
        more,
        lift1,
        $$throw,
        (state2$2, a$2) => more((v2$2) => more((v1$4) => postfixP(
          state2$2,
          more,
          lift1,
          $$throw,
          (state2$3, a$3) => more((v2$3) => {
            const $27 = a$3(a$1(a$2));
            return more((v2$4) => lassocP1(a(x2)($27))(lassocOp)(prefixP)(term)(postfixP)(state2$3, more, lift1, $$throw, done));
          })
        )))
      )))
    ))))
  ));
  var makeParser = (term) => (ops) => {
    const accum = foldrArray(splitOp)({
      rassoc: Nil,
      lassoc: Nil,
      nassoc: Nil,
      prefix: Nil,
      postfix: Nil
    })(ops);
    const lassocOp = choice2(accum.lassoc);
    const nassocOp = choice2(accum.nassoc);
    const postfixOp = withErrorMessage(choice2(accum.postfix))("");
    const prefixOp = withErrorMessage(choice2(accum.prefix))("");
    const rassocOp = choice2(accum.rassoc);
    const $8 = altParserT.alt(prefixOp)((state1, v, v1, v2, done) => done(state1, identity15));
    const $9 = altParserT.alt(postfixOp)((state1, v, v1, v2, done) => done(state1, identity15));
    return (state1, more, lift1, $$throw, done) => more((v1) => more((v1$1) => $8(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => more((v1$2) => term(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$1) => more((v1$3) => $9(
          state2$1,
          more,
          lift1,
          $$throw,
          (state2$2, a$2) => more((v2$2) => {
            const $28 = a$2(a(a$1));
            return more((v2$3) => altParserT.alt(rassocP($28)(rassocOp)(altParserT.alt(prefixOp)((state1$1, v, v1$4, v2$4, done$1) => done$1(state1$1, identity15)))(term)(altParserT.alt(postfixOp)((state1$1, v, v1$4, v2$4, done$1) => done$1(state1$1, identity15))))(altParserT.alt(lassocP($28)(lassocOp)(altParserT.alt(prefixOp)((state1$1, v, v1$4, v2$4, done$1) => done$1(
              state1$1,
              identity15
            )))(term)(altParserT.alt(postfixOp)((state1$1, v, v1$4, v2$4, done$1) => done$1(state1$1, identity15))))(altParserT.alt(nassocP($28)(nassocOp)(altParserT.alt(prefixOp)((state1$1, v, v1$4, v2$4, done$1) => done$1(state1$1, identity15)))(term)(altParserT.alt(postfixOp)((state1$1, v, v1$4, v2$4, done$1) => done$1(state1$1, identity15))))(withErrorMessage((state1$1, v, v1$4, v2$4, done$1) => done$1(state1$1, $28))("operator"))))(state2$2, more, lift1, $$throw, done));
          })
        )))
      )))
    )));
  };
  var buildExprParser = (operators2) => (simpleExpr) => foldlArray(makeParser)(simpleExpr)(operators2);

  // output-es/Primitive.Parse/index.js
  var opDefs = /* @__PURE__ */ fromFoldable(ordString)(foldableArray)([
    /* @__PURE__ */ $Tuple(".", { op: ".", prec: 8, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("!", { op: "!", prec: 8, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("**", { op: "**", prec: 8, assoc: AssocRight }),
    /* @__PURE__ */ $Tuple("*", { op: "*", prec: 7, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("/", { op: "/", prec: 7, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("+", { op: "+", prec: 6, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("-", { op: "-", prec: 6, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple(":", { op: ":", prec: 6, assoc: AssocRight }),
    /* @__PURE__ */ $Tuple("++", { op: "++", prec: 5, assoc: AssocRight }),
    /* @__PURE__ */ $Tuple("==", { op: "==", prec: 4, assoc: AssocNone }),
    /* @__PURE__ */ $Tuple("/=", { op: "/=", prec: 4, assoc: AssocNone }),
    /* @__PURE__ */ $Tuple("<", { op: "<", prec: 4, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple(">", { op: ">", prec: 4, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple("<=", { op: "<=", prec: 4, assoc: AssocLeft }),
    /* @__PURE__ */ $Tuple(">=", { op: ">=", prec: 4, assoc: AssocLeft })
  ]);

  // output-es/Bindings/index.js
  var keys3 = (v) => {
    if (v.tag === "Nil") {
      return Leaf2;
    }
    if (v.tag === "Cons") {
      return unionWith(ordString)($$const)($Map(
        "Two",
        Leaf2,
        v._1._1,
        unit2,
        Leaf2
      ))(keys3(v._2));
    }
    fail();
  };

  // output-es/Expr/index.js
  var $Cont = (tag, _1) => ({ tag, _1 });
  var $Elim = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Expr = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $Module = (_1) => ({ tag: "Module", _1 });
  var $VarDef = (_1, _2) => ({ tag: "VarDef", _1, _2 });
  var showSet2 = /* @__PURE__ */ showSet(showString);
  var eqSet = /* @__PURE__ */ (() => {
    const eq2 = eqMap(eqString)(eqUnit).eq;
    return { eq: (v) => (v1) => eq2(v)(v1) };
  })();
  var identity16 = (x2) => x2;
  var unions = /* @__PURE__ */ fold((z) => (v) => union2(ordString)(z))(Leaf2);
  var fromFoldable4 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2))();
  var unions1 = /* @__PURE__ */ (() => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = unionWith(ordString)($$const)(b)(v._1);
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go(Leaf2);
  })();
  var ContNone = /* @__PURE__ */ $Cont("ContNone");
  var Int = (value0) => (value1) => $Expr("Int", value0, value1);
  var Float = (value0) => (value1) => $Expr("Float", value0, value1);
  var Str = (value0) => (value1) => $Expr("Str", value0, value1);
  var Record = (value0) => (value1) => $Expr("Record", value0, value1);
  var Dictionary = (value0) => (value1) => $Expr("Dictionary", value0, value1);
  var Constr = (value0) => (value1) => (value2) => $Expr("Constr", value0, value1, value2);
  var Matrix = (value0) => (value1) => (value2) => (value3) => $Expr("Matrix", value0, value1, value2, value3);
  var Project = (value0) => (value1) => $Expr("Project", value0, value1);
  var App2 = (value0) => (value1) => $Expr("App", value0, value1);
  var Let = (value0) => (value1) => $Expr("Let", value0, value1);
  var LetRec = (value0) => (value1) => $Expr("LetRec", value0, value1);
  var ElimVar = (value0) => (value1) => $Elim("ElimVar", value0, value1);
  var ElimRecord = (value0) => (value1) => $Elim("ElimRecord", value0, value1);
  var VarDef = (value0) => (value1) => $VarDef(value0, value1);
  var functorVarDef = { map: (f) => (m) => $VarDef(functorElim.map(f)(m._1), functorExpr.map(f)(m._2)) };
  var functorExpr = {
    map: (f) => (m) => {
      if (m.tag === "Var") {
        return $Expr("Var", m._1);
      }
      if (m.tag === "Op") {
        return $Expr("Op", m._1);
      }
      if (m.tag === "Int") {
        return $Expr("Int", f(m._1), m._2);
      }
      if (m.tag === "Float") {
        return $Expr("Float", f(m._1), m._2);
      }
      if (m.tag === "Str") {
        return $Expr("Str", f(m._1), m._2);
      }
      if (m.tag === "Record") {
        return $Expr("Record", f(m._1), _fmapObject(m._2, functorExpr.map(f)));
      }
      if (m.tag === "Dictionary") {
        return $Expr("Dictionary", f(m._1), listMap(functorPair.map(functorExpr.map(f)))(m._2));
      }
      if (m.tag === "Constr") {
        return $Expr("Constr", f(m._1), m._2, listMap(functorExpr.map(f))(m._3));
      }
      if (m.tag === "Matrix") {
        return $Expr("Matrix", f(m._1), functorExpr.map(f)(m._2), m._3, functorExpr.map(f)(m._4));
      }
      if (m.tag === "Lambda") {
        return $Expr("Lambda", functorElim.map(f)(m._1));
      }
      if (m.tag === "Project") {
        return $Expr("Project", functorExpr.map(f)(m._1), m._2);
      }
      if (m.tag === "App") {
        return $Expr("App", functorExpr.map(f)(m._1), functorExpr.map(f)(m._2));
      }
      if (m.tag === "Let") {
        return $Expr("Let", functorVarDef.map(f)(m._1), functorExpr.map(f)(m._2));
      }
      if (m.tag === "LetRec") {
        return $Expr("LetRec", _fmapObject(m._1, functorElim.map(f)), functorExpr.map(f)(m._2));
      }
      fail();
    }
  };
  var functorElim = {
    map: (f) => (m) => {
      if (m.tag === "ElimVar") {
        return $Elim("ElimVar", m._1, functorCont.map(f)(m._2));
      }
      if (m.tag === "ElimConstr") {
        return $Elim("ElimConstr", _fmapObject(m._1, functorCont.map(f)));
      }
      if (m.tag === "ElimRecord") {
        return $Elim("ElimRecord", m._1, functorCont.map(f)(m._2));
      }
      fail();
    }
  };
  var functorCont = {
    map: (f) => (m) => {
      if (m.tag === "ContNone") {
        return ContNone;
      }
      if (m.tag === "ContExpr") {
        return $Cont("ContExpr", functorExpr.map(f)(m._1));
      }
      if (m.tag === "ContElim") {
        return $Cont("ContElim", functorElim.map(f)(m._1));
      }
      fail();
    }
  };
  var joinSemilatticeVarDef = (dictJoinSemilattice) => ({
    join: (def) => definedJoin(joinSemilatticeVarDef(dictJoinSemilattice))(def),
    maybeJoin: (v) => (v1) => applyEither.apply((() => {
      const $3 = joinSemilatticeElim(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", VarDef($3._1));
      }
      fail();
    })())(joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._2)(v1._2)),
    neg: functorVarDef.map(dictJoinSemilattice.neg)
  });
  var joinSemilatticeExpr = (dictJoinSemilattice) => ({
    maybeJoin: (v) => (v1) => {
      if (v.tag === "Var") {
        if (v1.tag === "Var") {
          const $3 = mayFailEq(showString)(eqString)(v._1)(v1._1);
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", $Expr("Var", $3._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Op") {
        if (v1.tag === "Op") {
          const $3 = mayFailEq(showString)(eqString)(v._1)(v1._1);
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", $Expr("Op", $3._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          const $3 = Int(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = mayFailEq(showInt)(eqInt)(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          const $3 = Str(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = mayFailEq(showString)(eqString)(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          const $3 = Float(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = mayFailEq(showNumber)(eqNumber)(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          const $3 = Record(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = joinSemilatticeDict(joinSemilatticeExpr(dictJoinSemilattice)).maybeJoin(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          const $3 = Dictionary(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = joinSemilatticeList(joinSemilatticePair(joinSemilatticeExpr(dictJoinSemilattice))).maybeJoin(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return applyEither.apply((() => {
            const $3 = Constr(dictJoinSemilattice.join(v._1)(v1._1));
            const $4 = mayFailEq(showString)(eqString)(v._2)(v1._2);
            if ($4.tag === "Left") {
              return $Either("Left", $4._1);
            }
            if ($4.tag === "Right") {
              return $Either("Right", $3($4._1));
            }
            fail();
          })())(joinSemilatticeList(joinSemilatticeExpr(dictJoinSemilattice)).maybeJoin(v._3)(v1._3));
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return applyEither.apply(applyEither.apply((() => {
            const $3 = Matrix(dictJoinSemilattice.join(v._1)(v1._1));
            const $4 = joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._2)(v1._2);
            if ($4.tag === "Left") {
              return $Either("Left", $4._1);
            }
            if ($4.tag === "Right") {
              return $Either("Right", $3($4._1));
            }
            fail();
          })())((() => {
            const $3 = mayFailEq(showString)(eqString)(v._3._1)(v1._3._1);
            return applyEither.apply((() => {
              if ($3.tag === "Left") {
                return $Either("Left", $3._1);
              }
              if ($3.tag === "Right") {
                return $Either("Right", Tuple($3._1));
              }
              fail();
            })())(mayFailEq(showString)(eqString)(v._3._2)(v1._3._2));
          })()))(joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._4)(v1._4));
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Lambda") {
        if (v1.tag === "Lambda") {
          const $3 = joinSemilatticeElim(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", $Expr("Lambda", $3._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Project") {
        if (v1.tag === "Project") {
          return applyEither.apply((() => {
            const $3 = joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", Project($3._1));
            }
            fail();
          })())(mayFailEq(showString)(eqString)(v._2)(v1._2));
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "App") {
        if (v1.tag === "App") {
          return applyEither.apply((() => {
            const $3 = joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", App2($3._1));
            }
            fail();
          })())(joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._2)(v1._2));
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "Let") {
        if (v1.tag === "Let") {
          return applyEither.apply((() => {
            const $3 = joinSemilatticeVarDef(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", Let($3._1));
            }
            fail();
          })())(joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._2)(v1._2));
        }
        return $Either("Left", "Incompatible expressions");
      }
      if (v.tag === "LetRec") {
        if (v1.tag === "LetRec") {
          return applyEither.apply((() => {
            const $3 = joinSemilatticeDict(joinSemilatticeElim(dictJoinSemilattice)).maybeJoin(v._1)(v1._1);
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", LetRec($3._1));
            }
            fail();
          })())(joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._2)(v1._2));
        }
        return $Either("Left", "Incompatible expressions");
      }
      return $Either("Left", "Incompatible expressions");
    },
    join: (e) => definedJoin(joinSemilatticeExpr(dictJoinSemilattice))(e),
    neg: functorExpr.map(dictJoinSemilattice.neg)
  });
  var joinSemilatticeElim = (dictJoinSemilattice) => ({
    maybeJoin: (v) => (v1) => {
      if (v.tag === "ElimVar") {
        if (v1.tag === "ElimVar") {
          return applyEither.apply((() => {
            const $3 = mayFailEq(showString)(eqString)(v._1)(v1._1);
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", ElimVar($3._1));
            }
            fail();
          })())(joinSemilatticeCont(dictJoinSemilattice).maybeJoin(v._2)(v1._2));
        }
        return $Either("Left", "Incompatible eliminators");
      }
      if (v.tag === "ElimConstr") {
        if (v1.tag === "ElimConstr") {
          const $3 = consistentWith(keys2(v._1))(keys2(v1._1));
          const $4 = applyEither.apply((() => {
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", identity4);
            }
            fail();
          })())(joinSemilatticeDict(joinSemilatticeCont(dictJoinSemilattice)).maybeJoin(v._1)(v1._1));
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $Elim("ElimConstr", $4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible eliminators");
      }
      if (v.tag === "ElimRecord") {
        if (v1.tag === "ElimRecord") {
          return applyEither.apply((() => {
            const $3 = mayFailEq(showSet2)(eqSet)(v._1)(v1._1);
            if ($3.tag === "Left") {
              return $Either("Left", $3._1);
            }
            if ($3.tag === "Right") {
              return $Either("Right", ElimRecord($3._1));
            }
            fail();
          })())(joinSemilatticeCont(dictJoinSemilattice).maybeJoin(v._2)(v1._2));
        }
        return $Either("Left", "Incompatible eliminators");
      }
      return $Either("Left", "Incompatible eliminators");
    },
    join: (\u03C3) => definedJoin(joinSemilatticeElim(dictJoinSemilattice))(\u03C3),
    neg: functorElim.map(dictJoinSemilattice.neg)
  });
  var joinSemilatticeCont = (dictJoinSemilattice) => ({
    maybeJoin: (v) => (v1) => {
      if (v.tag === "ContNone") {
        if (v1.tag === "ContNone") {
          return $Either("Right", ContNone);
        }
        return $Either("Left", "Incompatible continuations");
      }
      if (v.tag === "ContExpr") {
        if (v1.tag === "ContExpr") {
          const $3 = joinSemilatticeExpr(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", $Cont("ContExpr", $3._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible continuations");
      }
      if (v.tag === "ContElim") {
        if (v1.tag === "ContElim") {
          const $3 = joinSemilatticeElim(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", $Cont("ContElim", $3._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible continuations");
      }
      return $Either("Left", "Incompatible continuations");
    },
    join: (\u03BA) => definedJoin(joinSemilatticeCont(dictJoinSemilattice))(\u03BA),
    neg: functorCont.map(dictJoinSemilattice.neg)
  });
  var foldableVarDef = {
    foldl: (f) => (z) => (m) => foldableExpr.foldl(f)(foldableElim.foldl(f)(z)(m._1))(m._2),
    foldr: (f) => (z) => (m) => foldableElim.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1),
    foldMap: (dictMonoid) => {
      const append = dictMonoid.Semigroup0().append;
      return (f) => (m) => append(foldableElim.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2));
    }
  };
  var foldableExpr = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Var") {
        return z;
      }
      if (m.tag === "Op") {
        return z;
      }
      if (m.tag === "Int") {
        return f(z)(m._1);
      }
      if (m.tag === "Float") {
        return f(z)(m._1);
      }
      if (m.tag === "Str") {
        return f(z)(m._1);
      }
      if (m.tag === "Record") {
        const $3 = foldableExpr.foldl(f);
        return fold((z$1) => (v) => $3(z$1))(f(z)(m._1))(m._2);
      }
      if (m.tag === "Dictionary") {
        const $3 = foldableExpr.foldl(f);
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = $3($3(b)(v._1._1))(v._1._2);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(f(z)(m._1))(m._2);
      }
      if (m.tag === "Constr") {
        const $3 = foldableExpr.foldl(f);
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = $3(b)(v._1);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(f(z)(m._1))(m._3);
      }
      if (m.tag === "Matrix") {
        return foldableExpr.foldl(f)(foldableExpr.foldl(f)(f(z)(m._1))(m._2))(m._4);
      }
      if (m.tag === "Lambda") {
        return foldableElim.foldl(f)(z)(m._1);
      }
      if (m.tag === "Project") {
        return foldableExpr.foldl(f)(z)(m._1);
      }
      if (m.tag === "App") {
        return foldableExpr.foldl(f)(foldableExpr.foldl(f)(z)(m._1))(m._2);
      }
      if (m.tag === "Let") {
        return foldableExpr.foldl(f)(foldableVarDef.foldl(f)(z)(m._1))(m._2);
      }
      if (m.tag === "LetRec") {
        return foldableExpr.foldl(f)((() => {
          const $3 = foldableElim.foldl(f);
          return fold((z$1) => (v) => $3(z$1))(z)(m._1);
        })())(m._2);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Var") {
        return z;
      }
      if (m.tag === "Op") {
        return z;
      }
      if (m.tag === "Int") {
        return f(m._1)(z);
      }
      if (m.tag === "Float") {
        return f(m._1)(z);
      }
      if (m.tag === "Str") {
        return f(m._1)(z);
      }
      if (m.tag === "Record") {
        return f(m._1)((() => {
          const $3 = foldableExpr.foldr(f);
          return foldrArray((b) => (a) => $3(a)(b))(z)(values(m._2));
        })());
      }
      if (m.tag === "Dictionary") {
        return f(m._1)(foldableList.foldr((() => {
          const $3 = foldableExpr.foldr(f);
          const $4 = foldrDefault(foldablePair)((b) => (a) => $3(a)(b));
          return (b) => (a) => $4(a)(b);
        })())(z)(m._2));
      }
      if (m.tag === "Constr") {
        return f(m._1)(foldableList.foldr((() => {
          const $3 = foldableExpr.foldr(f);
          return (b) => (a) => $3(a)(b);
        })())(z)(m._3));
      }
      if (m.tag === "Matrix") {
        return f(m._1)(foldableExpr.foldr(f)(foldableExpr.foldr(f)(z)(m._4))(m._2));
      }
      if (m.tag === "Lambda") {
        return foldableElim.foldr(f)(z)(m._1);
      }
      if (m.tag === "Project") {
        return foldableExpr.foldr(f)(z)(m._1);
      }
      if (m.tag === "App") {
        return foldableExpr.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1);
      }
      if (m.tag === "Let") {
        return foldableVarDef.foldr(f)(foldableExpr.foldr(f)(z)(m._2))(m._1);
      }
      if (m.tag === "LetRec") {
        const $3 = foldableElim.foldr(f);
        return foldrArray((b) => (a) => $3(a)(b))(foldableExpr.foldr(f)(z)(m._2))(values(m._1));
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const append = dictMonoid.Semigroup0().append;
      const foldMap1 = foldMap(dictMonoid);
      const foldMap4 = foldableList.foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "Var") {
          return dictMonoid.mempty;
        }
        if (m.tag === "Op") {
          return dictMonoid.mempty;
        }
        if (m.tag === "Int") {
          return f(m._1);
        }
        if (m.tag === "Float") {
          return f(m._1);
        }
        if (m.tag === "Str") {
          return f(m._1);
        }
        if (m.tag === "Record") {
          return append(f(m._1))((() => {
            const $6 = foldableExpr.foldMap(dictMonoid)(f);
            return foldMap1((v) => $6)(m._2);
          })());
        }
        if (m.tag === "Dictionary") {
          return append(f(m._1))(foldMap4(foldablePair.foldMap(dictMonoid)(foldableExpr.foldMap(dictMonoid)(f)))(m._2));
        }
        if (m.tag === "Constr") {
          return append(f(m._1))(foldMap4(foldableExpr.foldMap(dictMonoid)(f))(m._3));
        }
        if (m.tag === "Matrix") {
          return append(f(m._1))(append(foldableExpr.foldMap(dictMonoid)(f)(m._2))(foldableExpr.foldMap(dictMonoid)(f)(m._4)));
        }
        if (m.tag === "Lambda") {
          return foldableElim.foldMap(dictMonoid)(f)(m._1);
        }
        if (m.tag === "Project") {
          return foldableExpr.foldMap(dictMonoid)(f)(m._1);
        }
        if (m.tag === "App") {
          return append(foldableExpr.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "Let") {
          return append(foldableVarDef.foldMap(dictMonoid)(f)(m._1))(foldableExpr.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "LetRec") {
          return append((() => {
            const $6 = foldableElim.foldMap(dictMonoid)(f);
            return foldMap1((v) => $6)(m._1);
          })())(foldableExpr.foldMap(dictMonoid)(f)(m._2));
        }
        fail();
      };
    }
  };
  var foldableElim = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "ElimVar") {
        return foldableCont.foldl(f)(z)(m._2);
      }
      if (m.tag === "ElimConstr") {
        const $3 = foldableCont.foldl(f);
        return fold((z$1) => (v) => $3(z$1))(z)(m._1);
      }
      if (m.tag === "ElimRecord") {
        return foldableCont.foldl(f)(z)(m._2);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "ElimVar") {
        return foldableCont.foldr(f)(z)(m._2);
      }
      if (m.tag === "ElimConstr") {
        const $3 = foldableCont.foldr(f);
        return foldrArray((b) => (a) => $3(a)(b))(z)(values(m._1));
      }
      if (m.tag === "ElimRecord") {
        return foldableCont.foldr(f)(z)(m._2);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const foldMap1 = foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "ElimVar") {
          return foldableCont.foldMap(dictMonoid)(f)(m._2);
        }
        if (m.tag === "ElimConstr") {
          const $4 = foldableCont.foldMap(dictMonoid)(f);
          return foldMap1((v) => $4)(m._1);
        }
        if (m.tag === "ElimRecord") {
          return foldableCont.foldMap(dictMonoid)(f)(m._2);
        }
        fail();
      };
    }
  };
  var foldableCont = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "ContNone") {
        return z;
      }
      if (m.tag === "ContExpr") {
        return foldableExpr.foldl(f)(z)(m._1);
      }
      if (m.tag === "ContElim") {
        return foldableElim.foldl(f)(z)(m._1);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "ContNone") {
        return z;
      }
      if (m.tag === "ContExpr") {
        return foldableExpr.foldr(f)(z)(m._1);
      }
      if (m.tag === "ContElim") {
        return foldableElim.foldr(f)(z)(m._1);
      }
      fail();
    },
    foldMap: (dictMonoid) => (f) => (m) => {
      if (m.tag === "ContNone") {
        return dictMonoid.mempty;
      }
      if (m.tag === "ContExpr") {
        return foldableExpr.foldMap(dictMonoid)(f)(m._1);
      }
      if (m.tag === "ContElim") {
        return foldableElim.foldMap(dictMonoid)(f)(m._1);
      }
      fail();
    }
  };
  var traversableVarDef = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map8 = Apply0.Functor0().map;
      return (f) => (m) => Apply0.apply(map8((v2) => (v3) => $VarDef(v2, v3))(traversableElim.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
    },
    sequence: (dictApplicative) => (v) => traversableVarDef.traverse(dictApplicative)(identity16)(v),
    Functor0: () => functorVarDef,
    Foldable1: () => foldableVarDef
  };
  var traversableExpr = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map8 = Apply0.Functor0().map;
      const $3 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      const traverse62 = traversableList.traverse(dictApplicative);
      const traverse7 = traversablePair.traverse(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "Var") {
          return dictApplicative.pure($Expr("Var", m._1));
        }
        if (m.tag === "Op") {
          return dictApplicative.pure($Expr("Op", m._1));
        }
        if (m.tag === "Int") {
          return map8((v2) => $Expr("Int", v2, m._2))(f(m._1));
        }
        if (m.tag === "Float") {
          return map8((v2) => $Expr("Float", v2, m._2))(f(m._1));
        }
        if (m.tag === "Str") {
          return map8((v2) => $Expr("Str", v2, m._2))(f(m._1));
        }
        if (m.tag === "Record") {
          return Apply0.apply(map8((v2) => (v3) => $Expr("Record", v2, v3))(f(m._1)))((() => {
            const $8 = traversableExpr.traverse(dictApplicative)(f);
            return $3((v) => $8)(m._2);
          })());
        }
        if (m.tag === "Dictionary") {
          return Apply0.apply(map8((v2) => (v3) => $Expr("Dictionary", v2, v3))(f(m._1)))(traverse62(traverse7(traversableExpr.traverse(dictApplicative)(f)))(m._2));
        }
        if (m.tag === "Constr") {
          return Apply0.apply(map8((v3) => (v4) => $Expr("Constr", v3, m._2, v4))(f(m._1)))(traverse62(traversableExpr.traverse(dictApplicative)(f))(m._3));
        }
        if (m.tag === "Matrix") {
          return Apply0.apply(Apply0.apply(map8((v4) => (v5) => (v6) => $Expr("Matrix", v4, v5, m._3, v6))(f(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2)))(traversableExpr.traverse(dictApplicative)(f)(m._4));
        }
        if (m.tag === "Lambda") {
          return map8((v1) => $Expr("Lambda", v1))(traversableElim.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "Project") {
          return map8((v2) => $Expr("Project", v2, m._2))(traversableExpr.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "App") {
          return Apply0.apply(map8((v2) => (v3) => $Expr("App", v2, v3))(traversableExpr.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "Let") {
          return Apply0.apply(map8((v2) => (v3) => $Expr("Let", v2, v3))(traversableVarDef.traverse(dictApplicative)(f)(m._1)))(traversableExpr.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "LetRec") {
          return Apply0.apply(map8((v2) => (v3) => $Expr("LetRec", v2, v3))((() => {
            const $8 = traversableElim.traverse(dictApplicative)(f);
            return $3((v) => $8)(m._1);
          })()))(traversableExpr.traverse(dictApplicative)(f)(m._2));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableExpr.traverse(dictApplicative)(identity16)(v),
    Functor0: () => functorExpr,
    Foldable1: () => foldableExpr
  };
  var traversableElim = {
    traverse: (dictApplicative) => {
      const map8 = dictApplicative.Apply0().Functor0().map;
      const $2 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "ElimVar") {
          return map8((v2) => $Elim("ElimVar", m._1, v2))(traversableCont.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "ElimConstr") {
          return map8((v1) => $Elim("ElimConstr", v1))((() => {
            const $5 = traversableCont.traverse(dictApplicative)(f);
            return $2((v) => $5)(m._1);
          })());
        }
        if (m.tag === "ElimRecord") {
          return map8((v2) => $Elim("ElimRecord", m._1, v2))(traversableCont.traverse(dictApplicative)(f)(m._2));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableElim.traverse(dictApplicative)(identity16)(v),
    Functor0: () => functorElim,
    Foldable1: () => foldableElim
  };
  var traversableCont = {
    traverse: (dictApplicative) => {
      const map8 = dictApplicative.Apply0().Functor0().map;
      return (f) => (m) => {
        if (m.tag === "ContNone") {
          return dictApplicative.pure(ContNone);
        }
        if (m.tag === "ContExpr") {
          return map8((v1) => $Cont("ContExpr", v1))(traversableExpr.traverse(dictApplicative)(f)(m._1));
        }
        if (m.tag === "ContElim") {
          return map8((v1) => $Cont("ContElim", v1))(traversableElim.traverse(dictApplicative)(f)(m._1));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableCont.traverse(dictApplicative)(identity16)(v),
    Functor0: () => functorCont,
    Foldable1: () => foldableCont
  };
  var expandableVarDefRawVarDef = (dictBoundedJoinSemilattice) => ({ expand: (v) => (v1) => $VarDef(expandableElimRawElim(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2)) });
  var expandableExprRawExpr = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => {
      if (v.tag === "Var") {
        if (v1.tag === "Var") {
          return $Expr("Var", mustEq(eqString)(showString)(v._1)(v1._1));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Op") {
        if (v1.tag === "Op") {
          return $Expr("Op", mustEq(eqString)(showString)(v._1)(v1._1));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          return $Expr("Int", v._1, mustEq(eqInt)(showInt)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          return $Expr("Str", v._1, mustEq(eqString)(showString)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          return $Expr("Float", v._1, mustEq(eqNumber)(showNumber)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          return $Expr(
            "Record",
            v._1,
            expandableDictDict({ botOf: functorExpr.map((v$1) => dictBoundedJoinSemilattice.bot) })(expandableExprRawExpr(dictBoundedJoinSemilattice)).expand(v._2)(v1._2)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          return $Expr("Dictionary", v._1, zipWith(expandablePairPair(expandableExprRawExpr(dictBoundedJoinSemilattice)).expand)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return $Expr(
            "Constr",
            v._1,
            mustEq(eqString)(showString)(v._2)(v1._2),
            zipWith(expandableExprRawExpr(dictBoundedJoinSemilattice).expand)(v._3)(v1._3)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return $Expr(
            "Matrix",
            v._1,
            expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2),
            $Tuple(mustEq(eqString)(showString)(v._3._1)(v1._3._1), mustEq(eqString)(showString)(v._3._2)(v1._3._2)),
            expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._4)(v1._4)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Lambda") {
        if (v1.tag === "Lambda") {
          return $Expr("Lambda", expandableElimRawElim(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Project") {
        if (v1.tag === "Project") {
          return $Expr("Project", expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._1)(v1._1), mustEq(eqString)(showString)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "App") {
        if (v1.tag === "App") {
          return $Expr("App", expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "Let") {
        if (v1.tag === "Let") {
          return $Expr("Let", expandableVarDefRawVarDef(dictBoundedJoinSemilattice).expand(v._1)(v1._1), expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      if (v.tag === "LetRec") {
        if (v1.tag === "LetRec") {
          return $Expr(
            "LetRec",
            expandableDictDict({ botOf: functorElim.map((v$1) => dictBoundedJoinSemilattice.bot) })(expandableElimRawElim(dictBoundedJoinSemilattice)).expand(v._1)(v1._1),
            expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._2)(v1._2)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible expressions")));
      }
      return unsafePerformEffect(throwException(error("Incompatible expressions")));
    }
  });
  var expandableElimRawElim = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => {
      if (v.tag === "ElimVar") {
        if (v1.tag === "ElimVar") {
          return $Elim("ElimVar", mustEq(eqString)(showString)(v._1)(v1._1), expandableContRawCont(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible eliminators")));
      }
      if (v.tag === "ElimConstr") {
        if (v1.tag === "ElimConstr") {
          return $Elim(
            "ElimConstr",
            expandableDictDict({ botOf: functorCont.map((v$1) => dictBoundedJoinSemilattice.bot) })(expandableContRawCont(dictBoundedJoinSemilattice)).expand(v._1)(v1._1)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible eliminators")));
      }
      if (v.tag === "ElimRecord") {
        if (v1.tag === "ElimRecord") {
          return $Elim("ElimRecord", mustEq(eqSet)(showSet2)(v._1)(v1._1), expandableContRawCont(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible eliminators")));
      }
      return unsafePerformEffect(throwException(error("Incompatible eliminators")));
    }
  });
  var expandableContRawCont = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => {
      if (v.tag === "ContNone") {
        if (v1.tag === "ContNone") {
          return ContNone;
        }
        return unsafePerformEffect(throwException(error("Incompatible continuations")));
      }
      if (v.tag === "ContExpr") {
        if (v1.tag === "ContExpr") {
          return $Cont("ContExpr", expandableExprRawExpr(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
        }
        return unsafePerformEffect(throwException(error("Incompatible continuations")));
      }
      if (v.tag === "ContElim") {
        if (v1.tag === "ContElim") {
          return $Cont("ContElim", expandableElimRawElim(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
        }
        return unsafePerformEffect(throwException(error("Incompatible continuations")));
      }
      return unsafePerformEffect(throwException(error("Incompatible continuations")));
    }
  });
  var traverseModule = (dictMonad) => {
    const Applicative0 = dictMonad.Applicative0();
    const bind = dictMonad.Bind1().bind;
    const traverse52 = traversableVarDef.traverse(Applicative0);
    const $4 = traversableWithIndexObject.traverseWithIndex(Applicative0);
    const traverse7 = traversableElim.traverse(Applicative0);
    return (v) => (v1) => {
      if (v1._1.tag === "Nil") {
        return Applicative0.pure($Module(Nil));
      }
      if (v1._1.tag === "Cons") {
        if (v1._1._1.tag === "Left") {
          return bind(traverse52(v)($VarDef(v1._1._1._1._1, v1._1._1._1._2)))((v2) => bind(traverseModule(dictMonad)(v)($Module(v1._1._2)))((v3) => Applicative0.pure($Module($List(
            "Cons",
            $Either("Left", $VarDef(v2._1, v2._2)),
            v3._1
          )))));
        }
        if (v1._1._1.tag === "Right") {
          return bind((() => {
            const $8 = traverse7(v);
            return $4((v$1) => $8)(v1._1._1._1);
          })())((\u03C1$p) => bind(traverseModule(dictMonad)(v)($Module(v1._1._2)))((v2) => Applicative0.pure($Module($List(
            "Cons",
            $Either("Right", \u03C1$p),
            v2._1
          )))));
        }
        fail();
      }
      fail();
    };
  };
  var fVDict = (dictFV) => ({ fv: (\u03C1) => difference3(ordString)(unions(_fmapObject(\u03C1, dictFV.fv)))(fromFoldable4(keys2(\u03C1))) });
  var bVElim = {
    bv: (v) => {
      if (v.tag === "ElimVar") {
        return unionWith(ordString)($$const)($Map(
          "Two",
          Leaf2,
          v._1,
          unit2,
          Leaf2
        ))(bVCont.bv(v._2));
      }
      if (v.tag === "ElimConstr") {
        return bVCont.bv(asSingletonMap(v._1)._2);
      }
      if (v.tag === "ElimRecord") {
        return bVCont.bv(v._2);
      }
      fail();
    }
  };
  var bVCont = {
    bv: (v) => {
      if (v.tag === "ContNone") {
        return Leaf2;
      }
      if (v.tag === "ContElim") {
        return bVElim.bv(v._1);
      }
      if (v.tag === "ContExpr") {
        return Leaf2;
      }
      fail();
    }
  };
  var fVExpr = {
    fv: (v) => {
      if (v.tag === "Var") {
        return $Map("Two", Leaf2, v._1, unit2, Leaf2);
      }
      if (v.tag === "Op") {
        return $Map("Two", Leaf2, v._1, unit2, Leaf2);
      }
      if (v.tag === "Int") {
        return Leaf2;
      }
      if (v.tag === "Float") {
        return Leaf2;
      }
      if (v.tag === "Str") {
        return Leaf2;
      }
      if (v.tag === "Record") {
        return unions(_fmapObject(v._2, fVExpr.fv));
      }
      if (v.tag === "Dictionary") {
        return unions1(listMap((x2) => unionWith(ordString)($$const)(Leaf2)(fVExpr.fv(x2._2)))(v._2));
      }
      if (v.tag === "Constr") {
        return unions1(listMap(fVExpr.fv)(v._3));
      }
      if (v.tag === "Matrix") {
        return unionWith(ordString)($$const)(fVExpr.fv(v._2))(fVExpr.fv(v._4));
      }
      if (v.tag === "Lambda") {
        return fVElim.fv(v._1);
      }
      if (v.tag === "Project") {
        return fVExpr.fv(v._1);
      }
      if (v.tag === "App") {
        return unionWith(ordString)($$const)(fVExpr.fv(v._1))(fVExpr.fv(v._2));
      }
      if (v.tag === "Let") {
        return unionWith(ordString)($$const)(fVExpr.fv(v._1._2))(difference3(ordString)(fVExpr.fv(v._2))(bVElim.bv(v._1._1)));
      }
      if (v.tag === "LetRec") {
        return unionWith(ordString)($$const)(unions(_fmapObject(v._1, fVElim.fv)))(fVExpr.fv(v._2));
      }
      fail();
    }
  };
  var fVElim = {
    fv: (v) => {
      if (v.tag === "ElimVar") {
        return difference3(ordString)(fVCont.fv(v._2))($Map("Two", Leaf2, v._1, unit2, Leaf2));
      }
      if (v.tag === "ElimConstr") {
        return unions(_fmapObject(v._1, fVCont.fv));
      }
      if (v.tag === "ElimRecord") {
        return fVCont.fv(v._2);
      }
      fail();
    }
  };
  var fVCont = {
    fv: (v) => {
      if (v.tag === "ContNone") {
        return Leaf2;
      }
      if (v.tag === "ContElim") {
        return fVElim.fv(v._1);
      }
      if (v.tag === "ContExpr") {
        return fVExpr.fv(v._1);
      }
      fail();
    }
  };

  // output-es/SExpr/index.js
  var $Expr2 = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $ListRest = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $ListRestPattern = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Module2 = (_1) => ({ tag: "Module", _1 });
  var $Pattern = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Qualifier = (tag, _1, _2) => ({ tag, _1, _2 });
  var $VarDef2 = (_1, _2) => ({ tag: "VarDef", _1, _2 });
  var difference4 = /* @__PURE__ */ difference(eqString);
  var toUnfoldable7 = /* @__PURE__ */ toUnfoldable4(unfoldableList);
  var fromFoldable5 = /* @__PURE__ */ fromFoldable2(foldableNonEmptyList);
  var fromFoldable13 = /* @__PURE__ */ fromFoldable2(foldableList);
  var fromFoldable22 = /* @__PURE__ */ fromFoldable2(foldableArray);
  var traverse = /* @__PURE__ */ (() => traversableNonEmptyList.traverse(applicativeEither))();
  var traverse1 = /* @__PURE__ */ (() => traversableList.traverse(applicativeEither))();
  var traverse2 = /* @__PURE__ */ (() => traversableTuple.traverse(applicativeEither))();
  var traverse3 = /* @__PURE__ */ (() => traversablePair.traverse(applicativeEither))();
  var foldM4 = (f) => (b0) => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = bindEither.bind(b)((a) => f(a)(v._1));
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go($Either("Right", b0));
  };
  var PEnd = /* @__PURE__ */ $ListRestPattern("PEnd");
  var PNext = (value0) => (value1) => $ListRestPattern("PNext", value0, value1);
  var PConstr = (value0) => (value1) => $Pattern("PConstr", value0, value1);
  var PListEmpty = /* @__PURE__ */ $Pattern("PListEmpty");
  var PListNonEmpty = (value0) => (value1) => $Pattern("PListNonEmpty", value0, value1);
  var Int2 = (value0) => (value1) => $Expr2("Int", value0, value1);
  var Float2 = (value0) => (value1) => $Expr2("Float", value0, value1);
  var Str2 = (value0) => (value1) => $Expr2("Str", value0, value1);
  var Constr2 = (value0) => (value1) => (value2) => $Expr2("Constr", value0, value1, value2);
  var Record2 = (value0) => (value1) => $Expr2("Record", value0, value1);
  var Dictionary2 = (value0) => (value1) => $Expr2("Dictionary", value0, value1);
  var Matrix2 = (value0) => (value1) => (value2) => (value3) => $Expr2("Matrix", value0, value1, value2, value3);
  var App3 = (value0) => (value1) => $Expr2("App", value0, value1);
  var MatchAs = (value0) => (value1) => $Expr2("MatchAs", value0, value1);
  var IfElse = (value0) => (value1) => (value2) => $Expr2("IfElse", value0, value1, value2);
  var ListNonEmpty = (value0) => (value1) => (value2) => $Expr2("ListNonEmpty", value0, value1, value2);
  var ListEnum = (value0) => (value1) => $Expr2("ListEnum", value0, value1);
  var ListComp = (value0) => (value1) => (value2) => $Expr2("ListComp", value0, value1, value2);
  var Let2 = (value0) => (value1) => $Expr2("Let", value0, value1);
  var LetRec2 = (value0) => (value1) => $Expr2("LetRec", value0, value1);
  var Next = (value0) => (value1) => (value2) => $ListRest("Next", value0, value1, value2);
  var $$Generator = (value0) => (value1) => $Qualifier("Generator", value0, value1);
  var VarDef2 = (value0) => (value1) => $VarDef2(value0, value1);
  var RecDef = (x2) => x2;
  var functorVarDef2 = { map: (f) => (m) => $VarDef2(m._1, functorExpr2.map(f)(m._2)) };
  var functorQualifier = {
    map: (f) => (m) => {
      if (m.tag === "Guard") {
        return $Qualifier("Guard", functorExpr2.map(f)(m._1));
      }
      if (m.tag === "Generator") {
        return $Qualifier("Generator", m._1, functorExpr2.map(f)(m._2));
      }
      if (m.tag === "Declaration") {
        return $Qualifier("Declaration", $VarDef2(m._1._1, functorExpr2.map(f)(m._1._2)));
      }
      fail();
    }
  };
  var functorListRest = {
    map: (f) => (m) => {
      if (m.tag === "End") {
        return $ListRest("End", f(m._1));
      }
      if (m.tag === "Next") {
        return $ListRest("Next", f(m._1), functorExpr2.map(f)(m._2), functorListRest.map(f)(m._3));
      }
      fail();
    }
  };
  var functorExpr2 = {
    map: (f) => (m) => {
      if (m.tag === "Var") {
        return $Expr2("Var", m._1);
      }
      if (m.tag === "Op") {
        return $Expr2("Op", m._1);
      }
      if (m.tag === "Int") {
        return $Expr2("Int", f(m._1), m._2);
      }
      if (m.tag === "Float") {
        return $Expr2("Float", f(m._1), m._2);
      }
      if (m.tag === "Str") {
        return $Expr2("Str", f(m._1), m._2);
      }
      if (m.tag === "Constr") {
        return $Expr2("Constr", f(m._1), m._2, listMap(functorExpr2.map(f))(m._3));
      }
      if (m.tag === "Record") {
        return $Expr2("Record", f(m._1), listMap(functorTuple.map(functorExpr2.map(f)))(m._2));
      }
      if (m.tag === "Dictionary") {
        return $Expr2("Dictionary", f(m._1), listMap(functorPair.map(functorExpr2.map(f)))(m._2));
      }
      if (m.tag === "Matrix") {
        return $Expr2("Matrix", f(m._1), functorExpr2.map(f)(m._2), m._3, functorExpr2.map(f)(m._4));
      }
      if (m.tag === "Lambda") {
        return $Expr2("Lambda", functorClauses.map(f)(m._1));
      }
      if (m.tag === "Project") {
        return $Expr2("Project", functorExpr2.map(f)(m._1), m._2);
      }
      if (m.tag === "App") {
        return $Expr2("App", functorExpr2.map(f)(m._1), functorExpr2.map(f)(m._2));
      }
      if (m.tag === "BinaryApp") {
        return $Expr2("BinaryApp", functorExpr2.map(f)(m._1), m._2, functorExpr2.map(f)(m._3));
      }
      if (m.tag === "MatchAs") {
        return $Expr2("MatchAs", functorExpr2.map(f)(m._1), functorNonEmptyList.map(functorTuple.map(functorExpr2.map(f)))(m._2));
      }
      if (m.tag === "IfElse") {
        return $Expr2("IfElse", functorExpr2.map(f)(m._1), functorExpr2.map(f)(m._2), functorExpr2.map(f)(m._3));
      }
      if (m.tag === "ListEmpty") {
        return $Expr2("ListEmpty", f(m._1));
      }
      if (m.tag === "ListNonEmpty") {
        return $Expr2("ListNonEmpty", f(m._1), functorExpr2.map(f)(m._2), functorListRest.map(f)(m._3));
      }
      if (m.tag === "ListEnum") {
        return $Expr2("ListEnum", functorExpr2.map(f)(m._1), functorExpr2.map(f)(m._2));
      }
      if (m.tag === "ListComp") {
        return $Expr2("ListComp", f(m._1), functorExpr2.map(f)(m._2), listMap(functorQualifier.map(f))(m._3));
      }
      if (m.tag === "Let") {
        return $Expr2("Let", functorNonEmptyList.map(functorVarDef2.map(f))(m._1), functorExpr2.map(f)(m._2));
      }
      if (m.tag === "LetRec") {
        return $Expr2("LetRec", functorNonEmptyList.map(functorTuple.map(functorClause.map(f)))(m._1), functorExpr2.map(f)(m._2));
      }
      fail();
    }
  };
  var functorClauses = { map: (f) => (m) => functorNonEmptyList.map(functorClause.map(f))(m) };
  var functorClause = { map: (f) => (m) => $Tuple(m._1, functorExpr2.map(f)(m._2)) };
  var pattCont_ListRest_Fwd = (v) => (v1) => {
    if (v.tag === "PEnd") {
      return $Either(
        "Right",
        $Elim("ElimConstr", runST(bind_(newImpl)(poke3("Nil")(v1))))
      );
    }
    if (v.tag === "PNext") {
      const $2 = pattArgsFwd($List(
        "Cons",
        $Either("Left", v._1),
        $List("Cons", $Either("Right", v._2), Nil)
      ))(v1);
      if ($2.tag === "Left") {
        return $Either("Left", $2._1);
      }
      if ($2.tag === "Right") {
        return $Either(
          "Right",
          $Elim("ElimConstr", runST(bind_(newImpl)(poke3(":")($2._1))))
        );
      }
      fail();
    }
    fail();
  };
  var pattContFwd = (v) => (v1) => {
    if (v.tag === "PVar") {
      return $Either("Right", $Elim("ElimVar", v._1, v1));
    }
    if (v.tag === "PConstr") {
      const $2 = checkArity(v._1)((() => {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v$1 = go$a1;
            if (v$1.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v$1.tag === "Cons") {
              go$a0 = b + 1 | 0;
              go$a1 = v$1._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(0)(v._2);
      })());
      const $3 = pattArgsFwd(listMap(Left)(v._2))(v1);
      return applyEither.apply((() => {
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", identity4);
        }
        fail();
      })())((() => {
        if ($3.tag === "Left") {
          return $Either("Left", $3._1);
        }
        if ($3.tag === "Right") {
          return $Either(
            "Right",
            $Elim("ElimConstr", runST(bind_(newImpl)(poke3(v._1)($3._1))))
          );
        }
        fail();
      })());
    }
    if (v.tag === "PRecord") {
      const $2 = ElimRecord(keys3(v._1));
      const $3 = pattArgsFwd(listMap((x2) => $Either("Left", x2._2))(sortBy((x2) => (y2) => ordString.compare(x2._1)(y2._1))(v._1)))(v1);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", $2($3._1));
      }
      fail();
    }
    if (v.tag === "PListEmpty") {
      return $Either(
        "Right",
        $Elim("ElimConstr", runST(bind_(newImpl)(poke3("Nil")(v1))))
      );
    }
    if (v.tag === "PListNonEmpty") {
      const $2 = pattArgsFwd($List(
        "Cons",
        $Either("Left", v._1),
        $List("Cons", $Either("Right", v._2), Nil)
      ))(v1);
      if ($2.tag === "Left") {
        return $Either("Left", $2._1);
      }
      if ($2.tag === "Right") {
        return $Either(
          "Right",
          $Elim("ElimConstr", runST(bind_(newImpl)(poke3(":")($2._1))))
        );
      }
      fail();
    }
    fail();
  };
  var pattArgsFwd = (v) => (v1) => {
    if (v.tag === "Nil") {
      return $Either("Right", v1);
    }
    if (v.tag === "Cons") {
      if (v._1.tag === "Left") {
        const $2 = bindEither.bind(pattArgsFwd(v._2)(v1))(pattContFwd(v._1._1));
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", $Cont("ContElim", $2._1));
        }
        fail();
      }
      if (v._1.tag === "Right") {
        const $2 = bindEither.bind(pattArgsFwd(v._2)(v1))(pattCont_ListRest_Fwd(v._1._1));
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", $Cont("ContElim", $2._1));
        }
        fail();
      }
      fail();
    }
    fail();
  };
  var unlessFwd = (v) => (\u03B1) => fromFoldable13($List(
    "Cons",
    $Tuple(v._1, v._2),
    listMap((c$p) => $Tuple(
      c$p,
      (() => {
        const $3 = ElimVar("_");
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const n = go$a0, acc = go$a1;
            if (n <= 0) {
              go$c = false;
              go$r = acc;
              continue;
            }
            go$a0 = n - 1 | 0;
            go$a1 = $Cont("ContElim", $3(acc));
            continue;
          }
          ;
          return go$r;
        };
        return go(successful(arity(c$p)))($Cont("ContExpr", $Expr("Constr", \u03B1, "Nil", Nil)));
      })()
    ))(difference4(toUnfoldable7(fromFoldable12(keys2(successful(dataTypeForCtr.dataTypeFor(v._1))._2))))($List(
      "Cons",
      v._1,
      Nil
    )))
  ));
  var orElseFwd = (v) => (v1) => {
    if (v.tag === "ContNone") {
      return unsafePerformEffect(throwException(error("absurd")));
    }
    if (v.tag === "ContExpr") {
      return $Cont("ContExpr", v._1);
    }
    if (v.tag === "ContElim") {
      if (v._1.tag === "ElimConstr") {
        const v2 = asSingletonMap(v._1._1);
        return $Cont("ContElim", $Elim("ElimConstr", unlessFwd($Tuple(v2._1, orElseFwd(v2._2)(v1)))(v1)));
      }
      if (v._1.tag === "ElimRecord") {
        return $Cont("ContElim", $Elim("ElimRecord", v._1._1, orElseFwd(v._1._2)(v1)));
      }
      if (v._1.tag === "ElimVar") {
        return $Cont("ContElim", $Elim("ElimVar", v._1._1, orElseFwd(v._1._2)(v1)));
      }
      fail();
    }
    fail();
  };
  var elimBool = (\u03BA) => (\u03BA$p) => $Elim("ElimConstr", fromFoldable22([$Tuple("True", \u03BA), $Tuple("False", \u03BA$p)]));
  var econs = (\u03B1) => (e) => (e$p) => $Expr("Constr", \u03B1, ":", $List("Cons", e, $List("Cons", e$p, Nil)));
  var varDefsFwd = (dictJoinSemilattice) => (v) => {
    if (v._1._2.tag === "Nil") {
      return applyEither.apply((() => {
        const $2 = varDefFwd(dictJoinSemilattice)(v._1._1);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", Let($2._1));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._2));
    }
    if (v._1._2.tag === "Cons") {
      return applyEither.apply((() => {
        const $2 = varDefFwd(dictJoinSemilattice)(v._1._1);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", Let($2._1));
        }
        fail();
      })())(varDefsFwd(dictJoinSemilattice)($Tuple($NonEmpty(v._1._2._1, v._1._2._2), v._2)));
    }
    fail();
  };
  var varDefFwd = (dictJoinSemilattice) => (v) => applyEither.apply((() => {
    const $2 = pattContFwd(v._1)(ContNone);
    if ($2.tag === "Left") {
      return $Either("Left", $2._1);
    }
    if ($2.tag === "Right") {
      return $Either("Right", VarDef($2._1));
    }
    fail();
  })())(exprFwd(dictJoinSemilattice)(v._2));
  var recDefsFwd = (dictJoinSemilattice) => (xcs) => {
    const $2 = traverse(recDefFwd(dictJoinSemilattice))(functorNonEmptyList.map(RecDef)(wrappedOperation("groupBy")(groupBy((x2) => (y2) => x2._1 === y2._1))(xcs)));
    if ($2.tag === "Left") {
      return $Either("Left", $2._1);
    }
    if ($2.tag === "Right") {
      return $Either("Right", fromFoldable5($2._1));
    }
    fail();
  };
  var recDefFwd = (dictJoinSemilattice) => (xcs) => {
    const $2 = clausesFwd(dictJoinSemilattice)(functorNonEmptyList.map(snd)(xcs));
    if ($2.tag === "Left") {
      return $Either("Left", $2._1);
    }
    if ($2.tag === "Right") {
      return $Either("Right", $Tuple(xcs._1._1, $2._1));
    }
    fail();
  };
  var pattsExprFwd = (dictJoinSemilattice) => (v) => {
    if (v._1._2.tag === "Nil") {
      return bindEither.bind((() => {
        const $2 = exprFwd(dictJoinSemilattice)(v._2);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", $Cont("ContExpr", $2._1));
        }
        fail();
      })())(pattContFwd(v._1._1));
    }
    if (v._1._2.tag === "Cons") {
      return bindEither.bind((() => {
        const $2 = pattsExprFwd(dictJoinSemilattice)($Tuple($NonEmpty(v._1._2._1, v._1._2._2), v._2));
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", $Cont("ContExpr", $Expr("Lambda", $2._1)));
        }
        fail();
      })())(pattContFwd(v._1._1));
    }
    fail();
  };
  var listRestFwd = (dictJoinSemilattice) => (v) => {
    if (v.tag === "End") {
      return $Either("Right", $Expr("Constr", v._1, "Nil", Nil));
    }
    if (v.tag === "Next") {
      return applyEither.apply((() => {
        const $2 = exprFwd(dictJoinSemilattice)(v._2);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", econs(v._1)($2._1));
        }
        fail();
      })())(listRestFwd(dictJoinSemilattice)(v._3));
    }
    fail();
  };
  var listCompFwd = (dictJoinSemilattice) => (v) => {
    if (v._2._1.tag === "Nil") {
      const $2 = exprFwd(dictJoinSemilattice)(v._2._2);
      if ($2.tag === "Left") {
        return $Either("Left", $2._1);
      }
      if ($2.tag === "Right") {
        return $Either(
          "Right",
          $Expr(
            "Constr",
            v._1,
            ":",
            $List("Cons", $2._1, $List("Cons", $Expr("Constr", v._1, "Nil", Nil), Nil))
          )
        );
      }
      fail();
    }
    if (v._2._1.tag === "Cons") {
      if (v._2._1._1.tag === "Guard") {
        return bindEither.bind(listCompFwd(dictJoinSemilattice)($Tuple(v._1, $Tuple(v._2._1._2, v._2._2))))((e) => {
          const $3 = App2($Expr(
            "Lambda",
            $Elim(
              "ElimConstr",
              fromFoldable22([
                $Tuple("True", $Cont("ContExpr", e)),
                $Tuple("False", $Cont("ContExpr", $Expr("Constr", v._1, "Nil", Nil)))
              ])
            )
          ));
          const $4 = exprFwd(dictJoinSemilattice)(v._2._1._1._1);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        });
      }
      if (v._2._1._1.tag === "Declaration") {
        return bindEither.bind((() => {
          const $2 = listCompFwd(dictJoinSemilattice)($Tuple(v._1, $Tuple(v._2._1._2, v._2._2)));
          if ($2.tag === "Left") {
            return $Either("Left", $2._1);
          }
          if ($2.tag === "Right") {
            return $Either("Right", $Cont("ContExpr", $2._1));
          }
          fail();
        })())((e) => bindEither.bind(pattContFwd(v._2._1._1._1._1)(e))((\u03C3) => {
          const $4 = App2($Expr("Lambda", \u03C3));
          const $5 = exprFwd(dictJoinSemilattice)(v._2._1._1._1._2);
          if ($5.tag === "Left") {
            return $Either("Left", $5._1);
          }
          if ($5.tag === "Right") {
            return $Either("Right", $4($5._1));
          }
          fail();
        }));
      }
      if (v._2._1._1.tag === "Generator") {
        return bindEither.bind((() => {
          const $2 = listCompFwd(dictJoinSemilattice)($Tuple(v._1, $Tuple(v._2._1._2, v._2._2)));
          if ($2.tag === "Left") {
            return $Either("Left", $2._1);
          }
          if ($2.tag === "Right") {
            return $Either("Right", $Cont("ContExpr", $2._1));
          }
          fail();
        })())((e) => bindEither.bind(pattContFwd(v._2._1._1._1)(e))((\u03C3) => {
          const $4 = App2($Expr(
            "App",
            $Expr("Var", "concatMap"),
            $Expr(
              "Lambda",
              (() => {
                const $42 = orElseFwd($Cont("ContElim", \u03C3))(v._1);
                if ($42.tag === "ContElim") {
                  return $42._1;
                }
                return unsafePerformEffect(throwException(error("Eliminator expected")));
              })()
            )
          ));
          const $5 = exprFwd(dictJoinSemilattice)(v._2._1._1._2);
          if ($5.tag === "Left") {
            return $Either("Left", $5._1);
          }
          if ($5.tag === "Right") {
            return $Either("Right", $4($5._1));
          }
          fail();
        }));
      }
      fail();
    }
    fail();
  };
  var exprFwd = (dictJoinSemilattice) => (v) => {
    if (v.tag === "Var") {
      return $Either("Right", $Expr("Var", v._1));
    }
    if (v.tag === "Op") {
      return $Either("Right", $Expr("Op", v._1));
    }
    if (v.tag === "Int") {
      return $Either("Right", $Expr("Int", v._1, v._2));
    }
    if (v.tag === "Float") {
      return $Either("Right", $Expr("Float", v._1, v._2));
    }
    if (v.tag === "Str") {
      return $Either("Right", $Expr("Str", v._1, v._2));
    }
    if (v.tag === "Constr") {
      const $2 = Constr(v._1)(v._2);
      const $3 = traverse1(exprFwd(dictJoinSemilattice))(v._3);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", $2($3._1));
      }
      fail();
    }
    if (v.tag === "Record") {
      const $2 = Record(v._1);
      const $3 = traverse1(traverse2(exprFwd(dictJoinSemilattice)))(v._2);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", $2(fromFoldable13($3._1)));
      }
      fail();
    }
    if (v.tag === "Dictionary") {
      const $2 = Dictionary(v._1);
      const $3 = traverse1(traverse3(exprFwd(dictJoinSemilattice)))(v._2);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", $2($3._1));
      }
      fail();
    }
    if (v.tag === "Matrix") {
      return applyEither.apply((() => {
        const $2 = Matrix(v._1);
        const $3 = exprFwd(dictJoinSemilattice)(v._2);
        if ($3.tag === "Left") {
          return $Either("Left", $3._1);
        }
        if ($3.tag === "Right") {
          return $Either("Right", $2($3._1)($Tuple(v._3._1, v._3._2)));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._4));
    }
    if (v.tag === "Lambda") {
      const $2 = clausesFwd(dictJoinSemilattice)(v._1);
      if ($2.tag === "Left") {
        return $Either("Left", $2._1);
      }
      if ($2.tag === "Right") {
        return $Either("Right", $Expr("Lambda", $2._1));
      }
      fail();
    }
    if (v.tag === "Project") {
      const $2 = exprFwd(dictJoinSemilattice)(v._1);
      if ($2.tag === "Left") {
        return $Either("Left", $2._1);
      }
      if ($2.tag === "Right") {
        return $Either("Right", $Expr("Project", $2._1, v._2));
      }
      fail();
    }
    if (v.tag === "App") {
      return applyEither.apply((() => {
        const $2 = exprFwd(dictJoinSemilattice)(v._1);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", App2($2._1));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._2));
    }
    if (v.tag === "BinaryApp") {
      return applyEither.apply((() => {
        const $2 = App2($Expr("Op", v._2));
        const $3 = exprFwd(dictJoinSemilattice)(v._1);
        if ($3.tag === "Left") {
          return $Either("Left", $3._1);
        }
        if ($3.tag === "Right") {
          return $Either("Right", App2($2($3._1)));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._3));
    }
    if (v.tag === "MatchAs") {
      return applyEither.apply((() => {
        const $2 = clausesFwd(dictJoinSemilattice)(functorNonEmptyList.map((x2) => $Tuple($NonEmpty(x2._1, Nil), x2._2))(v._2));
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", App2($Expr("Lambda", $2._1)));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._1));
    }
    if (v.tag === "IfElse") {
      return applyEither.apply((() => {
        const $2 = applyEither.apply((() => {
          const $22 = exprFwd(dictJoinSemilattice)(v._2);
          if ($22.tag === "Left") {
            return $Either("Left", $22._1);
          }
          if ($22.tag === "Right") {
            return $Either("Right", elimBool($Cont("ContExpr", $22._1)));
          }
          fail();
        })())((() => {
          const $22 = exprFwd(dictJoinSemilattice)(v._3);
          if ($22.tag === "Left") {
            return $Either("Left", $22._1);
          }
          if ($22.tag === "Right") {
            return $Either("Right", $Cont("ContExpr", $22._1));
          }
          fail();
        })());
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", App2($Expr("Lambda", $2._1)));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._1));
    }
    if (v.tag === "ListEmpty") {
      return $Either("Right", $Expr("Constr", v._1, "Nil", Nil));
    }
    if (v.tag === "ListNonEmpty") {
      return applyEither.apply((() => {
        const $2 = exprFwd(dictJoinSemilattice)(v._2);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", econs(v._1)($2._1));
        }
        fail();
      })())(listRestFwd(dictJoinSemilattice)(v._3));
    }
    if (v.tag === "ListEnum") {
      return applyEither.apply((() => {
        const $2 = App2($Expr("Var", "enumFromTo"));
        const $3 = exprFwd(dictJoinSemilattice)(v._1);
        if ($3.tag === "Left") {
          return $Either("Left", $3._1);
        }
        if ($3.tag === "Right") {
          return $Either("Right", App2($2($3._1)));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._2));
    }
    if (v.tag === "ListComp") {
      return listCompFwd(dictJoinSemilattice)($Tuple(v._1, $Tuple(v._3, v._2)));
    }
    if (v.tag === "Let") {
      return varDefsFwd(dictJoinSemilattice)($Tuple(v._1, v._2));
    }
    if (v.tag === "LetRec") {
      return applyEither.apply((() => {
        const $2 = recDefsFwd(dictJoinSemilattice)(v._1);
        if ($2.tag === "Left") {
          return $Either("Left", $2._1);
        }
        if ($2.tag === "Right") {
          return $Either("Right", LetRec($2._1));
        }
        fail();
      })())(exprFwd(dictJoinSemilattice)(v._2));
    }
    fail();
  };
  var clausesFwd = (dictJoinSemilattice) => {
    const maybeJoin = joinSemilatticeElim(dictJoinSemilattice).maybeJoin;
    return (v) => bindEither.bind(traverse(pattsExprFwd(dictJoinSemilattice))(functorNonEmptyList.map(unsafeCoerce)(v)))((v1) => foldM4(maybeJoin)(v1._1)(v1._2));
  };
  var moduleFwd = (dictJoinSemilattice) => (v) => {
    const $2 = traverse1((v1) => {
      if (v1.tag === "Left") {
        const $3 = varDefFwd(dictJoinSemilattice)(v1._1);
        if ($3.tag === "Left") {
          return $Either("Left", $3._1);
        }
        if ($3.tag === "Right") {
          return $Either("Right", $Either("Left", $3._1));
        }
        fail();
      }
      if (v1.tag === "Right") {
        const $3 = recDefsFwd(dictJoinSemilattice)(v1._1);
        if ($3.tag === "Left") {
          return $Either("Left", $3._1);
        }
        if ($3.tag === "Right") {
          return $Either("Right", $Either("Right", $3._1));
        }
        fail();
      }
      fail();
    })(bindList.bind(listMap((v1) => {
      if (v1.tag === "Left") {
        return listMap(Left)($List("Cons", v1._1._1, v1._1._2));
      }
      if (v1.tag === "Right") {
        return $List("Cons", $Either("Right", v1._1), Nil);
      }
      fail();
    })(v._1))(identity5));
    if ($2.tag === "Left") {
      return $Either("Left", $2._1);
    }
    if ($2.tag === "Right") {
      return $Either("Right", $Module($2._1));
    }
    fail();
  };
  var desugarModuleFwd = (dictJoinSemilattice) => moduleFwd(dictJoinSemilattice);

  // output-es/Data.Semiring/foreign.js
  var intAdd = function(x2) {
    return function(y2) {
      return x2 + y2 | 0;
    };
  };
  var intMul = function(x2) {
    return function(y2) {
      return x2 * y2 | 0;
    };
  };
  var numAdd = function(n1) {
    return function(n2) {
      return n1 + n2;
    };
  };
  var numMul = function(n1) {
    return function(n2) {
      return n1 * n2;
    };
  };

  // output-es/Data.Ring/foreign.js
  var intSub = function(x2) {
    return function(y2) {
      return x2 - y2 | 0;
    };
  };
  var numSub = function(n1) {
    return function(n2) {
      return n1 - n2;
    };
  };

  // output-es/Data.EuclideanRing/foreign.js
  var intDiv = function(x2) {
    return function(y2) {
      if (y2 === 0)
        return 0;
      return y2 > 0 ? Math.floor(x2 / y2) : -Math.floor(x2 / -y2);
    };
  };
  var intMod = function(x2) {
    return function(y2) {
      if (y2 === 0)
        return 0;
      var yy = Math.abs(y2);
      return (x2 % yy + yy) % yy;
    };
  };
  var numDiv = function(n1) {
    return function(n2) {
      return n1 / n2;
    };
  };

  // output-es/Data.String.Common/foreign.js
  var split = function(sep) {
    return function(s) {
      return s.split(sep);
    };
  };
  var toLower = function(s) {
    return s.toLowerCase();
  };
  var joinWith = function(s) {
    return function(xs) {
      return xs.join(s);
    };
  };

  // output-es/Data.String.CodePoints/foreign.js
  var hasArrayFrom = typeof Array.from === "function";
  var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
  var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
  var hasCodePointAt = typeof String.prototype.codePointAt === "function";
  var _unsafeCodePointAt0 = function(fallback) {
    return hasCodePointAt ? function(str) {
      return str.codePointAt(0);
    } : fallback;
  };
  var _codePointAt = function(fallback) {
    return function(Just2) {
      return function(Nothing2) {
        return function(unsafeCodePointAt02) {
          return function(index3) {
            return function(str) {
              var length6 = str.length;
              if (index3 < 0 || index3 >= length6)
                return Nothing2;
              if (hasStringIterator) {
                var iter = str[Symbol.iterator]();
                for (var i = index3; ; --i) {
                  var o = iter.next();
                  if (o.done)
                    return Nothing2;
                  if (i === 0)
                    return Just2(unsafeCodePointAt02(o.value));
                }
              }
              return fallback(index3)(str);
            };
          };
        };
      };
    };
  };
  var _fromCodePointArray = function(singleton4) {
    return hasFromCodePoint ? function(cps) {
      if (cps.length < 1e4) {
        return String.fromCodePoint.apply(String, cps);
      }
      return cps.map(singleton4).join("");
    } : function(cps) {
      return cps.map(singleton4).join("");
    };
  };
  var _toCodePointArray = function(fallback) {
    return function(unsafeCodePointAt02) {
      if (hasArrayFrom) {
        return function(str) {
          return Array.from(str, unsafeCodePointAt02);
        };
      }
      return fallback;
    };
  };

  // output-es/Data.String.CodePoints/index.js
  var uncons3 = (s) => {
    const v = length3(s);
    if (v === 0) {
      return Nothing;
    }
    if (v === 1) {
      return $Maybe("Just", { head: toCharCode(charAt(0)(s)), tail: "" });
    }
    const cu1 = toCharCode(charAt(1)(s));
    const cu0 = toCharCode(charAt(0)(s));
    if (55296 <= cu0 && cu0 <= 56319 && (56320 <= cu1 && cu1 <= 57343)) {
      return $Maybe("Just", { head: (((cu0 - 55296 | 0) * 1024 | 0) + (cu1 - 56320 | 0) | 0) + 65536 | 0, tail: drop2(2)(s) });
    }
    return $Maybe("Just", { head: cu0, tail: drop2(1)(s) });
  };
  var unconsButWithTuple = (s) => {
    const $1 = uncons3(s);
    if ($1.tag === "Just") {
      return $Maybe("Just", $Tuple($1._1.head, $1._1.tail));
    }
    return Nothing;
  };
  var toCodePointArrayFallback = (s) => unfoldableArray.unfoldr(unconsButWithTuple)(s);
  var unsafeCodePointAt0Fallback = (s) => {
    const cu0 = toCharCode(charAt(0)(s));
    if (55296 <= cu0 && cu0 <= 56319 && length3(s) > 1) {
      const cu1 = toCharCode(charAt(1)(s));
      if (56320 <= cu1 && cu1 <= 57343) {
        return (((cu0 - 55296 | 0) * 1024 | 0) + (cu1 - 56320 | 0) | 0) + 65536 | 0;
      }
      return cu0;
    }
    return cu0;
  };
  var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
  var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
  var length4 = (x2) => toCodePointArray(x2).length;
  var fromCharCode2 = (x2) => singleton2((() => {
    if (x2 >= -2147483648 && x2 <= 2147483647) {
      return fromCharCode(x2);
    }
    if (x2 < 0) {
      return "\0";
    }
    return "\uFFFF";
  })());
  var singletonFallback = (v) => {
    if (v <= 65535) {
      return fromCharCode2(v);
    }
    return fromCharCode2(intDiv(v - 65536 | 0)(1024) + 55296 | 0) + fromCharCode2(intMod(v - 65536 | 0)(1024) + 56320 | 0);
  };
  var fromCodePointArray = /* @__PURE__ */ _fromCodePointArray(singletonFallback);
  var codePointAtFallback = (codePointAtFallback$a0$copy) => (codePointAtFallback$a1$copy) => {
    let codePointAtFallback$a0 = codePointAtFallback$a0$copy, codePointAtFallback$a1 = codePointAtFallback$a1$copy, codePointAtFallback$c = true, codePointAtFallback$r;
    while (codePointAtFallback$c) {
      const n = codePointAtFallback$a0, s = codePointAtFallback$a1;
      const v = uncons3(s);
      if (v.tag === "Just") {
        if (n === 0) {
          codePointAtFallback$c = false;
          codePointAtFallback$r = $Maybe("Just", v._1.head);
          continue;
        }
        codePointAtFallback$a0 = n - 1 | 0;
        codePointAtFallback$a1 = v._1.tail;
        continue;
      }
      codePointAtFallback$c = false;
      codePointAtFallback$r = Nothing;
      continue;
    }
    ;
    return codePointAtFallback$r;
  };
  var codePointAt2 = (v) => (v1) => {
    if (v < 0) {
      return Nothing;
    }
    if (v === 0) {
      if (v1 === "") {
        return Nothing;
      }
      return $Maybe("Just", unsafeCodePointAt0(v1));
    }
    return _codePointAt(codePointAtFallback)(Just)(Nothing)(unsafeCodePointAt0)(v)(v1);
  };

  // output-es/Util.Pretty/index.js
  var max3 = (x2) => (y2) => {
    const v = ordInt.compare(x2)(y2);
    if (v.tag === "LT") {
      return y2;
    }
    if (v.tag === "EQ") {
      return x2;
    }
    if (v.tag === "GT") {
      return x2;
    }
    fail();
  };
  var intercalate4 = (sep) => (xs) => foldlArray((v) => (v1) => {
    if (v.init) {
      return { init: false, acc: v1 };
    }
    return { init: false, acc: v.acc + (sep + v1) };
  })({ init: true, acc: "" })(xs).acc;
  var text = (s) => {
    const lines = split("\n")(s);
    return { width: foldlArray(max3)(0)(arrayMap(length4)(lines)), height: lines.length, lines };
  };
  var lastLine = (v) => {
    const $1 = index2(v.lines)(v.lines.length - 1 | 0);
    if ($1.tag === "Just") {
      return $1._1;
    }
    if ($1.tag === "Nothing") {
      return "";
    }
    fail();
  };
  var firstLine = (v) => {
    const $1 = index2(v.lines)(0);
    if ($1.tag === "Just") {
      return $1._1;
    }
    if ($1.tag === "Nothing") {
      return "";
    }
    fail();
  };
  var empty3 = (w) => (h) => ({
    width: w,
    height: h,
    lines: (() => {
      if (h === 0) {
        return [];
      }
      return arrayMap((v) => "")(range2(1)(h));
    })()
  });
  var atop = (v) => (v1) => ({ width: max3(v.width)(v1.width), height: v.height + v1.height | 0, lines: concatArray(v.lines)(v1.lines) });
  var allButLast = (v) => {
    const $1 = v.lines.length - 1 | 0;
    if ($1 < 1) {
      return [];
    }
    return slice3(0)($1)(v.lines);
  };
  var indentedExpression = (v) => (v1) => zipWith2(concatString)(replicate(unfoldableArray)(slice3(1)(v1.lines.length)(v1.lines).length)(foldlArray(concatString)("")(replicate(unfoldableArray)(toCodePointArray(lastLine(v)).length)(" "))))(slice3(1)(v1.lines.length)(v1.lines));
  var finalLines = (v) => (v1) => concatArray(allButLast(v))(concatArray([lastLine(v) + ("" + firstLine(v1))])(indentedExpression(v)(v1)));
  var beside = (v) => (v1) => ({ width: v.width + v1.width | 0, height: v.height + v1.height | 0, lines: finalLines(v)(v1) });
  var semigroupColumns = { append: (v) => (v1) => beside(v)(v1) };
  var monoidColumns = { mempty: /* @__PURE__ */ empty3(0)(0), Semigroup0: () => semigroupColumns };

  // output-es/Pretty/index.js
  var hcat = /* @__PURE__ */ (() => foldableList.foldMap(monoidColumns)(unsafeCoerce))();
  var toUnfoldable8 = /* @__PURE__ */ toUnfoldable4(unfoldableList);
  var toUnfoldable13 = /* @__PURE__ */ toAscUnfoldable(unfoldableList);
  var space2 = /* @__PURE__ */ text(" ");
  var semi = /* @__PURE__ */ text(";");
  var prettyP = (dictPretty) => (x2) => intercalate4("\n")(dictPretty.pretty(x2).lines);
  var nil2 = /* @__PURE__ */ text("[]");
  var hspace = (dictFoldable) => {
    const $1 = dictFoldable.foldr(Cons)(Nil);
    return (x2) => hcat(intercalate2($List("Cons", space2, Nil))(listMap(applicativeList.pure)($1(x2))));
  };
  var hspace1 = /* @__PURE__ */ hspace(foldableArray);
  var hspace2 = /* @__PURE__ */ hspace(foldableList);
  var emptyDoc = /* @__PURE__ */ empty3(0)(0);
  var vert = (dictFoldable) => {
    const fromFoldable11 = dictFoldable.foldr(Cons)(Nil);
    return (delim) => {
      const vert$p = (v) => {
        if (v.tag === "Nil") {
          return emptyDoc;
        }
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            return v._1;
          }
          if (v._2.tag === "Cons") {
            return atop(beside(v._1)(delim))(vert$p($List("Cons", v._2._1, v._2._2)));
          }
          fail();
        }
        fail();
      };
      return (x2) => vert$p(fromFoldable11(x2));
    };
  };
  var vert1 = /* @__PURE__ */ vert(foldableArray);
  var comma = /* @__PURE__ */ text(",");
  var hcomma = (dictFoldable) => {
    const $1 = dictFoldable.foldr(Cons)(Nil);
    const $2 = intersperse(beside(comma)(space2));
    return (x2) => hcat($2($1(x2)));
  };
  var hcomma1 = /* @__PURE__ */ hcomma(foldableList);
  var hcomma2 = /* @__PURE__ */ hcomma(foldableArray);
  var hcomma3 = /* @__PURE__ */ hcomma(foldableObject);
  var prettyRecordOrDict = (dictPretty) => (dictHighlightable) => (sep) => (bracify) => (prettyKey) => (\u03B1) => (xvs) => dictHighlightable.highlightIf(\u03B1)(bracify(hcomma1(listMap((v) => hspace1([
    beside(v._1)(sep),
    dictPretty.pretty(v._2)
  ]))(listMap(strongFn.first(prettyKey))(xvs)))));
  var between2 = (l) => (r) => (doc2) => beside(beside(l)(doc2))(r);
  var curlyBraces = /* @__PURE__ */ between2(/* @__PURE__ */ text("{"))(/* @__PURE__ */ text("}"));
  var prettyParensOpt = (dictPretty) => (x2) => {
    const doc2 = dictPretty.pretty(x2);
    if (contains2(" ")(intercalate4("\n")(doc2.lines))) {
      return beside(beside(text("("))(doc2))(text(")"));
    }
    return doc2;
  };
  var prettyConstr = (dictPretty) => (dictHighlightable) => (v) => (v1) => (v2) => {
    const $5 = (c, xs, \u03B1) => hspace2($List(
      "Cons",
      dictHighlightable.highlightIf(\u03B1)(text(showCtr(c))),
      listMap(prettyParensOpt(dictPretty))(xs)
    ));
    if (v2.tag === "Cons") {
      if (v2._2.tag === "Cons") {
        if (v1 === "Pair") {
          return (() => {
            if (v2._2._2.tag === "Nil") {
              return identity12;
            }
            return (v1$1) => unsafePerformEffect(throwException(error("Assertion failure")));
          })()(dictHighlightable.highlightIf(v)(beside(beside(text("("))(hcomma2([dictPretty.pretty(v2._1), dictPretty.pretty(v2._2._1)])))(text(")"))));
        }
        if (v1 === "Nil") {
          return (() => {
            if (v2.tag === "Nil") {
              return identity12;
            }
            return (v1$1) => unsafePerformEffect(throwException(error("Assertion failure")));
          })()(dictHighlightable.highlightIf(v)(nil2));
        }
        if (v1 === ":") {
          return (() => {
            if (v2._2._2.tag === "Nil") {
              return identity12;
            }
            return (v1$1) => unsafePerformEffect(throwException(error("Assertion failure")));
          })()(beside(beside(text("("))(hspace1([
            dictPretty.pretty(v2._1),
            dictHighlightable.highlightIf(v)(text(":")),
            dictPretty.pretty(v2._2._1)
          ])))(text(")")));
        }
        return $5(v1, v2, v);
      }
      if (v1 === "Nil") {
        return (() => {
          if (v2.tag === "Nil") {
            return identity12;
          }
          return (v1$1) => unsafePerformEffect(throwException(error("Assertion failure")));
        })()(dictHighlightable.highlightIf(v)(nil2));
      }
      return $5(v1, v2, v);
    }
    if (v1 === "Nil") {
      return (() => {
        if (v2.tag === "Nil") {
          return identity12;
        }
        return (v1$1) => unsafePerformEffect(throwException(error("Assertion failure")));
      })()(dictHighlightable.highlightIf(v)(nil2));
    }
    return $5(v1, v2, v);
  };
  var prettyDict = (dictPretty) => (dictHighlightable) => prettyRecordOrDict(dictPretty)(dictHighlightable)(text(":="))(between2(text("{|"))(text("|}")));
  var prettyVal = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "Int") {
        return dictHighlightable.highlightIf(v._1)(text(showIntImpl(v._2)));
      }
      if (v.tag === "Float") {
        return dictHighlightable.highlightIf(v._1)(text(showNumberImpl(v._2)));
      }
      if (v.tag === "Str") {
        return dictHighlightable.highlightIf(v._1)(text(showStringImpl(v._2)));
      }
      if (v.tag === "Record") {
        return prettyRecordOrDict(prettyVal(dictHighlightable))(dictHighlightable)(text(":"))(curlyBraces)(text)(v._1)(toUnfoldable13(v._2));
      }
      if (v.tag === "Dictionary") {
        return prettyDict(prettyVal(dictHighlightable))(dictHighlightable)((v1) => dictHighlightable.highlightIf(v1._2)(text(showStringImpl(v1._1))))(v._1)(listMap((v1) => $Tuple(
          $Tuple(v1._1, v1._2._1),
          v1._2._2
        ))(toUnfoldable13(v._2)));
      }
      if (v.tag === "Constr") {
        return prettyConstr(prettyVal(dictHighlightable))(dictHighlightable)(v._1)(v._2)(v._3);
      }
      if (v.tag === "Matrix") {
        return vert1(comma)(arrayMap((() => {
          const $2 = arrayMap(prettyVal(dictHighlightable).pretty);
          return (x2) => hcomma2($2(x2));
        })())(v._2._1));
      }
      if (v.tag === "Fun") {
        return prettyFun(dictHighlightable).pretty(v._1);
      }
      fail();
    }
  });
  var prettyFun = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "Closure") {
        return dictHighlightable.highlightIf(v._1)(text("<closure>"));
      }
      if (v.tag === "Foreign") {
        return text("<extern op>");
      }
      if (v.tag === "PartialConstr") {
        return prettyConstr(prettyVal(dictHighlightable))(dictHighlightable)(v._1)(v._2)(v._3);
      }
      fail();
    }
  });
  var prettyExpr = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "Var") {
        return text(v._1);
      }
      if (v.tag === "Int") {
        return dictHighlightable.highlightIf(v._1)(text(showIntImpl(v._2)));
      }
      if (v.tag === "Float") {
        return text(showNumberImpl(v._2));
      }
      if (v.tag === "Str") {
        return text(showStringImpl(v._2));
      }
      if (v.tag === "Record") {
        return prettyRecordOrDict(prettyExpr(dictHighlightable))(dictHighlightable)(text(":"))(curlyBraces)(text)(v._1)(toUnfoldable13(v._2));
      }
      if (v.tag === "Dictionary") {
        return prettyDict(prettyExpr(dictHighlightable))(dictHighlightable)(prettyExpr(dictHighlightable).pretty)(v._1)(listMap(toTuple)(v._2));
      }
      if (v.tag === "Constr") {
        return prettyConstr(prettyExpr(dictHighlightable))(dictHighlightable)(v._1)(v._2)(v._3);
      }
      if (v.tag === "Matrix") {
        return dictHighlightable.highlightIf(v._1)(prettyMatrix(dictHighlightable)(v._2)(v._3._1)(v._3._2)(v._4));
      }
      if (v.tag === "Lambda") {
        return hspace1([text("fun"), prettyElim(dictHighlightable).pretty(v._1)]);
      }
      if (v.tag === "Op") {
        return beside(beside(text("("))(text(v._1)))(text(")"));
      }
      if (v.tag === "Let") {
        return atop(hspace1([
          text("let"),
          prettyElim(dictHighlightable).pretty(v._1._1),
          text("="),
          prettyExpr(dictHighlightable).pretty(v._1._2),
          text("in")
        ]))(prettyExpr(dictHighlightable).pretty(v._2));
      }
      if (v.tag === "LetRec") {
        return atop(hspace1([text("let"), prettyDictElim(dictHighlightable).pretty(v._1), text("in")]))(prettyExpr(dictHighlightable).pretty(v._2));
      }
      if (v.tag === "Project") {
        return beside(beside(prettyExpr(dictHighlightable).pretty(v._1))(text(".")))(text(v._2));
      }
      if (v.tag === "App") {
        return hspace1([prettyExpr(dictHighlightable).pretty(v._1), prettyExpr(dictHighlightable).pretty(v._2)]);
      }
      fail();
    }
  });
  var prettyElim = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "ElimVar") {
        return hspace1([text(v._1), text("->"), prettyCont(dictHighlightable).pretty(v._2)]);
      }
      if (v.tag === "ElimConstr") {
        return hcomma3(_fmapObject(v._1, prettyCont(dictHighlightable).pretty));
      }
      if (v.tag === "ElimRecord") {
        return hspace1([
          beside(beside(text("{"))(hcomma1(listMap(text)(toUnfoldable8(v._1)))))(text("}")),
          text("->"),
          beside(beside(text("{"))(prettyCont(dictHighlightable).pretty(v._2)))(text("}"))
        ]);
      }
      fail();
    }
  });
  var prettyDictElim = (dictHighlightable) => ({
    pretty: (x2) => {
      const go = (v) => {
        if (v.tag === "Nil") {
          return unsafePerformEffect(throwException(error("absurd")));
        }
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            return prettyBindElim(dictHighlightable).pretty(v._1);
          }
          return atop(beside(go(v._2))(semi))(prettyBindElim(dictHighlightable).pretty(v._1));
        }
        fail();
      };
      return go(toUnfoldable13(x2));
    }
  });
  var prettyCont = (dictHighlightable) => ({
    pretty: (v) => {
      if (v.tag === "ContNone") {
        return emptyDoc;
      }
      if (v.tag === "ContExpr") {
        return prettyExpr(dictHighlightable).pretty(v._1);
      }
      if (v.tag === "ContElim") {
        return prettyElim(dictHighlightable).pretty(v._1);
      }
      fail();
    }
  });
  var prettyBindElim = (dictHighlightable) => ({ pretty: (v) => hspace1([text(v._1), text("="), prettyElim(dictHighlightable).pretty(v._2)]) });
  var prettyMatrix = (dictHighlightable) => (e1) => (i) => (j) => (e22) => beside(beside(text("[|"))(beside(beside(beside(beside(prettyExpr(dictHighlightable).pretty(e1))(text(" <- ")))(text(i + ("\xD7" + j))))(text(" in ")))(prettyExpr(dictHighlightable).pretty(e22))))(text("|]"));

  // output-es/Data.Bifoldable/index.js
  var bifoldableTuple = {
    bifoldMap: (dictMonoid) => {
      const append = dictMonoid.Semigroup0().append;
      return (f) => (g) => (v) => append(f(v._1))(g(v._2));
    },
    bifoldr: (f) => (g) => (z) => (v) => f(v._1)(g(v._2)(z)),
    bifoldl: (f) => (g) => (z) => (v) => g(f(z)(v._1))(v._2)
  };

  // output-es/Data.Bitraversable/index.js
  var bitraversableTuple = {
    bitraverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map6 = Apply0.Functor0().map;
      return (f) => (g) => (v) => Apply0.apply(map6(Tuple)(f(v._1)))(g(v._2));
    },
    bisequence: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map6 = Apply0.Functor0().map;
      return (v) => Apply0.apply(map6(Tuple)(v._1))(v._2);
    },
    Bifunctor0: () => bifunctorTuple,
    Bifoldable1: () => bifoldableTuple
  };

  // output-es/Val/index.js
  var $ForeignOp$p = (_1) => ({ tag: "ForeignOp'", _1 });
  var $Fun = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $Val = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var identity19 = (x2) => x2;
  var fromFoldable6 = /* @__PURE__ */ foldlArray((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2);
  var toUnfoldable9 = /* @__PURE__ */ toUnfoldable4(unfoldableList);
  var intersection2 = /* @__PURE__ */ intersection(ordString);
  var Int3 = (value0) => (value1) => $Val("Int", value0, value1);
  var Float3 = (value0) => (value1) => $Val("Float", value0, value1);
  var Str3 = (value0) => (value1) => $Val("Str", value0, value1);
  var Constr3 = (value0) => (value1) => (value2) => $Val("Constr", value0, value1, value2);
  var Record3 = (value0) => (value1) => $Val("Record", value0, value1);
  var Dictionary3 = (value0) => (value1) => $Val("Dictionary", value0, value1);
  var Matrix3 = (value0) => (value1) => $Val("Matrix", value0, value1);
  var Fun = (value0) => $Val("Fun", value0);
  var DictRep = (x2) => x2;
  var MatrixRep = (x2) => x2;
  var Closure = (value0) => (value1) => (value2) => (value3) => $Fun("Closure", value0, value1, value2, value3);
  var Foreign = (value0) => (value1) => $Fun("Foreign", value0, value1);
  var PartialConstr = (value0) => (value1) => (value2) => $Fun("PartialConstr", value0, value1, value2);
  var highlightableVertex = { highlightIf: (v) => (doc2) => beside(beside(doc2)(text("_")))(text("\u27E8" + (v + "\u27E9"))) };
  var highlightableUnit = { highlightIf: (v) => identity19 };
  var highlightableBoolean = {
    highlightIf: (v) => {
      if (!v) {
        return identity19;
      }
      if (v) {
        return (doc2) => beside(beside(text("_"))(doc2))(text("_"));
      }
      fail();
    }
  };
  var functorVal = {
    map: (f) => (m) => {
      if (m.tag === "Int") {
        return $Val("Int", f(m._1), m._2);
      }
      if (m.tag === "Float") {
        return $Val("Float", f(m._1), m._2);
      }
      if (m.tag === "Str") {
        return $Val("Str", f(m._1), m._2);
      }
      if (m.tag === "Constr") {
        return $Val("Constr", f(m._1), m._2, listMap(functorVal.map(f))(m._3));
      }
      if (m.tag === "Record") {
        return $Val("Record", f(m._1), _fmapObject(m._2, functorVal.map(f)));
      }
      if (m.tag === "Dictionary") {
        return $Val("Dictionary", f(m._1), functorDictRep.map(f)(m._2));
      }
      if (m.tag === "Matrix") {
        return $Val("Matrix", f(m._1), functorMatrixRep.map(f)(m._2));
      }
      if (m.tag === "Fun") {
        return $Val("Fun", functorFun.map(f)(m._1));
      }
      fail();
    }
  };
  var functorMatrixRep = {
    map: (f) => (m) => $Tuple(
      arrayMap(arrayMap(functorVal.map(f)))(m._1),
      $Tuple($Tuple(m._2._1._1, f(m._2._1._2)), $Tuple(m._2._2._1, f(m._2._2._2)))
    )
  };
  var functorFun = {
    map: (f) => (m) => {
      if (m.tag === "Closure") {
        return $Fun(
          "Closure",
          f(m._1),
          _fmapObject(m._2, functorVal.map(f)),
          _fmapObject(m._3, functorElim.map(f)),
          functorElim.map(f)(m._4)
        );
      }
      if (m.tag === "Foreign") {
        return $Fun("Foreign", m._1, listMap(functorVal.map(f))(m._2));
      }
      if (m.tag === "PartialConstr") {
        return $Fun("PartialConstr", f(m._1), m._2, listMap(functorVal.map(f))(m._3));
      }
      fail();
    }
  };
  var functorDictRep = { map: (f) => (m) => _fmapObject(m, bifunctorTuple.bimap(f)(functorVal.map(f))) };
  var joinSemilatticeVal = (dictJoinSemilattice) => ({
    maybeJoin: (v) => (v1) => {
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          const $3 = Int3(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = mayFailEq(showInt)(eqInt)(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          const $3 = Float3(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = mayFailEq(showNumber)(eqNumber)(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          const $3 = Str3(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = mayFailEq(showString)(eqString)(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          const $3 = Record3(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = joinSemilatticeDict(joinSemilatticeVal(dictJoinSemilattice)).maybeJoin(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          const $3 = Dictionary3(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = joinSemilatticeDictRep(dictJoinSemilattice).maybeJoin(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return applyEither.apply((() => {
            const $3 = Constr3(dictJoinSemilattice.join(v._1)(v1._1));
            const $4 = mayFailEq(showString)(eqString)(v._2)(v1._2);
            if ($4.tag === "Left") {
              return $Either("Left", $4._1);
            }
            if ($4.tag === "Right") {
              return $Either("Right", $3($4._1));
            }
            fail();
          })())(joinSemilatticeList(joinSemilatticeVal(dictJoinSemilattice)).maybeJoin(v._3)(v1._3));
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          const $3 = Matrix3(dictJoinSemilattice.join(v._1)(v1._1));
          const $4 = joinSemilatticeMatrixRep(dictJoinSemilattice).maybeJoin(v._2)(v1._2);
          if ($4.tag === "Left") {
            return $Either("Left", $4._1);
          }
          if ($4.tag === "Right") {
            return $Either("Right", $3($4._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      if (v.tag === "Fun") {
        if (v1.tag === "Fun") {
          const $3 = joinSemilatticeFun(dictJoinSemilattice).maybeJoin(v._1)(v1._1);
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", $Val("Fun", $3._1));
          }
          fail();
        }
        return $Either("Left", "Incompatible values");
      }
      return $Either("Left", "Incompatible values");
    },
    join: (v) => definedJoin(joinSemilatticeVal(dictJoinSemilattice))(v),
    neg: functorVal.map(dictJoinSemilattice.neg)
  });
  var joinSemilatticeMatrixRep = (dictJoinSemilattice) => ({
    maybeJoin: (v) => (v1) => {
      const $3 = joinSemilatticeArray(joinSemilatticeArray(joinSemilatticeVal(dictJoinSemilattice))).maybeJoin(v._1)(v1._1);
      const $4 = mayFailEq(showInt)(eqInt)(v._2._1._1)(v1._2._1._1);
      if ($4.tag === "Left") {
        const $5 = applyEither.apply((() => {
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", Tuple($3._1));
          }
          fail();
        })())(applyEither.apply($Either("Left", $4._1))((() => {
          const $52 = mayFailEq(showInt)(eqInt)(v._2._2._1)(v1._2._2._1);
          if ($52.tag === "Left") {
            return $Either("Left", $52._1);
          }
          if ($52.tag === "Right") {
            return $Either("Right", $Tuple($52._1, dictJoinSemilattice.join(v._2._2._2)(v1._2._2._2)));
          }
          fail();
        })()));
        if ($5.tag === "Left") {
          return $Either("Left", $5._1);
        }
        if ($5.tag === "Right") {
          return $Either("Right", $5._1);
        }
        fail();
      }
      if ($4.tag === "Right") {
        const $5 = applyEither.apply((() => {
          if ($3.tag === "Left") {
            return $Either("Left", $3._1);
          }
          if ($3.tag === "Right") {
            return $Either("Right", Tuple($3._1));
          }
          fail();
        })())(applyEither.apply($Either("Right", Tuple($Tuple($4._1, dictJoinSemilattice.join(v._2._1._2)(v1._2._1._2)))))((() => {
          const $52 = mayFailEq(showInt)(eqInt)(v._2._2._1)(v1._2._2._1);
          if ($52.tag === "Left") {
            return $Either("Left", $52._1);
          }
          if ($52.tag === "Right") {
            return $Either("Right", $Tuple($52._1, dictJoinSemilattice.join(v._2._2._2)(v1._2._2._2)));
          }
          fail();
        })()));
        if ($5.tag === "Left") {
          return $Either("Left", $5._1);
        }
        if ($5.tag === "Right") {
          return $Either("Right", $5._1);
        }
        fail();
      }
      fail();
    },
    join: (v) => definedJoin(joinSemilatticeMatrixRep(dictJoinSemilattice))(v),
    neg: functorMatrixRep.map(dictJoinSemilattice.neg)
  });
  var joinSemilatticeFun = (dictJoinSemilattice) => {
    const joinSemilatticeElim2 = joinSemilatticeElim(dictJoinSemilattice);
    const maybeJoin = joinSemilatticeDict(joinSemilatticeElim2).maybeJoin;
    return {
      maybeJoin: (v) => (v1) => {
        if (v.tag === "Closure") {
          if (v1.tag === "Closure") {
            return applyEither.apply(applyEither.apply((() => {
              const $5 = Closure(dictJoinSemilattice.join(v._1)(v1._1));
              const $6 = joinSemilatticeDict(joinSemilatticeVal(dictJoinSemilattice)).maybeJoin(v._2)(v1._2);
              if ($6.tag === "Left") {
                return $Either("Left", $6._1);
              }
              if ($6.tag === "Right") {
                return $Either("Right", $5($6._1));
              }
              fail();
            })())(maybeJoin(v._3)(v1._3)))(joinSemilatticeElim2.maybeJoin(v._4)(v1._4));
          }
          return $Either("Left", "Incompatible functions");
        }
        if (v.tag === "Foreign") {
          if (v1.tag === "Foreign") {
            const $5 = Foreign(v._1);
            const $6 = joinSemilatticeList(joinSemilatticeVal(dictJoinSemilattice)).maybeJoin(v._2)(v1._2);
            if ($6.tag === "Left") {
              return $Either("Left", $6._1);
            }
            if ($6.tag === "Right") {
              return $Either("Right", $5($6._1));
            }
            fail();
          }
          return $Either("Left", "Incompatible functions");
        }
        if (v.tag === "PartialConstr") {
          if (v1.tag === "PartialConstr") {
            return applyEither.apply((() => {
              const $5 = PartialConstr(dictJoinSemilattice.join(v._1)(v1._1));
              const $6 = mayFailEq(showString)(eqString)(v._2)(v1._2);
              if ($6.tag === "Left") {
                return $Either("Left", $6._1);
              }
              if ($6.tag === "Right") {
                return $Either("Right", $5($6._1));
              }
              fail();
            })())(joinSemilatticeList(joinSemilatticeVal(dictJoinSemilattice)).maybeJoin(v._3)(v1._3));
          }
          return $Either("Left", "Incompatible functions");
        }
        return $Either("Left", "Incompatible functions");
      },
      join: (v) => definedJoin(joinSemilatticeFun(dictJoinSemilattice))(v),
      neg: functorFun.map(dictJoinSemilattice.neg)
    };
  };
  var joinSemilatticeDictRep = (dictJoinSemilattice) => ({
    maybeJoin: (v) => (v1) => {
      const $3 = joinSemilatticeDict(joinSemilattice$x215(dictJoinSemilattice)(joinSemilatticeVal(dictJoinSemilattice))).maybeJoin(v)(v1);
      if ($3.tag === "Left") {
        return $Either("Left", $3._1);
      }
      if ($3.tag === "Right") {
        return $Either("Right", $3._1);
      }
      fail();
    },
    join: (v) => definedJoin(joinSemilatticeDictRep(dictJoinSemilattice))(v),
    neg: functorDictRep.map(dictJoinSemilattice.neg)
  });
  var foldableVal = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Int") {
        return f(z)(m._1);
      }
      if (m.tag === "Float") {
        return f(z)(m._1);
      }
      if (m.tag === "Str") {
        return f(z)(m._1);
      }
      if (m.tag === "Constr") {
        const $3 = foldableVal.foldl(f);
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = $3(b)(v._1);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(f(z)(m._1))(m._3);
      }
      if (m.tag === "Record") {
        const $3 = foldableVal.foldl(f);
        return fold((z$1) => (v) => $3(z$1))(f(z)(m._1))(m._2);
      }
      if (m.tag === "Dictionary") {
        return foldableDictRep.foldl(f)(f(z)(m._1))(m._2);
      }
      if (m.tag === "Matrix") {
        return foldableMatrixRep.foldl(f)(f(z)(m._1))(m._2);
      }
      if (m.tag === "Fun") {
        return foldableFun.foldl(f)(z)(m._1);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Int") {
        return f(m._1)(z);
      }
      if (m.tag === "Float") {
        return f(m._1)(z);
      }
      if (m.tag === "Str") {
        return f(m._1)(z);
      }
      if (m.tag === "Constr") {
        return f(m._1)(foldableList.foldr((() => {
          const $3 = foldableVal.foldr(f);
          return (b) => (a) => $3(a)(b);
        })())(z)(m._3));
      }
      if (m.tag === "Record") {
        return f(m._1)((() => {
          const $3 = foldableVal.foldr(f);
          return foldrArray((b) => (a) => $3(a)(b))(z)(values(m._2));
        })());
      }
      if (m.tag === "Dictionary") {
        return f(m._1)(foldableDictRep.foldr(f)(z)(m._2));
      }
      if (m.tag === "Matrix") {
        return f(m._1)(foldableMatrixRep.foldr(f)(z)(m._2));
      }
      if (m.tag === "Fun") {
        return foldableFun.foldr(f)(z)(m._1);
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const append3 = dictMonoid.Semigroup0().append;
      const foldMap3 = foldableList.foldMap(dictMonoid);
      const foldMap1 = foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "Int") {
          return f(m._1);
        }
        if (m.tag === "Float") {
          return f(m._1);
        }
        if (m.tag === "Str") {
          return f(m._1);
        }
        if (m.tag === "Constr") {
          return append3(f(m._1))(foldMap3(foldableVal.foldMap(dictMonoid)(f))(m._3));
        }
        if (m.tag === "Record") {
          return append3(f(m._1))((() => {
            const $6 = foldableVal.foldMap(dictMonoid)(f);
            return foldMap1((v) => $6)(m._2);
          })());
        }
        if (m.tag === "Dictionary") {
          return append3(f(m._1))(foldableDictRep.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "Matrix") {
          return append3(f(m._1))(foldableMatrixRep.foldMap(dictMonoid)(f)(m._2));
        }
        if (m.tag === "Fun") {
          return foldableFun.foldMap(dictMonoid)(f)(m._1);
        }
        fail();
      };
    }
  };
  var foldableMatrixRep = {
    foldl: (f) => (acc) => (v) => foldlArray(foldlArray(foldableVal.foldl(f)))(f(f(acc)(v._2._1._2))(v._2._2._2))(v._1),
    foldr: (f) => foldrDefault(foldableMatrixRep)(f),
    foldMap: (dictMonoid) => (f) => {
      const append = dictMonoid.Semigroup0().append;
      return foldableMatrixRep.foldl((acc) => (x2) => append(acc)(f(x2)))(dictMonoid.mempty);
    }
  };
  var foldableFun = {
    foldl: (f) => (z) => (m) => {
      if (m.tag === "Closure") {
        return foldableElim.foldl(f)(fold((z$1) => (v) => foldableElim.foldl(f)(z$1))(fold((z$1) => (v) => foldableVal.foldl(f)(z$1))(f(z)(m._1))(m._2))(m._3))(m._4);
      }
      if (m.tag === "Foreign") {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = foldableVal.foldl(f)(b)(v._1);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(z)(m._2);
      }
      if (m.tag === "PartialConstr") {
        const go = (go$a0$copy) => (go$a1$copy) => {
          let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
          while (go$c) {
            const b = go$a0, v = go$a1;
            if (v.tag === "Nil") {
              go$c = false;
              go$r = b;
              continue;
            }
            if (v.tag === "Cons") {
              go$a0 = foldableVal.foldl(f)(b)(v._1);
              go$a1 = v._2;
              continue;
            }
            fail();
          }
          ;
          return go$r;
        };
        return go(f(z)(m._1))(m._3);
      }
      fail();
    },
    foldr: (f) => (z) => (m) => {
      if (m.tag === "Closure") {
        return f(m._1)(foldrArray((b) => (a) => foldableVal.foldr(f)(a)(b))(foldrArray((b) => (a) => foldableElim.foldr(f)(a)(b))(foldableElim.foldr(f)(z)(m._4))(values(m._3)))(values(m._2)));
      }
      if (m.tag === "Foreign") {
        return foldableList.foldr((b) => (a) => foldableVal.foldr(f)(a)(b))(z)(m._2);
      }
      if (m.tag === "PartialConstr") {
        return f(m._1)(foldableList.foldr((b) => (a) => foldableVal.foldr(f)(a)(b))(z)(m._3));
      }
      fail();
    },
    foldMap: (dictMonoid) => {
      const append3 = dictMonoid.Semigroup0().append;
      const foldMap1 = foldMap(dictMonoid);
      const foldMap4 = foldableElim.foldMap(dictMonoid);
      const foldMap5 = foldableList.foldMap(dictMonoid);
      return (f) => (m) => {
        if (m.tag === "Closure") {
          return append3(f(m._1))(append3((() => {
            const $7 = foldableVal.foldMap(dictMonoid)(f);
            return foldMap1((v) => $7)(m._2);
          })())(append3((() => {
            const $7 = foldMap4(f);
            return foldMap1((v) => $7)(m._3);
          })())(foldMap4(f)(m._4))));
        }
        if (m.tag === "Foreign") {
          return foldMap5(foldableVal.foldMap(dictMonoid)(f))(m._2);
        }
        if (m.tag === "PartialConstr") {
          return append3(f(m._1))(foldMap5(foldableVal.foldMap(dictMonoid)(f))(m._3));
        }
        fail();
      };
    }
  };
  var foldableDictRep = {
    foldl: (f) => (acc) => (v) => fold((z) => (v$1) => (v1) => foldableVal.foldl(f)(f(z)(v1._1))(v1._2))(acc)(v),
    foldr: (f) => foldrDefault(foldableDictRep)(f),
    foldMap: (dictMonoid) => (f) => {
      const append = dictMonoid.Semigroup0().append;
      return foldableDictRep.foldl((acc) => (x2) => append(acc)(f(x2)))(dictMonoid.mempty);
    }
  };
  var traversableVal = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map10 = Apply0.Functor0().map;
      const traverse52 = traversableList.traverse(dictApplicative);
      const $4 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "Int") {
          return map10((v2) => $Val("Int", v2, m._2))(f(m._1));
        }
        if (m.tag === "Float") {
          return map10((v2) => $Val("Float", v2, m._2))(f(m._1));
        }
        if (m.tag === "Str") {
          return map10((v2) => $Val("Str", v2, m._2))(f(m._1));
        }
        if (m.tag === "Constr") {
          return Apply0.apply(map10((v3) => (v4) => $Val("Constr", v3, m._2, v4))(f(m._1)))(traverse52(traversableVal.traverse(dictApplicative)(f))(m._3));
        }
        if (m.tag === "Record") {
          return Apply0.apply(map10((v2) => (v3) => $Val("Record", v2, v3))(f(m._1)))((() => {
            const $7 = traversableVal.traverse(dictApplicative)(f);
            return $4((v) => $7)(m._2);
          })());
        }
        if (m.tag === "Dictionary") {
          return Apply0.apply(map10((v2) => (v3) => $Val("Dictionary", v2, v3))(f(m._1)))(traversableDictRep.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "Matrix") {
          return Apply0.apply(map10((v2) => (v3) => $Val("Matrix", v2, v3))(f(m._1)))(traversableMatrixRep.traverse(dictApplicative)(f)(m._2));
        }
        if (m.tag === "Fun") {
          return map10((v1) => $Val("Fun", v1))(traversableFun.traverse(dictApplicative)(f)(m._1));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableVal.traverse(dictApplicative)(identity19)(v),
    Functor0: () => functorVal,
    Foldable1: () => foldableVal
  };
  var traversableMatrixRep = {
    traverse: (dictApplicative) => {
      const map10 = dictApplicative.Apply0().Functor0().map;
      const bitraverse1 = bitraversableTuple.bitraverse(dictApplicative);
      const traverse52 = traversableArray.traverse(dictApplicative);
      const traverse62 = traversableTuple.traverse(dictApplicative);
      return (f) => (v) => map10(MatrixRep)(bitraverse1(traverse52(traverse52(traversableVal.traverse(dictApplicative)(f))))(bitraverse1(traverse62(f))(traverse62(f)))(v));
    },
    sequence: (dictApplicative) => traversableMatrixRep.traverse(dictApplicative)(identity10),
    Functor0: () => functorMatrixRep,
    Foldable1: () => foldableMatrixRep
  };
  var traversableFun = {
    traverse: (dictApplicative) => {
      const Apply0 = dictApplicative.Apply0();
      const map10 = Apply0.Functor0().map;
      const $3 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      const traverse62 = traversableElim.traverse(dictApplicative);
      const traverse7 = traversableList.traverse(dictApplicative);
      return (f) => (m) => {
        if (m.tag === "Closure") {
          return Apply0.apply(Apply0.apply(Apply0.apply(map10((v4) => (v5) => (v6) => (v7) => $Fun("Closure", v4, v5, v6, v7))(f(m._1)))((() => {
            const $8 = traversableVal.traverse(dictApplicative)(f);
            return $3((v) => $8)(m._2);
          })()))((() => {
            const $8 = traverse62(f);
            return $3((v) => $8)(m._3);
          })()))(traverse62(f)(m._4));
        }
        if (m.tag === "Foreign") {
          return map10((v2) => $Fun("Foreign", m._1, v2))(traverse7(traversableVal.traverse(dictApplicative)(f))(m._2));
        }
        if (m.tag === "PartialConstr") {
          return Apply0.apply(map10((v3) => (v4) => $Fun("PartialConstr", v3, m._2, v4))(f(m._1)))(traverse7(traversableVal.traverse(dictApplicative)(f))(m._3));
        }
        fail();
      };
    },
    sequence: (dictApplicative) => (v) => traversableFun.traverse(dictApplicative)(identity19)(v),
    Functor0: () => functorFun,
    Foldable1: () => foldableFun
  };
  var traversableDictRep = {
    traverse: (dictApplicative) => {
      const map10 = dictApplicative.Apply0().Functor0().map;
      const $2 = traversableWithIndexObject.traverseWithIndex(dictApplicative);
      const bitraverse1 = bitraversableTuple.bitraverse(dictApplicative);
      return (f) => (v) => map10(DictRep)((() => {
        const $6 = bitraverse1(f)(traversableVal.traverse(dictApplicative)(f));
        return $2((v$1) => $6)(v);
      })());
    },
    sequence: (dictApplicative) => traversableDictRep.traverse(dictApplicative)(identity10),
    Functor0: () => functorDictRep,
    Foldable1: () => foldableDictRep
  };
  var expandableValRawVal = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => {
      if (v.tag === "Int") {
        if (v1.tag === "Int") {
          return $Val("Int", v._1, mustEq(eqInt)(showInt)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Float") {
        if (v1.tag === "Float") {
          return $Val("Float", v._1, mustEq(eqNumber)(showNumber)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Str") {
        if (v1.tag === "Str") {
          return $Val("Str", v._1, mustEq(eqString)(showString)(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          return $Val(
            "Record",
            v._1,
            expandableDictDict({ botOf: functorVal.map((v$1) => dictBoundedJoinSemilattice.bot) })(expandableValRawVal(dictBoundedJoinSemilattice)).expand(v._2)(v1._2)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          return $Val("Dictionary", v._1, expandableDictRepRawDictR(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          return $Val(
            "Constr",
            v._1,
            mustEq(eqString)(showString)(v._2)(v1._2),
            zipWith(expandableValRawVal(dictBoundedJoinSemilattice).expand)(v._3)(v1._3)
          );
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          return $Val("Matrix", v._1, expandableMatrixRepRawMat(dictBoundedJoinSemilattice).expand(v._2)(v1._2));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      if (v.tag === "Fun") {
        if (v1.tag === "Fun") {
          return $Val("Fun", expandableFunRawFun(dictBoundedJoinSemilattice).expand(v._1)(v1._1));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
      return unsafePerformEffect(throwException(error("Incompatible values")));
    }
  });
  var expandableMatrixRepRawMat = (dictBoundedJoinSemilattice) => ({
    expand: (v) => (v1) => $Tuple(
      (() => {
        const $3 = expandableValRawVal(dictBoundedJoinSemilattice);
        return zipWith2((xs) => (ys) => zipWith2($3.expand)(xs)(ys))(v._1)(v1._1);
      })(),
      $Tuple(
        $Tuple(mustEq(eqInt)(showInt)(v._2._1._1)(v1._2._1._1), v._2._1._2),
        $Tuple(mustEq(eqInt)(showInt)(v._2._2._1)(v1._2._2._1), v._2._2._2)
      )
    )
  });
  var expandableFunRawFun = (dictBoundedJoinSemilattice) => {
    const expandableElimRawElim2 = expandableElimRawElim(dictBoundedJoinSemilattice);
    const expand = expandableDictDict({ botOf: functorElim.map((v) => dictBoundedJoinSemilattice.bot) })(expandableElimRawElim2).expand;
    return {
      expand: (v) => (v1) => {
        if (v.tag === "Closure") {
          if (v1.tag === "Closure") {
            return $Fun(
              "Closure",
              v._1,
              expandableDictDict({ botOf: functorVal.map((v$1) => dictBoundedJoinSemilattice.bot) })(expandableValRawVal(dictBoundedJoinSemilattice)).expand(v._2)(v1._2),
              expand(v._3)(v1._3),
              expandableElimRawElim2.expand(v._4)(v1._4)
            );
          }
          return unsafePerformEffect(throwException(error("Incompatible values")));
        }
        if (v.tag === "Foreign") {
          if (v1.tag === "Foreign") {
            return $Fun("Foreign", v._1, zipWith(expandableValRawVal(dictBoundedJoinSemilattice).expand)(v._2)(v1._2));
          }
          return unsafePerformEffect(throwException(error("Incompatible values")));
        }
        if (v.tag === "PartialConstr") {
          if (v1.tag === "PartialConstr") {
            return $Fun(
              "PartialConstr",
              v._1,
              mustEq(eqString)(showString)(v._2)(v1._2),
              zipWith(expandableValRawVal(dictBoundedJoinSemilattice).expand)(v._3)(v1._3)
            );
          }
          return unsafePerformEffect(throwException(error("Incompatible values")));
        }
        return unsafePerformEffect(throwException(error("Incompatible values")));
      }
    };
  };
  var expandableDictRepRawDictR = (dictBoundedJoinSemilattice) => {
    const expandableDictDict2 = expandableDictDict(botOfUnit$x215Raw$x215(functorVal)(dictBoundedJoinSemilattice));
    return {
      expand: (v) => (v1) => expandableDictDict2((() => {
        const $4 = expandableValRawVal(dictBoundedJoinSemilattice);
        return { expand: (v$1) => (v1$1) => $Tuple(v$1._1, $4.expand(v$1._2)(v1$1._2)) };
      })()).expand(v)(v1)
    };
  };
  var annBoolean = { Highlightable0: () => highlightableBoolean, BoundedLattice1: () => boundedLatticeBoolean };
  var updateMatrix = (i) => (j) => (\u03B4v) => (v) => {
    const vs_i = definitely("index within bounds")(index2(v._1)(i - 1 | 0));
    return $Tuple(
      unsafeUpdateAt(i - 1 | 0)(unsafeUpdateAt(j - 1 | 0)(\u03B4v(definitely("index within bounds")(index2(vs_i)(j - 1 | 0))))(vs_i))(v._1),
      $Tuple(v._2._1, v._2._2)
    );
  };
  var restrict = (\u03B3) => (xs) => filterWithKey((x2) => {
    const $3 = lookup(ordString)(x2)(xs);
    const $4 = (() => {
      if ($3.tag === "Nothing") {
        return false;
      }
      if ($3.tag === "Just") {
        return true;
      }
      fail();
    })();
    return (v) => $4;
  })(\u03B3);
  var reaches = (\u03C1) => (xs) => {
    const dom_\u03C1 = fromFoldable6(keys(\u03C1));
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const v = go$a0, v1 = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = v1;
          continue;
        }
        if (v.tag === "Cons") {
          if ((() => {
            const $6 = lookup(ordString)(v._1)(v1);
            if ($6.tag === "Nothing") {
              return false;
            }
            if ($6.tag === "Just") {
              return true;
            }
            fail();
          })()) {
            go$a0 = v._2;
            go$a1 = v1;
            continue;
          }
          go$a0 = foldableList.foldr(Cons)(v._2)(toUnfoldable9(intersection2(fVElim.fv($$get(v._1)(\u03C1)))(dom_\u03C1)));
          go$a1 = unionWith(ordString)($$const)($Map(
            "Two",
            Leaf2,
            v._1,
            unit2,
            Leaf2
          ))(v1);
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go(toUnfoldable9(xs))(Leaf2);
  };
  var lookup$p = (x2) => (\u03B3) => {
    const $2 = "variable " + (x2 + " not found");
    const $3 = _lookup(Nothing, Just, x2, \u03B3);
    if ($3.tag === "Nothing") {
      return $Either("Left", $2);
    }
    if ($3.tag === "Just") {
      return $Either("Right", $3._1);
    }
    fail();
  };
  var $$for = (\u03C1) => (\u03C3) => restrict(\u03C1)(reaches(\u03C1)(intersection2(fVElim.fv(\u03C3))(fromFoldable6(keys(\u03C1)))));
  var append_inv = (xs) => (\u03B3) => $Tuple(
    filterWithKey((x2) => {
      const $3 = lookup(ordString)(x2)(xs);
      const $4 = (() => {
        if ($3.tag === "Nothing") {
          return true;
        }
        if ($3.tag === "Just") {
          return false;
        }
        fail();
      })();
      return (v) => $4;
    })(\u03B3),
    restrict(\u03B3)(xs)
  );

  // output-es/Primitive/index.js
  var fanin2 = /* @__PURE__ */ fanin(categoryFn)(choiceFn);
  var isZeroNumber = { isZero: ($0) => 0 === $0 };
  var isZeroInt = { isZero: ($0) => 0 === $0 };
  var unary = (op) => $Val(
    "Fun",
    $Fun(
      "Foreign",
      $ForeignOp$p({
        arity: 1,
        "op'": (dictMonad) => {
          const $2 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
          const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
          return (dictSet) => (v) => {
            if (v.tag === "Cons") {
              if (v._2.tag === "Nil") {
                const v2 = op.i.match(v._1);
                return $2.map(functorEither.map(op.o.constr))($2.map((m) => {
                  if (m.tag === "Left") {
                    return $Either("Left", m._1);
                  }
                  if (m.tag === "Right") {
                    return $Either("Right", $Tuple(op.fwd(v2._1), m._1));
                  }
                  fail();
                })($$new(dictSet.singleton(v2._2))));
              }
              fail();
            }
            fail();
          };
        },
        op: (dictAnn) => (v) => {
          if (v.tag === "Cons") {
            if (v._2.tag === "Nil") {
              const v2 = op.i.match(v._1);
              return $Either("Right", $Tuple(functorVal.map((v$1) => unit2)(v._1), op.o.constr($Tuple(op.fwd(v2._1), v2._2))));
            }
            fail();
          }
          fail();
        },
        op_bwd: (dictAnn) => (v) => $List("Cons", op.i.constr($Tuple(op.i.match(v._1)._1, op.o.constr_bwd(v._2)._2)), Nil)
      }),
      Nil
    )
  );
  var string2 = {
    constr: (v) => $Val("Str", v._2, v._1),
    constr_bwd: (v) => {
      if (v.tag === "Str") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Str expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Str") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Str expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var record = (dictAnn) => {
    const prettyP1 = prettyP(prettyVal(dictAnn.Highlightable0()));
    const match$p1 = (v) => {
      if (v.tag === "Record") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Record expected; got " + prettyP1(v))));
    };
    return { constr: (v) => $Val("Record", v._2, v._1), constr_bwd: match$p1, match: match$p1 };
  };
  var number5 = {
    constr: (v) => $Val("Float", v._2, v._1),
    constr_bwd: (v) => {
      if (v.tag === "Float") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Float expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Float") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Float expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var matrixRep = (dictAnn) => {
    const prettyP1 = prettyP(prettyVal(dictAnn.Highlightable0()));
    const match$p1 = (v) => {
      if (v.tag === "Matrix") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Matrix expected; got " + prettyP1(v))));
    };
    return { constr: (v) => $Val("Matrix", v._2, v._1), constr_bwd: match$p1, match: match$p1 };
  };
  var intOrNumberOrString = {
    constr: (v) => {
      if (v._1.tag === "Left") {
        return $Val("Int", v._2, v._1._1);
      }
      if (v._1.tag === "Right") {
        if (v._1._1.tag === "Left") {
          return $Val("Float", v._2, v._1._1._1);
        }
        if (v._1._1.tag === "Right") {
          return $Val("Str", v._2, v._1._1._1);
        }
        fail();
      }
      fail();
    },
    constr_bwd: (v) => {
      if (v.tag === "Int") {
        return $Tuple($Either("Left", v._2), v._1);
      }
      if (v.tag === "Float") {
        return $Tuple($Either("Right", $Either("Left", v._2)), v._1);
      }
      if (v.tag === "Str") {
        return $Tuple($Either("Right", $Either("Right", v._2)), v._1);
      }
      return unsafePerformEffect(throwException(error("Int, Float or Str expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Int") {
        return $Tuple($Either("Left", v._2), v._1);
      }
      if (v.tag === "Float") {
        return $Tuple($Either("Right", $Either("Left", v._2)), v._1);
      }
      if (v.tag === "Str") {
        return $Tuple($Either("Right", $Either("Right", v._2)), v._1);
      }
      return unsafePerformEffect(throwException(error("Int, Float or Str expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var intOrNumber = {
    constr: (v) => {
      if (v._1.tag === "Left") {
        return $Val("Int", v._2, v._1._1);
      }
      if (v._1.tag === "Right") {
        return $Val("Float", v._2, v._1._1);
      }
      fail();
    },
    constr_bwd: (v) => {
      if (v.tag === "Int") {
        return $Tuple($Either("Left", v._2), v._1);
      }
      if (v.tag === "Float") {
        return $Tuple($Either("Right", v._2), v._1);
      }
      return unsafePerformEffect(throwException(error("Int or Float expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Int") {
        return $Tuple($Either("Left", v._2), v._1);
      }
      if (v.tag === "Float") {
        return $Tuple($Either("Right", v._2), v._1);
      }
      return unsafePerformEffect(throwException(error("Int or Float expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var $$int = {
    constr: (v) => $Val("Int", v._2, v._1),
    constr_bwd: (v) => {
      if (v.tag === "Int") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Int expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Int") {
        return $Tuple(v._2, v._1);
      }
      return unsafePerformEffect(throwException(error("Int expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var intPair = {
    constr: (v) => $Val(
      "Constr",
      v._2,
      "Pair",
      $List("Cons", $Val("Int", v._1._1._2, v._1._1._1), $List("Cons", $Val("Int", v._1._2._2, v._1._2._1), Nil))
    ),
    constr_bwd: (v) => {
      if (v.tag === "Constr") {
        if (v._3.tag === "Cons") {
          if (v._3._2.tag === "Cons") {
            if (v._3._2._2.tag === "Nil") {
              if (v._2 === "Pair") {
                return $Tuple($Tuple($$int.match(v._3._1), $$int.match(v._3._2._1)), v._1);
              }
              return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
            }
            return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
          }
          return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
        }
        return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
      }
      return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Constr") {
        if (v._3.tag === "Cons") {
          if (v._3._2.tag === "Cons") {
            if (v._3._2._2.tag === "Nil") {
              if (v._2 === "Pair") {
                return $Tuple($Tuple($$int.match(v._3._1), $$int.match(v._3._2._1)), v._1);
              }
              return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
            }
            return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
          }
          return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
        }
        return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
      }
      return unsafePerformEffect(throwException(error("Pair expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var $$boolean = {
    constr: (v) => {
      if (v._1) {
        return $Val("Constr", v._2, "True", Nil);
      }
      if (!v._1) {
        return $Val("Constr", v._2, "False", Nil);
      }
      fail();
    },
    constr_bwd: (v) => {
      if (v.tag === "Constr") {
        if (v._3.tag === "Nil") {
          if (v._2 === "True") {
            return $Tuple(true, v._1);
          }
          if (v._2 === "False") {
            return $Tuple(false, v._1);
          }
          return unsafePerformEffect(throwException(error("Boolean expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
        }
        return unsafePerformEffect(throwException(error("Boolean expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
      }
      return unsafePerformEffect(throwException(error("Boolean expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    },
    match: (v) => {
      if (v.tag === "Constr") {
        if (v._3.tag === "Nil") {
          if (v._2 === "True") {
            return $Tuple(true, v._1);
          }
          if (v._2 === "False") {
            return $Tuple(false, v._1);
          }
          return unsafePerformEffect(throwException(error("Boolean expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
        }
        return unsafePerformEffect(throwException(error("Boolean expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
      }
      return unsafePerformEffect(throwException(error("Boolean expected; got " + intercalate4("\n")(prettyVal(highlightableUnit).pretty(functorVal.map((v$1) => unit2)(v)).lines))));
    }
  };
  var binaryZero = (dictIsZero) => (op) => $Val(
    "Fun",
    $Fun(
      "Foreign",
      $ForeignOp$p({
        arity: 2,
        "op'": (dictMonad) => {
          const $3 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
          const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
          return (dictSet) => (v) => {
            if (v.tag === "Cons") {
              if (v._2.tag === "Cons") {
                if (v._2._2.tag === "Nil") {
                  const $7 = op.i.match(v._1);
                  const $8 = op.i.match(v._2._1);
                  return $3.map(functorEither.map(op.o.constr))($3.map((m) => {
                    if (m.tag === "Left") {
                      return $Either("Left", m._1);
                    }
                    if (m.tag === "Right") {
                      return $Either("Right", $Tuple(op.fwd($7._1)($8._1), m._1));
                    }
                    fail();
                  })($$new((() => {
                    if (dictIsZero.isZero($7._1)) {
                      return dictSet.singleton($7._2);
                    }
                    if (dictIsZero.isZero($8._1)) {
                      return dictSet.singleton($8._2);
                    }
                    return dictSet.insert($8._2)(dictSet.singleton($7._2));
                  })())));
                }
                fail();
              }
              fail();
            }
            fail();
          };
        },
        op: (dictAnn) => {
          const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
          return (v) => {
            if (v.tag === "Cons") {
              if (v._2.tag === "Cons") {
                if (v._2._2.tag === "Nil") {
                  const $5 = op.i.match(v._1);
                  const $6 = op.i.match(v._2._1);
                  return $Either(
                    "Right",
                    $Tuple(
                      $Tuple(functorVal.map((v$1) => unit2)(v._1), functorVal.map((v$1) => unit2)(v._2._1)),
                      op.o.constr($Tuple(
                        op.fwd($5._1)($6._1),
                        (() => {
                          if (dictIsZero.isZero($5._1)) {
                            return $5._2;
                          }
                          if (dictIsZero.isZero($6._1)) {
                            return $6._2;
                          }
                          return meet($5._2)($6._2);
                        })()
                      ))
                    )
                  );
                }
                fail();
              }
              fail();
            }
            fail();
          };
        },
        op_bwd: (dictAnn) => {
          const bot = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().bot;
          return (v) => {
            const $5 = op.o.constr_bwd(v._2)._2;
            const $6 = op.i.match(v._1._1);
            const $7 = op.i.match(v._1._2);
            if (dictIsZero.isZero($6._1)) {
              return $List(
                "Cons",
                op.i.constr($Tuple($6._1, $5)),
                $List("Cons", op.i.constr($Tuple($7._1, bot)), Nil)
              );
            }
            if (dictIsZero.isZero($7._1)) {
              return $List(
                "Cons",
                op.i.constr($Tuple($6._1, bot)),
                $List("Cons", op.i.constr($Tuple($7._1, $5)), Nil)
              );
            }
            return $List(
              "Cons",
              op.i.constr($Tuple($6._1, $5)),
              $List("Cons", op.i.constr($Tuple($7._1, $5)), Nil)
            );
          };
        }
      }),
      Nil
    )
  );
  var binary = (op) => $Val(
    "Fun",
    $Fun(
      "Foreign",
      $ForeignOp$p({
        arity: 2,
        "op'": (dictMonad) => {
          const $2 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
          const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
          return (dictSet) => (v) => {
            if (v.tag === "Cons") {
              if (v._2.tag === "Cons") {
                if (v._2._2.tag === "Nil") {
                  const $6 = op.i1.match(v._1);
                  const $7 = op.i2.match(v._2._1);
                  return $2.map(functorEither.map(op.o.constr))($2.map((m) => {
                    if (m.tag === "Left") {
                      return $Either("Left", m._1);
                    }
                    if (m.tag === "Right") {
                      return $Either("Right", $Tuple(op.fwd($6._1)($7._1), m._1));
                    }
                    fail();
                  })($$new(dictSet.insert($7._2)(dictSet.singleton($6._2)))));
                }
                fail();
              }
              fail();
            }
            fail();
          };
        },
        op: (dictAnn) => {
          const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
          return (v) => {
            if (v.tag === "Cons") {
              if (v._2.tag === "Cons") {
                if (v._2._2.tag === "Nil") {
                  const $4 = op.i1.match(v._1);
                  const $5 = op.i2.match(v._2._1);
                  return $Either(
                    "Right",
                    $Tuple(
                      $Tuple(functorVal.map((v$1) => unit2)(v._1), functorVal.map((v$1) => unit2)(v._2._1)),
                      op.o.constr($Tuple(op.fwd($4._1)($5._1), meet($4._2)($5._2)))
                    )
                  );
                }
                fail();
              }
              fail();
            }
            fail();
          };
        },
        op_bwd: (dictAnn) => (v) => {
          const $3 = op.o.constr_bwd(v._2)._2;
          return $List(
            "Cons",
            op.i1.constr($Tuple(op.i1.match(v._1._1)._1, $3)),
            $List("Cons", op.i2.constr($Tuple(op.i2.match(v._1._2)._1, $3)), Nil)
          );
        }
      }),
      Nil
    )
  );
  var asNumberString = { as: (v) => unsafePerformEffect(throwException(error("Non-uniform argument types"))) };
  var asNumberIntOrNumber = { as: Right };
  var asIntNumberOrString = { as: (x2) => $Either("Left", toNumber(x2)) };
  var asIntNumber = { as: toNumber };
  var asIntIntOrNumber = { as: Left };
  var asBooleanBoolean = { as: (x2) => x2 };
  var union4 = (dictAs) => (dictAs1) => (dictAs2) => (dictAs3) => (v) => (v1) => (v2) => (v3) => {
    if (v2.tag === "Left") {
      if (v3.tag === "Left") {
        return dictAs.as(v(v2._1)(v3._1));
      }
      if (v3.tag === "Right") {
        return dictAs1.as(v1(dictAs2.as(v2._1))(v3._1));
      }
      fail();
    }
    if (v2.tag === "Right") {
      if (v3.tag === "Right") {
        return dictAs1.as(v1(v2._1)(v3._1));
      }
      if (v3.tag === "Left") {
        return dictAs1.as(v1(v2._1)(dictAs3.as(v3._1)));
      }
      fail();
    }
    fail();
  };
  var unionStr = (dictAs) => (dictAs1) => union4(dictAs)(dictAs)(dictAs1)(dictAs1);

  // output-es/App.Util/index.js
  var neg = /* @__PURE__ */ (() => joinSemilatticeVal(joinSemilatticeBoolean).neg)();
  var record1 = /* @__PURE__ */ record(annBoolean);
  var toggleField = (v) => (v1) => (v2) => {
    if (v2.tag === "Record") {
      return $Val("Record", v2._1, update2((x2) => $Maybe("Just", v1(x2)))(v)(v2._2));
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var toggleConstrArg = (v) => (v1) => (v2) => (v3) => {
    if (v3.tag === "Constr") {
      if (v === v3._2) {
        return definitely("absurd")((() => {
          const $4 = index(v3._3)(v1);
          if ($4.tag === "Just") {
            const $5 = updateAt(v1)(v2($4._1))(v3._3);
            if ($5.tag === "Just") {
              return $Maybe("Just", $Val("Constr", v3._1, v, $5._1));
            }
            if ($5.tag === "Nothing") {
              return Nothing;
            }
            fail();
          }
          if ($4.tag === "Nothing") {
            return Nothing;
          }
          fail();
        })());
      }
      return unsafePerformEffect(throwException(error("absurd")));
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var toggleCell = (v) => (v1) => (v2) => {
    if (v2.tag === "Matrix") {
      return $Val("Matrix", v2._1, updateMatrix(v)(v1)(neg)(v2._2));
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var selectNth = (v) => (v1) => (v2) => {
    if (v2.tag === "Constr") {
      if (v2._3.tag === "Cons") {
        if (v2._3._2.tag === "Cons") {
          if (v2._3._2._2.tag === "Nil") {
            if (v === 0) {
              if (v2._2 === ":") {
                return $Val("Constr", v2._1, v2._2, $List("Cons", v1(v2._3._1), $List("Cons", v2._3._2._1, Nil)));
              }
              if (v2._2 === ":") {
                return $Val(
                  "Constr",
                  v2._1,
                  v2._2,
                  $List("Cons", v2._3._1, $List("Cons", selectNth(v - 1 | 0)(v1)(v2._3._2._1), Nil))
                );
              }
              return unsafePerformEffect(throwException(error("absurd")));
            }
            if (v2._2 === ":") {
              return $Val(
                "Constr",
                v2._1,
                v2._2,
                $List("Cons", v2._3._1, $List("Cons", selectNth(v - 1 | 0)(v1)(v2._3._2._1), Nil))
              );
            }
            return unsafePerformEffect(throwException(error("absurd")));
          }
          return unsafePerformEffect(throwException(error("absurd")));
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      return unsafePerformEffect(throwException(error("absurd")));
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var record2 = (toRecord) => (u) => toRecord(record1.match(u)._1);
  var get_intOrNumber = (x2) => (r) => {
    const $2 = intOrNumber.match($$get(x2)(r));
    return $Tuple(
      (() => {
        if ($2._1.tag === "Left") {
          return toNumber($2._1._1);
        }
        if ($2._1.tag === "Right") {
          return $2._1._1;
        }
        fail();
      })(),
      $2._2
    );
  };
  var reflectArray = {
    from: () => (v) => {
      if (v.tag === "Constr") {
        if (v._3.tag === "Nil") {
          if (v._2 === "Nil") {
            return [];
          }
          fail();
        }
        if (v._3.tag === "Cons") {
          if (v._3._2.tag === "Cons") {
            if (v._3._2._2.tag === "Nil") {
              if (v._2 === ":") {
                return concatArray([v._3._1])(reflectArray.from()(v._3._2._1));
              }
              fail();
            }
            fail();
          }
          fail();
        }
        fail();
      }
      fail();
    }
  };
  var doNothing = (v) => () => unit2;

  // output-es/Data.Nullable/foreign.js
  var nullImpl = null;
  function nullable(a, r, f) {
    return a == null ? r : f(a);
  }
  function notNull(x2) {
    return x2;
  }

  // output-es/Web.Event.Event/foreign.js
  function _target(e) {
    return e.target;
  }

  // node_modules/d3-collection/src/map.js
  var prefix = "$";
  function Map2() {
  }
  Map2.prototype = map3.prototype = {
    constructor: Map2,
    has: function(key) {
      return prefix + key in this;
    },
    get: function(key) {
      return this[prefix + key];
    },
    set: function(key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this)
        if (property[0] === prefix)
          delete this[property];
    },
    keys: function() {
      var keys4 = [];
      for (var property in this)
        if (property[0] === prefix)
          keys4.push(property.slice(1));
      return keys4;
    },
    values: function() {
      var values2 = [];
      for (var property in this)
        if (property[0] === prefix)
          values2.push(this[property]);
      return values2;
    },
    entries: function() {
      var entries = [];
      for (var property in this)
        if (property[0] === prefix)
          entries.push({ key: property.slice(1), value: this[property] });
      return entries;
    },
    size: function() {
      var size3 = 0;
      for (var property in this)
        if (property[0] === prefix)
          ++size3;
      return size3;
    },
    empty: function() {
      for (var property in this)
        if (property[0] === prefix)
          return false;
      return true;
    },
    each: function(f) {
      for (var property in this)
        if (property[0] === prefix)
          f(this[property], property.slice(1), this);
    }
  };
  function map3(object, f) {
    var map6 = new Map2();
    if (object instanceof Map2)
      object.each(function(value, key2) {
        map6.set(key2, value);
      });
    else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (f == null)
        while (++i < n)
          map6.set(i, object[i]);
      else
        while (++i < n)
          map6.set(f(o = object[i], i, object), o);
    } else if (object)
      for (var key in object)
        map6.set(key, object[key]);
    return map6;
  }
  var map_default = map3;

  // node_modules/d3-collection/src/set.js
  function Set2() {
  }
  var proto = map_default.prototype;
  Set2.prototype = set3.prototype = {
    constructor: Set2,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };
  function set3(object, f) {
    var set4 = new Set2();
    if (object instanceof Set2)
      object.each(function(value) {
        set4.add(value);
      });
    else if (object) {
      var i = -1, n = object.length;
      if (f == null)
        while (++i < n)
          set4.add(object[i]);
      else
        while (++i < n)
          set4.add(f(object[i], i, object));
    }
    return set4;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/namespaces.js
  var xhtml2 = "http://www.w3.org/1999/xhtml";
  var namespaces_default2 = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml2,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-tip/node_modules/d3-selection/src/namespace.js
  function namespace_default2(name3) {
    var prefix2 = name3 += "", i = prefix2.indexOf(":");
    if (i >= 0 && (prefix2 = name3.slice(0, i)) !== "xmlns")
      name3 = name3.slice(i + 1);
    return namespaces_default2.hasOwnProperty(prefix2) ? { space: namespaces_default2[prefix2], local: name3 } : name3;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/creator.js
  function creatorInherit2(name3) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml2 && document2.documentElement.namespaceURI === xhtml2 ? document2.createElement(name3) : document2.createElementNS(uri, name3);
    };
  }
  function creatorFixed2(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default2(name3) {
    var fullname = namespace_default2(name3);
    return (fullname.local ? creatorFixed2 : creatorInherit2)(fullname);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selector.js
  function none4() {
  }
  function selector_default2(selector) {
    return selector == null ? none4 : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/select.js
  function select_default4(select) {
    if (typeof select !== "function")
      select = selector_default2(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection3(subgroups, this._parents);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selectorAll.js
  function empty4() {
    return [];
  }
  function selectorAll_default2(selector) {
    return selector == null ? empty4 : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/selectAll.js
  function selectAll_default3(select) {
    if (typeof select !== "function")
      select = selectorAll_default2(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          subgroups.push(select.call(node, node.__data__, i, group2));
          parents.push(node);
        }
      }
    }
    return new Selection3(subgroups, parents);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/matcher.js
  function matcher_default2(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/filter.js
  function filter_default3(match5) {
    if (typeof match5 !== "function")
      match5 = matcher_default2(match5);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group2[i]) && match5.call(node, node.__data__, i, group2)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection3(subgroups, this._parents);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/sparse.js
  function sparse_default2(update3) {
    return new Array(update3.length);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/enter.js
  function enter_default2() {
    return new Selection3(this._enter || this._groups.map(sparse_default2), this._parents);
  }
  function EnterNode2(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode2.prototype = {
    constructor: EnterNode2,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-tip/node_modules/d3-selection/src/constant.js
  function constant_default6(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/data.js
  var keyPrefix = "$";
  function bindIndex2(parent, group2, enter, update3, exit, data) {
    var i = 0, node, groupLength = group2.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node = group2[i]) {
        node.__data__ = data[i];
        update3[i] = node;
      } else {
        enter[i] = new EnterNode2(parent, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group2[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey2(parent, group2, enter, update3, exit, data, key) {
    var i, node, nodeByKeyValue = {}, groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group2[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group2);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update3[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode2(parent, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group2[i]) && nodeByKeyValue[keyValues[i]] === node) {
        exit[i] = node;
      }
    }
  }
  function data_default2(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) {
        data[++j] = d;
      });
      return data;
    }
    var bind = key ? bindKey2 : bindIndex2, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default6(value);
    for (var m = groups.length, update3 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j], group2 = groups[j], groupLength = group2.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update3[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update3 = new Selection3(update3, parents);
    update3._enter = enter;
    update3._exit = exit;
    return update3;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/exit.js
  function exit_default2() {
    return new Selection3(this._exit || this._groups.map(sparse_default2), this._parents);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/join.js
  function join_default2(onenter, onupdate, onexit) {
    var enter = this.enter(), update3 = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null)
      update3 = onupdate(update3);
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update3 ? enter.merge(update3).order() : update3;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/merge.js
  function merge_default3(selection3) {
    for (var groups0 = this._groups, groups1 = selection3._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection3(merges, this._parents);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/order.js
  function order_default2() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
      for (var group2 = groups[j], i = group2.length - 1, next = group2[i], node; --i >= 0; ) {
        if (node = group2[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/sort.js
  function sort_default2(compare2) {
    if (!compare2)
      compare2 = ascending2;
    function compareNode(a, b) {
      return a && b ? compare2(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group2 = groups[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection3(sortgroups, this._parents).order();
  }
  function ascending2(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/call.js
  function call_default2() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/nodes.js
  function nodes_default2() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() {
      nodes[++i] = this;
    });
    return nodes;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/node.js
  function node_default2() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group2 = groups[j], i = 0, n = group2.length; i < n; ++i) {
        var node = group2[i];
        if (node)
          return node;
      }
    }
    return null;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/size.js
  function size_default2() {
    var size3 = 0;
    this.each(function() {
      ++size3;
    });
    return size3;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/empty.js
  function empty_default2() {
    return !this.node();
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/each.js
  function each_default2(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group2 = groups[j], i = 0, n = group2.length, node; i < n; ++i) {
        if (node = group2[i])
          callback.call(node, node.__data__, i, group2);
      }
    }
    return this;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/attr.js
  function attrRemove3(name3) {
    return function() {
      this.removeAttribute(name3);
    };
  }
  function attrRemoveNS3(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant3(name3, value) {
    return function() {
      this.setAttribute(name3, value);
    };
  }
  function attrConstantNS3(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction3(name3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name3);
      else
        this.setAttribute(name3, v);
    };
  }
  function attrFunctionNS3(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function attr_default3(name3, value) {
    var fullname = namespace_default2(name3);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS3 : attrRemove3 : typeof value === "function" ? fullname.local ? attrFunctionNS3 : attrFunction3 : fullname.local ? attrConstantNS3 : attrConstant3)(fullname, value));
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/window.js
  function window_default2(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/style.js
  function styleRemove3(name3) {
    return function() {
      this.style.removeProperty(name3);
    };
  }
  function styleConstant3(name3, value, priority) {
    return function() {
      this.style.setProperty(name3, value, priority);
    };
  }
  function styleFunction3(name3, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name3);
      else
        this.style.setProperty(name3, v, priority);
    };
  }
  function style_default3(name3, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove3 : typeof value === "function" ? styleFunction3 : styleConstant3)(name3, value, priority == null ? "" : priority)) : styleValue2(this.node(), name3);
  }
  function styleValue2(node, name3) {
    return node.style.getPropertyValue(name3) || window_default2(node).getComputedStyle(node, null).getPropertyValue(name3);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/property.js
  function propertyRemove2(name3) {
    return function() {
      delete this[name3];
    };
  }
  function propertyConstant2(name3, value) {
    return function() {
      this[name3] = value;
    };
  }
  function propertyFunction2(name3, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name3];
      else
        this[name3] = v;
    };
  }
  function property_default2(name3, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove2 : typeof value === "function" ? propertyFunction2 : propertyConstant2)(name3, value)) : this.node()[name3];
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/classed.js
  function classArray2(string4) {
    return string4.trim().split(/^|\s+/);
  }
  function classList2(node) {
    return node.classList || new ClassList2(node);
  }
  function ClassList2(node) {
    this._node = node;
    this._names = classArray2(node.getAttribute("class") || "");
  }
  ClassList2.prototype = {
    add: function(name3) {
      var i = this._names.indexOf(name3);
      if (i < 0) {
        this._names.push(name3);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name3) {
      var i = this._names.indexOf(name3);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name3) {
      return this._names.indexOf(name3) >= 0;
    }
  };
  function classedAdd2(node, names) {
    var list = classList2(node), i = -1, n = names.length;
    while (++i < n)
      list.add(names[i]);
  }
  function classedRemove2(node, names) {
    var list = classList2(node), i = -1, n = names.length;
    while (++i < n)
      list.remove(names[i]);
  }
  function classedTrue2(names) {
    return function() {
      classedAdd2(this, names);
    };
  }
  function classedFalse2(names) {
    return function() {
      classedRemove2(this, names);
    };
  }
  function classedFunction2(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd2 : classedRemove2)(this, names);
    };
  }
  function classed_default2(name3, value) {
    var names = classArray2(name3 + "");
    if (arguments.length < 2) {
      var list = classList2(this.node()), i = -1, n = names.length;
      while (++i < n)
        if (!list.contains(names[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction2 : value ? classedTrue2 : classedFalse2)(names, value));
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/text.js
  function textRemove2() {
    this.textContent = "";
  }
  function textConstant3(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction3(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function text_default3(value) {
    return arguments.length ? this.each(value == null ? textRemove2 : (typeof value === "function" ? textFunction3 : textConstant3)(value)) : this.node().textContent;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/html.js
  function htmlRemove2() {
    this.innerHTML = "";
  }
  function htmlConstant2(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction2(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function html_default2(value) {
    return arguments.length ? this.each(value == null ? htmlRemove2 : (typeof value === "function" ? htmlFunction2 : htmlConstant2)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/raise.js
  function raise2() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default2() {
    return this.each(raise2);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/lower.js
  function lower2() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default2() {
    return this.each(lower2);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/append.js
  function append_default2(name3) {
    var create2 = typeof name3 === "function" ? name3 : creator_default2(name3);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/insert.js
  function constantNull2() {
    return null;
  }
  function insert_default2(name3, before) {
    var create2 = typeof name3 === "function" ? name3 : creator_default2(name3), select = before == null ? constantNull2 : typeof before === "function" ? before : selector_default2(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/remove.js
  function remove3() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function remove_default3() {
    return this.each(remove3);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow2() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep2() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default2(deep) {
    return this.select(deep ? selection_cloneDeep2 : selection_cloneShallow2);
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/datum.js
  function datum_default2(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/on.js
  var filterEvents = {};
  var event = null;
  if (typeof document !== "undefined") {
    element = document.documentElement;
    if (!("onmouseenter" in element)) {
      filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
    }
  }
  var element;
  function filterContextListener(listener, index3, group2) {
    listener = contextListener2(listener, index3, group2);
    return function(event2) {
      var related = event2.relatedTarget;
      if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
        listener.call(this, event2);
      }
    };
  }
  function contextListener2(listener, index3, group2) {
    return function(event1) {
      var event0 = event;
      event = event1;
      try {
        listener.call(this, this.__data__, index3, group2);
      } finally {
        event = event0;
      }
    };
  }
  function parseTypenames3(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name3 = "", i = t2.indexOf(".");
      if (i >= 0)
        name3 = t2.slice(i + 1), t2 = t2.slice(0, i);
      return { type: t2, name: name3 };
    });
  }
  function onRemove2(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i)
        on.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd2(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener2;
    return function(d, i, group2) {
      var on = this.__on, o, listener = wrap(value, i, group2);
      if (on)
        for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
            this.addEventListener(o.type, o.listener = listener, o.capture = capture);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, capture);
      o = { type: typename.type, name: typename.name, value, listener, capture };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function on_default3(typename, value, capture) {
    var typenames = parseTypenames3(typename + ""), i, n = typenames.length, t2;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t2 = typenames[i]).type === o.type && t2.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd2 : onRemove2;
    if (capture == null)
      capture = false;
    for (i = 0; i < n; ++i)
      this.each(on(typenames[i], value, capture));
    return this;
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent2(node, type2, params) {
    var window2 = window_default2(node), event2 = window2.CustomEvent;
    if (typeof event2 === "function") {
      event2 = new event2(type2, params);
    } else {
      event2 = window2.document.createEvent("Event");
      if (params)
        event2.initEvent(type2, params.bubbles, params.cancelable), event2.detail = params.detail;
      else
        event2.initEvent(type2, false, false);
    }
    node.dispatchEvent(event2);
  }
  function dispatchConstant2(type2, params) {
    return function() {
      return dispatchEvent2(this, type2, params);
    };
  }
  function dispatchFunction2(type2, params) {
    return function() {
      return dispatchEvent2(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default3(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction2 : dispatchConstant2)(type2, params));
  }

  // node_modules/d3-tip/node_modules/d3-selection/src/selection/index.js
  var root2 = [null];
  function Selection3(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection2() {
    return new Selection3([[document.documentElement]], root2);
  }
  Selection3.prototype = selection2.prototype = {
    constructor: Selection3,
    select: select_default4,
    selectAll: selectAll_default3,
    filter: filter_default3,
    data: data_default2,
    enter: enter_default2,
    exit: exit_default2,
    join: join_default2,
    merge: merge_default3,
    order: order_default2,
    sort: sort_default2,
    call: call_default2,
    nodes: nodes_default2,
    node: node_default2,
    size: size_default2,
    empty: empty_default2,
    each: each_default2,
    attr: attr_default3,
    style: style_default3,
    property: property_default2,
    classed: classed_default2,
    text: text_default3,
    html: html_default2,
    raise: raise_default2,
    lower: lower_default2,
    append: append_default2,
    insert: insert_default2,
    remove: remove_default3,
    clone: clone_default2,
    datum: datum_default2,
    on: on_default3,
    dispatch: dispatch_default3
  };
  var selection_default3 = selection2;

  // node_modules/d3-tip/node_modules/d3-selection/src/select.js
  function select_default5(selector) {
    return typeof selector === "string" ? new Selection3([[document.querySelector(selector)]], [document.documentElement]) : new Selection3([[selector]], root2);
  }

  // node_modules/d3-tip/index.js
  function d3_tip_default() {
    var direction = d3TipDirection, offset = d3TipOffset, html = d3TipHTML, rootElement = document.body, node = initNode(), svg = null, point2 = null, target = null;
    function tip(vis) {
      svg = getSVGNode(vis);
      if (!svg)
        return;
      point2 = svg.createSVGPoint();
      rootElement.appendChild(node);
    }
    tip.show = function() {
      var args = Array.prototype.slice.call(arguments);
      if (args[args.length - 1] instanceof SVGElement)
        target = args.pop();
      var content2 = html.apply(this, args), poffset = offset.apply(this, args), dir = direction.apply(this, args), nodel = getNodeEl(), i = directions.length, coords, scrollTop = document.documentElement.scrollTop || rootElement.scrollTop, scrollLeft = document.documentElement.scrollLeft || rootElement.scrollLeft;
      nodel.html(content2).style("opacity", 1).style("pointer-events", "all");
      while (i--)
        nodel.classed(directions[i], false);
      coords = directionCallbacks.get(dir).apply(this);
      nodel.classed(dir, true).style("top", coords.top + poffset[0] + scrollTop + "px").style("left", coords.left + poffset[1] + scrollLeft + "px");
      return tip;
    };
    tip.hide = function() {
      var nodel = getNodeEl();
      nodel.style("opacity", 0).style("pointer-events", "none");
      return tip;
    };
    tip.attr = function(n, v) {
      if (arguments.length < 2 && typeof n === "string") {
        return getNodeEl().attr(n);
      }
      var args = Array.prototype.slice.call(arguments);
      selection_default3.prototype.attr.apply(getNodeEl(), args);
      return tip;
    };
    tip.style = function(n, v) {
      if (arguments.length < 2 && typeof n === "string") {
        return getNodeEl().style(n);
      }
      var args = Array.prototype.slice.call(arguments);
      selection_default3.prototype.style.apply(getNodeEl(), args);
      return tip;
    };
    tip.direction = function(v) {
      if (!arguments.length)
        return direction;
      direction = v == null ? v : functor(v);
      return tip;
    };
    tip.offset = function(v) {
      if (!arguments.length)
        return offset;
      offset = v == null ? v : functor(v);
      return tip;
    };
    tip.html = function(v) {
      if (!arguments.length)
        return html;
      html = v == null ? v : functor(v);
      return tip;
    };
    tip.rootElement = function(v) {
      if (!arguments.length)
        return rootElement;
      rootElement = v == null ? v : functor(v);
      return tip;
    };
    tip.destroy = function() {
      if (node) {
        getNodeEl().remove();
        node = null;
      }
      return tip;
    };
    function d3TipDirection() {
      return "n";
    }
    function d3TipOffset() {
      return [0, 0];
    }
    function d3TipHTML() {
      return " ";
    }
    var directionCallbacks = map_default({
      n: directionNorth,
      s: directionSouth,
      e: directionEast,
      w: directionWest,
      nw: directionNorthWest,
      ne: directionNorthEast,
      sw: directionSouthWest,
      se: directionSouthEast
    }), directions = directionCallbacks.keys();
    function directionNorth() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.n.y - node.offsetHeight,
        left: bbox.n.x - node.offsetWidth / 2
      };
    }
    function directionSouth() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.s.y,
        left: bbox.s.x - node.offsetWidth / 2
      };
    }
    function directionEast() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.e.y - node.offsetHeight / 2,
        left: bbox.e.x
      };
    }
    function directionWest() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.w.y - node.offsetHeight / 2,
        left: bbox.w.x - node.offsetWidth
      };
    }
    function directionNorthWest() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.nw.y - node.offsetHeight,
        left: bbox.nw.x - node.offsetWidth
      };
    }
    function directionNorthEast() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.ne.y - node.offsetHeight,
        left: bbox.ne.x
      };
    }
    function directionSouthWest() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.sw.y,
        left: bbox.sw.x - node.offsetWidth
      };
    }
    function directionSouthEast() {
      var bbox = getScreenBBox(this);
      return {
        top: bbox.se.y,
        left: bbox.se.x
      };
    }
    function initNode() {
      var div = select_default5(document.createElement("div"));
      div.style("position", "absolute").style("top", 0).style("opacity", 0).style("pointer-events", "none").style("box-sizing", "border-box");
      return div.node();
    }
    function getSVGNode(element) {
      var svgNode2 = element.node();
      if (!svgNode2)
        return null;
      if (svgNode2.tagName.toLowerCase() === "svg")
        return svgNode2;
      return svgNode2.ownerSVGElement;
    }
    function getNodeEl() {
      if (node == null) {
        node = initNode();
        rootElement.appendChild(node);
      }
      return select_default5(node);
    }
    function getScreenBBox(targetShape) {
      var targetel = target || targetShape;
      while (targetel.getScreenCTM == null && targetel.parentNode != null) {
        targetel = targetel.parentNode;
      }
      var bbox = {}, matrix = targetel.getScreenCTM(), tbbox = targetel.getBBox(), width = tbbox.width, height = tbbox.height, x2 = tbbox.x, y2 = tbbox.y;
      point2.x = x2;
      point2.y = y2;
      bbox.nw = point2.matrixTransform(matrix);
      point2.x += width;
      bbox.ne = point2.matrixTransform(matrix);
      point2.y += height;
      bbox.se = point2.matrixTransform(matrix);
      point2.x -= width;
      bbox.sw = point2.matrixTransform(matrix);
      point2.y -= height / 2;
      bbox.w = point2.matrixTransform(matrix);
      point2.x += width;
      bbox.e = point2.matrixTransform(matrix);
      point2.x -= width / 2;
      point2.y -= height / 2;
      bbox.n = point2.matrixTransform(matrix);
      point2.y += height;
      bbox.s = point2.matrixTransform(matrix);
      return bbox;
    }
    function functor(v) {
      return typeof v === "function" ? v : function() {
        return v;
      };
    }
    return tip;
  }

  // output-es/App.BarChart/foreign.js
  function curry4(f) {
    return (x1) => (x2) => (x3) => (x4) => f(x1, x2, x3, x4);
  }
  function colorShade(col, amt) {
    col = col.replace(/^#/, "");
    if (col.length === 3)
      col = col[0] + col[0] + col[1] + col[1] + col[2] + col[2];
    let [r, g, b] = col.match(/.{2}/g);
    [r, g, b] = [parseInt(r, 16) + amt, parseInt(g, 16) + amt, parseInt(b, 16) + amt];
    r = Math.max(Math.min(255, r), 0).toString(16);
    g = Math.max(Math.min(255, g), 0).toString(16);
    b = Math.max(Math.min(255, b), 0).toString(16);
    const rr = (r.length < 2 ? "0" : "") + r;
    const gg = (g.length < 2 ? "0" : "") + g;
    const bb = (b.length < 2 ? "0" : "") + b;
    return `#${rr}${gg}${bb}`;
  }
  function drawBarChart_(id3, childIndex, {
    caption,
    data
  }, listener) {
    return () => {
      const childId = id3 + "-" + childIndex;
      const margin = { top: 15, right: 0, bottom: 40, left: 30 }, width = 200 - margin.left - margin.right, height = 185 - margin.top - margin.bottom;
      const div = select_default2("#" + id3);
      div.selectAll("#" + childId).remove();
      const svg = div.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).attr("id", childId).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
      const tip = d3_tip_default().attr("class", "d3-tip").offset([0, 0]).html((_, d) => d.y._1);
      svg.call(tip);
      const x2 = band().range([0, width]).domain(data.map((d) => d.x._1)).padding(0.2);
      svg.append("g").attr("transform", "translate(0," + height + ")").call(axisBottom(x2)).selectAll("text").style("text-anchor", "middle");
      const nearest = 100, y_max = Math.ceil(Math.max(...data.map((d) => d.y._1)) / nearest) * nearest;
      const y2 = linear2().domain([0, y_max]).range([height, 0]);
      const tickEvery = nearest / 2, ticks = Array.from(Array(y_max / tickEvery + 1).keys()).map((n) => n * tickEvery);
      const yAxis = axisLeft(y2).tickValues(ticks);
      svg.append("g").call(yAxis);
      const barFill = "#dcdcdc";
      svg.selectAll("rect").data([...data.entries()]).enter().append("rect").attr("x", ([, d]) => x2(d.x._1)).attr("y", ([, d]) => y2(d.y._1 + 1)).attr("width", x2.bandwidth()).attr("height", ([, d]) => height - y2(d.y._1)).attr("fill", ([, d]) => d.y._2 ? colorShade(barFill, -40) : barFill).attr("class", ([, d]) => d.y._2 ? "bar-selected" : "bar-unselected").on("mousedown", (e, d) => {
        console.log(`mousedown ${d[0]}`);
        listener(e);
      });
      svg.append("text").text(caption._1).attr("x", width / 2).attr("y", height + 35).attr("class", "title-text").attr("dominant-baseline", "bottom").attr("text-anchor", "middle");
    };
  }
  var drawBarChart = curry4(drawBarChart_);

  // output-es/App.BarChart/index.js
  var neg2 = /* @__PURE__ */ (() => joinSemilatticeVal(joinSemilatticeBoolean).neg)();
  var reflectDictValBooleanBarC = { from: () => (r) => ({ x: string2.match($$get("x")(r)), y: get_intOrNumber("y")(r) }) };
  var reflectDictValBooleanBarC1 = {
    from: () => (r) => ({
      caption: string2.match($$get("caption")(r)),
      data: arrayMap(record2(reflectDictValBooleanBarC.from()))(reflectArray.from()($$get("data")(r)))
    })
  };
  var barChartHandler = (ev) => toggleConstrArg("BarChart")(0)(toggleField("data")(selectNth(definitely("index within bounds")(index2(definitely("absurd")(nullable(
    _target(ev),
    Nothing,
    Just
  )).__data__)(0)))(neg2)));

  // output-es/App.LineChart/foreign.js
  function curry42(f) {
    return (x1) => (x2) => (x3) => (x4) => f(x1, x2, x3, x4);
  }
  function colorShade2(col, amt) {
    col = col.replace(/^#/, "");
    if (col.length === 3)
      col = col[0] + col[0] + col[1] + col[1] + col[2] + col[2];
    let [r, g, b] = col.match(/.{2}/g);
    [r, g, b] = [parseInt(r, 16) + amt, parseInt(g, 16) + amt, parseInt(b, 16) + amt];
    r = Math.max(Math.min(255, r), 0).toString(16);
    g = Math.max(Math.min(255, g), 0).toString(16);
    b = Math.max(Math.min(255, b), 0).toString(16);
    const rr = (r.length < 2 ? "0" : "") + r;
    const gg = (g.length < 2 ? "0" : "") + g;
    const bb = (b.length < 2 ? "0" : "") + b;
    return `#${rr}${gg}${bb}`;
  }
  function max_y(linePlot) {
    return Math.max(...linePlot.data.map((point2) => point2.y._1));
  }
  function min_x(linePlot) {
    return Math.min(...linePlot.data.map((point2) => point2.x._1));
  }
  function max_x(linePlot) {
    return Math.max(...linePlot.data.map((point2) => point2.x._1));
  }
  function drawLineChart_(id3, childIndex, {
    caption,
    plots
  }, listener) {
    return () => {
      const childId = id3 + "-" + childIndex;
      const margin = { top: 15, right: 65, bottom: 40, left: 30 }, width = 230 - margin.left - margin.right, height = 185 - margin.top - margin.bottom, y_max = Math.max(...plots.map(max_y)), x_min = Math.min(...plots.map(min_x)), x_max = Math.max(...plots.map(max_x)), names = plots.map((plot) => plot.name._1);
      const div = select_default2("#" + id3);
      div.selectAll("#" + childId).remove();
      const svg = div.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).attr("id", childId).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
      const x2 = linear2().domain([x_min, x_max]).range([0, width]), y2 = linear2().domain([0, y_max]).range([height, 0]);
      const line1 = line_default().x((d) => x2(d.x._1)).y((d) => y2(d.y._1));
      const color2 = ordinal(Pastel1_default);
      svg.selectAll("lines").data([...plots.entries()]).enter().append("g").append("path").attr("fill", "none").attr("stroke", ([, d]) => color2(names.indexOf(d.name._1))).attr("stroke-width", 1).attr("class", "line").attr("d", ([_, d]) => line1(d.data));
      const smallRadius = 2;
      for (const n_plot of plots.entries()) {
        const [i, plot] = n_plot, col = color2(names.indexOf(plot.name._1));
        svg.selectAll("markers").data([...plot.data.entries()].map(([j, ns]) => [[i, j], ns])).enter().append("g").append("circle").attr("r", ([, d]) => d.y._2 ? smallRadius * 2 : smallRadius).attr("cx", ([, d]) => x2(d.x._1)).attr("cy", ([, d]) => y2(d.y._1)).attr("fill", col).attr("stroke", ([, d]) => d.y._2 ? colorShade2(col, -30) : col).on("mousedown", (e, d) => {
          console.log(`mousedown ${d[0]}`);
          listener(e);
        });
      }
      svg.append("g").attr("transform", `translate(0, ${height})`).call(axisBottom(x2).ticks(x_max - x_min).tickFormat(format("d")));
      svg.append("g").call(axisLeft(y2).tickSizeOuter(0).ticks(3).tickFormat(format(".1f")));
      const legendLineHeight = 15, legendStart = width + margin.left / 2;
      svg.append("rect").attr("transform", `translate(${legendStart}, ${legendLineHeight * (names.length - 1) + 2})`).attr("x", 0).attr("y", 0).attr("stroke", "lightgray").attr("fill", "none").attr("height", legendLineHeight * names.length).attr("width", margin.right - 16);
      const legend = svg.selectAll("legend").data(names).enter().append("g").attr("class", "legend").attr(
        "transform",
        (d, i) => `translate(${legendStart}, ${height / 2 - margin.top + i * legendLineHeight})`
      );
      legend.append("text").text((d) => d).attr("font-size", 11).attr("transform", "translate(15, 9)");
      legend.append("circle").attr("fill", (d) => color2(names.indexOf(d))).attr("r", smallRadius).attr("cx", legendLineHeight / 2 - smallRadius / 2).attr("cy", legendLineHeight / 2 - smallRadius / 2);
      svg.append("text").text(caption._1).attr("x", width / 2).attr("y", height + 35).attr("class", "title-text").attr("dominant-baseline", "bottom").attr("text-anchor", "middle");
    };
  }
  var drawLineChart = curry42(drawLineChart_);

  // output-es/App.LineChart/index.js
  var neg3 = /* @__PURE__ */ (() => joinSemilatticeVal(joinSemilatticeBoolean).neg)();
  var reflectDictValBooleanPoin = { from: () => (r) => ({ x: get_intOrNumber("x")(r), y: get_intOrNumber("y")(r) }) };
  var reflectDictValBooleanLine = {
    from: () => (r) => ({
      name: string2.match($$get("name")(r)),
      data: arrayMap(record2(reflectDictValBooleanPoin.from()))(reflectArray.from()($$get("data")(r)))
    })
  };
  var reflectValBooleanLinePlot = {
    from: () => (v) => {
      if (v.tag === "Constr") {
        if (v._3.tag === "Cons") {
          if (v._3._2.tag === "Nil") {
            if (v._2 === "LinePlot") {
              return reflectDictValBooleanLine.from()(record1.match(v._3._1)._1);
            }
            fail();
          }
          fail();
        }
        fail();
      }
      fail();
    }
  };
  var reflectDictValBooleanLine1 = {
    from: () => (r) => ({ caption: string2.match($$get("caption")(r)), plots: arrayMap(reflectValBooleanLinePlot.from())(reflectArray.from()($$get("plots")(r))) })
  };
  var lineChartHandler = (ev) => {
    const xy = definitely("index within bounds")(index2(definitely("absurd")(nullable(
      _target(ev),
      Nothing,
      Just
    )).__data__)(0));
    return toggleConstrArg("LineChart")(0)(toggleField("plots")(selectNth(definitely("index within bounds")(index2(xy)(0)))(toggleConstrArg("LinePlot")(0)(toggleField("data")(selectNth(definitely("index within bounds")(index2(xy)(1)))(neg3))))));
  };

  // output-es/App.MatrixView/foreign.js
  function curry43(f) {
    return (x1) => (x2) => (x3) => (x4) => f(x1, x2, x3, x4);
  }
  function drawMatrix_(id3, childIndex, {
    title: title2,
    matrix: { _1: nss, _2: { _1: i_max, _2: j_max } }
  }, listener) {
    return () => {
      const childId = id3 + "-" + childIndex;
      const strokeWidth = 0.5;
      const w = 30, h = 30;
      const div = select_default2("#" + id3);
      const [width, height] = [w * j_max + strokeWidth, h * i_max + strokeWidth];
      const hMargin = w / 2;
      const vMargin = h / 2;
      div.selectAll("#" + childId).remove();
      const svg = div.append("svg").attr("id", childId).attr("width", width + hMargin).attr("height", height + vMargin);
      const grp = svg.selectAll("g").data([...nss.entries()].map(([i, ns]) => [i + 1, ns])).enter().append("g").attr(
        "transform",
        (_, i) => `translate(${strokeWidth / 2 + hMargin / 2}, ${h * i + strokeWidth / 2 + vMargin})`
      );
      const rect = grp.selectAll("rect").data(([i, ns]) => [...ns.entries()].map(([j, n]) => [[i, j + 1], n])).enter();
      rect.append("rect").attr("x", (_, j) => w * j).attr("width", w).attr("height", h).attr("class", ([, n]) => n._2 ? "matrix-cell-selected" : "matrix-cell-unselected").attr("stroke-width", strokeWidth);
      rect.append("text").text(([, n]) => n._1).attr("x", (_, j) => w * (j + 0.5)).attr("y", 0.5 * h).attr("class", "matrix-cell-text").attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("pointer-events", "none");
      svg.append("text").text(title2).attr("x", hMargin / 2).attr("y", vMargin / 2).attr("class", "title-text").attr("dominant-baseline", "middle").attr("text-anchor", "left");
      svg.selectAll("rect").on("mousedown", (e, d) => {
        console.log(`mousedown ${d[0]}`);
        listener(e);
      });
    };
  }
  var drawMatrix = curry43(drawMatrix_);

  // output-es/App.MatrixView/index.js
  var matrixViewHandler = (ev) => {
    const xy = definitely("index within bounds")(index2(definitely("absurd")(nullable(
      _target(ev),
      Nothing,
      Just
    )).__data__)(0));
    return toggleCell(definitely("index within bounds")(index2(xy)(0)))(definitely("index within bounds")(index2(xy)(1)));
  };
  var matrixRep2 = (v) => $Tuple(arrayMap(arrayMap((x2) => $$int.match(x2)))(v._1), $Tuple(v._2._1._1, v._2._2._1));

  // output-es/App.TableView/foreign.js
  function curry44(f) {
    return (x1) => (x2) => (x3) => (x4) => f(x1, x2, x3, x4);
  }
  function colorShade3(col, amt) {
    col = col.replace(/^#/, "");
    if (col.length === 3)
      col = col[0] + col[0] + col[1] + col[1] + col[2] + col[2];
    let [r, g, b] = col.match(/.{2}/g);
    [r, g, b] = [parseInt(r, 16) + amt, parseInt(g, 16) + amt, parseInt(b, 16) + amt];
    r = Math.max(Math.min(255, r), 0).toString(16);
    g = Math.max(Math.min(255, g), 0).toString(16);
    b = Math.max(Math.min(255, b), 0).toString(16);
    const rr = (r.length < 2 ? "0" : "") + r;
    const gg = (g.length < 2 ? "0" : "") + g;
    const bb = (b.length < 2 ? "0" : "") + b;
    return `#${rr}${gg}${bb}`;
  }
  function isUsed(r) {
    return Object.keys(r).some((k) => r[k]._2);
  }
  function drawTable_(id3, childIndex, {
    title: title2,
    table
  }, listener) {
    return () => {
      const childId = id3 + "-" + childIndex;
      const cellFill = "#ffffff";
      const div = select_default2("#" + id3);
      div.selectAll("#" + childId).remove();
      table = table.filter((r) => isUsed(r));
      if (table.length > 0) {
        const HTMLtable = div.append("table").attr("id", childId);
        const colNames = Object.keys(table[0]);
        HTMLtable.append("thead").append("tr").selectAll("th").data(colNames).enter().append("th").text((d) => d);
        const rows = HTMLtable.append("tbody").selectAll("tr").data(table).enter().append("tr");
        rows.selectAll("td").data((d) => colNames.map((k) => {
          return { "value": d[k], "name": k };
        })).enter().append("td").attr("data-th", (d) => d.name).attr("class", (d) => d.value._2 ? "cell-selected" : null).attr("bgcolor", (d) => d.value._2 ? colorShade3(cellFill, -40) : cellFill).text((d) => d.value._1).on(
          "mouseover",
          (e, d) => listener(e)
        );
      }
    };
  }
  var drawTable = curry44(drawTable_);

  // output-es/App.TableView/index.js
  var energyRecord = (r) => ({
    year: $$int.match($$get("year")(r)),
    country: string2.match($$get("country")(r)),
    energyType: string2.match($$get("energyType")(r)),
    output: get_intOrNumber("output")(r)
  });

  // output-es/Control.Monad.Error.Class/index.js
  var $$try2 = (dictMonadError) => {
    const Monad0 = dictMonadError.MonadThrow0().Monad0();
    const map6 = Monad0.Bind1().Apply0().Functor0().map;
    const pure2 = Monad0.Applicative0().pure;
    return (a) => dictMonadError.catchError(map6(Right)(a))((x2) => pure2($Either("Left", x2)));
  };

  // output-es/Effect.Aff/foreign.js
  var Aff = function() {
    var EMPTY = {};
    var PURE = "Pure";
    var THROW = "Throw";
    var CATCH = "Catch";
    var SYNC = "Sync";
    var ASYNC = "Async";
    var BIND = "Bind";
    var BRACKET = "Bracket";
    var FORK = "Fork";
    var SEQ = "Sequential";
    var MAP = "Map";
    var APPLY = "Apply";
    var ALT = "Alt";
    var CONS = "Cons";
    var RESUME = "Resume";
    var RELEASE = "Release";
    var FINALIZER = "Finalizer";
    var FINALIZED = "Finalized";
    var FORKED = "Forked";
    var FIBER = "Fiber";
    var THUNK = "Thunk";
    function Aff2(tag, _1, _2, _3) {
      this.tag = tag;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
    }
    function AffCtr(tag) {
      var fn = function(_1, _2, _3) {
        return new Aff2(tag, _1, _2, _3);
      };
      fn.tag = tag;
      return fn;
    }
    function nonCanceler2(error3) {
      return new Aff2(PURE, void 0);
    }
    function runEff(eff) {
      try {
        eff();
      } catch (error3) {
        setTimeout(function() {
          throw error3;
        }, 0);
      }
    }
    function runSync(left2, right2, eff) {
      try {
        return right2(eff());
      } catch (error3) {
        return left2(error3);
      }
    }
    function runAsync(left2, eff, k) {
      try {
        return eff(k)();
      } catch (error3) {
        k(left2(error3))();
        return nonCanceler2;
      }
    }
    var Scheduler = function() {
      var limit = 1024;
      var size3 = 0;
      var ix = 0;
      var queue = new Array(limit);
      var draining = false;
      function drain() {
        var thunk;
        draining = true;
        while (size3 !== 0) {
          size3--;
          thunk = queue[ix];
          queue[ix] = void 0;
          ix = (ix + 1) % limit;
          thunk();
        }
        draining = false;
      }
      return {
        isDraining: function() {
          return draining;
        },
        enqueue: function(cb) {
          var i, tmp;
          if (size3 === limit) {
            tmp = draining;
            drain();
            draining = tmp;
          }
          queue[(ix + size3) % limit] = cb;
          size3++;
          if (!draining) {
            drain();
          }
        }
      };
    }();
    function Supervisor(util2) {
      var fibers = {};
      var fiberId = 0;
      var count = 0;
      return {
        register: function(fiber) {
          var fid = fiberId++;
          fiber.onComplete({
            rethrow: true,
            handler: function(result) {
              return function() {
                count--;
                delete fibers[fid];
              };
            }
          })();
          fibers[fid] = fiber;
          count++;
        },
        isEmpty: function() {
          return count === 0;
        },
        killAll: function(killError, cb) {
          return function() {
            if (count === 0) {
              return cb();
            }
            var killCount = 0;
            var kills = {};
            function kill(fid) {
              kills[fid] = fibers[fid].kill(killError, function(result) {
                return function() {
                  delete kills[fid];
                  killCount--;
                  if (util2.isLeft(result) && util2.fromLeft(result)) {
                    setTimeout(function() {
                      throw util2.fromLeft(result);
                    }, 0);
                  }
                  if (killCount === 0) {
                    cb();
                  }
                };
              })();
            }
            for (var k in fibers) {
              if (fibers.hasOwnProperty(k)) {
                killCount++;
                kill(k);
              }
            }
            fibers = {};
            fiberId = 0;
            count = 0;
            return function(error3) {
              return new Aff2(SYNC, function() {
                for (var k2 in kills) {
                  if (kills.hasOwnProperty(k2)) {
                    kills[k2]();
                  }
                }
              });
            };
          };
        }
      };
    }
    var SUSPENDED = 0;
    var CONTINUE = 1;
    var STEP_BIND = 2;
    var STEP_RESULT = 3;
    var PENDING = 4;
    var RETURN = 5;
    var COMPLETED = 6;
    function Fiber(util2, supervisor, aff) {
      var runTick = 0;
      var status = SUSPENDED;
      var step = aff;
      var fail4 = null;
      var interrupt = null;
      var bhead = null;
      var btail = null;
      var attempts = null;
      var bracketCount = 0;
      var joinId = 0;
      var joins = null;
      var rethrow = true;
      function run2(localRunTick) {
        var tmp, result, attempt;
        while (true) {
          tmp = null;
          result = null;
          attempt = null;
          switch (status) {
            case STEP_BIND:
              status = CONTINUE;
              try {
                step = bhead(step);
                if (btail === null) {
                  bhead = null;
                } else {
                  bhead = btail._1;
                  btail = btail._2;
                }
              } catch (e) {
                status = RETURN;
                fail4 = util2.left(e);
                step = null;
              }
              break;
            case STEP_RESULT:
              if (util2.isLeft(step)) {
                status = RETURN;
                fail4 = step;
                step = null;
              } else if (bhead === null) {
                status = RETURN;
              } else {
                status = STEP_BIND;
                step = util2.fromRight(step);
              }
              break;
            case CONTINUE:
              switch (step.tag) {
                case BIND:
                  if (bhead) {
                    btail = new Aff2(CONS, bhead, btail);
                  }
                  bhead = step._2;
                  status = CONTINUE;
                  step = step._1;
                  break;
                case PURE:
                  if (bhead === null) {
                    status = RETURN;
                    step = util2.right(step._1);
                  } else {
                    status = STEP_BIND;
                    step = step._1;
                  }
                  break;
                case SYNC:
                  status = STEP_RESULT;
                  step = runSync(util2.left, util2.right, step._1);
                  break;
                case ASYNC:
                  status = PENDING;
                  step = runAsync(util2.left, step._1, function(result2) {
                    return function() {
                      if (runTick !== localRunTick) {
                        return;
                      }
                      runTick++;
                      Scheduler.enqueue(function() {
                        if (runTick !== localRunTick + 1) {
                          return;
                        }
                        status = STEP_RESULT;
                        step = result2;
                        run2(runTick);
                      });
                    };
                  });
                  return;
                case THROW:
                  status = RETURN;
                  fail4 = util2.left(step._1);
                  step = null;
                  break;
                case CATCH:
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step = step._1;
                  break;
                case BRACKET:
                  bracketCount++;
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step = step._1;
                  break;
                case FORK:
                  status = STEP_RESULT;
                  tmp = Fiber(util2, supervisor, step._2);
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
                  if (step._1) {
                    tmp.run();
                  }
                  step = util2.right(tmp);
                  break;
                case SEQ:
                  status = CONTINUE;
                  step = sequential(util2, supervisor, step._1);
                  break;
              }
              break;
            case RETURN:
              bhead = null;
              btail = null;
              if (attempts === null) {
                status = COMPLETED;
                step = interrupt || fail4 || step;
              } else {
                tmp = attempts._3;
                attempt = attempts._1;
                attempts = attempts._2;
                switch (attempt.tag) {
                  case CATCH:
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      status = RETURN;
                    } else if (fail4) {
                      status = CONTINUE;
                      step = attempt._2(util2.fromLeft(fail4));
                      fail4 = null;
                    }
                    break;
                  case RESUME:
                    if (interrupt && interrupt !== tmp && bracketCount === 0 || fail4) {
                      status = RETURN;
                    } else {
                      bhead = attempt._1;
                      btail = attempt._2;
                      status = STEP_BIND;
                      step = util2.fromRight(step);
                    }
                    break;
                  case BRACKET:
                    bracketCount--;
                    if (fail4 === null) {
                      result = util2.fromRight(step);
                      attempts = new Aff2(CONS, new Aff2(RELEASE, attempt._2, result), attempts, tmp);
                      if (interrupt === tmp || bracketCount > 0) {
                        status = CONTINUE;
                        step = attempt._3(result);
                      }
                    }
                    break;
                  case RELEASE:
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step, fail4), attempts, interrupt);
                    status = CONTINUE;
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      step = attempt._1.killed(util2.fromLeft(interrupt))(attempt._2);
                    } else if (fail4) {
                      step = attempt._1.failed(util2.fromLeft(fail4))(attempt._2);
                    } else {
                      step = attempt._1.completed(util2.fromRight(step))(attempt._2);
                    }
                    fail4 = null;
                    bracketCount++;
                    break;
                  case FINALIZER:
                    bracketCount++;
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step, fail4), attempts, interrupt);
                    status = CONTINUE;
                    step = attempt._1;
                    break;
                  case FINALIZED:
                    bracketCount--;
                    status = RETURN;
                    step = attempt._1;
                    fail4 = attempt._2;
                    break;
                }
              }
              break;
            case COMPLETED:
              for (var k in joins) {
                if (joins.hasOwnProperty(k)) {
                  rethrow = rethrow && joins[k].rethrow;
                  runEff(joins[k].handler(step));
                }
              }
              joins = null;
              if (interrupt && fail4) {
                setTimeout(function() {
                  throw util2.fromLeft(fail4);
                }, 0);
              } else if (util2.isLeft(step) && rethrow) {
                setTimeout(function() {
                  if (rethrow) {
                    throw util2.fromLeft(step);
                  }
                }, 0);
              }
              return;
            case SUSPENDED:
              status = CONTINUE;
              break;
            case PENDING:
              return;
          }
        }
      }
      function onComplete(join2) {
        return function() {
          if (status === COMPLETED) {
            rethrow = rethrow && join2.rethrow;
            join2.handler(step)();
            return function() {
            };
          }
          var jid = joinId++;
          joins = joins || {};
          joins[jid] = join2;
          return function() {
            if (joins !== null) {
              delete joins[jid];
            }
          };
        };
      }
      function kill(error3, cb) {
        return function() {
          if (status === COMPLETED) {
            cb(util2.right(void 0))();
            return function() {
            };
          }
          var canceler = onComplete({
            rethrow: false,
            handler: function() {
              return cb(util2.right(void 0));
            }
          })();
          switch (status) {
            case SUSPENDED:
              interrupt = util2.left(error3);
              status = COMPLETED;
              step = interrupt;
              run2(runTick);
              break;
            case PENDING:
              if (interrupt === null) {
                interrupt = util2.left(error3);
              }
              if (bracketCount === 0) {
                if (status === PENDING) {
                  attempts = new Aff2(CONS, new Aff2(FINALIZER, step(error3)), attempts, interrupt);
                }
                status = RETURN;
                step = null;
                fail4 = null;
                run2(++runTick);
              }
              break;
            default:
              if (interrupt === null) {
                interrupt = util2.left(error3);
              }
              if (bracketCount === 0) {
                status = RETURN;
                step = null;
                fail4 = null;
              }
          }
          return canceler;
        };
      }
      function join(cb) {
        return function() {
          var canceler = onComplete({
            rethrow: false,
            handler: cb
          })();
          if (status === SUSPENDED) {
            run2(runTick);
          }
          return canceler;
        };
      }
      return {
        kill,
        join,
        onComplete,
        isSuspended: function() {
          return status === SUSPENDED;
        },
        run: function() {
          if (status === SUSPENDED) {
            if (!Scheduler.isDraining()) {
              Scheduler.enqueue(function() {
                run2(runTick);
              });
            } else {
              run2(runTick);
            }
          }
        }
      };
    }
    function runPar(util2, supervisor, par, cb) {
      var fiberId = 0;
      var fibers = {};
      var killId = 0;
      var kills = {};
      var early = new Error("[ParAff] Early exit");
      var interrupt = null;
      var root3 = EMPTY;
      function kill(error3, par2, cb2) {
        var step = par2;
        var head = null;
        var tail = null;
        var count = 0;
        var kills2 = {};
        var tmp, kid;
        loop:
          while (true) {
            tmp = null;
            switch (step.tag) {
              case FORKED:
                if (step._3 === EMPTY) {
                  tmp = fibers[step._1];
                  kills2[count++] = tmp.kill(error3, function(result) {
                    return function() {
                      count--;
                      if (count === 0) {
                        cb2(result)();
                      }
                    };
                  });
                }
                if (head === null) {
                  break loop;
                }
                step = head._2;
                if (tail === null) {
                  head = null;
                } else {
                  head = tail._1;
                  tail = tail._2;
                }
                break;
              case MAP:
                step = step._2;
                break;
              case APPLY:
              case ALT:
                if (head) {
                  tail = new Aff2(CONS, head, tail);
                }
                head = step;
                step = step._1;
                break;
            }
          }
        if (count === 0) {
          cb2(util2.right(void 0))();
        } else {
          kid = 0;
          tmp = count;
          for (; kid < tmp; kid++) {
            kills2[kid] = kills2[kid]();
          }
        }
        return kills2;
      }
      function join(result, head, tail) {
        var fail4, step, lhs, rhs, tmp, kid;
        if (util2.isLeft(result)) {
          fail4 = result;
          step = null;
        } else {
          step = result;
          fail4 = null;
        }
        loop:
          while (true) {
            lhs = null;
            rhs = null;
            tmp = null;
            kid = null;
            if (interrupt !== null) {
              return;
            }
            if (head === null) {
              cb(fail4 || step)();
              return;
            }
            if (head._3 !== EMPTY) {
              return;
            }
            switch (head.tag) {
              case MAP:
                if (fail4 === null) {
                  head._3 = util2.right(head._1(util2.fromRight(step)));
                  step = head._3;
                } else {
                  head._3 = fail4;
                }
                break;
              case APPLY:
                lhs = head._1._3;
                rhs = head._2._3;
                if (fail4) {
                  head._3 = fail4;
                  tmp = true;
                  kid = killId++;
                  kills[kid] = kill(early, fail4 === lhs ? head._2 : head._1, function() {
                    return function() {
                      delete kills[kid];
                      if (tmp) {
                        tmp = false;
                      } else if (tail === null) {
                        join(fail4, null, null);
                      } else {
                        join(fail4, tail._1, tail._2);
                      }
                    };
                  });
                  if (tmp) {
                    tmp = false;
                    return;
                  }
                } else if (lhs === EMPTY || rhs === EMPTY) {
                  return;
                } else {
                  step = util2.right(util2.fromRight(lhs)(util2.fromRight(rhs)));
                  head._3 = step;
                }
                break;
              case ALT:
                lhs = head._1._3;
                rhs = head._2._3;
                if (lhs === EMPTY && util2.isLeft(rhs) || rhs === EMPTY && util2.isLeft(lhs)) {
                  return;
                }
                if (lhs !== EMPTY && util2.isLeft(lhs) && rhs !== EMPTY && util2.isLeft(rhs)) {
                  fail4 = step === lhs ? rhs : lhs;
                  step = null;
                  head._3 = fail4;
                } else {
                  head._3 = step;
                  tmp = true;
                  kid = killId++;
                  kills[kid] = kill(early, step === lhs ? head._2 : head._1, function() {
                    return function() {
                      delete kills[kid];
                      if (tmp) {
                        tmp = false;
                      } else if (tail === null) {
                        join(step, null, null);
                      } else {
                        join(step, tail._1, tail._2);
                      }
                    };
                  });
                  if (tmp) {
                    tmp = false;
                    return;
                  }
                }
                break;
            }
            if (tail === null) {
              head = null;
            } else {
              head = tail._1;
              tail = tail._2;
            }
          }
      }
      function resolve(fiber) {
        return function(result) {
          return function() {
            delete fibers[fiber._1];
            fiber._3 = result;
            join(result, fiber._2._1, fiber._2._2);
          };
        };
      }
      function run2() {
        var status = CONTINUE;
        var step = par;
        var head = null;
        var tail = null;
        var tmp, fid;
        loop:
          while (true) {
            tmp = null;
            fid = null;
            switch (status) {
              case CONTINUE:
                switch (step.tag) {
                  case MAP:
                    if (head) {
                      tail = new Aff2(CONS, head, tail);
                    }
                    head = new Aff2(MAP, step._1, EMPTY, EMPTY);
                    step = step._2;
                    break;
                  case APPLY:
                    if (head) {
                      tail = new Aff2(CONS, head, tail);
                    }
                    head = new Aff2(APPLY, EMPTY, step._2, EMPTY);
                    step = step._1;
                    break;
                  case ALT:
                    if (head) {
                      tail = new Aff2(CONS, head, tail);
                    }
                    head = new Aff2(ALT, EMPTY, step._2, EMPTY);
                    step = step._1;
                    break;
                  default:
                    fid = fiberId++;
                    status = RETURN;
                    tmp = step;
                    step = new Aff2(FORKED, fid, new Aff2(CONS, head, tail), EMPTY);
                    tmp = Fiber(util2, supervisor, tmp);
                    tmp.onComplete({
                      rethrow: false,
                      handler: resolve(step)
                    })();
                    fibers[fid] = tmp;
                    if (supervisor) {
                      supervisor.register(tmp);
                    }
                }
                break;
              case RETURN:
                if (head === null) {
                  break loop;
                }
                if (head._1 === EMPTY) {
                  head._1 = step;
                  status = CONTINUE;
                  step = head._2;
                  head._2 = EMPTY;
                } else {
                  head._2 = step;
                  step = head;
                  if (tail === null) {
                    head = null;
                  } else {
                    head = tail._1;
                    tail = tail._2;
                  }
                }
            }
          }
        root3 = step;
        for (fid = 0; fid < fiberId; fid++) {
          fibers[fid].run();
        }
      }
      function cancel(error3, cb2) {
        interrupt = util2.left(error3);
        var innerKills;
        for (var kid in kills) {
          if (kills.hasOwnProperty(kid)) {
            innerKills = kills[kid];
            for (kid in innerKills) {
              if (innerKills.hasOwnProperty(kid)) {
                innerKills[kid]();
              }
            }
          }
        }
        kills = null;
        var newKills = kill(error3, root3, cb2);
        return function(killError) {
          return new Aff2(ASYNC, function(killCb) {
            return function() {
              for (var kid2 in newKills) {
                if (newKills.hasOwnProperty(kid2)) {
                  newKills[kid2]();
                }
              }
              return nonCanceler2;
            };
          });
        };
      }
      run2();
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            return cancel(killError, killCb);
          };
        });
      };
    }
    function sequential(util2, supervisor, par) {
      return new Aff2(ASYNC, function(cb) {
        return function() {
          return runPar(util2, supervisor, par, cb);
        };
      });
    }
    Aff2.EMPTY = EMPTY;
    Aff2.Pure = AffCtr(PURE);
    Aff2.Throw = AffCtr(THROW);
    Aff2.Catch = AffCtr(CATCH);
    Aff2.Sync = AffCtr(SYNC);
    Aff2.Async = AffCtr(ASYNC);
    Aff2.Bind = AffCtr(BIND);
    Aff2.Bracket = AffCtr(BRACKET);
    Aff2.Fork = AffCtr(FORK);
    Aff2.Seq = AffCtr(SEQ);
    Aff2.ParMap = AffCtr(MAP);
    Aff2.ParApply = AffCtr(APPLY);
    Aff2.ParAlt = AffCtr(ALT);
    Aff2.Fiber = Fiber;
    Aff2.Supervisor = Supervisor;
    Aff2.Scheduler = Scheduler;
    Aff2.nonCanceler = nonCanceler2;
    return Aff2;
  }();
  var _pure = Aff.Pure;
  var _throwError = Aff.Throw;
  function _catchError(aff) {
    return function(k) {
      return Aff.Catch(aff, k);
    };
  }
  function _map(f) {
    return function(aff) {
      if (aff.tag === Aff.Pure.tag) {
        return Aff.Pure(f(aff._1));
      } else {
        return Aff.Bind(aff, function(value) {
          return Aff.Pure(f(value));
        });
      }
    };
  }
  function _bind(aff) {
    return function(k) {
      return Aff.Bind(aff, k);
    };
  }
  var _liftEffect = Aff.Sync;
  var makeAff = Aff.Async;
  function _makeFiber(util2, aff) {
    return function() {
      return Aff.Fiber(util2, null, aff);
    };
  }
  var _delay = function() {
    function setDelay(n, k) {
      if (n === 0 && typeof setImmediate !== "undefined") {
        return setImmediate(k);
      } else {
        return setTimeout(k, n);
      }
    }
    function clearDelay(n, t2) {
      if (n === 0 && typeof clearImmediate !== "undefined") {
        return clearImmediate(t2);
      } else {
        return clearTimeout(t2);
      }
    }
    return function(right2, ms) {
      return Aff.Async(function(cb) {
        return function() {
          var timer2 = setDelay(ms, cb(right2()));
          return function() {
            return Aff.Sync(function() {
              return right2(clearDelay(ms, timer2));
            });
          };
        };
      });
    };
  }();
  var _sequential = Aff.Seq;

  // output-es/Effect.Aff/index.js
  var functorAff = { map: _map };
  var ffiUtil = {
    isLeft: (v) => {
      if (v.tag === "Left") {
        return true;
      }
      if (v.tag === "Right") {
        return false;
      }
      fail();
    },
    fromLeft: (v) => {
      if (v.tag === "Left") {
        return v._1;
      }
      if (v.tag === "Right") {
        return _crashWith("unsafeFromLeft: Right");
      }
      fail();
    },
    fromRight: (v) => {
      if (v.tag === "Right") {
        return v._1;
      }
      if (v.tag === "Left") {
        return _crashWith("unsafeFromRight: Left");
      }
      fail();
    },
    left: Left,
    right: Right
  };
  var monadAff = { Applicative0: () => applicativeAff, Bind1: () => bindAff };
  var bindAff = { bind: _bind, Apply0: () => applyAff };
  var applyAff = { apply: (f) => (a) => _bind(f)((f$p) => _bind(a)((a$p) => applicativeAff.pure(f$p(a$p)))), Functor0: () => functorAff };
  var applicativeAff = { pure: _pure, Apply0: () => applyAff };
  var monadThrowAff = { throwError: _throwError, Monad0: () => monadAff };
  var monadErrorAff = { catchError: _catchError, MonadThrow0: () => monadThrowAff };
  var $$try3 = /* @__PURE__ */ $$try2(monadErrorAff);
  var runAff = (k) => (aff) => {
    const $2 = _makeFiber(ffiUtil, _bind($$try3(aff))((x2) => _liftEffect(k(x2))));
    return () => {
      const fiber = $2();
      fiber.run();
      return fiber;
    };
  };
  var nonCanceler = /* @__PURE__ */ (() => {
    const $0 = _pure(unit2);
    return (v) => $0;
  })();

  // output-es/Effect.Console/foreign.js
  var log2 = function(s) {
    return function() {
      console.log(s);
    };
  };

  // output-es/Trace/index.js
  var $AppTrace = (tag, _1, _2, _3) => ({ tag, _1, _2, _3 });
  var $ForeignTrace$p = (_1, _2) => ({ tag: "ForeignTrace'", _1, _2 });
  var $Match = (tag, _1, _2) => ({ tag, _1, _2 });
  var $Trace = (tag, _1, _2, _3, _4) => ({ tag, _1, _2, _3, _4 });
  var $VarDef3 = (_1, _2) => ({ tag: "VarDef", _1, _2 });
  var unions2 = /* @__PURE__ */ (() => {
    const go = (go$a0$copy) => (go$a1$copy) => {
      let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
      while (go$c) {
        const b = go$a0, v = go$a1;
        if (v.tag === "Nil") {
          go$c = false;
          go$r = b;
          continue;
        }
        if (v.tag === "Cons") {
          go$a0 = unionWith(ordString)($$const)(b)(v._1);
          go$a1 = v._2;
          continue;
        }
        fail();
      }
      ;
      return go$r;
    };
    return go(Leaf2);
  })();
  var unions12 = /* @__PURE__ */ fold((z) => (v) => union2(ordString)(z))(Leaf2);
  var Const2 = /* @__PURE__ */ $Trace("Const");
  var bVMatch = {
    bv: (v) => {
      if (v.tag === "MatchVar") {
        return $Map("Two", Leaf2, v._1, unit2, Leaf2);
      }
      if (v.tag === "MatchVarAnon") {
        return Leaf2;
      }
      if (v.tag === "MatchConstr") {
        return unions2(listMap(bVMatch.bv)(v._2));
      }
      if (v.tag === "MatchRecord") {
        return unions12(_fmapObject(v._1, bVMatch.bv));
      }
      fail();
    }
  };

  // output-es/Eval/index.js
  var fromFoldable7 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2))();
  var show2 = /* @__PURE__ */ (() => showSet(showString).show)();
  var toUnfoldable10 = /* @__PURE__ */ toUnfoldable4(unfoldableList);
  var fromFoldable14 = /* @__PURE__ */ fromFoldable2(foldableList);
  var fv = /* @__PURE__ */ (() => fVDict(fVElim).fv)();
  var traverse4 = /* @__PURE__ */ (() => {
    const $0 = traversableWithIndexObject.traverseWithIndex(applicativeEither);
    return (x2) => $0((v) => x2);
  })();
  var traverse12 = /* @__PURE__ */ (() => traversableList.traverse(applicativeEither))();
  var traverse22 = /* @__PURE__ */ (() => traversablePair.traverse(applicativeEither))();
  var fromFoldable23 = /* @__PURE__ */ (() => fromFoldableImpl(foldableList.foldr))();
  var greaterThanOrEq1 = /* @__PURE__ */ (() => {
    const $0 = ordTuple(ordInt)(ordInt);
    return (a1) => (a2) => !($0.compare(a1)(a2).tag === "LT");
  })();
  var show3 = (v) => "(Tuple " + (showIntImpl(v._1) + (" " + (showIntImpl(v._2) + ")")));
  var sequence2 = /* @__PURE__ */ (() => traversableList.traverse(applicativeEither)(identity6))();
  var erase1 = /* @__PURE__ */ (() => functorElim.map((v) => unit2))();
  var matchMany = (dictAnn) => {
    const BoundedMeetSemilattice1 = dictAnn.BoundedLattice1().BoundedMeetSemilattice1();
    const meet = BoundedMeetSemilattice1.MeetSemilattice0().meet;
    return (v) => (v1) => {
      if (v.tag === "Nil") {
        return $Either(
          "Right",
          $Tuple(empty2, $Tuple(v1, $Tuple(BoundedMeetSemilattice1.top, Nil)))
        );
      }
      if (v.tag === "Cons") {
        if (v1.tag === "ContElim") {
          return bindEither.bind(match(dictAnn)(v._1)(v1._1))((v3) => bindEither.bind(matchMany(dictAnn)(v._2)(v3._2._1))((v4) => $Either(
            "Right",
            $Tuple(
              unionWith2((v$1) => (v1$1) => unsafePerformEffect(throwException(error("not disjoint"))))(v3._1)(v4._1),
              $Tuple(v4._2._1, $Tuple(meet(v3._2._2._1)(v4._2._2._1), $List("Cons", v3._2._2._2, v4._2._2._2)))
            )
          )));
        }
        if (v1.tag === "ContExpr") {
          return $Either(
            "Left",
            showIntImpl((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                ;
                return go$r;
              };
              return go(0)(v._2) + 1 | 0;
            })()) + " extra argument(s) to constructor/record; did you forget parentheses in lambda pattern?"
          );
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      return unsafePerformEffect(throwException(error("absurd")));
    };
  };
  var match = (dictAnn) => {
    const BoundedMeetSemilattice1 = dictAnn.BoundedLattice1().BoundedMeetSemilattice1();
    const meet = BoundedMeetSemilattice1.MeetSemilattice0().meet;
    const prettyP2 = prettyP(prettyVal(dictAnn.Highlightable0()));
    return (v) => (v1) => {
      if (v1.tag === "ElimVar") {
        if (v1._1 === "_") {
          return $Either(
            "Right",
            $Tuple(
              empty2,
              $Tuple(v1._2, $Tuple(BoundedMeetSemilattice1.top, $Match("MatchVarAnon", functorVal.map((v$1) => unit2)(v))))
            )
          );
        }
        return $Either(
          "Right",
          $Tuple(
            runST(bind_(newImpl)(poke3(v1._1)(v))),
            $Tuple(v1._2, $Tuple(BoundedMeetSemilattice1.top, $Match("MatchVar", v1._1, functorVal.map((v$1) => unit2)(v))))
          )
        );
      }
      if (v1.tag === "ElimConstr") {
        if (v.tag === "Constr") {
          return bindEither.bind($$with("Pattern mismatch")(consistentWith($Map(
            "Two",
            Leaf2,
            v._2,
            unit2,
            Leaf2
          ))(keys2(v1._1))))(() => bindEither.bind((() => {
            const $7 = "Incomplete patterns: no branch for " + showCtr(v._2);
            const $8 = _lookup(Nothing, Just, v._2, v1._1);
            if ($8.tag === "Nothing") {
              return $Either("Left", $7);
            }
            if ($8.tag === "Just") {
              return $Either("Right", $8._1);
            }
            fail();
          })())((\u03BA) => bindEither.bind(matchMany(dictAnn)(v._3)(\u03BA))((v2) => $Either(
            "Right",
            $Tuple(v2._1, $Tuple(v2._2._1, $Tuple(meet(v._1)(v2._2._2._1), $Match("MatchConstr", v._2, v2._2._2._2))))
          ))));
        }
        return bindEither.bind((() => {
          const v$1 = toUnfoldable6(keys2(v1._1));
          if (v$1.tag === "Cons") {
            return dataTypeForCtr.dataTypeFor(v$1._1);
          }
          fail();
        })())((d) => $Either("Left", "Pattern mismatch: found " + (prettyP2(v) + (", expected " + d._1))));
      }
      if (v1.tag === "ElimRecord") {
        if (v.tag === "Record") {
          return bindEither.bind((() => {
            const $6 = "Pattern mismatch: found " + (show2(keys2(v._2)) + (", expected " + show2(v1._1)));
            if (difference3(ordString)(v1._1)(fromFoldable7(keys2(v._2))).tag === "Leaf") {
              return $Either("Right", unit2);
            }
            return $Either("Left", $6);
          })())(() => {
            const xs$p = toUnfoldable10(v1._1);
            return bindEither.bind(matchMany(dictAnn)(listMap((a) => $$get(a)(v._2))(xs$p))(v1._2))((v2) => $Either(
              "Right",
              $Tuple(
                v2._1,
                $Tuple(
                  v2._2._1,
                  $Tuple(meet(v._1)(v2._2._2._1), $Match("MatchRecord", fromFoldable14(zipWith(Tuple)(xs$p)(v2._2._2._2))))
                )
              )
            ));
          });
        }
        return $Either("Left", "Pattern mismatch: found " + (prettyP2(v) + (", expected " + show2(v1._1))));
      }
      fail();
    };
  };
  var closeDefs = (\u03B3) => (\u03C1) => (\u03B1) => _fmapObject(
    \u03C1,
    (\u03C3) => {
      const \u03C1$p = $$for(\u03C1)(\u03C3);
      return $Val("Fun", $Fun("Closure", \u03B1, restrict(\u03B3)(unionWith(ordString)($$const)(fv(\u03C1$p))(fVElim.fv(\u03C3))), \u03C1$p, \u03C3));
    }
  );
  var checkArity2 = (c) => (n) => bindEither.bind(arity(c))((n$p) => {
    const $3 = showCtr(c) + (" got " + (showIntImpl(n) + (" argument(s), expects at most " + showIntImpl(n$p))));
    if (n$p >= n) {
      return $Either("Right", unit2);
    }
    return $Either("Left", $3);
  });
  var $$eval = (dictAnn) => {
    const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
    const prettyP2 = prettyP(prettyVal(dictAnn.Highlightable0()));
    const match1 = match(dictAnn);
    return (v) => (v1) => (v2) => {
      if (v1.tag === "Var") {
        const $7 = lookup$p(v1._1)(v);
        if ($7.tag === "Left") {
          return $Either("Left", $7._1);
        }
        if ($7.tag === "Right") {
          return $Either("Right", $Tuple($Trace("Var", v1._1), $7._1));
        }
        fail();
      }
      if (v1.tag === "Op") {
        const $7 = lookup$p(v1._1)(v);
        if ($7.tag === "Left") {
          return $Either("Left", $7._1);
        }
        if ($7.tag === "Right") {
          return $Either("Right", $Tuple($Trace("Op", v1._1), $7._1));
        }
        fail();
      }
      if (v1.tag === "Int") {
        return $Either("Right", $Tuple(Const2, $Val("Int", meet(v1._1)(v2), v1._2)));
      }
      if (v1.tag === "Float") {
        return $Either("Right", $Tuple(Const2, $Val("Float", meet(v1._1)(v2), v1._2)));
      }
      if (v1.tag === "Str") {
        return $Either("Right", $Tuple(Const2, $Val("Str", meet(v1._1)(v2), v1._2)));
      }
      if (v1.tag === "Record") {
        return bindEither.bind((() => {
          const $7 = traverse4((() => {
            const $72 = $$eval(dictAnn)(v);
            return (a) => $72(a)(v2);
          })())(v1._2);
          if ($7.tag === "Left") {
            return $Either("Left", $7._1);
          }
          if ($7.tag === "Right") {
            return $Either("Right", $Tuple(_fmapObject($7._1, fst), _fmapObject($7._1, snd)));
          }
          fail();
        })())((v3) => $Either("Right", $Tuple($Trace("Record", v3._1), $Val("Record", meet(v1._1)(v2), v3._2))));
      }
      if (v1.tag === "Dictionary") {
        return bindEither.bind((() => {
          const $7 = traverse12(traverse22((() => {
            const $72 = $$eval(dictAnn)(v);
            return (a) => $72(a)(v2);
          })()))(v1._2);
          if ($7.tag === "Left") {
            return $Either("Left", $7._1);
          }
          if ($7.tag === "Right") {
            return $Either(
              "Right",
              (() => {
                const $8 = unzip(listMap(toTuple)($7._1));
                return $Tuple(unzip($8._1), unzip($8._2));
              })()
            );
          }
          fail();
        })())((v3) => {
          const v4 = unzip(listMap((u) => string2.match(u))(v3._1._2));
          const d = fromFoldable14(zipWith(Tuple)(v4._1)(zipWith(Tuple)(v4._2)(v3._2._2)));
          return $Either(
            "Right",
            $Tuple(
              $Trace(
                "Dictionary",
                zipWith(Tuple)(v4._1)(zipWith(Tuple)(v3._1._1)(v3._2._1)),
                _fmapObject(d, (x2) => functorVal.map((v$1) => unit2)(x2._2))
              ),
              $Val("Dictionary", meet(v1._1)(v2), d)
            )
          );
        });
      }
      if (v1.tag === "Constr") {
        return bindEither.bind(checkArity2(v1._2)((() => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v$1 = go$a1;
              if (v$1.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v$1.tag === "Cons") {
                go$a0 = b + 1 | 0;
                go$a1 = v$1._2;
                continue;
              }
              fail();
            }
            ;
            return go$r;
          };
          return go(0)(v1._3);
        })()))(() => bindEither.bind((() => {
          const $8 = traverse12((() => {
            const $82 = $$eval(dictAnn)(v);
            return (a) => $82(a)(v2);
          })())(v1._3);
          if ($8.tag === "Left") {
            return $Either("Left", $8._1);
          }
          if ($8.tag === "Right") {
            return $Either("Right", unzip($8._1));
          }
          fail();
        })())((v3) => $Either("Right", $Tuple($Trace("Constr", v1._2, v3._1), $Val("Constr", meet(v1._1)(v2), v1._2, v3._2)))));
      }
      if (v1.tag === "Matrix") {
        return bindEither.bind($$eval(dictAnn)(v)(v1._4)(v2))((v3) => {
          const v5 = intPair.match(v3._2)._1;
          return bindEither.bind((() => {
            const $9 = "array must be at least (" + (show3($Tuple(1, 1)) + ("); got (" + (show3($Tuple(v5._1._1, v5._2._1)) + ")")));
            if (greaterThanOrEq1($Tuple(v5._1._1, v5._2._1))($Tuple(1, 1))) {
              return $Either("Right", unit2);
            }
            return $Either("Left", $9);
          })())(() => bindEither.bind((() => {
            const $10 = listMap((x2) => {
              const $112 = unzip(x2);
              return $Tuple(fromFoldable23($112._1), fromFoldable23($112._2));
            });
            const $11 = sequence2(bindList.bind(range(1)(v5._1._1))((i) => $List(
              "Cons",
              sequence2(bindList.bind(range(1)(v5._2._1))((j) => $List(
                "Cons",
                $$eval(dictAnn)(unionWith2((v$1) => identity19)(v)(unionWith2((v$1) => (v1$1) => unsafePerformEffect(throwException(error("not disjoint"))))(runST(bind_(newImpl)(poke3(v1._3._1)($Val(
                  "Int",
                  v5._1._2,
                  i
                )))))(runST(bind_(newImpl)(poke3(v1._3._2)($Val("Int", v5._2._2, j)))))))(v1._2)(v2),
                Nil
              ))),
              Nil
            )));
            if ($11.tag === "Left") {
              return $Either("Left", $11._1);
            }
            if ($11.tag === "Right") {
              return $Either(
                "Right",
                (() => {
                  const $12 = unzip($10($11._1));
                  return $Tuple(fromFoldable23($12._1), fromFoldable23($12._2));
                })()
              );
            }
            fail();
          })())((v6) => $Either(
            "Right",
            $Tuple(
              $Trace("Matrix", v6._1, $Tuple(v1._3._1, v1._3._2), $Tuple(v5._1._1, v5._2._1), v3._1),
              $Val("Matrix", meet(v1._1)(v2), $Tuple(v6._2, $Tuple($Tuple(v5._1._1, v5._1._2), $Tuple(v5._2._1, v5._2._2))))
            )
          )));
        });
      }
      if (v1.tag === "Lambda") {
        return $Either(
          "Right",
          $Tuple(Const2, $Val("Fun", $Fun("Closure", v2, restrict(v)(fVElim.fv(v1._1)), empty2, v1._1)))
        );
      }
      if (v1.tag === "Project") {
        return bindEither.bind($$eval(dictAnn)(v)(v1._1)(v2))((v3) => {
          if (v3._2.tag === "Record") {
            const $8 = lookup$p(v1._2)(v3._2._2);
            if ($8.tag === "Left") {
              return $Either("Left", $8._1);
            }
            if ($8.tag === "Right") {
              return $Either("Right", $Tuple($Trace("Project", v3._1, v1._2), $8._1));
            }
            fail();
          }
          return $Either("Left", "Found " + (prettyP2(v3._2) + ", expected record"));
        });
      }
      if (v1.tag === "App") {
        return bindEither.bind($$eval(dictAnn)(v)(v1._1)(v2))((v3) => bindEither.bind($$eval(dictAnn)(v)(v1._2)(v2))((v5) => bindEither.bind(apply2(dictAnn)($Tuple(
          v3._2,
          v5._2
        )))((v6) => $Either("Right", $Tuple($Trace("App", v3._1, v5._1, v6._1), v6._2)))));
      }
      if (v1.tag === "Let") {
        return bindEither.bind($$eval(dictAnn)(v)(v1._1._2)(v2))((v3) => bindEither.bind(match1(v3._2)(v1._1._1))((v5) => bindEither.bind($$eval(dictAnn)(unionWith2((v$1) => identity19)(v)(v5._1))(v1._2)(v5._2._2._1))((v6) => $Either(
          "Right",
          $Tuple($Trace("Let", $VarDef3(v5._2._2._2, v3._1), v6._1), v6._2)
        ))));
      }
      if (v1.tag === "LetRec") {
        return bindEither.bind($$eval(dictAnn)(unionWith2((v$1) => identity19)(v)(closeDefs(v)(v1._1)(v2)))(v1._2)(v2))((v3) => $Either(
          "Right",
          $Tuple($Trace("LetRec", _fmapObject(v1._1, erase1), v3._1), v3._2)
        ));
      }
      fail();
    };
  };
  var apply2 = (dictAnn) => {
    const match1 = match(dictAnn);
    const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
    const prettyP2 = prettyP(prettyVal(dictAnn.Highlightable0()));
    return (v) => {
      if (v._1.tag === "Fun") {
        if (v._1._1.tag === "Closure") {
          const \u03B32 = closeDefs(v._1._1._2)(v._1._1._3)(v._1._1._1);
          return bindEither.bind(match1(v._2)(v._1._1._4))((v2) => bindEither.bind($$eval(dictAnn)(unionWith2((v$1) => identity19)(unionWith2((v$1) => identity19)(v._1._1._2)(\u03B32))(v2._1))((() => {
            if (v2._2._1.tag === "ContExpr") {
              return v2._2._1._1;
            }
            return unsafePerformEffect(throwException(error("Expression expected")));
          })())(meet(v._1._1._1)(v2._2._2._1)))((v3) => $Either(
            "Right",
            $Tuple($AppTrace("AppClosure", fromFoldable7(keys2(v._1._1._3)), v2._2._2._2, v3._1), v3._2)
          )));
        }
        if (v._1._1.tag === "Foreign") {
          const vs$p = foldableList.foldr(Cons)($List("Cons", v._2, Nil))(v._1._1._2);
          return bindEither.bind(bindEither.bind((() => {
            if ((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                ;
                return go$r;
              };
              return v._1._1._1._1.arity > go(0)(vs$p);
            })()) {
              return $Either("Right", $Tuple(Nothing, $Val("Fun", $Fun("Foreign", v._1._1._1, vs$p))));
            }
            const $6 = v._1._1._1._1.op(dictAnn)(vs$p);
            if ($6.tag === "Left") {
              return $Either("Left", $6._1);
            }
            if ($6.tag === "Right") {
              return $Either("Right", $Tuple($Maybe("Just", $6._1._1), $6._1._2));
            }
            fail();
          })())((v3) => $Either("Right", $Tuple($ForeignTrace$p($ForeignOp$p(v._1._1._1._1), v3._1), v3._2))))((v2) => $Either(
            "Right",
            $Tuple(
              $AppTrace(
                "AppForeign",
                (() => {
                  const go = (go$a0$copy) => (go$a1$copy) => {
                    let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                    while (go$c) {
                      const b = go$a0, v$1 = go$a1;
                      if (v$1.tag === "Nil") {
                        go$c = false;
                        go$r = b;
                        continue;
                      }
                      if (v$1.tag === "Cons") {
                        go$a0 = b + 1 | 0;
                        go$a1 = v$1._2;
                        continue;
                      }
                      fail();
                    }
                    ;
                    return go$r;
                  };
                  return go(0)(v._1._1._2) + 1 | 0;
                })(),
                v2._1
              ),
              v2._2
            )
          ));
        }
        if (v._1._1.tag === "PartialConstr") {
          const n = successful(arity(v._1._1._2));
          return bindEither.bind((() => {
            const $6 = "Too many arguments to " + showCtr(v._1._1._2);
            if ((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                ;
                return go$r;
              };
              return go(0)(v._1._1._3) < n;
            })()) {
              return $Either("Right", unit2);
            }
            return $Either("Left", $6);
          })())(() => $Either(
            "Right",
            $Tuple(
              $AppTrace("AppConstr", v._1._1._2),
              (() => {
                if ((() => {
                  const go = (go$a0$copy) => (go$a1$copy) => {
                    let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                    while (go$c) {
                      const b = go$a0, v$1 = go$a1;
                      if (v$1.tag === "Nil") {
                        go$c = false;
                        go$r = b;
                        continue;
                      }
                      if (v$1.tag === "Cons") {
                        go$a0 = b + 1 | 0;
                        go$a1 = v$1._2;
                        continue;
                      }
                      fail();
                    }
                    ;
                    return go$r;
                  };
                  return go(0)(v._1._1._3) < (n - 1 | 0);
                })()) {
                  return $Val(
                    "Fun",
                    $Fun(
                      "PartialConstr",
                      v._1._1._1,
                      v._1._1._2,
                      foldableList.foldr(Cons)($List("Cons", v._2, Nil))(v._1._1._3)
                    )
                  );
                }
                return $Val(
                  "Constr",
                  v._1._1._1,
                  v._1._1._2,
                  foldableList.foldr(Cons)($List("Cons", v._2, Nil))(v._1._1._3)
                );
              })()
            )
          ));
        }
        return $Either("Left", "Found " + (prettyP2(v._2) + ", expected function"));
      }
      return $Either("Left", "Found " + (prettyP2(v._2) + ", expected function"));
    };
  };
  var apply22 = (dictAnn) => {
    const apply1 = apply2(dictAnn);
    return (v) => bindEither.bind(apply1($Tuple(v._1, v._2._1)))((v3) => bindEither.bind(apply1($Tuple(v3._2, v._2._2)))((v4) => $Either(
      "Right",
      $Tuple($Tuple(v3._1, v4._1), v4._2)
    )));
  };
  var eval_module = (dictAnn) => {
    const eval1 = $$eval(dictAnn);
    const match1 = match(dictAnn);
    return (\u03B3) => {
      const go = (v) => (v1) => (v2) => {
        if (v1._1.tag === "Nil") {
          return $Either("Right", v);
        }
        if (v1._1.tag === "Cons") {
          if (v1._1._1.tag === "Left") {
            return bindEither.bind(eval1(unionWith2((v$1) => identity19)(\u03B3)(v))(v1._1._1._1._2)(v2))((v3) => bindEither.bind(match1(v3._2)(v1._1._1._1._1))((v5) => go(unionWith2((v$1) => identity19)(v)(v5._1))($Module(v1._1._2))(v5._2._2._1)));
          }
          if (v1._1._1.tag === "Right") {
            return go(unionWith2((v$1) => identity19)(v)(closeDefs(unionWith2((v$1) => identity19)(\u03B3)(v))(v1._1._1._1)(v2)))($Module(v1._1._2))(v2);
          }
          fail();
        }
        fail();
      };
      return go(empty2);
    };
  };

  // output-es/EvalBwd/index.js
  var eq = /* @__PURE__ */ (() => eqMap(eqString)(eqUnit).eq)();
  var toUnfoldable11 = /* @__PURE__ */ toAscUnfoldable(unfoldableList);
  var fromFoldable8 = /* @__PURE__ */ fromFoldable2(foldableList);
  var fromFoldable15 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2))();
  var foldl1 = /* @__PURE__ */ (() => foldable1NonEmpty(foldableList).foldl1)();
  var map4 = /* @__PURE__ */ (() => functorNonEmpty(functorList).map)();
  var matchManyBwd = (dictAnn) => (v) => (v1) => (v2) => (v3) => {
    if (v3.tag === "Nil") {
      if (isEmpty(v)) {
        return $Tuple(Nil, v1);
      }
      return unsafePerformEffect(throwException(error("absurd")));
    }
    if (v3.tag === "Cons") {
      const v4 = disjointUnion_inv(bVMatch.bv(v3._1))(v);
      const v5 = matchBwd(dictAnn)(v4._1)(v1)(v2)(v3._1);
      const v7 = matchManyBwd(dictAnn)(v4._2)($Cont("ContElim", v5._2))(v2)(v3._2);
      return $Tuple(foldableList.foldr(Cons)($List("Cons", v5._1, Nil))(v7._1), v7._2);
    }
    fail();
  };
  var matchBwd = (dictAnn) => {
    const $1 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const $2 = functorVal.map((v) => $1.bot);
    return (v) => (v1) => (v2) => (v3) => {
      if (v3.tag === "MatchVar") {
        if (eq(keys2(v))($Map("Two", Leaf2, v3._1, unit2, Leaf2))) {
          return $Tuple($$get(v3._1)(v), $Elim("ElimVar", v3._1, v1));
        }
        return $Tuple($2(v3._2), $Elim("ElimVar", v3._1, v1));
      }
      if (v3.tag === "MatchVarAnon") {
        if (isEmpty(v)) {
          return $Tuple($2(v3._1), $Elim("ElimVar", "_", v1));
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v3.tag === "MatchConstr") {
        const v4 = matchManyBwd(dictAnn)(v)(v1)(v2)(reverse(v3._2));
        return $Tuple(
          $Val("Constr", v2, v3._1, v4._1),
          $Elim("ElimConstr", runST(bind_(newImpl)(poke3(v3._1)(v4._2))))
        );
      }
      if (v3.tag === "MatchRecord") {
        const v4 = unzip(toUnfoldable11(v3._1));
        const v5 = matchManyBwd(dictAnn)(v)(v1)(v2)(reverse(v4._2));
        return $Tuple(
          $Val("Record", v2, fromFoldable8(zipWith(Tuple)(v4._1)(v5._1))),
          $Elim("ElimRecord", fromFoldable15(keys2(v3._1)), v5._2)
        );
      }
      fail();
    };
  };
  var closeDefsBwd = (dictAnn) => {
    const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const JoinSemilattice0 = BoundedJoinSemilattice0.JoinSemilattice0();
    const join = joinSemilatticeDict(joinSemilatticeVal(JoinSemilattice0)).join;
    const join1 = joinSemilatticeDict(joinSemilatticeElim(JoinSemilattice0)).join;
    return (\u03B3) => {
      const v = foldableWithIndexObject.foldrWithIndex((f) => (v2) => (v1) => {
        const v22 = $$get(f)(\u03B3);
        if (v22.tag === "Fun") {
          if (v22._1.tag === "Closure") {
            return $Tuple(
              mutate(poke3(f)(v22._1._4))(v1._1),
              $Tuple(join(v1._2._1)(v22._1._2), $Tuple(join1(v1._2._2._1)(v22._1._3), JoinSemilattice0.join(v1._2._2._2)(v22._1._1)))
            );
          }
          return unsafePerformEffect(throwException(error("absurd")));
        }
        return unsafePerformEffect(throwException(error("absurd")));
      })($Tuple(empty2, $Tuple(empty2, $Tuple(empty2, BoundedJoinSemilattice0.bot))))(\u03B3);
      return $Tuple(v._2._1, $Tuple(join1(v._2._2._1)(v._1), v._2._2._2));
    };
  };
  var evalBwd$p = (dictAnn) => {
    const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const JoinSemilattice0 = BoundedJoinSemilattice0.JoinSemilattice0();
    const join = joinSemilatticeDict(joinSemilatticeVal(JoinSemilattice0)).join;
    const expand = expandableDictDict(botOfUnit$x215Raw$x215(functorVal)(BoundedJoinSemilattice0))((() => {
      const $4 = expandableValRawVal(BoundedJoinSemilattice0);
      return { expand: (v) => (v1) => $Tuple(v._1, $4.expand(v._2)(v1._2)) };
    })()).expand;
    const join2 = joinSemilatticeExpr(JoinSemilattice0).join;
    const matchBwd1 = matchBwd(dictAnn);
    const closeDefsBwd1 = closeDefsBwd(dictAnn);
    return (v) => (v1) => {
      const $10 = (t2, v2, x2) => {
        const v3 = evalBwd$p(dictAnn)($Val(
          "Record",
          BoundedJoinSemilattice0.bot,
          runST(bind_(newImpl)(poke3(x2)(v2)))
        ))(t2);
        return { "\u03B3": v3["\u03B3"], e: $Expr("Project", v3.e, x2), "\u03B1": v3["\u03B1"] };
      };
      const $11 = (t1, t2, t3, v2) => {
        const v3 = applyBwd(dictAnn)($Tuple(t3, v2));
        const v4 = evalBwd$p(dictAnn)(v3._1)(t1);
        const v5 = evalBwd$p(dictAnn)(v3._2)(t2);
        return { "\u03B3": join(v4["\u03B3"])(v5["\u03B3"]), e: $Expr("App", v4.e, v5.e), "\u03B1": JoinSemilattice0.join(v4["\u03B1"])(v5["\u03B1"]) };
      };
      const $12 = (t1, t2, v2, w) => {
        const v3 = evalBwd$p(dictAnn)(v2)(t2);
        const v4 = append_inv(bVMatch.bv(w))(v3["\u03B3"]);
        const v5 = matchBwd1(v4._2)(ContNone)(v3["\u03B1"])(w);
        const v6 = evalBwd$p(dictAnn)(v5._1)(t1);
        return { "\u03B3": join(v4._1)(v6["\u03B3"]), e: $Expr("Let", $VarDef(v5._2, v6.e), v3.e), "\u03B1": v6["\u03B1"] };
      };
      const $13 = (t2, v2, \u03C1) => {
        const v3 = evalBwd$p(dictAnn)(v2)(t2);
        const v4 = append_inv(fromFoldable15(keys2(\u03C1)))(v3["\u03B3"]);
        const v5 = closeDefsBwd1(v4._2);
        return { "\u03B3": join(v4._1)(v5._1), e: $Expr("LetRec", v5._2._1, v3.e), "\u03B1": JoinSemilattice0.join(v3["\u03B1"])(v5._2._2) };
      };
      if (v1.tag === "Var") {
        return {
          "\u03B3": runST(bind_(newImpl)(poke3(v1._1)(v))),
          e: $Expr("Var", v1._1),
          "\u03B1": BoundedJoinSemilattice0.bot
        };
      }
      if (v1.tag === "Op") {
        return {
          "\u03B3": runST(bind_(newImpl)(poke3(v1._1)(v))),
          e: $Expr("Op", v1._1),
          "\u03B1": BoundedJoinSemilattice0.bot
        };
      }
      if (v1.tag === "Const") {
        if (v.tag === "Str") {
          return { "\u03B3": empty2, e: $Expr("Str", v._1, v._2), "\u03B1": v._1 };
        }
        if (v.tag === "Int") {
          return { "\u03B3": empty2, e: $Expr("Int", v._1, v._2), "\u03B1": v._1 };
        }
        if (v.tag === "Float") {
          return { "\u03B3": empty2, e: $Expr("Float", v._1, v._2), "\u03B1": v._1 };
        }
        if (v.tag === "Fun") {
          if (v._1.tag === "Closure") {
            return { "\u03B3": v._1._2, e: $Expr("Lambda", v._1._4), "\u03B1": v._1._1 };
          }
          return unsafePerformEffect(throwException(error("absurd")));
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v.tag === "Record") {
        if (v1.tag === "Record") {
          const $14 = evalBwd$p(dictAnn);
          const x\u03B3e\u03B1s = _fmapObject(intersectionWith(Tuple)(v._2)(v1._1), (v$1) => $14(v$1._1)(v$1._2));
          return {
            "\u03B3": foldrArray(join)(empty2)(values(_fmapObject(x\u03B3e\u03B1s, (v2) => v2["\u03B3"]))),
            e: $Expr("Record", v._1, _fmapObject(x\u03B3e\u03B1s, (v2) => v2.e)),
            "\u03B1": foldrArray(JoinSemilattice0.join)(v._1)(values(_fmapObject(x\u03B3e\u03B1s, (v2) => v2["\u03B1"])))
          };
        }
        if (v1.tag === "Project") {
          return $10(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $11(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $12(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $13(v1._2, v, v1._1);
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v.tag === "Dictionary") {
        if (v1.tag === "Dictionary") {
          const s\u03B1vs$p = expand(v._2)(_fmapObject(v1._2, (v2) => $Tuple(unit2, v2)));
          const \u03B3e\u03B1s = listMap((v2) => evalBwd$p(dictAnn)($Val("Str", $$get(v2._1)(s\u03B1vs$p)._1, v2._1))(v2._2._1))(v1._1);
          const \u03B3e\u03B1s$p = listMap((v2) => evalBwd$p(dictAnn)($$get(v2._1)(s\u03B1vs$p)._2)(v2._2._2))(v1._1);
          return {
            "\u03B3": foldableList.foldr(join)(empty2)(foldableList.foldr(Cons)(listMap((v2) => v2["\u03B3"])(\u03B3e\u03B1s$p))(listMap((v2) => v2["\u03B3"])(\u03B3e\u03B1s))),
            e: $Expr(
              "Dictionary",
              v._1,
              listMap(fromTuple)(zipWith(Tuple)(listMap((v2) => v2.e)(\u03B3e\u03B1s))(listMap((v2) => v2.e)(\u03B3e\u03B1s$p)))
            ),
            "\u03B1": foldableList.foldr(JoinSemilattice0.join)(v._1)(foldableList.foldr(Cons)(listMap((v2) => v2["\u03B1"])(\u03B3e\u03B1s$p))(listMap((v2) => v2["\u03B1"])(\u03B3e\u03B1s)))
          };
        }
        if (v1.tag === "Project") {
          return $10(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $11(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $12(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $13(v1._2, v, v1._1);
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v.tag === "Constr") {
        if (v1.tag === "Constr") {
          const v2 = foldableList.foldr((v22) => (v3) => {
            const v4 = evalBwd$p(dictAnn)(v22._1)(v22._2);
            return $Tuple(join(v3._1)(v4["\u03B3"]), $Tuple($List("Cons", v4.e, v3._2._1), JoinSemilattice0.join(v3._2._2)(v4["\u03B1"])));
          })($Tuple(empty2, $Tuple(Nil, v._1)))(zipWith(Tuple)(v._3)(v1._2));
          return { "\u03B3": v2._1, e: $Expr("Constr", v._1, v1._1, v2._2._1), "\u03B1": v2._2._2 };
        }
        if (v1.tag === "Project") {
          return $10(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $11(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $12(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $13(v1._2, v, v1._1);
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v.tag === "Matrix") {
        if (v1.tag === "Matrix") {
          const v3 = foldl1((v42) => (v5) => $Tuple(
            join(v42._1)(v5._1),
            $Tuple(
              join2(v42._2._1)(v5._2._1),
              $Tuple(
                JoinSemilattice0.join(v42._2._2._1)(v5._2._2._1),
                $Tuple(JoinSemilattice0.join(v42._2._2._2._1)(v5._2._2._2._1), JoinSemilattice0.join(v42._2._2._2._2)(v5._2._2._2._2))
              )
            )
          ))(map4((v32) => {
            const v42 = evalBwd$p(dictAnn)(definitely("index within bounds")(index2(definitely("index within bounds")(index2(v._2._1)(v32._1 - 1 | 0)))(v32._2 - 1 | 0)))(definitely("index within bounds")(index2(definitely("index within bounds")(index2(v1._1)(v32._1 - 1 | 0)))(v32._2 - 1 | 0)));
            const v5 = append_inv(unionWith(ordString)($$const)($Map(
              "Two",
              Leaf2,
              v1._2._1,
              unit2,
              Leaf2
            ))($Map("Two", Leaf2, v1._2._2, unit2, Leaf2)))(v42["\u03B3"]);
            const \u03B30 = unionWith2((v$1) => identity19)(unionWith2((v$1) => (v1$1) => unsafePerformEffect(throwException(error("not disjoint"))))(runST(bind_(newImpl)(poke3(v1._2._1)($Val(
              "Int",
              BoundedJoinSemilattice0.bot,
              v1._3._1
            )))))(runST(bind_(newImpl)(poke3(v1._2._2)($Val(
              "Int",
              BoundedJoinSemilattice0.bot,
              v1._3._2
            ))))))(v5._2);
            const $18 = $$get(v1._2._1)(\u03B30);
            const $19 = $$get(v1._2._1)(\u03B30);
            if ($18.tag === "Int") {
              if ($19.tag === "Int") {
                return $Tuple(v5._1, $Tuple(v42.e, $Tuple(v42["\u03B1"], $Tuple($18._1, $19._1))));
              }
              fail();
            }
            fail();
          })(nonEmpty(bindList.bind(range(1)(v1._3._1))((i) => bindList.bind(range(1)(v1._3._2))((j) => $List(
            "Cons",
            $Tuple(i, j),
            Nil
          ))))));
          const v4 = evalBwd$p(dictAnn)($Val(
            "Constr",
            BoundedJoinSemilattice0.bot,
            "Pair",
            $List(
              "Cons",
              $Val("Int", JoinSemilattice0.join(v3._2._2._2._1)(v._2._2._1._2), v1._3._1),
              $List("Cons", $Val("Int", JoinSemilattice0.join(v3._2._2._2._2)(v._2._2._2._2), v1._3._2), Nil)
            )
          ))(v1._4);
          return {
            "\u03B3": join(v3._1)(v4["\u03B3"]),
            e: $Expr("Matrix", v._1, v3._2._1, $Tuple(v1._2._1, v1._2._2), v4.e),
            "\u03B1": JoinSemilattice0.join(JoinSemilattice0.join(v._1)(v3._2._2._1))(v4["\u03B1"])
          };
        }
        if (v1.tag === "Project") {
          return $10(v1._1, v, v1._2);
        }
        if (v1.tag === "App") {
          return $11(v1._1, v1._2, v1._3, v);
        }
        if (v1.tag === "Let") {
          return $12(v1._1._2, v1._2, v, v1._1._1);
        }
        if (v1.tag === "LetRec") {
          return $13(v1._2, v, v1._1);
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v1.tag === "Project") {
        return $10(v1._1, v, v1._2);
      }
      if (v1.tag === "App") {
        return $11(v1._1, v1._2, v1._3, v);
      }
      if (v1.tag === "Let") {
        return $12(v1._1._2, v1._2, v, v1._1._1);
      }
      if (v1.tag === "LetRec") {
        return $13(v1._2, v, v1._1);
      }
      return unsafePerformEffect(throwException(error("absurd")));
    };
  };
  var applyBwd = (dictAnn) => {
    const closeDefsBwd1 = closeDefsBwd(dictAnn);
    const matchBwd1 = matchBwd(dictAnn);
    const JoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().JoinSemilattice0();
    const join1 = joinSemilatticeDict(joinSemilatticeVal(JoinSemilattice0)).join;
    return (v) => {
      if (v._1.tag === "AppClosure") {
        const v2 = evalBwd$p(dictAnn)(v._2)(v._1._3);
        const v3 = append_inv(bVMatch.bv(v._1._2))(v2["\u03B3"]);
        const v4 = append_inv(v._1._1)(v3._1);
        const v5 = closeDefsBwd1(v4._2);
        const v6 = matchBwd1(v3._2)($Cont("ContExpr", v2.e))(v2["\u03B1"])(v._1._2);
        return $Tuple($Val("Fun", $Fun("Closure", JoinSemilattice0.join(v2["\u03B1"])(v5._2._2), join1(v4._1)(v5._1), v5._2._1, v6._2)), v6._1);
      }
      if (v._1.tag === "AppForeign") {
        const $6 = definitely("absurd")(unsnoc((() => {
          if (v._1._2._1._1.arity > v._1._1) {
            if (v._2.tag === "Fun") {
              if (v._2._1.tag === "Foreign") {
                return v._2._1._2;
              }
              fail();
            }
            fail();
          }
          return v._1._2._1._1.op_bwd(dictAnn)($Tuple(definitely("absurd")(v._1._2._2), v._2));
        })()));
        return $Tuple($Val("Fun", $Fun("Foreign", $ForeignOp$p(v._1._2._1._1), $6.init)), $6.last);
      }
      if (v._1.tag === "AppConstr") {
        if (v._2.tag === "Constr") {
          if (v._2._2 === v._1._1) {
            const v33 = definitely("absurd")(unsnoc(v._2._3));
            return $Tuple($Val("Fun", $Fun("PartialConstr", v._2._1, v._1._1, v33.init)), v33.last);
          }
          const v32 = definitely("absurd")(unsnoc(unsafePerformEffect(throwException(error("absurd")))._1));
          return $Tuple(
            $Val("Fun", $Fun("PartialConstr", unsafePerformEffect(throwException(error("absurd")))._2, v._1._1, v32.init)),
            v32.last
          );
        }
        if (v._2.tag === "Fun") {
          if (v._2._1.tag === "PartialConstr") {
            if (v._2._1._2 === v._1._1) {
              const v34 = definitely("absurd")(unsnoc(v._2._1._3));
              return $Tuple($Val("Fun", $Fun("PartialConstr", v._2._1._1, v._1._1, v34.init)), v34.last);
            }
            const v33 = definitely("absurd")(unsnoc(unsafePerformEffect(throwException(error("absurd")))._1));
            return $Tuple(
              $Val("Fun", $Fun("PartialConstr", unsafePerformEffect(throwException(error("absurd")))._2, v._1._1, v33.init)),
              v33.last
            );
          }
          const v32 = definitely("absurd")(unsnoc(unsafePerformEffect(throwException(error("absurd")))._1));
          return $Tuple(
            $Val("Fun", $Fun("PartialConstr", unsafePerformEffect(throwException(error("absurd")))._2, v._1._1, v32.init)),
            v32.last
          );
        }
        const v3 = definitely("absurd")(unsnoc(unsafePerformEffect(throwException(error("absurd")))._1));
        return $Tuple(
          $Val("Fun", $Fun("PartialConstr", unsafePerformEffect(throwException(error("absurd")))._2, v._1._1, v3.init)),
          v3.last
        );
      }
      fail();
    };
  };
  var evalBwd = (dictAnn) => {
    const evalBwd$p1 = evalBwd$p(dictAnn);
    const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
    const expand = expandableDictDict({ botOf: functorVal.map((v) => BoundedJoinSemilattice0.bot) })(expandableValRawVal(BoundedJoinSemilattice0)).expand;
    const expand1 = expandableExprRawExpr(BoundedJoinSemilattice0).expand;
    return (\u03B3) => (e) => (v) => (t2) => {
      const v1 = evalBwd$p1(v)(t2);
      return { "\u03B3": expand(v1["\u03B3"])(\u03B3), e: expand1(v1.e)(e), "\u03B1": v1["\u03B1"] };
    };
  };
  var apply2Bwd = (dictAnn) => {
    const applyBwd1 = applyBwd(dictAnn);
    return (v) => {
      const v2 = applyBwd1($Tuple(v._1._2, v._2));
      const v3 = applyBwd1($Tuple(v._1._1, v2._1));
      return $Tuple(v3._1, $Tuple(v3._2, v2._2));
    };
  };

  // output-es/Graph/index.js
  var Vertex = (x2) => x2;
  var eqVertex = { eq: (x2) => (y2) => x2 === y2 };
  var ordVertex = { compare: (x2) => (y2) => ordString.compare(x2)(y2), Eq0: () => eqVertex };

  // output-es/Set/index.js
  var setSet = (dictOrd) => {
    const ordSet2 = ordSet(dictOrd);
    return {
      delete: $$delete2(dictOrd),
      difference: difference3(dictOrd),
      union: union2(dictOrd),
      intersection: intersection(dictOrd),
      insert: insert3(dictOrd),
      isEmpty: isEmpty2,
      member: member(dictOrd),
      singleton,
      subset: subset(dictOrd),
      empty: Leaf2,
      map: (dictOrd1) => map2(dictOrd1),
      fromFoldable: (dictFoldable) => dictFoldable.foldl((m) => (a) => insert2(dictOrd)(a)(unit2)(m))(Leaf2),
      toUnfoldable: (dictUnfoldable) => toUnfoldable4(dictUnfoldable),
      Ord0: () => dictOrd,
      Ord1: () => ordSet2,
      Foldable2: () => foldableSet
    };
  };

  // output-es/Graph.GraphImpl/index.js
  var $GraphImpl = (_1) => ({ tag: "GraphImpl", _1 });
  var map5 = /* @__PURE__ */ (() => setSet(ordString).map(ordVertex))();
  var semigroupGraphImpl = (dictSet) => ({ append: (v) => (v1) => $GraphImpl({ out: unionWith2(dictSet.union)(v._1.out)(v1._1.out), in: unionWith2(dictSet.union)(v._1.in)(v1._1.in) }) });
  var sinks$p = (dictSet) => {
    const fromFoldable11 = dictSet.fromFoldable(foldableArray);
    return (m) => fromFoldable11(arrayMap((x2) => x2._1)(filter3((x2) => dictSet.isEmpty(x2._2))(toArrayWithKey(Tuple)(m))));
  };
  var addIfMissing = (dictSet) => (acc) => (v) => {
    const $3 = peek(v)(acc);
    return () => {
      const v1 = $3();
      if (v1.tag === "Nothing") {
        return poke3(v)(dictSet.empty)(acc)();
      }
      if (v1.tag === "Just") {
        return acc;
      }
      fail();
    };
  };
  var inMap = (dictSet) => {
    const $1 = dictSet.Foldable2();
    return (\u03B1_\u03B1s) => () => {
      const in_ = newImpl();
      return monadRecST.tailRecM((v) => {
        if (v._1.tag === "Nil") {
          return () => $Step("Done", v._2);
        }
        if (v._1.tag === "Cons") {
          return () => {
            const acc$p = (() => {
              const $5 = $1.foldl((b) => (a) => () => {
                const a$1 = b();
                const v1 = peek(a)(a$1)();
                if (v1.tag === "Nothing") {
                  return poke3(a)(dictSet.singleton(v._1._1._1))(a$1)();
                }
                if (v1.tag === "Just") {
                  return poke3(a)(dictSet.insert(v._1._1._1)(v1._1))(a$1)();
                }
                fail();
              })(() => v._2)(v._1._1._2);
              return () => {
                const a = $5();
                return addIfMissing(dictSet)(a)(v._1._1._1)();
              };
            })()();
            return $Step("Loop", $Tuple(v._1._2, acc$p));
          };
        }
        fail();
      })($Tuple(\u03B1_\u03B1s, in_))();
    };
  };
  var outMap = (dictSet) => {
    const $1 = dictSet.Foldable2();
    return (\u03B1_\u03B1s) => () => {
      const out = newImpl();
      return monadRecST.tailRecM((v) => {
        if (v._1.tag === "Nil") {
          return () => $Step("Done", v._2);
        }
        if (v._1.tag === "Cons") {
          return () => {
            const acc$p = (() => {
              const $5 = poke3(v._1._1._1)(v._1._1._2)(v._2);
              return () => {
                const a = $5();
                return $1.foldl((b) => (a$1) => () => {
                  const a$2 = b();
                  return addIfMissing(dictSet)(a$2)(a$1)();
                })(() => a)(v._1._1._2)();
              };
            })()();
            return $Step("Loop", $Tuple(v._1._2, acc$p));
          };
        }
        fail();
      })($Tuple(\u03B1_\u03B1s, out))();
    };
  };
  var graphGraphImpl = (dictSet) => {
    const fromFoldable11 = dictSet.fromFoldable(foldableSet);
    const sinks$p1 = sinks$p(dictSet);
    const outMap1 = outMap(dictSet);
    const inMap1 = inMap(dictSet);
    const semigroupGraphImpl1 = semigroupGraphImpl(dictSet);
    return {
      outN: (v) => (\u03B1) => definitely("in graph")(_lookup(Nothing, Just, \u03B1, v._1.out)),
      inN: (g) => graphGraphImpl(dictSet).outN(graphGraphImpl(dictSet).op(g)),
      elem: (\u03B1) => (v) => {
        const $8 = _lookup(Nothing, Just, \u03B1, v._1.out);
        if ($8.tag === "Nothing") {
          return false;
        }
        if ($8.tag === "Just") {
          return true;
        }
        fail();
      },
      size: (v) => size(v._1.out),
      vertices: (v) => fromFoldable11(map5(Vertex)(keys2(v._1.out))),
      sinks: (v) => sinks$p1(v._1.out),
      sources: (v) => sinks$p1(v._1.in),
      op: (v) => $GraphImpl({ out: v._1.in, in: v._1.out }),
      empty: $GraphImpl({ out: empty2, in: empty2 }),
      fromFoldable: (dictFunctor) => (dictFoldable) => {
        const fromFoldable18 = dictFoldable.foldr(Cons)(Nil);
        return (\u03B1_\u03B1s) => {
          const \u03B1_\u03B1s$p = fromFoldable18(\u03B1_\u03B1s);
          return $GraphImpl({ out: runST(outMap1(\u03B1_\u03B1s$p)), in: runST(inMap1(\u03B1_\u03B1s$p)) });
        };
      },
      Semigroup0: () => semigroupGraphImpl1,
      Set1: () => dictSet
    };
  };

  // output-es/Affjax.RequestHeader/index.js
  var $RequestHeader = (tag, _1, _2) => ({ tag, _1, _2 });

  // output-es/Affjax.ResponseFormat/index.js
  var $ResponseFormat = (tag, _1) => ({ tag, _1 });
  var identity21 = (x2) => x2;

  // output-es/Affjax.ResponseHeader/index.js
  var $ResponseHeader = (_1, _2) => ({ tag: "ResponseHeader", _1, _2 });
  var ResponseHeader = (value0) => (value1) => $ResponseHeader(value0, value1);

  // output-es/Data.Argonaut.Core/foreign.js
  function id2(x2) {
    return x2;
  }
  function stringify(j) {
    return JSON.stringify(j);
  }

  // output-es/Data.Argonaut.Core/index.js
  var jsonEmptyObject = /* @__PURE__ */ id2(empty2);

  // output-es/Data.Argonaut.Parser/foreign.js
  function _jsonParser(fail4, succ, s) {
    try {
      return succ(JSON.parse(s));
    } catch (e) {
      return fail4(e.message);
    }
  }

  // output-es/JSURI/foreign.js
  function toRFC3896(input) {
    return input.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16);
    });
  }
  var _encodeFormURLComponent = function encode(fail4, succeed, input) {
    try {
      return succeed(toRFC3896(encodeURIComponent(input)).replace(/%20/g, "+"));
    } catch (err) {
      return fail4(err);
    }
  };

  // output-es/Data.FormURLEncoded/index.js
  var traverse5 = /* @__PURE__ */ (() => traversableArray.traverse(applicativeMaybe))();
  var encode2 = /* @__PURE__ */ (() => {
    const $0 = functorMaybe.map(joinWith("&"));
    const $1 = traverse5((v) => {
      if (v._2.tag === "Nothing") {
        return _encodeFormURLComponent((v$1) => Nothing, Just, v._1);
      }
      if (v._2.tag === "Just") {
        return applyMaybe.apply((() => {
          const $2 = _encodeFormURLComponent((v$1) => Nothing, Just, v._1);
          if ($2.tag === "Just") {
            return $Maybe("Just", (val) => $2._1 + ("=" + val));
          }
          return Nothing;
        })())(_encodeFormURLComponent((v$1) => Nothing, Just, v._2._1));
      }
      fail();
    });
    return (x2) => $0($1(x2));
  })();

  // output-es/Data.HTTP.Method/index.js
  var $Method = (tag) => ({ tag });
  var GET = /* @__PURE__ */ $Method("GET");
  var print = (v2) => {
    if (v2.tag === "Left") {
      if (v2._1.tag === "OPTIONS") {
        return "OPTIONS";
      }
      if (v2._1.tag === "GET") {
        return "GET";
      }
      if (v2._1.tag === "HEAD") {
        return "HEAD";
      }
      if (v2._1.tag === "POST") {
        return "POST";
      }
      if (v2._1.tag === "PUT") {
        return "PUT";
      }
      if (v2._1.tag === "DELETE") {
        return "DELETE";
      }
      if (v2._1.tag === "TRACE") {
        return "TRACE";
      }
      if (v2._1.tag === "CONNECT") {
        return "CONNECT";
      }
      if (v2._1.tag === "PROPFIND") {
        return "PROPFIND";
      }
      if (v2._1.tag === "PROPPATCH") {
        return "PROPPATCH";
      }
      if (v2._1.tag === "MKCOL") {
        return "MKCOL";
      }
      if (v2._1.tag === "COPY") {
        return "COPY";
      }
      if (v2._1.tag === "MOVE") {
        return "MOVE";
      }
      if (v2._1.tag === "LOCK") {
        return "LOCK";
      }
      if (v2._1.tag === "UNLOCK") {
        return "UNLOCK";
      }
      if (v2._1.tag === "PATCH") {
        return "PATCH";
      }
      fail();
    }
    if (v2.tag === "Right") {
      return v2._1;
    }
    fail();
  };

  // output-es/Effect.Aff.Compat/index.js
  var fromEffectFnAff = (v) => makeAff((k) => () => {
    const v1 = v((x2) => k($Either("Left", x2))(), (x2) => k($Either("Right", x2))());
    return (e) => makeAff((k2) => () => {
      v1(e, (x2) => k2($Either("Left", x2))(), (x2) => k2($Either("Right", x2))());
      return nonCanceler;
    });
  });

  // output-es/Foreign/foreign.js
  function tagOf(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  var isArray = Array.isArray || function(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
  };

  // output-es/Foreign/index.js
  var $ForeignError = (tag, _1, _2) => ({ tag, _1, _2 });
  var renderForeignError = (v) => {
    if (v.tag === "ForeignError") {
      return v._1;
    }
    if (v.tag === "ErrorAtIndex") {
      return "Error at array index " + (showIntImpl(v._1) + (": " + renderForeignError(v._2)));
    }
    if (v.tag === "ErrorAtProperty") {
      return "Error at property " + (showStringImpl(v._1) + (": " + renderForeignError(v._2)));
    }
    if (v.tag === "TypeMismatch") {
      return "Type mismatch: expected " + (v._1 + (", found " + v._2));
    }
    fail();
  };
  var unsafeReadTagged = (dictMonad) => {
    const pure1 = applicativeExceptT(dictMonad).pure;
    const $2 = monadThrowExceptT(dictMonad).throwError;
    return (tag) => (value) => {
      if (tagOf(value) === tag) {
        return pure1(value);
      }
      return $2($NonEmpty($ForeignError("TypeMismatch", tag, tagOf(value)), Nil));
    };
  };

  // output-es/Affjax/foreign.js
  function _ajax(platformSpecificDriver, timeoutErrorMessageIdent, requestFailedMessageIdent, mkHeader, options) {
    return function(errback, callback) {
      var xhr = platformSpecificDriver.newXHR();
      var fixedUrl = platformSpecificDriver.fixupUrl(options.url, xhr);
      xhr.open(options.method || "GET", fixedUrl, true, options.username, options.password);
      if (options.headers) {
        try {
          for (var i = 0, header; (header = options.headers[i]) != null; i++) {
            xhr.setRequestHeader(header.field, header.value);
          }
        } catch (e) {
          errback(e);
        }
      }
      var onerror = function(msgIdent) {
        return function() {
          errback(new Error(msgIdent));
        };
      };
      xhr.onerror = onerror(requestFailedMessageIdent);
      xhr.ontimeout = onerror(timeoutErrorMessageIdent);
      xhr.onload = function() {
        callback({
          status: xhr.status,
          statusText: xhr.statusText,
          headers: xhr.getAllResponseHeaders().split("\r\n").filter(function(header2) {
            return header2.length > 0;
          }).map(function(header2) {
            var i2 = header2.indexOf(":");
            return mkHeader(header2.substring(0, i2))(header2.substring(i2 + 2));
          }),
          body: xhr.response
        });
      };
      xhr.responseType = options.responseType;
      xhr.withCredentials = options.withCredentials;
      xhr.timeout = options.timeout;
      xhr.send(options.content);
      return function(error3, cancelErrback, cancelCallback) {
        try {
          xhr.abort();
        } catch (e) {
          return cancelErrback(e);
        }
        return cancelCallback();
      };
    };
  }

  // output-es/Affjax/index.js
  var $Error = (tag, _1, _2) => ({ tag, _1, _2 });
  var pure = /* @__PURE__ */ (() => applicativeExceptT(monadIdentity).pure)();
  var fail3 = /* @__PURE__ */ (() => {
    const $0 = monadThrowExceptT(monadIdentity).throwError;
    return (x2) => $0($NonEmpty(x2, Nil));
  })();
  var unsafeReadTagged2 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
  var alt = /* @__PURE__ */ (() => altExceptT(semigroupNonEmptyList)(monadIdentity).alt)();
  var any2 = /* @__PURE__ */ (() => foldableArray.foldMap((() => {
    const semigroupDisj1 = { append: (v) => (v1) => v || v1 };
    return { mempty: false, Semigroup0: () => semigroupDisj1 };
  })()))();
  var $$try4 = /* @__PURE__ */ $$try2(monadErrorAff);
  var TimeoutError = /* @__PURE__ */ $Error("TimeoutError");
  var RequestFailedError = /* @__PURE__ */ $Error("RequestFailedError");
  var request = (driver2) => (req2) => {
    const fromResponse = (() => {
      if (req2.responseFormat.tag === "ArrayBuffer") {
        return unsafeReadTagged2("ArrayBuffer");
      }
      if (req2.responseFormat.tag === "Blob") {
        return unsafeReadTagged2("Blob");
      }
      if (req2.responseFormat.tag === "Document") {
        return (x2) => alt(unsafeReadTagged2("Document")(x2))(alt(unsafeReadTagged2("XMLDocument")(x2))(unsafeReadTagged2("HTMLDocument")(x2)));
      }
      if (req2.responseFormat.tag === "Json") {
        const $2 = bindExceptT(monadIdentity);
        const $3 = unsafeReadTagged2("String");
        return (a) => $2.bind($3(a))((x2) => req2.responseFormat._1((() => {
          if (x2 === "") {
            return pure(jsonEmptyObject);
          }
          const $6 = _jsonParser(Left, Right, x2);
          if ($6.tag === "Left") {
            return fail3($ForeignError("ForeignError", $6._1));
          }
          if ($6.tag === "Right") {
            return pure($6._1);
          }
          fail();
        })()));
      }
      if (req2.responseFormat.tag === "String") {
        return unsafeReadTagged2("String");
      }
      if (req2.responseFormat.tag === "Ignore") {
        const $2 = req2.responseFormat._1(pure(unit2));
        return (v) => $2;
      }
      fail();
    })();
    const send = (content2) => _map((v) => {
      if (v.tag === "Right") {
        const v1 = fromResponse(v._1.body);
        if (v1.tag === "Left") {
          return $Either("Left", $Error("ResponseBodyError", v1._1._1, v._1));
        }
        if (v1.tag === "Right") {
          return $Either("Right", { body: v1._1, headers: v._1.headers, status: v._1.status, statusText: v._1.statusText });
        }
        fail();
      }
      if (v.tag === "Left") {
        return $Either(
          "Left",
          (() => {
            const message2 = message(v._1);
            if (message2 === "AffjaxTimeoutErrorMessageIdent") {
              return TimeoutError;
            }
            if (message2 === "AffjaxRequestFailedMessageIdent") {
              return RequestFailedError;
            }
            return $Error("XHROtherError", v._1);
          })()
        );
      }
      fail();
    })($$try4(fromEffectFnAff(_ajax(
      driver2,
      "AffjaxTimeoutErrorMessageIdent",
      "AffjaxRequestFailedMessageIdent",
      ResponseHeader,
      {
        method: print(req2.method),
        url: req2.url,
        headers: arrayMap((h) => ({
          field: (() => {
            if (h.tag === "Accept") {
              return "Accept";
            }
            if (h.tag === "ContentType") {
              return "Content-Type";
            }
            if (h.tag === "RequestHeader") {
              return h._1;
            }
            fail();
          })(),
          value: (() => {
            if (h.tag === "Accept") {
              return h._1;
            }
            if (h.tag === "ContentType") {
              return h._1;
            }
            if (h.tag === "RequestHeader") {
              return h._2;
            }
            fail();
          })()
        }))((() => {
          const $4 = (() => {
            if (req2.content.tag === "Just") {
              if (req2.content._1.tag === "FormURLEncoded") {
                return $Maybe("Just", "application/x-www-form-urlencoded");
              }
              if (req2.content._1.tag === "Json") {
                return $Maybe("Just", "application/json");
              }
              return Nothing;
            }
            if (req2.content.tag === "Nothing") {
              return Nothing;
            }
            fail();
          })();
          if ($4.tag === "Just") {
            if (req2.responseFormat.tag === "Json") {
              const $5 = (() => {
                if (!any2((y2) => {
                  if (y2.tag === "Accept") {
                    return true;
                  }
                  if (y2.tag === "ContentType") {
                    return false;
                  }
                  if (y2.tag === "RequestHeader") {
                    return "Accept" === y2._1;
                  }
                  fail();
                })(req2.headers)) {
                  return run(withArray(pushAll([$RequestHeader("Accept", "application/json")]))(req2.headers));
                }
                return req2.headers;
              })();
              if (!any2((y2) => {
                if (y2.tag === "Accept") {
                  return false;
                }
                if (y2.tag === "ContentType") {
                  return true;
                }
                if (y2.tag === "RequestHeader") {
                  return "Content-Type" === y2._1;
                }
                fail();
              })($5)) {
                return run(withArray(pushAll([$RequestHeader("ContentType", $4._1)]))($5));
              }
              return $5;
            }
            if (!any2((y2) => {
              if (y2.tag === "Accept") {
                return false;
              }
              if (y2.tag === "ContentType") {
                return true;
              }
              if (y2.tag === "RequestHeader") {
                return "Content-Type" === y2._1;
              }
              fail();
            })(req2.headers)) {
              return run(withArray(pushAll([$RequestHeader("ContentType", $4._1)]))(req2.headers));
            }
            return req2.headers;
          }
          if (req2.responseFormat.tag === "Json") {
            if (!any2((y2) => {
              if (y2.tag === "Accept") {
                return true;
              }
              if (y2.tag === "ContentType") {
                return false;
              }
              if (y2.tag === "RequestHeader") {
                return "Accept" === y2._1;
              }
              fail();
            })(req2.headers)) {
              return run(withArray(pushAll([$RequestHeader("Accept", "application/json")]))(req2.headers));
            }
            return req2.headers;
          }
          return req2.headers;
        })()),
        content: content2,
        responseType: (() => {
          if (req2.responseFormat.tag === "ArrayBuffer") {
            return "arraybuffer";
          }
          if (req2.responseFormat.tag === "Blob") {
            return "blob";
          }
          if (req2.responseFormat.tag === "Document") {
            return "document";
          }
          if (req2.responseFormat.tag === "Json") {
            return "text";
          }
          if (req2.responseFormat.tag === "String") {
            return "text";
          }
          if (req2.responseFormat.tag === "Ignore") {
            return "";
          }
          fail();
        })(),
        username: (() => {
          if (req2.username.tag === "Nothing") {
            return nullImpl;
          }
          if (req2.username.tag === "Just") {
            return notNull(req2.username._1);
          }
          fail();
        })(),
        password: (() => {
          if (req2.password.tag === "Nothing") {
            return nullImpl;
          }
          if (req2.password.tag === "Just") {
            return notNull(req2.password._1);
          }
          fail();
        })(),
        withCredentials: req2.withCredentials,
        timeout: (() => {
          if (req2.timeout.tag === "Just") {
            return req2.timeout._1;
          }
          return 0;
        })()
      }
    ))));
    if (req2.content.tag === "Nothing") {
      return send(nullImpl);
    }
    if (req2.content.tag === "Just") {
      if (req2.content._1.tag === "ArrayView") {
        return send(notNull(req2.content._1._1(unsafeCoerce)));
      }
      if (req2.content._1.tag === "Blob") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "Document") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "String") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "FormData") {
        return send(notNull(req2.content._1._1));
      }
      if (req2.content._1.tag === "FormURLEncoded") {
        const $4 = encode2(req2.content._1._1);
        if ($4.tag === "Just") {
          return send(notNull($4._1));
        }
        return _pure($Either("Left", $Error("RequestContentError", "Body contains values that cannot be encoded as application/x-www-form-urlencoded")));
      }
      if (req2.content._1.tag === "Json") {
        return send(notNull(stringify(req2.content._1._1)));
      }
      fail();
    }
    fail();
  };
  var printError = (v) => {
    if (v.tag === "RequestContentError") {
      return "There was a problem with the request content: " + v._1;
    }
    if (v.tag === "ResponseBodyError") {
      return "There was a problem with the response body: " + renderForeignError(v._1);
    }
    if (v.tag === "TimeoutError") {
      return "There was a problem making the request: timeout";
    }
    if (v.tag === "RequestFailedError") {
      return "There was a problem making the request: request failed";
    }
    if (v.tag === "XHROtherError") {
      return "There was a problem making the request: " + message(v._1);
    }
    fail();
  };

  // output-es/Affjax.Web/foreign.js
  var driver = {
    newXHR: function() {
      return new XMLHttpRequest();
    },
    fixupUrl: function(url) {
      return url || "/";
    }
  };

  // output-es/EvalGraph/index.js
  var fromFoldable9 = /* @__PURE__ */ (() => foldableSet.foldl((m) => (a) => insert2(ordString)(a)(unit2)(m))(Leaf2))();
  var show22 = /* @__PURE__ */ (() => showSet(showString).show)();
  var toUnfoldable14 = /* @__PURE__ */ toUnfoldable4(unfoldableList);
  var fv2 = /* @__PURE__ */ (() => fVDict(fVElim).fv)();
  var fromFoldable16 = /* @__PURE__ */ fromFoldable2(foldableList);
  var greaterThanOrEq = /* @__PURE__ */ (() => {
    const $0 = ordTuple(ordInt)(ordInt);
    return (a1) => (a2) => !($0.compare(a1)(a2).tag === "LT");
  })();
  var show32 = (v) => "(Tuple " + (showIntImpl(v._1) + (" " + (showIntImpl(v._2) + ")")));
  var matchMany2 = (dictSet) => (v) => (v1) => {
    if (v.tag === "Nil") {
      return $Either("Right", $Tuple(empty2, $Tuple(v1, dictSet.empty)));
    }
    if (v.tag === "Cons") {
      if (v1.tag === "ContElim") {
        return bindEither.bind(match2(dictSet)(v._1)(v1._1))((v3) => bindEither.bind(matchMany2(dictSet)(v._2)(v3._2._1))((v4) => $Either(
          "Right",
          $Tuple(
            unionWith2((v$1) => (v1$1) => unsafePerformEffect(throwException(error("not disjoint"))))(v3._1)(v4._1),
            $Tuple(v4._2._1, dictSet.union(v3._2._2)(v4._2._2))
          )
        )));
      }
      if (v1.tag === "ContExpr") {
        return $Either(
          "Left",
          showIntImpl((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = b + 1 | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              ;
              return go$r;
            };
            return go(0)(v._2) + 1 | 0;
          })()) + " extra argument(s) to constructor/record; did you forget parentheses in lambda pattern?"
        );
      }
      return unsafePerformEffect(throwException(error("absurd")));
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var match2 = (dictSet) => (v) => (v1) => {
    if (v1.tag === "ElimVar") {
      if (v1._1 === "_") {
        return $Either("Right", $Tuple(empty2, $Tuple(v1._2, dictSet.empty)));
      }
      return $Either(
        "Right",
        $Tuple(
          runST(bind_(newImpl)(poke3(v1._1)(v))),
          $Tuple(v1._2, dictSet.empty)
        )
      );
    }
    if (v1.tag === "ElimConstr") {
      if (v.tag === "Constr") {
        return bindEither.bind($$with("Pattern mismatch")(consistentWith($Map(
          "Two",
          Leaf2,
          v._2,
          unit2,
          Leaf2
        ))(keys2(v1._1))))(() => bindEither.bind((() => {
          const $4 = "Incomplete patterns: no branch for " + showCtr(v._2);
          const $5 = _lookup(Nothing, Just, v._2, v1._1);
          if ($5.tag === "Nothing") {
            return $Either("Left", $4);
          }
          if ($5.tag === "Just") {
            return $Either("Right", $5._1);
          }
          fail();
        })())((\u03BA) => bindEither.bind(matchMany2(dictSet)(v._3)(\u03BA))((v2) => $Either(
          "Right",
          $Tuple(v2._1, $Tuple(v2._2._1, dictSet.insert(v._1)(v2._2._2)))
        ))));
      }
      return bindEither.bind((() => {
        const v$1 = toUnfoldable6(keys2(v1._1));
        if (v$1.tag === "Cons") {
          return dataTypeForCtr.dataTypeFor(v$1._1);
        }
        fail();
      })())((d) => $Either(
        "Left",
        "Pattern mismatch: found " + (intercalate4("\n")(prettyVal(highlightableVertex).pretty(v).lines) + (", expected " + d._1))
      ));
    }
    if (v1.tag === "ElimRecord") {
      if (v.tag === "Record") {
        return bindEither.bind((() => {
          const $3 = "Pattern mismatch: found " + (show22(keys2(v._2)) + (", expected " + show22(v1._1)));
          if (difference3(ordString)(v1._1)(fromFoldable9(keys2(v._2))).tag === "Leaf") {
            return $Either("Right", unit2);
          }
          return $Either("Left", $3);
        })())(() => bindEither.bind(matchMany2(dictSet)(listMap((a) => $$get(a)(v._2))(toUnfoldable14(v1._1)))(v1._2))((v2) => $Either(
          "Right",
          $Tuple(v2._1, $Tuple(v2._2._1, dictSet.insert(v._1)(v2._2._2)))
        )));
      }
      return $Either(
        "Left",
        "Pattern mismatch: found " + (intercalate4("\n")(prettyVal(highlightableVertex).pretty(v).lines) + (", expected " + show22(v1._1)))
      );
    }
    fail();
  };
  var closeDefs2 = (dictMonad) => {
    const $1 = traversableWithIndexObject.traverseWithIndex(applicativeExceptT((() => {
      const $12 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      return { Applicative0: () => applicativeStateT($12), Bind1: () => bindStateT($12) };
    })()));
    const $2 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
    const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
    return (dictSet) => (\u03B3) => (\u03C1) => (\u03B1s) => $1((v) => (\u03C3) => {
      const \u03C1$p = $$for(\u03C1)(\u03C3);
      return $2.map(functorEither.map(Fun))($2.map((m) => {
        if (m.tag === "Left") {
          return $Either("Left", m._1);
        }
        if (m.tag === "Right") {
          return $Either("Right", m._1(\u03C3));
        }
        fail();
      })($2.map((m) => {
        if (m.tag === "Left") {
          return $Either("Left", m._1);
        }
        if (m.tag === "Right") {
          return $Either("Right", m._1(\u03C1$p));
        }
        fail();
      })((() => {
        const $11 = restrict(\u03B3)(unionWith(ordString)($$const)(fv2(\u03C1$p))(fVElim.fv(\u03C3)));
        return $2.map((m) => {
          if (m.tag === "Left") {
            return $Either("Left", m._1);
          }
          if (m.tag === "Right") {
            return $Either("Right", m._1($11));
          }
          fail();
        })($2.map(functorEither.map(Closure))($$new(\u03B1s)));
      })())));
    })(\u03C1);
  };
  var $$eval2 = (dictMonad) => {
    const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    const $2 = applicativeStateT(monadStateT2);
    const $3 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
    const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
    const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
    const bindExceptT2 = bindExceptT(monadStateT12);
    const applicativeExceptT3 = applicativeExceptT(monadStateT12);
    const $8 = traversableWithIndexObject.traverseWithIndex(applicativeExceptT3);
    const traverse42 = traversableList.traverse(applicativeExceptT3);
    const traverse52 = traversablePair.traverse(applicativeExceptT3);
    const sequence13 = traversableArray.traverse(applicativeExceptT3)(identity10);
    const closeDefs1 = closeDefs2(dictMonad);
    return (dictSet) => {
      const closeDefs22 = closeDefs1(dictSet);
      return (v) => (v1) => (v2) => {
        if (v1.tag === "Var") {
          return $2.pure(lookup$p(v1._1)(v));
        }
        if (v1.tag === "Op") {
          return $2.pure(lookup$p(v1._1)(v));
        }
        if (v1.tag === "Int") {
          return $3.map((m) => {
            if (m.tag === "Left") {
              return $Either("Left", m._1);
            }
            if (m.tag === "Right") {
              return $Either("Right", m._1(v1._2));
            }
            fail();
          })($3.map(functorEither.map(Int3))($$new(dictSet.insert(v1._1)(v2))));
        }
        if (v1.tag === "Float") {
          return $3.map((m) => {
            if (m.tag === "Left") {
              return $Either("Left", m._1);
            }
            if (m.tag === "Right") {
              return $Either("Right", m._1(v1._2));
            }
            fail();
          })($3.map(functorEither.map(Float3))($$new(dictSet.insert(v1._1)(v2))));
        }
        if (v1.tag === "Str") {
          return $3.map((m) => {
            if (m.tag === "Left") {
              return $Either("Left", m._1);
            }
            if (m.tag === "Right") {
              return $Either("Right", m._1(v1._2));
            }
            fail();
          })($3.map(functorEither.map(Str3))($$new(dictSet.insert(v1._1)(v2))));
        }
        if (v1.tag === "Record") {
          return bindExceptT2.bind((() => {
            const $18 = $$eval2(dictMonad)(dictSet)(v);
            return $8((v$1) => (a) => $18(a)(v2))(v1._2);
          })())((xvs) => $3.map((m) => {
            if (m.tag === "Left") {
              return $Either("Left", m._1);
            }
            if (m.tag === "Right") {
              return $Either("Right", m._1(xvs));
            }
            fail();
          })($3.map(functorEither.map(Record3))($$new(dictSet.insert(v1._1)(v2)))));
        }
        if (v1.tag === "Dictionary") {
          return bindExceptT2.bind($3.map(functorEither.map(unzip2))(traverse42(traverse52((() => {
            const $18 = $$eval2(dictMonad)(dictSet)(v);
            return (a) => $18(a)(v2);
          })()))(v1._2)))((v3) => {
            const v4 = unzip(listMap(string2.match)(v3._1));
            const $20 = fromFoldable16(zipWith(Tuple)(v4._1)(zipWith(Tuple)(v4._2)(v3._2)));
            return $3.map((m) => {
              if (m.tag === "Left") {
                return $Either("Left", m._1);
              }
              if (m.tag === "Right") {
                return $Either("Right", m._1($20));
              }
              fail();
            })($3.map(functorEither.map(Dictionary3))($$new(dictSet.insert(v1._1)(v2))));
          });
        }
        if (v1.tag === "Constr") {
          return bindExceptT2.bind($2.pure(checkArity(v1._2)((() => {
            const go = (go$a0$copy) => (go$a1$copy) => {
              let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
              while (go$c) {
                const b = go$a0, v$1 = go$a1;
                if (v$1.tag === "Nil") {
                  go$c = false;
                  go$r = b;
                  continue;
                }
                if (v$1.tag === "Cons") {
                  go$a0 = b + 1 | 0;
                  go$a1 = v$1._2;
                  continue;
                }
                fail();
              }
              ;
              return go$r;
            };
            return go(0)(v1._3);
          })())))(() => bindExceptT2.bind(traverse42((() => {
            const $19 = $$eval2(dictMonad)(dictSet)(v);
            return (a) => $19(a)(v2);
          })())(v1._3))((vs) => bindExceptT2.bind($$new(dictSet.insert(v1._1)(v2)))((\u03B1$p) => applicativeExceptT3.pure($Val("Constr", \u03B1$p, v1._2, vs)))));
        }
        if (v1.tag === "Matrix") {
          return bindExceptT2.bind($$eval2(dictMonad)(dictSet)(v)(v1._4)(v2))((v3) => {
            const v4 = intPair.match(v3)._1;
            return bindExceptT2.bind((() => {
              const $20 = "array must be at least (" + (show32($Tuple(1, 1)) + ("); got (" + (show32($Tuple(v4._1._1, v4._2._1)) + ")")));
              return $2.pure((() => {
                if (greaterThanOrEq($Tuple(v4._1._1, v4._2._1))($Tuple(1, 1))) {
                  return $Either("Right", unit2);
                }
                return $Either("Left", $20);
              })());
            })())(() => bindExceptT2.bind(sequence13(arrayBind(range2(1)(v4._1._1))((i) => [
              sequence13(arrayBind(range2(1)(v4._2._1))((j) => [
                $$eval2(dictMonad)(dictSet)(unionWith2((v$1) => identity19)(v)(unionWith2((v$1) => (v1$1) => unsafePerformEffect(throwException(error("not disjoint"))))(runST(bind_(newImpl)(poke3(v1._3._1)($Val(
                  "Int",
                  v4._1._2,
                  i
                )))))(runST(bind_(newImpl)(poke3(v1._3._2)($Val("Int", v4._2._2, j)))))))(v1._2)(v2)
              ]))
            ])))((vss) => $3.map((m) => {
              if (m.tag === "Left") {
                return $Either("Left", m._1);
              }
              if (m.tag === "Right") {
                return $Either(
                  "Right",
                  m._1($Tuple(vss, $Tuple($Tuple(v4._1._1, v4._1._2), $Tuple(v4._2._1, v4._2._2))))
                );
              }
              fail();
            })($3.map(functorEither.map(Matrix3))($$new(dictSet.insert(v1._1)(v2))))));
          });
        }
        if (v1.tag === "Lambda") {
          return $3.map(functorEither.map(Fun))($3.map((m) => {
            if (m.tag === "Left") {
              return $Either("Left", m._1);
            }
            if (m.tag === "Right") {
              return $Either("Right", m._1(v1._1));
            }
            fail();
          })($3.map((m) => {
            if (m.tag === "Left") {
              return $Either("Left", m._1);
            }
            if (m.tag === "Right") {
              return $Either("Right", m._1(empty2));
            }
            fail();
          })((() => {
            const $18 = restrict(v)(fVElim.fv(v1._1));
            return $3.map((m) => {
              if (m.tag === "Left") {
                return $Either("Left", m._1);
              }
              if (m.tag === "Right") {
                return $Either("Right", m._1($18));
              }
              fail();
            })($3.map(functorEither.map(Closure))($$new(v2)));
          })())));
        }
        if (v1.tag === "Project") {
          return bindExceptT2.bind($$eval2(dictMonad)(dictSet)(v)(v1._1)(v2))((v3) => $2.pure((() => {
            if (v3.tag === "Record") {
              return lookup$p(v1._2)(v3._2);
            }
            return $Either("Left", "Found " + (intercalate4("\n")(prettyVal(highlightableVertex).pretty(v3).lines) + ", expected record"));
          })()));
        }
        if (v1.tag === "App") {
          return bindExceptT2.bind($$eval2(dictMonad)(dictSet)(v)(v1._1)(v2))((v3) => bindExceptT2.bind($$eval2(dictMonad)(dictSet)(v)(v1._2)(v2))((v$p) => apply3(dictMonad)(dictSet)(v3)(v$p)));
        }
        if (v1.tag === "Let") {
          return bindExceptT2.bind($$eval2(dictMonad)(dictSet)(v)(v1._1._2)(v2))((v3) => bindExceptT2.bind($2.pure(match2(dictSet)(v3)(v1._1._1)))((v4) => $$eval2(dictMonad)(dictSet)(unionWith2((v$1) => identity19)(v)(v4._1))(v1._2)(v4._2._2)));
        }
        if (v1.tag === "LetRec") {
          return bindExceptT2.bind(closeDefs22(v)(v1._1)(v2))((\u03B3$p) => $$eval2(dictMonad)(dictSet)(unionWith2((v$1) => identity19)(v)(\u03B3$p))(v1._2)(v2));
        }
        fail();
      };
    };
  };
  var apply3 = (dictMonad) => {
    const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
    const bindExceptT2 = bindExceptT(monadStateT12);
    const closeDefs1 = closeDefs2(dictMonad);
    const $5 = applicativeStateT(monadStateT2);
    const pure1 = applicativeExceptT(monadStateT12).pure;
    return (dictSet) => {
      const closeDefs22 = closeDefs1(dictSet);
      return (v) => (v1) => {
        const $11 = (v2) => $5.pure($Either(
          "Left",
          "Found " + (intercalate4("\n")(prettyVal(highlightableVertex).pretty(v2).lines) + ", expected function")
        ));
        if (v.tag === "Fun") {
          if (v._1.tag === "Closure") {
            return bindExceptT2.bind(closeDefs22(v._1._2)(v._1._3)(dictSet.singleton(v._1._1)))((\u03B32) => bindExceptT2.bind($5.pure(match2(dictSet)(v1)(v._1._4)))((v3) => $$eval2(dictMonad)(dictSet)(unionWith2((v$1) => identity19)(unionWith2((v$1) => identity19)(v._1._2)(\u03B32))(v3._1))((() => {
              if (v3._2._1.tag === "ContExpr") {
                return v3._2._1._1;
              }
              return unsafePerformEffect(throwException(error("Expression expected")));
            })())(dictSet.insert(v._1._1)(v3._2._2))));
          }
          if (v._1.tag === "PartialConstr") {
            const n = successful(arity(v._1._2));
            return bindExceptT2.bind((() => {
              const $13 = "Too many arguments to " + showCtr(v._1._2);
              return $5.pure((() => {
                if ((() => {
                  const go = (go$a0$copy) => (go$a1$copy) => {
                    let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                    while (go$c) {
                      const b = go$a0, v$1 = go$a1;
                      if (v$1.tag === "Nil") {
                        go$c = false;
                        go$r = b;
                        continue;
                      }
                      if (v$1.tag === "Cons") {
                        go$a0 = b + 1 | 0;
                        go$a1 = v$1._2;
                        continue;
                      }
                      fail();
                    }
                    ;
                    return go$r;
                  };
                  return go(0)(v._1._3) < n;
                })()) {
                  return $Either("Right", unit2);
                }
                return $Either("Left", $13);
              })());
            })())(() => pure1((() => {
              if ((() => {
                const go = (go$a0$copy) => (go$a1$copy) => {
                  let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                  while (go$c) {
                    const b = go$a0, v$1 = go$a1;
                    if (v$1.tag === "Nil") {
                      go$c = false;
                      go$r = b;
                      continue;
                    }
                    if (v$1.tag === "Cons") {
                      go$a0 = b + 1 | 0;
                      go$a1 = v$1._2;
                      continue;
                    }
                    fail();
                  }
                  ;
                  return go$r;
                };
                return go(0)(v._1._3) < (n - 1 | 0);
              })()) {
                return $Val(
                  "Fun",
                  $Fun(
                    "PartialConstr",
                    v._1._1,
                    v._1._2,
                    foldableList.foldr(Cons)($List("Cons", v1, Nil))(v._1._3)
                  )
                );
              }
              return $Val(
                "Constr",
                v._1._1,
                v._1._2,
                foldableList.foldr(Cons)($List("Cons", v1, Nil))(v._1._3)
              );
            })()));
          }
          if (v._1.tag === "Foreign") {
            const vs$p = foldableList.foldr(Cons)($List("Cons", v1, Nil))(v._1._2);
            if ((() => {
              const go = (go$a0$copy) => (go$a1$copy) => {
                let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
                while (go$c) {
                  const b = go$a0, v$1 = go$a1;
                  if (v$1.tag === "Nil") {
                    go$c = false;
                    go$r = b;
                    continue;
                  }
                  if (v$1.tag === "Cons") {
                    go$a0 = b + 1 | 0;
                    go$a1 = v$1._2;
                    continue;
                  }
                  fail();
                }
                ;
                return go$r;
              };
              return v._1._1._1.arity > go(0)(vs$p);
            })()) {
              return pure1($Val("Fun", $Fun("Foreign", v._1._1, vs$p)));
            }
            return v._1._1._1["op'"](dictMonad)(dictSet)(vs$p);
          }
          return $11(v1);
        }
        return $11(v1);
      };
    };
  };
  var eval_module2 = (dictMonad) => {
    const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
    const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
    const pure1 = applicativeExceptT(monadStateT12).pure;
    const bind2 = bindExceptT(monadStateT12).bind;
    const eval1 = $$eval2(dictMonad);
    const $6 = applicativeStateT(monadStateT2);
    const closeDefs1 = closeDefs2(dictMonad);
    return (dictSet) => {
      const eval2 = eval1(dictSet);
      const closeDefs22 = closeDefs1(dictSet);
      return (\u03B3) => {
        const go = (v) => (v1) => (v2) => {
          if (v1._1.tag === "Nil") {
            return pure1(v);
          }
          if (v1._1.tag === "Cons") {
            if (v1._1._1.tag === "Left") {
              return bind2(eval2(unionWith2((v$1) => identity19)(\u03B3)(v))(v1._1._1._1._2)(v2))((v3) => bind2($6.pure(match2(dictSet)(v3)(v1._1._1._1._1)))((v4) => go(unionWith2((v$1) => identity19)(v)(v4._1))($Module(v1._1._2))(v4._2._2)));
            }
            if (v1._1._1.tag === "Right") {
              return bind2(closeDefs22(unionWith2((v$1) => identity19)(\u03B3)(v))(v1._1._1._1)(v2))((\u03B3$p$p) => go(unionWith2((v$1) => identity19)(v)(\u03B3$p$p))($Module(v1._1._2))(v2));
            }
            fail();
          }
          fail();
        };
        return go(empty2);
      };
    };
  };

  // output-es/Data.CodePoint.Unicode/index.js
  var isUpper = (x2) => checkAttr([512, 524288])(x2);
  var isSpace = (c) => {
    if (c <= 823) {
      return c === 32 || (c >= 9 && c <= 13 || c === 160);
    }
    return checkAttrS([2])(c);
  };
  var isOctDigit = (c) => {
    const diff = c - 48 | 0;
    return diff <= 7 && diff >= 0;
  };
  var isDecDigit = (c) => {
    const diff = c - 48 | 0;
    return diff <= 9 && diff >= 0;
  };
  var isHexDigit = (c) => {
    const diff = c - 48 | 0;
    const diff$1 = c - 65 | 0;
    const diff$2 = c - 97 | 0;
    return diff <= 9 && diff >= 0 || (diff$1 <= 5 && diff$1 >= 0 || diff$2 <= 5 && diff$2 >= 0);
  };
  var isAlphaNum = (x2) => checkAttr([524288, 512, 4096, 1048576, 16384, 8388608, 4194304, 2097152, 131072, 256, 16777216])(x2);
  var isAlpha = (x2) => checkAttr([4096, 512, 524288, 1048576, 16384])(x2);
  var hexDigitToInt = (c) => {
    const hexUpper = c - 65 | 0;
    const hexLower = c - 97 | 0;
    const dec2 = c - 48 | 0;
    if (dec2 <= 9 && dec2 >= 0) {
      return $Maybe("Just", dec2);
    }
    if (hexLower <= 5 && hexLower >= 0) {
      return $Maybe("Just", hexLower + 10 | 0);
    }
    if (hexUpper <= 5 && hexUpper >= 0) {
      return $Maybe("Just", hexUpper + 10 | 0);
    }
    return Nothing;
  };

  // output-es/Parsing.String/index.js
  var updatePosSingle = (v) => (cp) => (after) => {
    if (cp === 10) {
      return { index: v.index + 1 | 0, line: v.line + 1 | 0, column: 1 };
    }
    if (cp === 13) {
      const v2 = codePointAt2(0)(after);
      if (v2.tag === "Just") {
        if (v2._1 === 10) {
          return { index: v.index + 1 | 0, line: v.line, column: v.column };
        }
        return { index: v.index + 1 | 0, line: v.line + 1 | 0, column: 1 };
      }
      return { index: v.index + 1 | 0, line: v.line + 1 | 0, column: 1 };
    }
    if (cp === 9) {
      return { index: v.index + 1 | 0, line: v.line, column: (v.column + 8 | 0) - intMod(v.column - 1 | 0)(8) | 0 };
    }
    return { index: v.index + 1 | 0, line: v.line, column: v.column + 1 | 0 };
  };
  var updatePosString = (updatePosString$a0$copy) => (updatePosString$a1$copy) => (updatePosString$a2$copy) => {
    let updatePosString$a0 = updatePosString$a0$copy;
    let updatePosString$a1 = updatePosString$a1$copy;
    let updatePosString$a2 = updatePosString$a2$copy;
    let updatePosString$c = true;
    let updatePosString$r;
    while (updatePosString$c) {
      const pos = updatePosString$a0, before = updatePosString$a1, after = updatePosString$a2;
      const v = uncons3(before);
      if (v.tag === "Nothing") {
        updatePosString$c = false;
        updatePosString$r = pos;
        continue;
      }
      if (v.tag === "Just") {
        updatePosString$a0 = (() => {
          if (v._1.tail === "") {
            return updatePosSingle(pos)(v._1.head)(after);
          }
          return updatePosSingle(pos)(v._1.head)(v._1.tail);
        })();
        updatePosString$a1 = v._1.tail;
        updatePosString$a2 = after;
        continue;
      }
      fail();
    }
    ;
    return updatePosString$r;
  };
  var satisfyCodePoint = (f) => (v, $2, $3, $4, $5) => {
    const v3 = uncons3(v._1);
    if (v3.tag === "Nothing") {
      return $4(v, $ParseError("Unexpected EOF", v._2));
    }
    if (v3.tag === "Just") {
      if (f(v3._1.head)) {
        return $5($ParseState(v3._1.tail, updatePosSingle(v._2)(v3._1.head)(v3._1.tail), true), v3._1.head);
      }
      return $4(v, $ParseError("Predicate unsatisfied", v._2));
    }
    fail();
  };
  var satisfy = (f) => (v, $2, $3, $4, $5) => {
    const v3 = uncons3(v._1);
    if (v3.tag === "Nothing") {
      return $4(v, $ParseError("Unexpected EOF", v._2));
    }
    if (v3.tag === "Just") {
      if (v3._1.head < 0 || v3._1.head > 65535) {
        return $4(v, $ParseError("Expected Char", v._2));
      }
      const ch = (() => {
        if (v3._1.head >= -2147483648 && v3._1.head <= 2147483647) {
          return fromCharCode(v3._1.head);
        }
        fail();
      })();
      if (f(ch)) {
        return $5($ParseState(v3._1.tail, updatePosSingle(v._2)(v3._1.head)(v3._1.tail), true), ch);
      }
      return $4(v, $ParseError("Predicate unsatisfied", v._2));
    }
    fail();
  };
  var eof = (v, $1, $2, $3, $4) => {
    if (v._1 === "") {
      return $4($ParseState(v._1, v._2, true), unit2);
    }
    return $3(v, $ParseError("Expected EOF", v._2));
  };
  var consumeWith = (f) => (v, $2, $3, $4, $5) => {
    const v3 = f(v._1);
    if (v3.tag === "Left") {
      return $4(v, $ParseError(v3._1, v._2));
    }
    if (v3.tag === "Right") {
      return $5($ParseState(v3._1.remainder, updatePosString(v._2)(v3._1.consumed)(v3._1.remainder), v3._1.consumed !== ""), v3._1.value);
    }
    fail();
  };
  var string3 = (str) => consumeWith((input) => {
    const v = stripPrefix(str)(input);
    if (v.tag === "Just") {
      return $Either("Right", { value: str, consumed: str, remainder: v._1 });
    }
    return $Either("Left", "Expected " + showStringImpl(str));
  });
  var $$char = (c) => withErrorMessage(satisfy((v) => v === c))(showCharImpl(c));

  // output-es/Parsing.String.Basic/index.js
  var show1 = /* @__PURE__ */ showArrayImpl(showCharImpl);
  var satisfyCP = (p) => satisfy((x2) => p(toCharCode(x2)));
  var oneOf = (ss) => withLazyErrorMessage(satisfy((a) => elem(eqChar)(a)(ss)))((v) => "one of " + show1(ss));
  var noneOf = (ss) => withLazyErrorMessage(satisfy((a) => notElem(eqChar)(a)(ss)))((v) => "none of " + show1(ss));

  // output-es/Data.String.Unicode/index.js
  var convert = (f) => {
    const $1 = arrayMap(f);
    return (x2) => fromCodePointArray($1(toCodePointArray(x2)));
  };
  var toLowerSimple = /* @__PURE__ */ convert(uTowlower);
  var toUpperSimple = /* @__PURE__ */ convert(uTowupper);

  // output-es/Parsing.Token/index.js
  var identity22 = (x2) => x2;
  var many3 = /* @__PURE__ */ many2(alternativeParserT)(lazyParserT);
  var some3 = /* @__PURE__ */ some2(alternativeParserT)(lazyParserT);
  var choice3 = /* @__PURE__ */ choice(foldableArray);
  var many1 = /* @__PURE__ */ many(alternativeParserT)(lazyParserT);
  var toUnfoldable15 = /* @__PURE__ */ toUnfoldable(unfoldableArray);
  var theReservedNames = (v) => {
    if (v.caseSensitive) {
      return sortBy2(ordString.compare)(v.reservedNames);
    }
    return sortBy2(ordString.compare)(arrayMap(toLower)(v.reservedNames));
  };
  var oneLineComment = (v) => {
    const $1 = skipMany(satisfy((v1) => v1 !== "\n"));
    return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$try(string3(v.commentLine))(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $1(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )));
  };
  var isReserved = (isReserved$a0$copy) => (isReserved$a1$copy) => {
    let isReserved$a0 = isReserved$a0$copy, isReserved$a1 = isReserved$a1$copy, isReserved$c = true, isReserved$r;
    while (isReserved$c) {
      const names = isReserved$a0, name3 = isReserved$a1;
      const v = uncons(names);
      if (v.tag === "Nothing") {
        isReserved$c = false;
        isReserved$r = false;
        continue;
      }
      if (v.tag === "Just") {
        const v1 = ordString.compare(v._1.head)(name3);
        if (v1.tag === "LT") {
          isReserved$a0 = v._1.tail;
          isReserved$a1 = name3;
          continue;
        }
        if (v1.tag === "EQ") {
          isReserved$c = false;
          isReserved$r = true;
          continue;
        }
        if (v1.tag === "GT") {
          isReserved$c = false;
          isReserved$r = false;
          continue;
        }
        fail();
      }
      fail();
    }
    ;
    return isReserved$r;
  };
  var inCommentSingle = (v) => {
    const startEnd = concatArray(toCharArray(v.commentEnd))(toCharArray(v.commentStart));
    const go$lazy = binding(() => lazyParserT.defer((v$1) => altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$try(string3(v.commentEnd))(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, unit2))
    )))(altParserT.alt((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => skipMany1(noneOf(startEnd))(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    ))))(withErrorMessage((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => oneOf(startEnd)(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    ))))("end of comment")))));
    const go = go$lazy();
    return go;
  };
  var multiLineComment = (v) => {
    const $1 = inComment(v);
    return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$try(string3(v.commentStart))(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $1(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )));
  };
  var inCommentMulti = (v) => {
    const startEnd = concatArray(toCharArray(v.commentEnd))(toCharArray(v.commentStart));
    const go$lazy = binding(() => lazyParserT.defer((v$1) => altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$try(string3(v.commentEnd))(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, unit2))
    )))(altParserT.alt((() => {
      const $4 = multiLineComment(v);
      return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $4(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
      )));
    })())(altParserT.alt((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => skipMany1(noneOf(startEnd))(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    ))))(withErrorMessage((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => oneOf(startEnd)(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => go$lazy()(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    ))))("end of comment"))))));
    const go = go$lazy();
    return go;
  };
  var inComment = (v) => {
    if (v.nestedComments) {
      return inCommentMulti(v);
    }
    return inCommentSingle(v);
  };
  var whiteSpace$p = (v) => {
    if (v.commentLine === "" && v.commentStart === "") {
      return skipMany(withErrorMessage(skipMany1(satisfyCodePoint(isSpace)))(""));
    }
    if (v.commentLine === "") {
      return skipMany(altParserT.alt(skipMany1(satisfyCodePoint(isSpace)))(withErrorMessage(multiLineComment(v))("")));
    }
    if (v.commentStart === "") {
      return skipMany(altParserT.alt(skipMany1(satisfyCodePoint(isSpace)))(withErrorMessage(oneLineComment(v))("")));
    }
    return skipMany(altParserT.alt(skipMany1(satisfyCodePoint(isSpace)))(altParserT.alt(oneLineComment(v))(withErrorMessage(multiLineComment(v))(""))));
  };
  var makeTokenParser = (v) => {
    const sign1 = altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$char("-")(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, (a$1) => -a$1))
    )))(altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$char("+")(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, identity22))
    )))((state1, v$1, v1, v2, done) => done(state1, identity22)));
    const $2 = some3(withErrorMessage(satisfyCP(isOctDigit))("oct digit"));
    const octal = (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => oneOf(["o", "O"])(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => more((v1$1) => $2(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$2) => {
          const $18 = foldlArray((v1$2) => (v2$3) => {
            if (v1$2.tag === "Nothing") {
              return Nothing;
            }
            if (v1$2.tag === "Just") {
              const $20 = hexDigitToInt(toCharCode(v2$3));
              if ($20.tag === "Just") {
                return $Maybe("Just", (8 * v1$2._1 | 0) + $20._1 | 0);
              }
              return Nothing;
            }
            fail();
          })($Maybe("Just", 0))(a$1);
          if ($18.tag === "Nothing") {
            return fail2("not digits")(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => done(state3, a$2)));
          }
          if ($18.tag === "Just") {
            return more((v4) => done(state2$1, $18._1));
          }
          fail();
        })
      ))))
    )));
    const $4 = whiteSpace$p(v);
    const semi2 = (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(";")(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $4(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ";"))))))
    ))));
    const $6 = some3(withErrorMessage(satisfyCP(isHexDigit))("hex digit"));
    const hexadecimal = (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => oneOf(["x", "X"])(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => more((v1$1) => $6(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$2) => {
          const $22 = foldlArray((v1$2) => (v2$3) => {
            if (v1$2.tag === "Nothing") {
              return Nothing;
            }
            if (v1$2.tag === "Just") {
              const $24 = hexDigitToInt(toCharCode(v2$3));
              if ($24.tag === "Just") {
                return $Maybe("Just", (16 * v1$2._1 | 0) + $24._1 | 0);
              }
              return Nothing;
            }
            fail();
          })($Maybe("Just", 0))(a$1);
          if ($22.tag === "Nothing") {
            return fail2("not digits")(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => done(state3, a$2)));
          }
          if ($22.tag === "Just") {
            return more((v4) => done(state2$1, $22._1));
          }
          fail();
        })
      ))))
    )));
    const fraction = asErrorMessage("fraction")((state1, more, lift1, $$throw, done) => more((v1) => $$char(".")(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => {
        const $172 = withErrorMessage(some3(withErrorMessage(satisfyCP(isDecDigit))("digit")))("fraction");
        return more((v1$1) => $172(
          state2,
          more,
          lift1,
          $$throw,
          (state2$1, a$1) => more((v2$1) => {
            const $22 = foldrArray((v1$2) => (v2$2) => {
              if (v2$2.tag === "Nothing") {
                return Nothing;
              }
              if (v2$2.tag === "Just") {
                const $24 = hexDigitToInt(toCharCode(v1$2));
                if ($24.tag === "Just") {
                  return $Maybe("Just", (v2$2._1 + toNumber($24._1)) / 10);
                }
                if ($24.tag === "Nothing") {
                  return Nothing;
                }
                fail();
              }
              fail();
            })($Maybe("Just", 0))(a$1);
            if ($22.tag === "Nothing") {
              return fail2("not digit")(state2$1, more, lift1, $$throw, done);
            }
            if ($22.tag === "Just") {
              return done(state2$1, $22._1);
            }
            fail();
          })
        ));
      })
    )));
    const escapeGap = withErrorMessage((() => {
      const $9 = some3(withErrorMessage(satisfyCP(isSpace))("space"));
      return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $9(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => $$char("\\")(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
      )));
    })())("end of string gap");
    const $10 = some3(withErrorMessage(satisfyCP(isDecDigit))("digit"));
    const decimal = (state1, more, lift1, $$throw, done) => more((v1) => $10(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => {
        const $20 = foldlArray((v1$1) => (v2$1) => {
          if (v1$1.tag === "Nothing") {
            return Nothing;
          }
          if (v1$1.tag === "Just") {
            const $22 = hexDigitToInt(toCharCode(v2$1));
            if ($22.tag === "Just") {
              return $Maybe("Just", (10 * v1$1._1 | 0) + $22._1 | 0);
            }
            return Nothing;
          }
          fail();
        })($Maybe("Just", 0))(a);
        if ($20.tag === "Nothing") {
          return fail2("not digits")(state2, more, lift1, $$throw, done);
        }
        if ($20.tag === "Just") {
          return done(state2, $20._1);
        }
        fail();
      })
    ));
    const exponent$p = (() => {
      const power = (e) => {
        if (e < 0) {
          return 1 / power(-e);
        }
        return pow(10)(toNumber(e));
      };
      return asErrorMessage("exponent")((state1, more, lift1, $$throw, done) => more((v1) => oneOf(["e", "E"])(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2) => more((v1$1) => sign1(
          state2,
          more,
          lift1,
          $$throw,
          (state2$1, a$1) => more((v2$1) => more((v1$2) => withErrorMessage(decimal)("exponent")(
            state2$1,
            more,
            lift1,
            $$throw,
            (state2$2, a$2) => more((v2$2) => done(state2$2, power(a$1(a$2))))
          )))
        )))
      )));
    })();
    const fractExponent = (n) => altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => fraction(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => more((v1$1) => option(1)(exponent$p)(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$1) => done(state2$1, (toNumber(n) + a) * a$1))
      )))
    )))((state1, more, lift1, $$throw, done) => more((v1) => exponent$p(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, toNumber(n) * a)))));
    const decimalFloat = (state1, more, lift1, $$throw, done) => more((v1) => decimal(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => option($Either("Left", a))((() => {
        const $23 = fractExponent(a);
        return (state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v1$1) => $23(
          state1$1,
          more$1,
          lift1$1,
          throw$1,
          (state2$1, a$1) => more$1((v2$1) => done$1(state2$1, $Either("Right", a$1)))
        ));
      })())(state2, more, lift1, $$throw, done))
    ));
    const $15 = whiteSpace$p(v);
    const comma2 = (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(",")(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $15(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ","))))))
    ))));
    const $17 = altParserT.alt(decimal)(altParserT.alt((() => {
      const $172 = some3(withErrorMessage(satisfyCP(isOctDigit))("oct digit"));
      return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$char("o")(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => more((v1$1) => $172(
          state2,
          more,
          lift1,
          $$throw,
          (state2$1, a$1) => more((v2$2) => {
            const $33 = foldlArray((v1$2) => (v2$3) => {
              if (v1$2.tag === "Nothing") {
                return Nothing;
              }
              if (v1$2.tag === "Just") {
                const $35 = hexDigitToInt(toCharCode(v2$3));
                if ($35.tag === "Just") {
                  return $Maybe("Just", (8 * v1$2._1 | 0) + $35._1 | 0);
                }
                return Nothing;
              }
              fail();
            })($Maybe("Just", 0))(a$1);
            if ($33.tag === "Nothing") {
              return fail2("not digits")(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => done(state3, a$2)));
            }
            if ($33.tag === "Just") {
              return more((v4) => done(state2$1, $33._1));
            }
            fail();
          })
        ))))
      )));
    })())((() => {
      const $172 = some3(withErrorMessage(satisfyCP(isHexDigit))("hex digit"));
      return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$char("x")(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => more((v1$1) => $172(
          state2,
          more,
          lift1,
          $$throw,
          (state2$1, a$1) => more((v2$2) => {
            const $33 = foldlArray((v1$2) => (v2$3) => {
              if (v1$2.tag === "Nothing") {
                return Nothing;
              }
              if (v1$2.tag === "Just") {
                const $35 = hexDigitToInt(toCharCode(v2$3));
                if ($35.tag === "Just") {
                  return $Maybe("Just", (16 * v1$2._1 | 0) + $35._1 | 0);
                }
                return Nothing;
              }
              fail();
            })($Maybe("Just", 0))(a$1);
            if ($33.tag === "Nothing") {
              return fail2("not digits")(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => done(state3, a$2)));
            }
            if ($33.tag === "Just") {
              return more((v4) => done(state2$1, $33._1));
            }
            fail();
          })
        ))))
      )));
    })()));
    const charNum = (state1, more, lift1, $$throw, done) => more((v1) => $17(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => {
        if (a > 1114111) {
          return fail2("invalid escape sequence")(state2, more, lift1, $$throw, done);
        }
        if (a >= -2147483648 && a <= 2147483647) {
          return done(state2, fromCharCode(a));
        }
        return fail2("invalid character code (should not happen)")(state2, more, lift1, $$throw, done);
      })
    ));
    const charEsc = choice3(arrayMap((v1) => (state1, more, lift1, $$throw, done) => more((v1$1) => $$char(v1._1)(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, v1._2))
    )))(zip(["a", "b", "f", "n", "r", "t", "v", "\\", '"', "'"])(["\x07", "\b", "\f", "\n", "\r", "	", "\v", "\\", '"', "'"])));
    const charAscii = choice3(arrayMap((v1) => $$try((state1, more, lift1, $$throw, done) => more((v1$1) => string3(v1._1)(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, v1._2))
    ))))(zip([
      "NUL",
      "SOH",
      "STX",
      "ETX",
      "EOT",
      "ENQ",
      "ACK",
      "BEL",
      "DLE",
      "DC1",
      "DC2",
      "DC3",
      "DC4",
      "NAK",
      "SYN",
      "ETB",
      "CAN",
      "SUB",
      "ESC",
      "DEL",
      "BS",
      "HT",
      "LF",
      "VT",
      "FF",
      "CR",
      "SO",
      "SI",
      "EM",
      "FS",
      "GS",
      "RS",
      "US",
      "SP"
    ])([
      "\0",
      "",
      "",
      "",
      "",
      "",
      "",
      "\x07",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\x1B",
      "\x7F",
      "\b",
      "	",
      "\n",
      "\v",
      "\f",
      "\r",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      " "
    ])));
    return {
      identifier: (() => {
        const $21 = $$try((() => {
          const $212 = withErrorMessage((state1, more, lift1, $$throw, done) => more((v1) => v.identStart(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => {
              const $30 = many3(v.identLetter);
              return more((v1$1) => $30(
                state2,
                more,
                lift1,
                $$throw,
                (state2$1, a$1) => more((v2$1) => done(state2$1, singleton2(a) + fromCharArray(a$1)))
              ));
            })
          )))("identifier");
          return (state1, more, lift1, $$throw, done) => more((v1) => $212(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => {
              if (isReserved(theReservedNames(v))((() => {
                if (v.caseSensitive) {
                  return a;
                }
                return toLower(a);
              })())) {
                return fail2("reserved word " + showStringImpl(a))(state2, more, lift1, $$throw, done);
              }
              return done(state2, a);
            })
          ));
        })());
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $21(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })(),
      reserved: (name3) => {
        const $22 = $$try((() => {
          const $222 = (() => {
            if (v.caseSensitive) {
              return (state1, more, lift1, $$throw, done) => more((v1) => string3(name3)(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, name3))));
            }
            const msg = showStringImpl(name3);
            const walk = (name$p) => {
              const v1 = uncons2(name$p);
              if (v1.tag === "Nothing") {
                return (state1, v$1, v1$1, v2, done) => done(state1, unit2);
              }
              if (v1.tag === "Just") {
                const $26 = withErrorMessage((() => {
                  if (checkAttr([4096, 512, 524288, 1048576, 16384])(toCharCode(v1._1.head))) {
                    const $262 = toChar(toLowerSimple(singleton2(v1._1.head)));
                    if ($262.tag === "Just") {
                      const $272 = toChar(toUpperSimple(singleton2(v1._1.head)));
                      if ($272.tag === "Just") {
                        return altParserT.alt($$char($262._1))($$char($272._1));
                      }
                      return $$char(v1._1.head);
                    }
                    return $$char(v1._1.head);
                  }
                  return $$char(v1._1.head);
                })())(msg);
                const $27 = walk(v1._1.tail);
                return (state1, more, lift1, $$throw, done) => more((v2) => more((v1$1) => $26(
                  state1,
                  more,
                  lift1,
                  $$throw,
                  (state2, a) => more((v2$1) => more((v3) => $27(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
                )));
              }
              fail();
            };
            const $24 = walk(name3);
            return (state1, more, lift1, $$throw, done) => more((v1) => $24(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, name3))));
          })();
          const $232 = withErrorMessage(notFollowedBy(v.identLetter))("end of " + name3);
          return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $222(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2$1) => more((v3) => $232(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
          )));
        })());
        const $23 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $22(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $23(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      },
      operator: (() => {
        const $21 = $$try((() => {
          const $212 = withErrorMessage((state1, more, lift1, $$throw, done) => more((v1) => v.opStart(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => {
              const $30 = many3(v.opLetter);
              return more((v1$1) => $30(
                state2,
                more,
                lift1,
                $$throw,
                (state2$1, a$1) => more((v2$1) => done(state2$1, singleton2(a) + fromCharArray(a$1)))
              ));
            })
          )))("operator");
          return (state1, more, lift1, $$throw, done) => more((v1) => $212(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => {
              if (isReserved(sortBy2(ordString.compare)(v.reservedOpNames))(a)) {
                return fail2("reserved operator " + a)(state2, more, lift1, $$throw, done);
              }
              return done(state2, a);
            })
          ));
        })());
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $21(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })(),
      reservedOp: (name3) => {
        const $22 = $$try((state1, more, lift1, $$throw, done) => more((v1) => string3(name3)(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => withErrorMessage(notFollowedBy(v.opLetter))("end of " + name3)(state2, more, lift1, $$throw, done))
        )));
        const $23 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $22(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $23(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      },
      charLiteral: withErrorMessage((() => {
        const $21 = between($$char("'"))(withErrorMessage($$char("'"))("end of character"))(altParserT.alt(satisfy((c) => c !== "'" && (c !== "\\" && c > "")))(withErrorMessage((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$char("\\")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => altParserT.alt(charEsc)(altParserT.alt(charNum)(altParserT.alt(charAscii)(withErrorMessage((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v1$1) => $$char("^")(
            state1$1,
            more$1,
            lift1$1,
            throw$1,
            (state2$1, a$1) => more$1((v2$2) => more$1((v1$2) => withErrorMessage(satisfyCP(isUpper))("uppercase letter")(
              state2$1,
              more$1,
              lift1$1,
              throw$1,
              (state2$2, a$2) => more$1((v2$3) => {
                const $45 = (toCharCode(a$2) - 65 | 0) + 1 | 0;
                if ($45 >= -2147483648 && $45 <= 2147483647) {
                  return done$1(state2$2, fromCharCode($45));
                }
                return fail2("invalid character code (should not happen)")(state2$2, more$1, lift1$1, throw$1, done$1);
              })
            )))
          )))("escape code"))))(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
        ))))("literal character")));
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $21(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })())("character"),
      stringLiteral: (() => {
        const $21 = withErrorMessage((() => {
          const $212 = between($$char('"'))(withErrorMessage($$char('"'))("end of string"))(many1(altParserT.alt((() => {
            const $213 = satisfy((c) => c !== '"' && (c !== "\\" && c > ""));
            return (state1, more, lift1, $$throw, done) => more((v1) => $213(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $Maybe("Just", a)))));
          })())(withErrorMessage((state1, more, lift1, $$throw, done) => more((v1) => $$char("\\")(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => altParserT.alt((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v1$1) => escapeGap(
              state1$1,
              more$1,
              lift1$1,
              throw$1,
              (state2$1, a$1) => more$1((v2$1) => done$1(state2$1, Nothing))
            )))(altParserT.alt((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v1$1) => $$char("&")(
              state1$1,
              more$1,
              lift1$1,
              throw$1,
              (state2$1, a$1) => more$1((v2$1) => done$1(state2$1, Nothing))
            )))((state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v1$1) => altParserT.alt(charEsc)(altParserT.alt(charNum)(altParserT.alt(charAscii)(withErrorMessage((state1$2, more$2, lift1$2, throw$2, done$2) => more$2((v1$2) => $$char("^")(
              state1$2,
              more$2,
              lift1$2,
              throw$2,
              (state2$1, a$1) => more$2((v2$1) => more$2((v1$3) => withErrorMessage(satisfyCP(isUpper))("uppercase letter")(
                state2$1,
                more$2,
                lift1$2,
                throw$2,
                (state2$2, a$2) => more$2((v2$2) => {
                  const $49 = (toCharCode(a$2) - 65 | 0) + 1 | 0;
                  if ($49 >= -2147483648 && $49 <= 2147483647) {
                    return done$2(state2$2, fromCharCode($49));
                  }
                  return fail2("invalid character code (should not happen)")(state2$2, more$2, lift1$2, throw$2, done$2);
                })
              )))
            )))("escape code"))))(state1$1, more$1, lift1$1, throw$1, (state2$1, a$1) => more$1((v2$1) => done$1(state2$1, $Maybe("Just", a$1)))))))(
              state2,
              more,
              lift1,
              $$throw,
              done
            ))
          )))("string character"))));
          return (state1, more, lift1, $$throw, done) => more((v1) => $212(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => done(
              state2,
              fromCharArray(toUnfoldable15(foldableList.foldr((v1$1) => (v2$1) => {
                if (v1$1.tag === "Nothing") {
                  return v2$1;
                }
                if (v1$1.tag === "Just") {
                  return $List("Cons", v1$1._1, v2$1);
                }
                fail();
              })(Nil)(a)))
            ))
          ));
        })())("literal string");
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $21(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })(),
      natural: withErrorMessage((() => {
        const $21 = altParserT.alt(withErrorMessage((() => {
          const $212 = altParserT.alt(hexadecimal)(altParserT.alt(octal)(altParserT.alt(decimal)((state1, v$1, v1, v2, done) => done(state1, 0))));
          return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$char("0")(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2$1) => more((v3) => $212(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
          )));
        })())(""))(decimal);
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $21(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })())("natural"),
      integer: withErrorMessage((() => {
        const $21 = whiteSpace$p(v);
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v1$1) => more((v2$1) => more((v1$2) => sign1(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$2) => more((v3) => $21(
            state2,
            more,
            lift1,
            $$throw,
            (state3, a$1) => more((v4) => more((v2$3) => {
              const $41 = altParserT.alt(withErrorMessage((() => {
                const $412 = altParserT.alt(hexadecimal)(altParserT.alt(octal)(altParserT.alt(decimal)((state1$1, v$1, v1$3, v2$4, done$1) => done$1(
                  state1$1,
                  0
                ))));
                return (state1$1, more$1, lift1$1, throw$1, done$1) => more$1((v2$4) => more$1((v1$3) => $$char("0")(
                  state1$1,
                  more$1,
                  lift1$1,
                  throw$1,
                  (state2$1, a$2) => more$1((v2$5) => more$1((v3$1) => $412(state2$1, more$1, lift1$1, throw$1, (state3$1, a$3) => more$1((v4$1) => done$1(state3$1, a$3)))))
                )));
              })())(""))(decimal);
              return more((v1$3) => $41(
                state3,
                more,
                lift1,
                $$throw,
                (state2$1, a$2) => more((v2$4) => {
                  const $46 = a(a$2);
                  return more((v2$5) => more((v3$1) => $22(state2$1, more, lift1, $$throw, (state3$1, a$3) => more((v4$1) => done(state3$1, $46)))));
                })
              ));
            }))
          )))
        ))))));
      })())("integer"),
      float: withErrorMessage((() => {
        const $21 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v1$1) => decimal(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => fractExponent(a)(
            state2,
            more,
            lift1,
            $$throw,
            (state2$1, a$1) => more((v2$2) => more((v3) => $21(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => done(state3, a$1)))))
          ))
        ))));
      })())("float"),
      naturalOrFloat: withErrorMessage((() => {
        const $21 = altParserT.alt((() => {
          const $212 = altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => altParserT.alt(hexadecimal)(octal)(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => done(state2, $Either("Left", a)))
          )))(altParserT.alt(decimalFloat)(altParserT.alt((() => {
            const $213 = fractExponent(0);
            return (state1, more, lift1, $$throw, done) => more((v1) => $213(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $Either("Right", a)))));
          })())((state1, v$1, v1, v2, done) => done(state1, $Either("Left", 0)))));
          return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $$char("0")(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2$1) => more((v3) => $212(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
          )));
        })())(decimalFloat);
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $21(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      })())("number"),
      decimal,
      hexadecimal,
      octal,
      symbol: (name3) => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(name3)(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, name3))))))
        ))));
      },
      lexeme: (p) => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => p(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
        )));
      },
      whiteSpace: whiteSpace$p(v),
      parens: (p) => between((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3("(")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "("))))))
        ))));
      })())((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(")")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ")"))))))
        ))));
      })())(p),
      braces: (p) => between((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3("{")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "{"))))))
        ))));
      })())((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3("}")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "}"))))))
        ))));
      })())(p),
      angles: (p) => between((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3("<")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "<"))))))
        ))));
      })())((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(">")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ">"))))))
        ))));
      })())(p),
      brackets: (p) => between((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3("[")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "["))))))
        ))));
      })())((() => {
        const $22 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3("]")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "]"))))))
        ))));
      })())(p),
      semi: semi2,
      comma: comma2,
      colon: (() => {
        const $21 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(":")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $21(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, ":"))))))
        ))));
      })(),
      dot: (() => {
        const $21 = whiteSpace$p(v);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => string3(".")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => $21(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => more((v2$2) => done(state3, "."))))))
        ))));
      })(),
      semiSep: (p) => sepBy(p)(semi2),
      semiSep1: (p) => sepBy1(p)(semi2),
      commaSep: (p) => sepBy(p)(comma2),
      commaSep1: (p) => sepBy1(p)(comma2)
    };
  };

  // output-es/Util.Parse/index.js
  var some1 = /* @__PURE__ */ some(alternativeParserT)(lazyParserT);
  var many4 = /* @__PURE__ */ many(alternativeParserT)(lazyParserT);
  var some4 = (p) => {
    const $1 = some1(p);
    return (state1, more, lift1, $$throw, done) => more((v1) => $1(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(
        state2,
        definitely("absurd")((() => {
          if (a.tag === "Nil") {
            return Nothing;
          }
          if (a.tag === "Cons") {
            return $Maybe("Just", $NonEmpty(a._1, a._2));
          }
          fail();
        })())
      ))
    ));
  };
  var sepBy1_try = (p) => (sep) => {
    const $2 = many4($$try((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => sep(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => p(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )))));
    return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => p(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $2(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, $NonEmpty(a, a$1))))))
    )));
  };
  var sepBy_try = (p) => (sep) => altParserT.alt((() => {
    const $2 = sepBy1_try(p)(sep);
    return (state1, more, lift1, $$throw, done) => more((v1) => $2(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $List("Cons", a._1, a._2)))));
  })())((state1, v, v1, v2, done) => done(state1, Nil));

  // output-es/Parse/index.js
  var fromFoldable10 = /* @__PURE__ */ (() => fromFoldableImpl(foldableList.foldr))();
  var fromFoldable17 = /* @__PURE__ */ (() => fromFoldableImpl(foldableNonEmptyList.foldr))();
  var choose2 = /* @__PURE__ */ choose(altParserT);
  var identity23 = (x2) => x2;
  var fanin3 = /* @__PURE__ */ fanin(categoryFn)(choiceFn);
  var operators = (binaryOp) => fromFoldable10(listMap(arrayMap((v) => $Operator("Infix", $$try(binaryOp(v.op)), v.assoc)))(listMap(fromFoldable17)(groupBy((x2) => (y2) => x2.prec === y2.prec)(sortBy((x2) => (x$1) => {
    const $3 = ordInt.compare(x2.prec)(x$1.prec);
    if ($3.tag === "GT") {
      return LT;
    }
    if ($3.tag === "EQ") {
      return EQ;
    }
    if ($3.tag === "LT") {
      return GT;
    }
    fail();
  })(foldableMap.foldr(Cons)(Nil)(opDefs))))));
  var languageDef = /* @__PURE__ */ (() => {
    const opChar = oneOf([":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~"]);
    return {
      commentStart: "{-",
      commentEnd: "-}",
      commentLine: "--",
      nestedComments: true,
      identStart: altParserT.alt(withErrorMessage(satisfyCP(isAlpha))("letter"))($$char("_")),
      identLetter: altParserT.alt(withErrorMessage(satisfyCP(isAlphaNum))("letter or digit"))(oneOf([
        "_",
        "'"
      ])),
      opStart: opChar,
      opLetter: opChar,
      reservedNames: ["as", "else", "fun", "if", "in", "let", "match", "then"],
      reservedOpNames: ["|", "..", "=", "<-", "->"],
      caseSensitive: true
    };
  })();
  var token = /* @__PURE__ */ makeTokenParser(languageDef);
  var rArrow = /* @__PURE__ */ (() => token.reservedOp("->"))();
  var rBracket = /* @__PURE__ */ (() => {
    const $0 = token.symbol("]");
    return (state1, more, lift1, $$throw, done) => more((v1) => $0(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, unit2))));
  })();
  var topLevel = (p) => (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => token.whiteSpace(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$2) => more((v3) => p(
      state2,
      more,
      lift1,
      $$throw,
      (state3, a$1) => more((v4) => more((v2$3) => more((v3$1) => eof(state3, more, lift1, $$throw, (state3$1, a$2) => more((v4$1) => done(state3$1, a$1))))))
    )))
  )))));
  var lBracket = /* @__PURE__ */ (() => {
    const $0 = token.symbol("[");
    return (state1, more, lift1, $$throw, done) => more((v1) => $0(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, unit2))));
  })();
  var lArrow = /* @__PURE__ */ (() => token.reservedOp("<-"))();
  var keyword2 = (str$p) => {
    if (elem(eqString)(str$p)(languageDef.reservedNames)) {
      return token.reserved(str$p);
    }
    return unsafePerformEffect(throwException(error(str$p + " is not a reserved word")));
  };
  var ident = (state1, more, lift1, $$throw, done) => more((v1) => token.identifier(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => {
      if (!isCtrName(a)) {
        return done(state2, a);
      }
      return fail2("No alternative")(state2, more, lift1, $$throw, done);
    })
  ));
  var field = (p) => (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => ident(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$1) => {
      const $11 = Tuple(a);
      return more((v3) => more((v2$2) => more((v1$1) => token.colon(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$3) => more((v3$1) => p(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => more((v4$1) => done(state3, $11(a$2)))))))
      ))));
    })
  )));
  var equals = /* @__PURE__ */ (() => token.reservedOp("="))();
  var ellipsis = /* @__PURE__ */ (() => token.reservedOp(".."))();
  var ctr = (state1, more, lift1, $$throw, done) => more((v1) => token.identifier(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => {
      if (isCtrName(a)) {
        return done(state2, a);
      }
      return fail2("No alternative")(state2, more, lift1, $$throw, done);
    })
  ));
  var simplePattern = (pattern$p) => altParserT.alt($$try(token.brackets((state1, v, v1, v2, done) => done(state1, PListEmpty))))(altParserT.alt((() => {
    const $1 = (() => {
      const go$lazy = binding(() => lazyParserT.defer((v) => altParserT.alt((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => rBracket(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => more((v4) => done(state2, PEnd))))
      ))))((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => token.comma(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => more((v2$2) => more((v1$1) => pattern$p(
          state2,
          more,
          lift1,
          $$throw,
          (state2$1, a$1) => more((v2$3) => {
            const $19 = PNext(a$1);
            return more((v3$1) => go$lazy()(
              state2$1,
              more,
              lift1,
              $$throw,
              (state3, a$2) => more((v4) => {
                const $24 = $19(a$2);
                return more((v4$1) => done(state3, $24));
              })
            ));
          })
        )))))
      ))))));
      const go = go$lazy();
      return go;
    })();
    return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => lBracket(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => more((v2$2) => more((v1$1) => pattern$p(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$3) => {
          const $18 = PListNonEmpty(a$1);
          return more((v3$1) => $1(
            state2$1,
            more,
            lift1,
            $$throw,
            (state3, a$2) => more((v4) => {
              const $23 = $18(a$2);
              return more((v4$1) => done(state3, $23));
            })
          ));
        })
      )))))
    )));
  })())(altParserT.alt($$try((state1, more, lift1, $$throw, done) => more((v1) => more((v1$1) => ctr(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => {
      const $11 = PConstr(a);
      return more((v2$1) => done(state2, $11(Nil)));
    })
  )))))(altParserT.alt($$try(token.braces((state1, more, lift1, $$throw, done) => more((v1) => sepBy(field(pattern$p))(token.comma)(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => done(state2, $Pattern("PRecord", a)))
  )))))(altParserT.alt($$try((state1, more, lift1, $$throw, done) => more((v1) => ident(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => done(state2, $Pattern("PVar", a)))
  ))))(altParserT.alt($$try(token.parens(pattern$p)))(token.parens((state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => pattern$p(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$1) => more((v3) => token.comma(
      state2,
      more,
      lift1,
      $$throw,
      (state3, a$1) => more((v4) => more((v2$2) => more((v1$2) => pattern$p(
        state3,
        more,
        lift1,
        $$throw,
        (state2$1, a$2) => more((v2$3) => done(
          state2$1,
          $Pattern("PConstr", "Pair", $List("Cons", a, $List("Cons", a$2, Nil)))
        ))
      ))))
    )))
  )))))))))));
  var pattern = /* @__PURE__ */ (() => {
    const $0 = buildExprParser(operators((op) => (state1, more, lift1, $$throw, done) => more((v1) => token.operator(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => (() => {
        if (":" === definitely("absurd")(charAt2(0)(a)) && op === a) {
          return applicativeParserT.pure;
        }
        return (v) => fail2("No alternative");
      })()((\u03C0) => (\u03C0$p) => $Pattern("PConstr", a, $List("Cons", \u03C0, $List("Cons", \u03C0$p, Nil))))(
        state2,
        more,
        lift1,
        $$throw,
        done
      ))
    ))));
    const go$lazy = binding(() => lazyParserT.defer((v) => $0((() => {
      const rest = (v$1) => {
        if (v$1.tag === "PConstr") {
          return altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => simplePattern(go$lazy())(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => rest($Pattern(
              "PConstr",
              v$1._1,
              foldableList.foldr(Cons)($List("Cons", a, Nil))(v$1._2)
            ))(state2, more, lift1, $$throw, done))
          )))((state1, v$2, v1, v2, done) => done(state1, v$1));
        }
        return (state1, v$2, v1, v2, done) => done(state1, v$1);
      };
      return (state1, more, lift1, $$throw, done) => more((v1) => simplePattern(go$lazy())(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2) => rest(a)(state2, more, lift1, $$throw, done))
      ));
    })())));
    const go = go$lazy();
    return go;
  })();
  var varDefs = (expr$p) => {
    const $1 = keyword2("let");
    const $2 = sepBy1_try((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => pattern(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$2) => more((v3) => equals(
        state2,
        more,
        lift1,
        $$throw,
        (state3, a$1) => more((v4) => more((v2$3) => {
          const $19 = VarDef2(a);
          return more((v3$1) => expr$p(state3, more, lift1, $$throw, (state3$1, a$2) => more((v4$1) => done(state3$1, $19(a$2)))));
        }))
      )))
    ))))))(token.semi);
    return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $1(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $2(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )));
  };
  var colonEq = /* @__PURE__ */ (() => token.reservedOp(":="))();
  var clause_uncurried = (expr$p) => (delim) => (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => pattern(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2$1) => {
      const $12 = Tuple(a);
      return more((v3) => more((v2$2) => more((v1$1) => delim(
        state2,
        more,
        lift1,
        $$throw,
        (state2$1, a$1) => more((v2$3) => more((v3$1) => expr$p(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => more((v4$1) => done(state3, $12(a$2)))))))
      ))));
    })
  )));
  var clause_curried = (expr$p) => (delim) => {
    const $2 = some4(simplePattern(pattern));
    return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => $2(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => {
        const $14 = Tuple(a);
        return more((v3) => more((v2$2) => more((v1$2) => delim(
          state2,
          more,
          lift1,
          $$throw,
          (state2$1, a$1) => more((v2$3) => more((v3$1) => expr$p(
            state2$1,
            more,
            lift1,
            $$throw,
            (state3, a$2) => more((v4) => more((v4$1) => {
              const $26 = $14(a$2);
              return more((v2$4) => done(state3, $26));
            }))
          )))
        ))));
      })
    ))));
  };
  var recDefs = (expr$p) => {
    const $1 = keyword2("let");
    const $2 = sepBy1_try((() => {
      const $22 = clause_curried(expr$p)(equals);
      return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => ident(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => {
          const $13 = Tuple(a);
          return more((v3) => $22(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, $13(a$1)))));
        })
      )));
    })())(token.semi);
    return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $1(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2$1) => more((v3) => $2(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a$1)))))
    )));
  };
  var defs = (expr$p) => {
    const $1 = choose2($$try(varDefs(expr$p)))(recDefs(expr$p));
    return (state1, more, lift1, $$throw, done) => more((v1) => $1(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, $List("Cons", a, Nil)))
    ));
  };
  var branches = (expr$p) => (branch_) => altParserT.alt((() => {
    const $2 = branch_(expr$p)(altParserT.alt(rArrow)(equals));
    return (state1, more, lift1, $$throw, done) => more((v1) => $2(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, $NonEmpty(a, Nil)))
    ));
  })())(token.braces(sepBy1(branch_(expr$p)(rArrow))(token.semi)));
  var bar = /* @__PURE__ */ (() => token.reservedOp("|"))();
  var backtick = /* @__PURE__ */ (() => {
    const $0 = token.symbol("`");
    return (state1, more, lift1, $$throw, done) => more((v1) => $0(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, unit2))));
  })();
  var expr_ = /* @__PURE__ */ (() => {
    const $0 = buildExprParser(concatArray([
      [
        $Operator(
          "Infix",
          (state1, more, lift1, $$throw, done) => more((v1) => between(backtick)(backtick)(ident)(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => done(state2, (e) => (e$p) => $Expr2("BinaryApp", e, a, e$p)))
          )),
          AssocLeft
        )
      ]
    ])(operators((op) => (state1, more, lift1, $$throw, done) => more((v1) => token.operator(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => (() => {
        if (op === a) {
          return applicativeParserT.pure;
        }
        return (v) => fail2("No alternative");
      })()((() => {
        if (op === ".") {
          return (e) => (e$p) => {
            if (e$p.tag === "Var") {
              return $Expr2("Project", e, e$p._1);
            }
            return unsafePerformEffect(throwException(error("Field names are not first class.")));
          };
        }
        if (":" === definitely("absurd")(charAt2(0)(a))) {
          return (e) => (e$p) => $Expr2("Constr", unit2, a, $List("Cons", e, $List("Cons", e$p, Nil)));
        }
        return (e) => (e$p) => $Expr2("BinaryApp", e, op, e$p);
      })())(state2, more, lift1, $$throw, done))
    )))));
    const go$lazy = binding(() => lazyParserT.defer((v) => $0((() => {
      const simpleExpr = altParserT.alt(between(token.symbol("[|"))(token.symbol("|]"))((() => {
        const $3 = Matrix2(unit2);
        const $4 = token.parens((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => ident(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => {
            const $14 = Tuple(a);
            return more((v3) => more((v2$2) => more((v1$1) => token.comma(
              state2,
              more,
              lift1,
              $$throw,
              (state2$1, a$1) => more((v2$3) => more((v3$1) => ident(state2$1, more, lift1, $$throw, (state3, a$2) => more((v4) => more((v4$1) => done(state3, $14(a$2)))))))
            ))));
          })
        ))));
        const $5 = keyword2("in");
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v1$1) => go$lazy()(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$3) => more((v3) => bar(
            state2,
            more,
            lift1,
            $$throw,
            (state3, a$1) => more((v4) => more((v2$4) => {
              const $24 = $3(a);
              return more((v3$1) => $4(
                state3,
                more,
                lift1,
                $$throw,
                (state3$1, a$2) => more((v4$1) => {
                  const $29 = $24(a$2);
                  return more((v3$2) => more((v2$5) => more((v1$2) => $5(
                    state3$1,
                    more,
                    lift1,
                    $$throw,
                    (state2$1, a$3) => more((v2$6) => more((v3$3) => go$lazy()(state2$1, more, lift1, $$throw, (state3$2, a$4) => more((v4$2) => more((v4$3) => done(state3$2, $29(a$4)))))))
                  ))));
                })
              ));
            }))
          )))
        ))))));
      })()))(altParserT.alt($$try(token.brackets((state1, v$1, v1, v2, done) => done(state1, $Expr2("ListEmpty", unit2)))))(altParserT.alt((() => {
        const $3 = ListNonEmpty(unit2);
        const $4 = (() => {
          const go$1$lazy = binding(() => lazyParserT.defer((v$1) => altParserT.alt((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => rBracket(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2$1) => more((v3) => more((v4) => done(state2, $ListRest("End", unit2)))))
          ))))((() => {
            const $6 = Next(unit2);
            return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => token.comma(
              state1,
              more,
              lift1,
              $$throw,
              (state2, a) => more((v2$1) => more((v3) => more((v2$2) => more((v1$1) => go$lazy()(
                state2,
                more,
                lift1,
                $$throw,
                (state2$1, a$1) => more((v2$3) => {
                  const $23 = $6(a$1);
                  return more((v3$1) => go$1$lazy()(
                    state2$1,
                    more,
                    lift1,
                    $$throw,
                    (state3, a$2) => more((v4) => {
                      const $28 = $23(a$2);
                      return more((v4$1) => done(state3, $28));
                    })
                  ));
                })
              )))))
            )));
          })())));
          const go$1 = go$1$lazy();
          return go$1;
        })();
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => lBracket(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => more((v2$2) => more((v1$1) => go$lazy()(
            state2,
            more,
            lift1,
            $$throw,
            (state2$1, a$1) => more((v2$3) => {
              const $21 = $3(a$1);
              return more((v3$1) => $4(
                state2$1,
                more,
                lift1,
                $$throw,
                (state3, a$2) => more((v4) => {
                  const $26 = $21(a$2);
                  return more((v4$1) => done(state3, $26));
                })
              ));
            })
          )))))
        )));
      })())(altParserT.alt(token.brackets((() => {
        const $3 = ListComp(unit2);
        const $4 = sepBy1(altParserT.alt((state1, more, lift1, $$throw, done) => more((v2) => more((v2$1) => more((v1) => more((v1$1) => pattern(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$2) => {
            const $16 = $$Generator(a);
            return more((v2$3) => more((v3) => lArrow(
              state2,
              more,
              lift1,
              $$throw,
              (state3, a$1) => more((v4) => more((v3$1) => go$lazy()(state3, more, lift1, $$throw, (state3$1, a$2) => more((v4$1) => done(state3$1, $16(a$2))))))
            )));
          })
        ))))))(altParserT.alt((() => {
          const $42 = keyword2("let");
          return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => more((v2$1) => more((v1$2) => more((v2$2) => more((v1$3) => $42(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2$3) => more((v3) => pattern(
              state2,
              more,
              lift1,
              $$throw,
              (state3, a$1) => more((v4) => more((v2$4) => more((v3$1) => equals(
                state3,
                more,
                lift1,
                $$throw,
                (state3$1, a$2) => more((v4$1) => more((v2$5) => {
                  const $30 = VarDef2(a$1);
                  return more((v3$2) => go$lazy()(
                    state3$1,
                    more,
                    lift1,
                    $$throw,
                    (state3$2, a$3) => more((v4$2) => {
                      const $35 = $30(a$3);
                      return more((v2$6) => done(state3$2, $Qualifier("Declaration", $35)));
                    })
                  ));
                }))
              ))))
            )))
          ))))))));
        })())((state1, more, lift1, $$throw, done) => more((v1) => go$lazy()(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $Qualifier("Guard", a))))))))(token.comma);
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v3) => go$lazy()(
          state1,
          more,
          lift1,
          $$throw,
          (state3, a) => more((v4) => {
            const $18 = $3(a);
            return more((v2$3) => more((v3$1) => bar(
              state3,
              more,
              lift1,
              $$throw,
              (state3$1, a$1) => more((v4$1) => more((v3$2) => more((v1$1) => $4(
                state3$1,
                more,
                lift1,
                $$throw,
                (state2, a$2) => more((v2$4) => more((v4$2) => done(state2, $18($List("Cons", a$2._1, a$2._2)))))
              ))))
            )));
          })
        ))))));
      })()))(altParserT.alt(token.brackets((state1, more, lift1, $$throw, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v3) => go$lazy()(
        state1,
        more,
        lift1,
        $$throw,
        (state3, a) => more((v4) => {
          const $16 = ListEnum(a);
          return more((v2$3) => more((v3$1) => ellipsis(
            state3,
            more,
            lift1,
            $$throw,
            (state3$1, a$1) => more((v4$1) => more((v3$2) => go$lazy()(state3$1, more, lift1, $$throw, (state3$2, a$2) => more((v4$2) => done(state3$2, $16(a$2))))))
          )));
        })
      ))))))))(altParserT.alt($$try((() => {
        const $3 = Constr2(unit2);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v1$1) => ctr(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => {
            const $14 = $3(a);
            return more((v2$1) => done(state2, $14(Nil)));
          })
        )));
      })()))(altParserT.alt(between(token.symbol("{|"))(token.symbol("|}"))((() => {
        const $3 = sepBy((state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => go$lazy()(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$2) => more((v3) => colonEq(
            state2,
            more,
            lift1,
            $$throw,
            (state3, a$1) => more((v4) => more((v2$3) => {
              const $20 = Pair(a);
              return more((v3$1) => go$lazy()(state3, more, lift1, $$throw, (state3$1, a$2) => more((v4$1) => done(state3$1, $20(a$2)))));
            }))
          )))
        ))))))(token.comma);
        const $4 = Dictionary2(unit2);
        return (state1, more, lift1, $$throw, done) => more((v1) => $3(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $4(a)))));
      })()))(altParserT.alt(token.braces((() => {
        const $3 = Record2(unit2);
        return (state1, more, lift1, $$throw, done) => more((v1) => sepBy(field(go$lazy()))(token.comma)(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => done(state2, $3(a)))
        ));
      })()))(altParserT.alt($$try((state1, more, lift1, $$throw, done) => more((v1) => ident(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2) => done(state2, $Expr2("Var", a)))
      ))))(altParserT.alt($$try((() => {
        const $3 = altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$char("-")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => done(state2, (a$1) => -a$1))
        )))(altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$char("+")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => done(state2, identity23))
        )))((state1, v$1, v1, v2, done) => done(state1, identity23)));
        return (state1, more, lift1, $$throw, done) => more((v1) => $3(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => {
            const $13 = Float2(unit2);
            return more((v1$1) => token.float(state2, more, lift1, $$throw, (state2$1, a$1) => more((v2$1) => done(state2$1, $13(a(a$1))))));
          })
        ));
      })()))(altParserT.alt($$try((() => {
        const $3 = altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$char("-")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => done(state2, (a$1) => -a$1))
        )))(altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => $$char("+")(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => done(state2, identity23))
        )))((state1, v$1, v1, v2, done) => done(state1, identity23)));
        return (state1, more, lift1, $$throw, done) => more((v1) => $3(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => {
            const $13 = Int2(unit2);
            return more((v1$1) => token.natural(state2, more, lift1, $$throw, (state2$1, a$1) => more((v2$1) => done(state2$1, $13(a(a$1))))));
          })
        ));
      })()))(altParserT.alt((() => {
        const $3 = Str2(unit2);
        return (state1, more, lift1, $$throw, done) => more((v1) => token.stringLiteral(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $3(a)))));
      })())(altParserT.alt((() => {
        const $3 = sepBy1(defs(go$lazy()))(token.semi);
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v1$1) => $3(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2) => {
            const $14 = bindList.bind($List("Cons", a._1, a._2))(identity7);
            return more((v2$1) => {
              const $16 = foldableList.foldr((def) => fanin3(Let2)(LetRec2)(def));
              const $17 = keyword2("in");
              return more((v1$2) => more((v1$3) => more((v2$2) => more((v1$4) => $17(
                state2,
                more,
                lift1,
                $$throw,
                (state2$1, a$1) => more((v2$3) => more((v3) => go$lazy()(
                  state2$1,
                  more,
                  lift1,
                  $$throw,
                  (state3, a$2) => more((v4) => more((v2$4) => {
                    const $30 = $16(a$2);
                    return more((v2$5) => done(state3, $30($14)));
                  }))
                )))
              )))));
            });
          })
        )));
      })())(altParserT.alt((() => {
        const $3 = keyword2("match");
        const $4 = keyword2("as");
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => more((v2$1) => more((v1$1) => more((v2$2) => more((v1$2) => $3(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$3) => more((v3) => go$lazy()(
            state2,
            more,
            lift1,
            $$throw,
            (state3, a$1) => more((v4) => more((v2$4) => more((v3$1) => $4(
              state3,
              more,
              lift1,
              $$throw,
              (state3$1, a$2) => more((v4$1) => more((v2$5) => {
                const $29 = MatchAs(a$1);
                return more((v3$2) => branches(go$lazy())(clause_uncurried)(state3$1, more, lift1, $$throw, (state3$2, a$3) => more((v4$2) => done(state3$2, $29(a$3)))));
              }))
            ))))
          )))
        )))))));
      })())(altParserT.alt($$try(token.parens(go$lazy())))(altParserT.alt($$try((() => {
        const $3 = token.parens(token.operator);
        return (state1, more, lift1, $$throw, done) => more((v1) => $3(state1, more, lift1, $$throw, (state2, a) => more((v2) => done(state2, $Expr2("Op", a)))));
      })()))(altParserT.alt(token.parens((state1, more, lift1, $$throw, done) => more((v2) => more((v2$1) => more((v3) => more((v2$2) => more((v1) => go$lazy()(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$3) => more((v3$1) => token.comma(
          state2,
          more,
          lift1,
          $$throw,
          (state3, a$1) => more((v4) => more((v4$1) => more((v3$2) => go$lazy()(
            state3,
            more,
            lift1,
            $$throw,
            (state3$1, a$2) => more((v4$2) => done(
              state3$1,
              $Expr2("Constr", unit2, "Pair", $List("Cons", a, $List("Cons", a$2, Nil)))
            ))
          ))))
        )))
      ))))))))(altParserT.alt((() => {
        const $3 = keyword2("fun");
        return (state1, more, lift1, $$throw, done) => more((v1) => more((v2) => more((v1$1) => $3(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$1) => more((v3) => branches(go$lazy())(clause_curried)(
            state2,
            more,
            lift1,
            $$throw,
            (state3, a$1) => more((v4) => more((v2$2) => done(state3, $Expr2("Lambda", a$1))))
          )))
        ))));
      })())((() => {
        const $3 = keyword2("if");
        const $4 = keyword2("then");
        const $5 = keyword2("else");
        return (state1, more, lift1, $$throw, done) => more((v2) => more((v2$1) => more((v1) => more((v2$2) => more((v2$3) => more((v1$1) => more((v2$4) => more((v3) => more((v2$5) => more((v1$2) => $3(
          state1,
          more,
          lift1,
          $$throw,
          (state2, a) => more((v2$6) => more((v3$1) => go$lazy()(
            state2,
            more,
            lift1,
            $$throw,
            (state3, a$1) => more((v4) => more((v4$1) => {
              const $29 = IfElse(a$1);
              return more((v2$7) => more((v3$2) => $4(
                state3,
                more,
                lift1,
                $$throw,
                (state3$1, a$2) => more((v4$2) => more((v3$3) => go$lazy()(
                  state3$1,
                  more,
                  lift1,
                  $$throw,
                  (state3$2, a$3) => more((v4$3) => {
                    const $39 = $29(a$3);
                    return more((v2$8) => more((v3$4) => $5(
                      state3$2,
                      more,
                      lift1,
                      $$throw,
                      (state3$3, a$4) => more((v4$4) => more((v3$5) => go$lazy()(state3$3, more, lift1, $$throw, (state3$4, a$5) => more((v4$5) => done(state3$4, $39(a$5))))))
                    )));
                  })
                )))
              )));
            }))
          )))
        )))))))))));
      })()))))))))))))))))));
      const rest = (v$1) => {
        if (v$1.tag === "Constr") {
          return altParserT.alt((state1, more, lift1, $$throw, done) => more((v1) => simpleExpr(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => rest($Expr2(
              "Constr",
              v$1._1,
              v$1._2,
              foldableList.foldr(Cons)($List("Cons", a, Nil))(v$1._3)
            ))(state2, more, lift1, $$throw, done))
          )))((state1, v$2, v1, v2, done) => done(state1, v$1));
        }
        return altParserT.alt((() => {
          const $6 = App3(v$1);
          return (state1, more, lift1, $$throw, done) => more((v1) => more((v1$1) => simpleExpr(
            state1,
            more,
            lift1,
            $$throw,
            (state2, a) => more((v2) => {
              const $17 = $6(a);
              return more((v2$1) => rest($17)(state2, more, lift1, $$throw, done));
            })
          )));
        })())((state1, v$2, v1, v2, done) => done(state1, v$1));
      };
      return (state1, more, lift1, $$throw, done) => more((v1) => simpleExpr(state1, more, lift1, $$throw, (state2, a) => more((v2) => rest(a)(state2, more, lift1, $$throw, done))));
    })())));
    const go = go$lazy();
    return go;
  })();
  var module_ = /* @__PURE__ */ (() => {
    const $0 = topLevel((() => {
      const $02 = sepBy_try(defs(expr_))(token.semi);
      return (state1, more, lift1, $$throw, done) => more((v2) => more((v1) => $02(
        state1,
        more,
        lift1,
        $$throw,
        (state2, a) => more((v2$1) => more((v3) => token.semi(state2, more, lift1, $$throw, (state3, a$1) => more((v4) => done(state3, a)))))
      )));
    })());
    return (state1, more, lift1, $$throw, done) => more((v1) => $0(
      state1,
      more,
      lift1,
      $$throw,
      (state2, a) => more((v2) => done(state2, $Module2(bindList.bind(a)(identity7))))
    ));
  })();

  // output-es/Debug/foreign.js
  var req = typeof module === "undefined" ? void 0 : module.require;
  var util = function() {
    try {
      return req === void 0 ? void 0 : req("util");
    } catch (e) {
      return void 0;
    }
  }();
  function _trace(x2, k) {
    if (util !== void 0) {
      console.log(util.inspect(x2, { depth: null, colors: true }));
    } else {
      console.log(x2);
    }
    return k({});
  }
  var now2 = function() {
    var perf;
    if (typeof performance !== "undefined") {
      perf = performance;
    } else if (req) {
      try {
        perf = req("perf_hooks").performance;
      } catch (e) {
      }
    }
    return function() {
      return (perf || Date).now();
    };
  }();

  // output-es/Primitive.Defs/index.js
  var erase = /* @__PURE__ */ (() => functorVal.map((v) => unit2))();
  var traverse13 = /* @__PURE__ */ (() => {
    const $0 = traversableWithIndexObject.traverseWithIndex(applicativeEither);
    return (x2) => $0((v) => x2);
  })();
  var sequence12 = /* @__PURE__ */ (() => traversableWithIndexObject.traverseWithIndex(applicativeEither)((v) => identity11))();
  var foldM5 = (dictMonad) => {
    const bind = dictMonad.Bind1().bind;
    const pure2 = dictMonad.Applicative0().pure;
    return (f) => (b0) => fold((z) => (v) => (a) => bind(z)((a$1) => f(a$1)(a)))(pure2(b0));
  };
  var foldWithIndexM = (f) => (a0) => fold((b) => (a) => (b$1) => bindEither.bind(b)((() => {
    const $5 = f(a);
    return (a$1) => $5(a$1)(b$1);
  })()))($Either("Right", a0));
  var pow3 = /* @__PURE__ */ union4(asNumberIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)((x2) => (y2) => pow(toNumber(x2))(toNumber(y2)))(pow);
  var numToStr = (v2) => {
    if (v2.tag === "Left") {
      return showIntImpl(v2._1);
    }
    if (v2.tag === "Right") {
      return showNumberImpl(v2._1);
    }
    fail();
  };
  var notEquals = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((x2) => (y2) => x2 !== y2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((x2) => (y2) => x2 !== y2)((x2) => (y2) => x2 !== y2));
  var matrixLookup = /* @__PURE__ */ $ForeignOp$p({
    arity: 2,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
      const bind2 = bindExceptT(monadStateT12).bind;
      const $4 = applicativeStateT(monadStateT2);
      const pure1 = applicativeExceptT(monadStateT12).pure;
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Matrix") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Constr") {
                if (v._2._1._3.tag === "Cons") {
                  if (v._2._1._3._1.tag === "Int") {
                    if (v._2._1._3._2.tag === "Cons") {
                      if (v._2._1._3._2._1.tag === "Int") {
                        if (v._2._1._3._2._2.tag === "Nil") {
                          if (v._2._2.tag === "Nil") {
                            if (v._2._1._2 === "Pair") {
                              return bind2((() => {
                                const $8 = index2(v._1._2._1)(v._2._1._3._1._2 - 1 | 0);
                                const $9 = (() => {
                                  if ($8.tag === "Just") {
                                    return index2($8._1)(v._2._1._3._2._1._2 - 1 | 0);
                                  }
                                  if ($8.tag === "Nothing") {
                                    return Nothing;
                                  }
                                  fail();
                                })();
                                return $4.pure((() => {
                                  if ($9.tag === "Nothing") {
                                    return $Either("Left", "Index out of bounds");
                                  }
                                  if ($9.tag === "Just") {
                                    return $Either("Right", $9._1);
                                  }
                                  fail();
                                })());
                              })())((v1) => pure1(v1));
                            }
                            return $4.pure($Either("Left", "Matrix and pair of integers expected"));
                          }
                          return $4.pure($Either("Left", "Matrix and pair of integers expected"));
                        }
                        return $4.pure($Either("Left", "Matrix and pair of integers expected"));
                      }
                      return $4.pure($Either("Left", "Matrix and pair of integers expected"));
                    }
                    return $4.pure($Either("Left", "Matrix and pair of integers expected"));
                  }
                  return $4.pure($Either("Left", "Matrix and pair of integers expected"));
                }
                return $4.pure($Either("Left", "Matrix and pair of integers expected"));
              }
              return $4.pure($Either("Left", "Matrix and pair of integers expected"));
            }
            return $4.pure($Either("Left", "Matrix and pair of integers expected"));
          }
          return $4.pure($Either("Left", "Matrix and pair of integers expected"));
        }
        return $4.pure($Either("Left", "Matrix and pair of integers expected"));
      };
    },
    op: (dictAnn) => (v) => {
      if (v.tag === "Cons") {
        if (v._1.tag === "Matrix") {
          if (v._2.tag === "Cons") {
            if (v._2._1.tag === "Constr") {
              if (v._2._1._3.tag === "Cons") {
                if (v._2._1._3._1.tag === "Int") {
                  if (v._2._1._3._2.tag === "Cons") {
                    if (v._2._1._3._2._1.tag === "Int") {
                      if (v._2._1._3._2._2.tag === "Nil") {
                        if (v._2._2.tag === "Nil") {
                          if (v._2._1._2 === "Pair") {
                            return bindEither.bind((() => {
                              const $2 = index2(v._1._2._1)(v._2._1._3._1._2 - 1 | 0);
                              const $3 = (() => {
                                if ($2.tag === "Just") {
                                  return index2($2._1)(v._2._1._3._2._1._2 - 1 | 0);
                                }
                                if ($2.tag === "Nothing") {
                                  return Nothing;
                                }
                                fail();
                              })();
                              if ($3.tag === "Nothing") {
                                return $Either("Left", "Index out of bounds");
                              }
                              if ($3.tag === "Just") {
                                return $Either("Right", $3._1);
                              }
                              fail();
                            })())((v1) => $Either(
                              "Right",
                              $Tuple(
                                $Tuple(
                                  arrayMap(arrayMap(erase))(v._1._2._1),
                                  $Tuple($Tuple(v._1._2._2._1._1, v._1._2._2._2._1), $Tuple(v._2._1._3._1._2, v._2._1._3._2._1._2))
                                ),
                                v1
                              )
                            ));
                          }
                          return $Either("Left", "Matrix and pair of integers expected");
                        }
                        return $Either("Left", "Matrix and pair of integers expected");
                      }
                      return $Either("Left", "Matrix and pair of integers expected");
                    }
                    return $Either("Left", "Matrix and pair of integers expected");
                  }
                  return $Either("Left", "Matrix and pair of integers expected");
                }
                return $Either("Left", "Matrix and pair of integers expected");
              }
              return $Either("Left", "Matrix and pair of integers expected");
            }
            return $Either("Left", "Matrix and pair of integers expected");
          }
          return $Either("Left", "Matrix and pair of integers expected");
        }
        return $Either("Left", "Matrix and pair of integers expected");
      }
      return $Either("Left", "Matrix and pair of integers expected");
    },
    op_bwd: (dictAnn) => {
      const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
      return (v) => $List(
        "Cons",
        $Val(
          "Matrix",
          BoundedJoinSemilattice0.bot,
          updateMatrix(v._1._2._2._1)(v._1._2._2._2)((v$1) => v._2)($Tuple(
            arrayMap(arrayMap(functorVal.map((v$1) => BoundedJoinSemilattice0.bot)))(v._1._1),
            $Tuple($Tuple(v._1._2._1._1, BoundedJoinSemilattice0.bot), $Tuple(v._1._2._1._2, BoundedJoinSemilattice0.bot))
          ))
        ),
        $List(
          "Cons",
          $Val(
            "Constr",
            BoundedJoinSemilattice0.bot,
            "Pair",
            $List(
              "Cons",
              $Val("Int", BoundedJoinSemilattice0.bot, v._1._2._2._1),
              $List("Cons", $Val("Int", BoundedJoinSemilattice0.bot, v._1._2._2._2), Nil)
            )
          ),
          Nil
        )
      );
    }
  });
  var log3 = (v2) => {
    if (v2.tag === "Left") {
      return log(toNumber(v2._1));
    }
    if (v2.tag === "Right") {
      return log(v2._1);
    }
    fail();
  };
  var lessThanEquals = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 <= a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 <= a2)((a1) => (a2) => a1 <= a2));
  var lessThan = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 < a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 < a2)((a1) => (a2) => a1 < a2));
  var greaterThanEquals = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 >= a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 >= a2)((a1) => (a2) => a1 >= a2));
  var greaterThan = /* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)((a1) => (a2) => a1 > a2)(/* @__PURE__ */ union4(asBooleanBoolean)(asBooleanBoolean)(asNumberString)(asNumberString)((a1) => (a2) => a1 > a2)((a1) => (a2) => a1 > a2));
  var error_ = /* @__PURE__ */ $ForeignOp$p({
    arity: 1,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const pure1 = applicativeExceptT({
        Applicative0: () => applicativeStateT(monadStateT2),
        Bind1: () => bindStateT(monadStateT2)
      }).pure;
      const $3 = applicativeStateT(monadStateT2);
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Str") {
            if (v._2.tag === "Nil") {
              return pure1(unsafePerformEffect(throwException(error(v._1._2))));
            }
            return $3.pure($Either("Left", "String expected"));
          }
          return $3.pure($Either("Left", "String expected"));
        }
        return $3.pure($Either("Left", "String expected"));
      };
    },
    op: (dictAnn) => (v) => {
      if (v.tag === "Cons") {
        if (v._1.tag === "Str") {
          if (v._2.tag === "Nil") {
            return unsafePerformEffect(throwException(error(v._1._2)));
          }
          return $Either("Left", "String expected");
        }
        return $Either("Left", "String expected");
      }
      return $Either("Left", "String expected");
    },
    op_bwd: (dictAnn) => (v) => unsafePerformEffect(throwException(error("unimplemented")))
  });
  var divide = /* @__PURE__ */ union4(asNumberIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)((x2) => (y2) => toNumber(x2) / toNumber(y2))(numDiv);
  var dims = /* @__PURE__ */ $ForeignOp$p({
    arity: 1,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const bind2 = bindExceptT({
        Applicative0: () => applicativeStateT(monadStateT2),
        Bind1: () => bindStateT(monadStateT2)
      }).bind;
      const $3 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
      const $5 = applicativeStateT(monadStateT2);
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Matrix") {
            if (v._2.tag === "Nil") {
              return bind2($3.map((m) => {
                if (m.tag === "Left") {
                  return $Either("Left", m._1);
                }
                if (m.tag === "Right") {
                  return $Either("Right", m._1(v._1._2._2._1._1));
                }
                fail();
              })($3.map(functorEither.map(Int3))($$new(dictSet.singleton(v._1._2._2._1._2)))))((v1) => bind2($3.map((m) => {
                if (m.tag === "Left") {
                  return $Either("Left", m._1);
                }
                if (m.tag === "Right") {
                  return $Either("Right", m._1(v._1._2._2._2._1));
                }
                fail();
              })($3.map(functorEither.map(Int3))($$new(dictSet.singleton(v._1._2._2._2._2)))))((v2) => $3.map((m) => {
                if (m.tag === "Left") {
                  return $Either("Left", m._1);
                }
                if (m.tag === "Right") {
                  return $Either("Right", m._1($List("Cons", v1, $List("Cons", v2, Nil))));
                }
                fail();
              })($3.map((m) => {
                if (m.tag === "Left") {
                  return $Either("Left", m._1);
                }
                if (m.tag === "Right") {
                  return $Either("Right", m._1("Pair"));
                }
                fail();
              })($3.map(functorEither.map(Constr3))($$new(dictSet.singleton(v._1._1)))))));
            }
            return $5.pure($Either("Left", "Matrix expected"));
          }
          return $5.pure($Either("Left", "Matrix expected"));
        }
        return $5.pure($Either("Left", "Matrix expected"));
      };
    },
    op: (dictAnn) => (v) => {
      if (v.tag === "Cons") {
        if (v._1.tag === "Matrix") {
          if (v._2.tag === "Nil") {
            return $Either(
              "Right",
              $Tuple(
                arrayMap(arrayMap(erase))(v._1._2._1),
                $Val(
                  "Constr",
                  v._1._1,
                  "Pair",
                  $List(
                    "Cons",
                    $Val("Int", v._1._2._2._1._2, v._1._2._2._1._1),
                    $List("Cons", $Val("Int", v._1._2._2._2._2, v._1._2._2._2._1), Nil)
                  )
                )
              )
            );
          }
          return $Either("Left", "Matrix expected");
        }
        return $Either("Left", "Matrix expected");
      }
      return $Either("Left", "Matrix expected");
    },
    op_bwd: (dictAnn) => {
      const $1 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
      return (v) => {
        if (v._2.tag === "Constr") {
          if (v._2._3.tag === "Cons") {
            if (v._2._3._1.tag === "Int") {
              if (v._2._3._2.tag === "Cons") {
                if (v._2._3._2._1.tag === "Int") {
                  if (v._2._3._2._2.tag === "Nil") {
                    if (v._2._2 === "Pair") {
                      return $List(
                        "Cons",
                        $Val(
                          "Matrix",
                          v._2._1,
                          $Tuple(
                            arrayMap(arrayMap(functorVal.map((v$1) => $1.bot)))(v._1),
                            $Tuple($Tuple(v._2._3._1._2, v._2._3._1._1), $Tuple(v._2._3._2._1._2, v._2._3._2._1._1))
                          )
                        ),
                        Nil
                      );
                    }
                    fail();
                  }
                  fail();
                }
                fail();
              }
              fail();
            }
            fail();
          }
          fail();
        }
        fail();
      };
    }
  });
  var dict_map = /* @__PURE__ */ $ForeignOp$p({
    arity: 2,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
      const bind2 = bindExceptT(monadStateT12).bind;
      const $4 = traversableWithIndexObject.traverseWithIndex(applicativeExceptT(monadStateT12));
      const $5 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const apply4 = apply3(dictMonad);
      const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
      const $8 = applicativeStateT(monadStateT2);
      return (dictSet) => {
        const apply1 = apply4(dictSet);
        return (v) => {
          if (v.tag === "Cons") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Nil") {
                  return bind2($4((v$1) => (v2) => $5.map((m) => {
                    if (m.tag === "Left") {
                      return $Either("Left", m._1);
                    }
                    if (m.tag === "Right") {
                      return $Either("Right", $Tuple(v2._1, m._1));
                    }
                    fail();
                  })(apply1(v._1)(v2._2)))(v._2._1._2))((d$p) => $5.map((m) => {
                    if (m.tag === "Left") {
                      return $Either("Left", m._1);
                    }
                    if (m.tag === "Right") {
                      return $Either("Right", m._1(d$p));
                    }
                    fail();
                  })($5.map(functorEither.map(Dictionary3))($$new(dictSet.singleton(v._2._1._1)))));
                }
                return $8.pure($Either("Left", "Function and dictionary expected"));
              }
              return $8.pure($Either("Left", "Function and dictionary expected"));
            }
            return $8.pure($Either("Left", "Function and dictionary expected"));
          }
          return $8.pure($Either("Left", "Function and dictionary expected"));
        };
      };
    },
    op: (dictAnn) => {
      const apply4 = apply2(dictAnn);
      return (v) => {
        if (v.tag === "Cons") {
          if (v._2.tag === "Cons") {
            if (v._2._1.tag === "Dictionary") {
              if (v._2._2.tag === "Nil") {
                return bindEither.bind((() => {
                  const $3 = traverse13((v2) => {
                    const $4 = apply4($Tuple(v._1, v2._2));
                    if ($4.tag === "Left") {
                      return $Either("Left", $4._1);
                    }
                    if ($4.tag === "Right") {
                      return $Either("Right", $Tuple($4._1._1, $Tuple(v2._1, $4._1._2)));
                    }
                    fail();
                  })(v._2._1._2);
                  if ($3.tag === "Left") {
                    return $Either("Left", $3._1);
                  }
                  if ($3.tag === "Right") {
                    return $Either("Right", $Tuple(_fmapObject($3._1, fst), _fmapObject($3._1, snd)));
                  }
                  fail();
                })())((v2) => $Either(
                  "Right",
                  $Tuple($Tuple(functorVal.map((v$1) => unit2)(v._1), v2._1), $Val("Dictionary", v._2._1._1, v2._2))
                ));
              }
              return $Either("Left", "Function and dictionary expected");
            }
            return $Either("Left", "Function and dictionary expected");
          }
          return $Either("Left", "Function and dictionary expected");
        }
        return $Either("Left", "Function and dictionary expected");
      };
    },
    op_bwd: (dictAnn) => {
      const applyBwd2 = applyBwd(dictAnn);
      const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
      const join = joinSemilatticeVal(BoundedJoinSemilattice0.JoinSemilattice0()).join;
      return (v) => {
        if (v._2.tag === "Dictionary") {
          const $5 = intersectionWith((t2) => (v3) => {
            const $7 = applyBwd2($Tuple(t2, v3._2));
            return $Tuple($7._1, $Tuple(v3._1, $7._2));
          })(v._1._2)(v._2._2);
          return $List(
            "Cons",
            fold((z) => (v$1) => join(z))(functorVal.map((v$1) => BoundedJoinSemilattice0.bot)(v._1._1))(_fmapObject($5, fst)),
            $List("Cons", $Val("Dictionary", v._2._1, _fmapObject($5, snd)), Nil)
          );
        }
        fail();
      };
    }
  });
  var dict_intersectionWith = /* @__PURE__ */ $ForeignOp$p({
    arity: 3,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
      const bind2 = bindExceptT(monadStateT12).bind;
      const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
      const $5 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const apply4 = apply3(dictMonad);
      const apply1 = applyExceptT(monadStateT12).apply;
      const sequence22 = traversableWithIndexObject.traverseWithIndex(applicativeExceptT(monadStateT12))((v) => identity11);
      const $9 = applicativeStateT(monadStateT2);
      return (dictSet) => {
        const apply23 = apply4(dictSet);
        return (v) => {
          if (v.tag === "Cons") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Cons") {
                  if (v._2._2._1.tag === "Dictionary") {
                    if (v._2._2._2.tag === "Nil") {
                      return apply1($5.map(functorEither.map(Dictionary3))($$new(dictSet.insert(v._2._2._1._1)(dictSet.singleton(v._2._1._1)))))($5.map(functorEither.map(DictRep))(sequence22(intersectionWith((v2) => (v3) => bind2($$new(dictSet.insert(v3._1)(dictSet.singleton(v2._1))))((\u03B2$p$p) => $5.map(functorEither.map(Tuple(\u03B2$p$p)))(bind2(apply23(v._1)(v2._2))((a) => apply23(a)(v3._2)))))(v._2._1._2)(v._2._2._1._2))));
                    }
                    return $9.pure($Either("Left", "Function and two dictionaries expected"));
                  }
                  return $9.pure($Either("Left", "Function and two dictionaries expected"));
                }
                return $9.pure($Either("Left", "Function and two dictionaries expected"));
              }
              return $9.pure($Either("Left", "Function and two dictionaries expected"));
            }
            return $9.pure($Either("Left", "Function and two dictionaries expected"));
          }
          return $9.pure($Either("Left", "Function and two dictionaries expected"));
        };
      };
    },
    op: (dictAnn) => {
      const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
      const apply23 = apply22(dictAnn);
      return (v) => {
        if (v.tag === "Cons") {
          if (v._2.tag === "Cons") {
            if (v._2._1.tag === "Dictionary") {
              if (v._2._2.tag === "Cons") {
                if (v._2._2._1.tag === "Dictionary") {
                  if (v._2._2._2.tag === "Nil") {
                    return bindEither.bind(sequence12(intersectionWith((v2) => (v3) => {
                      const $6 = apply23($Tuple(v._1, $Tuple(v2._2, v3._2)));
                      if ($6.tag === "Left") {
                        return $Either("Left", $6._1);
                      }
                      if ($6.tag === "Right") {
                        return $Either("Right", $Tuple(meet(v2._1)(v3._1), $6._1));
                      }
                      fail();
                    })(v._2._1._2)(v._2._2._1._2)))((d$p$p) => $Either(
                      "Right",
                      $Tuple(
                        $Tuple(functorVal.map((v$1) => unit2)(v._1), _fmapObject(d$p$p, (x2) => x2._2._1)),
                        $Val("Dictionary", meet(v._2._1._1)(v._2._2._1._1), _fmapObject(d$p$p, functorTuple.map(snd)))
                      )
                    ));
                  }
                  return $Either("Left", "Function and two dictionaries expected");
                }
                return $Either("Left", "Function and two dictionaries expected");
              }
              return $Either("Left", "Function and two dictionaries expected");
            }
            return $Either("Left", "Function and two dictionaries expected");
          }
          return $Either("Left", "Function and two dictionaries expected");
        }
        return $Either("Left", "Function and two dictionaries expected");
      };
    },
    op_bwd: (dictAnn) => {
      const apply2Bwd2 = apply2Bwd(dictAnn);
      const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
      const join = joinSemilatticeVal(BoundedJoinSemilattice0.JoinSemilattice0()).join;
      return (v) => {
        if (v._2.tag === "Dictionary") {
          const d$p = intersectionWith((tt) => (v2) => $Tuple(v2._1, apply2Bwd2($Tuple(tt, v2._2))))(v._1._2)(v._2._2);
          return $List(
            "Cons",
            fold((z) => (v$1) => join(z))(functorVal.map((v$1) => BoundedJoinSemilattice0.bot)(v._1._1))(_fmapObject(d$p, (x2) => x2._2._1)),
            $List(
              "Cons",
              $Val("Dictionary", v._2._1, _fmapObject(d$p, (m) => $Tuple(m._1, m._2._2._1))),
              $List("Cons", $Val("Dictionary", v._2._1, _fmapObject(d$p, (m) => $Tuple(m._1, m._2._2._2))), Nil)
            )
          );
        }
        fail();
      };
    }
  });
  var dict_get = /* @__PURE__ */ $ForeignOp$p({
    arity: 2,
    "op'": (dictMonad) => {
      const $1 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const $2 = applicativeStateT({
        Applicative0: () => applicativeStateT(dictMonad),
        Bind1: () => bindStateT(dictMonad)
      });
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Str") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Nil") {
                  return $1.map(functorEither.map(snd))((() => {
                    const $5 = 'Key "' + (v._1._2 + '" not found');
                    const $6 = _lookup(Nothing, Just, v._1._2, v._2._1._2);
                    return $2.pure((() => {
                      if ($6.tag === "Nothing") {
                        return $Either("Left", $5);
                      }
                      if ($6.tag === "Just") {
                        return $Either("Right", $6._1);
                      }
                      fail();
                    })());
                  })());
                }
                return $2.pure($Either("Left", "String and dictionary expected"));
              }
              return $2.pure($Either("Left", "String and dictionary expected"));
            }
            return $2.pure($Either("Left", "String and dictionary expected"));
          }
          return $2.pure($Either("Left", "String and dictionary expected"));
        }
        return $2.pure($Either("Left", "String and dictionary expected"));
      };
    },
    op: (dictAnn) => (v) => {
      if (v.tag === "Cons") {
        if (v._1.tag === "Str") {
          if (v._2.tag === "Cons") {
            if (v._2._1.tag === "Dictionary") {
              if (v._2._2.tag === "Nil") {
                const $2 = 'Key "' + (v._1._2 + '" not found');
                const $3 = _lookup(Nothing, Just, v._1._2, v._2._1._2);
                if ($3.tag === "Just") {
                  return $Either("Right", $Tuple(v._1._2, $3._1._2));
                }
                return $Either("Left", $2);
              }
              return $Either("Left", "String and dictionary expected");
            }
            return $Either("Left", "String and dictionary expected");
          }
          return $Either("Left", "String and dictionary expected");
        }
        return $Either("Left", "String and dictionary expected");
      }
      return $Either("Left", "String and dictionary expected");
    },
    op_bwd: (dictAnn) => {
      const bot = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().bot;
      return (v) => $List(
        "Cons",
        $Val("Str", bot, v._1),
        $List(
          "Cons",
          $Val(
            "Dictionary",
            bot,
            runST(bind_(newImpl)(poke3(v._1)($Tuple(bot, v._2))))
          ),
          Nil
        )
      );
    }
  });
  var dict_fromRecord = /* @__PURE__ */ $ForeignOp$p({
    arity: 1,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
      const bind2 = bindExceptT(monadStateT12).bind;
      const $4 = traversableWithIndexObject.traverseWithIndex(applicativeExceptT(monadStateT12));
      const $5 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
      const $7 = applicativeStateT(monadStateT2);
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Record") {
            if (v._2.tag === "Nil") {
              return bind2($4((v$1) => (v1) => $5.map((m) => {
                if (m.tag === "Left") {
                  return $Either("Left", m._1);
                }
                if (m.tag === "Right") {
                  return $Either("Right", $Tuple(m._1, v1));
                }
                fail();
              })($$new(dictSet.singleton(v._1._1))))(v._1._2))((xvs$p) => $5.map((m) => {
                if (m.tag === "Left") {
                  return $Either("Left", m._1);
                }
                if (m.tag === "Right") {
                  return $Either("Right", m._1(xvs$p));
                }
                fail();
              })($5.map(functorEither.map(Dictionary3))($$new(dictSet.singleton(v._1._1)))));
            }
            return $7.pure($Either("Left", "Record expected."));
          }
          return $7.pure($Either("Left", "Record expected."));
        }
        return $7.pure($Either("Left", "Record expected."));
      };
    },
    op: (dictAnn) => (v) => {
      if (v.tag === "Cons") {
        if (v._1.tag === "Record") {
          if (v._2.tag === "Nil") {
            return $Either(
              "Right",
              $Tuple(unit2, $Val("Dictionary", v._1._1, _fmapObject(v._1._2, (v1) => $Tuple(v._1._1, v1))))
            );
          }
          return $Either("Left", "Record expected.");
        }
        return $Either("Left", "Record expected.");
      }
      return $Either("Left", "Record expected.");
    },
    op_bwd: (dictAnn) => {
      const join = dictAnn.BoundedLattice1().BoundedJoinSemilattice0().JoinSemilattice0().join;
      return (v) => {
        if (v._2.tag === "Dictionary") {
          return $List(
            "Cons",
            $Val(
              "Record",
              fold((z) => (v$1) => join(z))(v._2._1)(_fmapObject(v._2._2, fst)),
              _fmapObject(v._2._2, snd)
            ),
            Nil
          );
        }
        fail();
      };
    }
  });
  var dict_foldl = /* @__PURE__ */ $ForeignOp$p({
    arity: 3,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const monadStateT12 = { Applicative0: () => applicativeStateT(monadStateT2), Bind1: () => bindStateT(monadStateT2) };
      const foldM12 = foldM5({ Applicative0: () => applicativeExceptT(monadStateT12), Bind1: () => bindExceptT(monadStateT12) });
      const bind2 = bindExceptT(monadStateT12).bind;
      const apply4 = apply3(dictMonad);
      const $6 = applicativeStateT(monadStateT2);
      return (dictSet) => {
        const apply1 = apply4(dictSet);
        return (v) => {
          if (v.tag === "Cons") {
            if (v._2.tag === "Cons") {
              if (v._2._2.tag === "Cons") {
                if (v._2._2._1.tag === "Dictionary") {
                  if (v._2._2._2.tag === "Nil") {
                    return foldM12((u1) => (v2) => bind2(apply1(v._1)(u1))((a) => apply1(a)(v2._2)))(v._2._1)(v._2._2._1._2);
                  }
                  return $6.pure($Either("Left", "Function, value and dictionary expected"));
                }
                return $6.pure($Either("Left", "Function, value and dictionary expected"));
              }
              return $6.pure($Either("Left", "Function, value and dictionary expected"));
            }
            return $6.pure($Either("Left", "Function, value and dictionary expected"));
          }
          return $6.pure($Either("Left", "Function, value and dictionary expected"));
        };
      };
    },
    op: (dictAnn) => {
      const apply23 = apply22(dictAnn);
      return (v) => {
        if (v.tag === "Cons") {
          if (v._2.tag === "Cons") {
            if (v._2._2.tag === "Cons") {
              if (v._2._2._1.tag === "Dictionary") {
                if (v._2._2._2.tag === "Nil") {
                  return bindEither.bind(foldWithIndexM((s) => (v2) => (v3) => {
                    const $6 = apply23($Tuple(v._1, $Tuple(v2._2, v3._2)));
                    if ($6.tag === "Left") {
                      return $Either("Left", $6._1);
                    }
                    if ($6.tag === "Right") {
                      return $Either("Right", $Tuple($List("Cons", $Tuple(s, $6._1._1), v2._1), $6._1._2));
                    }
                    fail();
                  })($Tuple(Nil, v._2._1))(v._2._2._1._2))((v2) => $Either(
                    "Right",
                    $Tuple($Tuple(functorVal.map((v$1) => unit2)(v._1), v2._1), v2._2)
                  ));
                }
                return $Either("Left", "Function, value and dictionary expected");
              }
              return $Either("Left", "Function, value and dictionary expected");
            }
            return $Either("Left", "Function, value and dictionary expected");
          }
          return $Either("Left", "Function, value and dictionary expected");
        }
        return $Either("Left", "Function, value and dictionary expected");
      };
    },
    op_bwd: (dictAnn) => {
      const apply2Bwd2 = apply2Bwd(dictAnn);
      const BoundedJoinSemilattice0 = dictAnn.BoundedLattice1().BoundedJoinSemilattice0();
      const join = joinSemilatticeVal(BoundedJoinSemilattice0.JoinSemilattice0()).join;
      return (v) => {
        const v2 = (() => {
          const go = (go$a0$copy) => (go$a1$copy) => {
            let go$a0 = go$a0$copy, go$a1 = go$a1$copy, go$c = true, go$r;
            while (go$c) {
              const b = go$a0, v$1 = go$a1;
              if (v$1.tag === "Nil") {
                go$c = false;
                go$r = b;
                continue;
              }
              if (v$1.tag === "Cons") {
                go$a0 = (() => {
                  const v5 = apply2Bwd2($Tuple(v$1._1._2, b._2._1));
                  return $Tuple(
                    join(b._1)(v5._1),
                    $Tuple(v5._2._1, mutate(poke3(v$1._1._1)($Tuple(BoundedJoinSemilattice0.bot, v5._2._2)))(b._2._2))
                  );
                })();
                go$a1 = v$1._2;
                continue;
              }
              fail();
            }
            ;
            return go$r;
          };
          return go($Tuple(functorVal.map((v$1) => BoundedJoinSemilattice0.bot)(v._1._1), $Tuple(v._2, empty2)))(v._1._2);
        })();
        return $List(
          "Cons",
          v2._1,
          $List("Cons", v2._2._1, $List("Cons", $Val("Dictionary", BoundedJoinSemilattice0.bot, v2._2._2), Nil))
        );
      };
    }
  });
  var dict_disjointUnion = /* @__PURE__ */ $ForeignOp$p({
    arity: 2,
    "op'": (dictMonad) => {
      const $1 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
      const $3 = applicativeStateT({
        Applicative0: () => applicativeStateT(dictMonad),
        Bind1: () => bindStateT(dictMonad)
      });
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Dictionary") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Nil") {
                  const $6 = unionWith2((v$1) => (v1) => unsafePerformEffect(throwException(error("not disjoint"))))(v._1._2)(v._2._1._2);
                  return $1.map((m) => {
                    if (m.tag === "Left") {
                      return $Either("Left", m._1);
                    }
                    if (m.tag === "Right") {
                      return $Either("Right", m._1($6));
                    }
                    fail();
                  })($1.map(functorEither.map(Dictionary3))($$new(dictSet.insert(v._2._1._1)(dictSet.singleton(v._1._1)))));
                }
                return $3.pure($Either("Left", "Dictionaries expected"));
              }
              return $3.pure($Either("Left", "Dictionaries expected"));
            }
            return $3.pure($Either("Left", "Dictionaries expected"));
          }
          return $3.pure($Either("Left", "Dictionaries expected"));
        }
        return $3.pure($Either("Left", "Dictionaries expected"));
      };
    },
    op: (dictAnn) => {
      const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
      return (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Dictionary") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Nil") {
                  return $Either(
                    "Right",
                    $Tuple(
                      $Tuple(_fmapObject(v._1._2, (v$1) => unit2), _fmapObject(v._2._1._2, (v$1) => unit2)),
                      $Val(
                        "Dictionary",
                        meet(v._1._1)(v._2._1._1),
                        unionWith2((v$1) => (v1) => unsafePerformEffect(throwException(error("not disjoint"))))(v._1._2)(v._2._1._2)
                      )
                    )
                  );
                }
                return $Either("Left", "Dictionaries expected");
              }
              return $Either("Left", "Dictionaries expected");
            }
            return $Either("Left", "Dictionaries expected");
          }
          return $Either("Left", "Dictionaries expected");
        }
        return $Either("Left", "Dictionaries expected");
      };
    },
    op_bwd: (dictAnn) => (v) => {
      if (v._2.tag === "Dictionary") {
        return $List(
          "Cons",
          $Val("Dictionary", v._2._1, difference2(v._2._2)(v._1._2)),
          $List("Cons", $Val("Dictionary", v._2._1, difference2(v._2._2)(v._1._1)), Nil)
        );
      }
      fail();
    }
  });
  var dict_difference = /* @__PURE__ */ $ForeignOp$p({
    arity: 2,
    "op'": (dictMonad) => {
      const $1 = functorStateT(functorStateT(dictMonad.Bind1().Apply0().Functor0()));
      const $$new = monadGraphAllocWithGraphA(dictMonad)(monadGraphWithGraphAllocT(dictMonad)).new;
      const $3 = applicativeStateT({
        Applicative0: () => applicativeStateT(dictMonad),
        Bind1: () => bindStateT(dictMonad)
      });
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Dictionary") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Nil") {
                  const $6 = difference2(v._1._2)(v._2._1._2);
                  return $1.map((m) => {
                    if (m.tag === "Left") {
                      return $Either("Left", m._1);
                    }
                    if (m.tag === "Right") {
                      return $Either("Right", m._1($6));
                    }
                    fail();
                  })($1.map(functorEither.map(Dictionary3))($$new(dictSet.insert(v._2._1._1)(dictSet.singleton(v._1._1)))));
                }
                return $3.pure($Either("Left", "Dictionaries expected."));
              }
              return $3.pure($Either("Left", "Dictionaries expected."));
            }
            return $3.pure($Either("Left", "Dictionaries expected."));
          }
          return $3.pure($Either("Left", "Dictionaries expected."));
        }
        return $3.pure($Either("Left", "Dictionaries expected."));
      };
    },
    op: (dictAnn) => {
      const meet = dictAnn.BoundedLattice1().BoundedMeetSemilattice1().MeetSemilattice0().meet;
      return (v) => {
        if (v.tag === "Cons") {
          if (v._1.tag === "Dictionary") {
            if (v._2.tag === "Cons") {
              if (v._2._1.tag === "Dictionary") {
                if (v._2._2.tag === "Nil") {
                  return $Either("Right", $Tuple(unit2, $Val("Dictionary", meet(v._1._1)(v._2._1._1), difference2(v._1._2)(v._2._1._2))));
                }
                return $Either("Left", "Dictionaries expected.");
              }
              return $Either("Left", "Dictionaries expected.");
            }
            return $Either("Left", "Dictionaries expected.");
          }
          return $Either("Left", "Dictionaries expected.");
        }
        return $Either("Left", "Dictionaries expected.");
      };
    },
    op_bwd: (dictAnn) => (v) => {
      if (v._2.tag === "Dictionary") {
        return $List(
          "Cons",
          $Val("Dictionary", v._2._1, v._2._2),
          $List("Cons", $Val("Dictionary", v._2._1, empty2), Nil)
        );
      }
      fail();
    }
  });
  var debugLog = /* @__PURE__ */ $ForeignOp$p({
    arity: 1,
    "op'": (dictMonad) => {
      const monadStateT2 = { Applicative0: () => applicativeStateT(dictMonad), Bind1: () => bindStateT(dictMonad) };
      const pure1 = applicativeExceptT({
        Applicative0: () => applicativeStateT(monadStateT2),
        Bind1: () => bindStateT(monadStateT2)
      }).pure;
      const $3 = applicativeStateT(monadStateT2);
      return (dictSet) => (v) => {
        if (v.tag === "Cons") {
          if (v._2.tag === "Nil") {
            return pure1(_trace(v._1, (v$1) => v._1));
          }
          return $3.pure($Either("Left", "Single value expected"));
        }
        return $3.pure($Either("Left", "Single value expected"));
      };
    },
    op: (dictAnn) => (v) => {
      if (v.tag === "Cons") {
        if (v._2.tag === "Nil") {
          return $Either("Right", $Tuple(unit2, _trace(v._1, (v$1) => v._1)));
        }
        return $Either("Left", "Single value expected");
      }
      return $Either("Left", "Single value expected");
    },
    op_bwd: (dictAnn) => (v) => unsafePerformEffect(throwException(error("unimplemented")))
  });
  var primitives = /* @__PURE__ */ (() => fromFoldable2(foldableArray)([
    $Tuple(":", $Val("Fun", $Fun("PartialConstr", unit2, ":", Nil))),
    $Tuple("ceiling", unary({ i: number5, o: $$int, fwd: ceil2 })),
    $Tuple("debugLog", $Val("Fun", $Fun("Foreign", debugLog, Nil))),
    $Tuple("dims", $Val("Fun", $Fun("Foreign", dims, Nil))),
    $Tuple("error", $Val("Fun", $Fun("Foreign", error_, Nil))),
    $Tuple("floor", unary({ i: number5, o: $$int, fwd: floor2 })),
    $Tuple("log", unary({ i: intOrNumber, o: number5, fwd: log3 })),
    $Tuple("numToStr", unary({ i: intOrNumber, o: string2, fwd: numToStr })),
    $Tuple(
      "+",
      binary({
        i1: intOrNumber,
        i2: intOrNumber,
        o: intOrNumber,
        fwd: union4(asIntIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)(intAdd)(numAdd)
      })
    ),
    $Tuple(
      "-",
      binary({
        i1: intOrNumber,
        i2: intOrNumber,
        o: intOrNumber,
        fwd: union4(asIntIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)(intSub)(numSub)
      })
    ),
    $Tuple(
      "*",
      binaryZero({ isZero: fanin2(isZeroInt.isZero)(isZeroNumber.isZero) })({
        i: intOrNumber,
        o: intOrNumber,
        fwd: union4(asIntIntOrNumber)(asNumberIntOrNumber)(asIntNumber)(asIntNumber)(intMul)(numMul)
      })
    ),
    $Tuple(
      "**",
      binaryZero({ isZero: fanin2(isZeroInt.isZero)(isZeroNumber.isZero) })({ i: intOrNumber, o: intOrNumber, fwd: pow3 })
    ),
    $Tuple(
      "/",
      binaryZero({ isZero: fanin2(isZeroInt.isZero)(isZeroNumber.isZero) })({ i: intOrNumber, o: intOrNumber, fwd: divide })
    ),
    $Tuple(
      "==",
      binary({
        i1: intOrNumberOrString,
        i2: intOrNumberOrString,
        o: $$boolean,
        fwd: union4(asBooleanBoolean)(asBooleanBoolean)(asIntNumberOrString)(asIntNumberOrString)(eqIntImpl)(unionStr(asBooleanBoolean)(asNumberString)(eqNumberImpl)(eqStringImpl))
      })
    ),
    $Tuple("/=", binary({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: notEquals })),
    $Tuple("<", binary({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: lessThan })),
    $Tuple(">", binary({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: greaterThan })),
    $Tuple("<=", binary({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: lessThanEquals })),
    $Tuple(">=", binary({ i1: intOrNumberOrString, i2: intOrNumberOrString, o: $$boolean, fwd: greaterThanEquals })),
    $Tuple("++", binary({ i1: string2, i2: string2, o: string2, fwd: concatString })),
    $Tuple("!", $Val("Fun", $Fun("Foreign", matrixLookup, Nil))),
    $Tuple("dict_difference", $Val("Fun", $Fun("Foreign", dict_difference, Nil))),
    $Tuple("dict_disjointUnion", $Val("Fun", $Fun("Foreign", dict_disjointUnion, Nil))),
    $Tuple("dict_foldl", $Val("Fun", $Fun("Foreign", dict_foldl, Nil))),
    $Tuple("dict_fromRecord", $Val("Fun", $Fun("Foreign", dict_fromRecord, Nil))),
    $Tuple("dict_get", $Val("Fun", $Fun("Foreign", dict_get, Nil))),
    $Tuple("dict_intersectionWith", $Val("Fun", $Fun("Foreign", dict_intersectionWith, Nil))),
    $Tuple("dict_map", $Val("Fun", $Fun("Foreign", dict_map, Nil))),
    $Tuple("div", binaryZero(isZeroInt)({ i: $$int, o: $$int, fwd: intDiv })),
    $Tuple("mod", binaryZero(isZeroInt)({ i: $$int, o: $$int, fwd: intMod })),
    $Tuple("quot", binaryZero(isZeroInt)({ i: $$int, o: $$int, fwd: quot })),
    $Tuple("rem", binaryZero(isZeroInt)({ i: $$int, o: $$int, fwd: rem }))
  ]))();

  // output-es/Module/index.js
  var identity24 = (x2) => x2;
  var monadStateT = {
    Applicative0: () => applicativeStateT(monadAff),
    Bind1: () => bindStateT(monadAff)
  };
  var monadStateT1 = { Applicative0: () => applicativeStateT(monadStateT), Bind1: () => bindStateT(monadStateT) };
  var bind1 = /* @__PURE__ */ (() => bindExceptT(monadStateT1).bind)();
  var lift = /* @__PURE__ */ (() => monadTransExceptT.lift(monadStateT1))();
  var lift2 = /* @__PURE__ */ (() => monadTransStateT.lift(monadStateT))();
  var lift3 = /* @__PURE__ */ (() => monadTransStateT.lift(monadAff))();
  var except = /* @__PURE__ */ (() => {
    const $0 = applicativeStateT(monadStateT);
    return (x2) => $0.pure(x2);
  })();
  var traverseModule2 = /* @__PURE__ */ traverseModule({
    Applicative0: () => applicativeExceptT(monadStateT1),
    Bind1: () => bindExceptT(monadStateT1)
  });
  var fresh = /* @__PURE__ */ (() => monadGraphAllocWithGraphA(monadAff)(monadGraphWithGraphAllocT(monadAff)).fresh)();
  var eval_module3 = /* @__PURE__ */ eval_module2(monadAff);
  var runWithGraphAllocT2 = /* @__PURE__ */ runWithGraphAllocT(monadAff);
  var alloc2 = /* @__PURE__ */ alloc(monadAff);
  var alloc1 = /* @__PURE__ */ alloc2(traversableExpr);
  var $$eval3 = /* @__PURE__ */ $$eval2(monadAff);
  var applicativeExceptT2 = /* @__PURE__ */ applicativeExceptT(monadStateT1);
  var traverse6 = /* @__PURE__ */ (() => {
    const $0 = traversableWithIndexObject.traverseWithIndex(applicativeExceptT2);
    return (x2) => $0((v) => x2);
  })();
  var alloc22 = /* @__PURE__ */ alloc2(traversableVal);
  var parse = (src) => {
    const $1 = runParserT1(src);
    return (x2) => bifunctorEither.bimap(showParseError.show)(identity24)($1(x2));
  };
  var loadFile = (v) => (v1) => _bind(request(driver)({
    method: $Either("Left", GET),
    url: "./" + (v + ("/" + (v1 + ".fld"))),
    headers: [],
    content: Nothing,
    username: Nothing,
    password: Nothing,
    withCredentials: false,
    responseFormat: $ResponseFormat("String", identity21),
    timeout: Nothing
  }))((result) => {
    if (result.tag === "Left") {
      return unsafePerformEffect(throwException(error(printError(result._1))));
    }
    if (result.tag === "Right") {
      return _pure(result._1.body);
    }
    fail();
  });
  var loadModule = (dictSet) => {
    const eval_module1 = eval_module3(dictSet);
    return (file) => (\u03B3) => bind1(lift(lift2(lift3(loadFile("fluid/lib")(file)))))((src) => bind1(bind1(except(bindEither.bind(parse(src)(module_))(desugarModuleFwd(joinSemilatticeUnit))))(traverseModule2((v) => fresh)))((mod) => functorStateT(functorStateT(functorAff)).map((m) => {
      if (m.tag === "Left") {
        return $Either("Left", m._1);
      }
      if (m.tag === "Right") {
        return $Either("Right", unionWith2((v) => identity19)(\u03B3)(m._1));
      }
      fail();
    })(eval_module1(\u03B3)(mod)(dictSet.empty))));
  };
  var parseProgram = (folder) => (file) => _bind(loadFile(folder)(file))((src) => _pure(successful(parse(src)((state1, more, lift1, $$throw, done) => more((v1) => topLevel(expr_)(
    state1,
    more,
    lift1,
    $$throw,
    (state2, a) => more((v2) => done(state2, functorExpr2.map((v) => unit2)(a)))
  ))))));
  var openDatasetAs = (dictGraph) => {
    const runWithGraphAllocT1 = runWithGraphAllocT2(dictGraph);
    const Set1 = dictGraph.Set1();
    const eval1 = $$eval3(Set1);
    return (file) => (x2) => (v) => _bind(parseProgram("fluid")(file))((s) => _bind(_map(successful)(runWithGraphAllocT1($Tuple(v.g, v.n))(bind1(alloc1(successful(exprFwd(joinSemilatticeUnit)(s))))((e\u03B1) => bind1(eval1(v["\u03B3"])(e\u03B1)(Set1.empty))((v\u03B1) => applicativeExceptT2.pure($Tuple(
      v["\u03B3"],
      runST(bind_(newImpl)(poke3(x2)(v\u03B1)))
    )))))))((v1) => _pure($Tuple({ g: v1._1._1, n: v1._1._2, "\u03B3": v1._2._1 }, v1._2._2))));
  };
  var defaultImports = (dictSet) => {
    const loadModule1 = loadModule(dictSet);
    return bind1(traverse6(alloc22)(primitives))((\u03B3\u03B1) => bind1(bind1(loadModule1("prelude")(\u03B3\u03B1))(loadModule1("graphics")))(loadModule1("convolution")));
  };
  var openDefaultImports = (dictGraph) => _bind(_map(successful)(runWithGraphAllocT2(dictGraph)($Tuple(dictGraph.empty, 0))(defaultImports(dictGraph.Set1()))))((v) => _pure({
    g: v._1._1,
    n: v._1._2,
    "\u03B3": v._2
  }));

  // output-es/Web.Event.EventTarget/foreign.js
  function eventListener(fn) {
    return function() {
      return function(event2) {
        return fn(event2)();
      };
    };
  }

  // output-es/App.Fig/index.js
  var $View = (tag, _1) => ({ tag, _1 });
  var matrixRep3 = /* @__PURE__ */ matrixRep(annBoolean);
  var sequence3 = /* @__PURE__ */ (() => traversableArray.traverse(applicativeEither)(identity10))();
  var eval_module4 = /* @__PURE__ */ eval_module(annBoolean);
  var graphGraphImpl2 = /* @__PURE__ */ graphGraphImpl(/* @__PURE__ */ setSet(ordVertex));
  var openDefaultImports2 = /* @__PURE__ */ openDefaultImports(graphGraphImpl2);
  var openDatasetAs2 = /* @__PURE__ */ openDatasetAs(graphGraphImpl2);
  var botOf = /* @__PURE__ */ (() => functorVal.map((v) => false))();
  var $$eval4 = /* @__PURE__ */ $$eval(annBoolean);
  var evalBwd2 = /* @__PURE__ */ evalBwd(annBoolean);
  var erase2 = /* @__PURE__ */ (() => functorVal.map((v) => unit2))();
  var joinSemilatticeVal2 = /* @__PURE__ */ joinSemilatticeVal(joinSemilatticeBoolean);
  var neg4 = /* @__PURE__ */ (() => joinSemilatticeDict(joinSemilatticeVal2).neg)();
  var sequence_ = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray)(identity8);
  var length5 = /* @__PURE__ */ foldlArray((c) => (v) => 1 + c | 0)(0);
  var identity25 = (x2) => x2;
  var view = (v) => (v1) => {
    if (v1.tag === "Constr") {
      if (v1._3.tag === "Cons") {
        if (v1._3._2.tag === "Nil") {
          if (v1._2 === "BarChart") {
            return $View("BarChartFig", reflectDictValBooleanBarC1.from()(record1.match(v1._3._1)._1));
          }
          if (v1._2 === "LineChart") {
            return $View("LineChartFig", reflectDictValBooleanLine1.from()(record1.match(v1._3._1)._1));
          }
          if (v1._2 === "Nil" || v1._2 === ":") {
            return $View("EnergyTableView", { title: v, table: arrayMap(record2(energyRecord))(reflectArray.from()(v1)) });
          }
          return unsafePerformEffect(throwException(error("absurd")));
        }
        if (v1._2 === "Nil" || v1._2 === ":") {
          return $View("EnergyTableView", { title: v, table: arrayMap(record2(energyRecord))(reflectArray.from()(v1)) });
        }
        return unsafePerformEffect(throwException(error("absurd")));
      }
      if (v1._2 === "Nil" || v1._2 === ":") {
        return $View("EnergyTableView", { title: v, table: arrayMap(record2(energyRecord))(reflectArray.from()(v1)) });
      }
      return unsafePerformEffect(throwException(error("absurd")));
    }
    if (v1.tag === "Matrix") {
      return $View("MatrixFig", { title: v, matrix: matrixRep2(matrixRep3.match(v1)._1) });
    }
    return unsafePerformEffect(throwException(error("absurd")));
  };
  var varView = (x2) => (\u03B3) => {
    const $2 = _lookup(Nothing, Just, x2, \u03B3);
    if ($2.tag === "Nothing") {
      return $Either("Left", "absurd");
    }
    if ($2.tag === "Just") {
      return $Either("Right", view(x2)($2._1));
    }
    fail();
  };
  var splitDefs = (\u03B30) => (s$p) => {
    if (s$p.tag === "LetRec") {
      return bindEither.bind(bindEither.bind(moduleFwd(joinSemilatticeBoolean)($Module2($List(
        "Cons",
        $Either("Right", s$p._1),
        Nil
      ))))((() => {
        const $2 = eval_module4(\u03B30);
        return (a) => $2(a)(false);
      })()))((\u03B3) => $Either("Right", { "\u03B3": \u03B3, s: s$p._2 }));
    }
    if (s$p.tag === "Let") {
      return bindEither.bind(bindEither.bind(moduleFwd(joinSemilatticeBoolean)($Module2($List(
        "Cons",
        $Either("Left", s$p._1),
        Nil
      ))))((() => {
        const $2 = eval_module4(\u03B30);
        return (a) => $2(a)(false);
      })()))((\u03B3) => $Either("Right", { "\u03B3": \u03B3, s: s$p._2 }));
    }
    fail();
  };
  var loadLinkFig = (v) => {
    const $1 = "linking/" + v.file1;
    const $2 = "linking/" + v.file2;
    return _bind(_bind(openDefaultImports2)(openDatasetAs2("example/linking/" + v.dataFile)(v.x)))((v2) => _bind(applyAff.apply(_map(Tuple)(parseProgram("fluid/example")($1)))(parseProgram("fluid/example")($2)))((v3) => {
      const \u03B30 = _fmapObject(v2._1["\u03B3"], botOf);
      const xv0 = _fmapObject(v2._2, botOf);
      const s2 = functorExpr2.map((v$1) => false)(v3._2);
      const s1 = functorExpr2.map((v$1) => false)(v3._1);
      return _pure(successful(bindEither.bind(applyEither.apply((() => {
        const $9 = exprFwd(joinSemilatticeBoolean)(s1);
        if ($9.tag === "Left") {
          return $Either("Left", $9._1);
        }
        if ($9.tag === "Right") {
          return $Either("Right", Tuple($9._1));
        }
        fail();
      })())(exprFwd(joinSemilatticeBoolean)(s2)))((v4) => bindEither.bind($$eval4(unionWith2((v$1) => identity19)(\u03B30)(xv0))(v4._1)(false))((v5) => bindEither.bind($$eval4(unionWith2((v$1) => identity19)(\u03B30)(xv0))(v4._2)(false))((v6) => bindEither.bind((() => {
        const $12 = _lookup(Nothing, Just, v.x, xv0);
        if ($12.tag === "Nothing") {
          return $Either("Left", "absurd");
        }
        if ($12.tag === "Just") {
          return $Either("Right", $12._1);
        }
        fail();
      })())((v0) => $Either("Right", { spec: v, "\u03B30": \u03B30, "\u03B3": xv0, s1, s2, e1: v4._1, e2: v4._2, t1: v5._1, t2: v6._1, v1: v5._2, v2: v6._2, v0 })))))));
    }));
  };
  var loadFig = (v) => _bind(_bind(openDefaultImports2)(openDatasetAs2("example/linking/renewables")("data")))((v1) => {
    const \u03B30 = _fmapObject(v1._1["\u03B3"], botOf);
    const xv0 = _fmapObject(v1._2, botOf);
    return _map((s$p) => successful(bindEither.bind(splitDefs(unionWith2((v$1) => identity19)(\u03B30)(xv0))(functorExpr2.map((v$1) => false)(s$p)))((v2) => bindEither.bind(exprFwd(joinSemilatticeBoolean)(v2.s))((e) => bindEither.bind($$eval4(unionWith2((v$1) => identity19)(unionWith2((v$1) => identity19)(\u03B30)(xv0))(v2["\u03B3"]))(e)(false))((v3) => $Either("Right", { spec: v, "\u03B30": \u03B30, "\u03B3": unionWith2((v$1) => identity19)(\u03B30)(v2["\u03B3"]), s: v2.s, e, t: v3._1, v: v3._2 }))))))(parseProgram("fluid/example")(v.file));
  });
  var linkResult = (x2) => (\u03B30) => (\u03B3) => (e1) => (e22) => (t1) => (v) => (v1) => {
    const $8 = append_inv($Map("Two", Leaf2, x2, unit2, Leaf2))(evalBwd2(_fmapObject(
      unionWith2((v$1) => identity19)(\u03B30)(\u03B3),
      erase2
    ))(functorExpr.map((v$1) => unit2)(e1))(v1)(t1)["\u03B3"])._2;
    return bindEither.bind((() => {
      const $9 = _lookup(Nothing, Just, x2, $8);
      if ($9.tag === "Nothing") {
        return $Either("Left", "absurd");
      }
      if ($9.tag === "Just") {
        return $Either("Right", $9._1);
      }
      fail();
    })())((v0$p) => bindEither.bind($$eval4(neg4(unionWith2((v$1) => identity19)(_fmapObject(\u03B30, botOf))($8)))(functorExpr.map((x$1) => true)(e22))(true))((v4) => $Either(
      "Right",
      { "v'": joinSemilatticeVal2.neg(v4._2), "v0'": v0$p }
    )));
  };
  var figViews = (v) => (\u03B4v) => {
    const v2 = evalBwd2(_fmapObject(unionWith2((v$1) => identity19)(v["\u03B30"])(v["\u03B3"]), erase2))(functorExpr.map((v$1) => unit2)(v.e))(\u03B4v(v.v))(v.t);
    return bindEither.bind($$eval4(v2["\u03B3"])(v2.e)(v2["\u03B1"]))((v3) => bindEither.bind(sequence3(arrayMap((a) => varView(a)(v2["\u03B3"]))(v.spec.xs)))((views) => $Either(
      "Right",
      $Tuple(view("output")(v3._2), views)
    )));
  };
  var drawView = (v) => (v1) => (v2) => (v3) => {
    if (v3.tag === "MatrixFig") {
      return bindE(eventListener((x2) => v1(matrixViewHandler(x2))))(drawMatrix(v)(v2)(v3._1));
    }
    if (v3.tag === "EnergyTableView") {
      return bindE(eventListener((x2) => v1((x$1) => x$1)))(drawTable(v)(v2)(v3._1));
    }
    if (v3.tag === "LineChartFig") {
      return bindE(eventListener((x2) => v1(lineChartHandler(x2))))(drawLineChart(v)(v2)(v3._1));
    }
    if (v3.tag === "BarChartFig") {
      return bindE(eventListener((x2) => v1(barChartHandler(x2))))(drawBarChart(v)(v2)(v3._1));
    }
    fail();
  };
  var drawFig = (v) => (\u03B4v) => {
    const $2 = log2("Redrawing " + v.spec.divId);
    return () => {
      $2();
      const v1 = successful(figViews(v)(\u03B4v));
      sequence_(arrayMap((v$1) => drawView(v.spec.divId)(doNothing)(v$1._1)(v$1._2))(zip(range2(0)(length5(v1._2) - 1 | 0))(v1._2)))();
      return drawView(v.spec.divId)((selector) => drawFig(v)((x2) => selector(\u03B4v(x2))))(length5(v1._2))(v1._1)();
    };
  };
  var drawCode = (ed) => (s) => {
    const $2 = update(ed.state)([{ changes: { from: 0, to: 0, insert: s } }]);
    return () => {
      const tr = $2();
      return dispatch2(ed)(tr)();
    };
  };
  var drawLinkFig = (v) => (ed) => (\u03B4v) => {
    const $3 = log2("Redrawing " + v.spec.divId);
    return () => {
      $3();
      const v3 = successful((() => {
        if (\u03B4v.tag === "Left") {
          const v1$p = \u03B4v._1(v.v1);
          return bindEither.bind(linkResult(v.spec.x)(v["\u03B30"])(v["\u03B3"])(v.e1)(v.e2)(v.t1)(v.t2)(v1$p))((v4) => $Either(
            "Right",
            $Tuple(v1$p, $Tuple(v4["v'"], $Tuple((v$1) => v1$p, $Tuple(identity25, v4["v0'"]))))
          ));
        }
        if (\u03B4v.tag === "Right") {
          const v2$p = \u03B4v._1(v.v2);
          return bindEither.bind(linkResult(v.spec.x)(v["\u03B30"])(v["\u03B3"])(v.e2)(v.e1)(v.t2)(v.t1)(v2$p))((v4) => $Either(
            "Right",
            $Tuple(v4["v'"], $Tuple(v2$p, $Tuple(identity25, $Tuple((v$1) => v2$p, v4["v0'"]))))
          ));
        }
        fail();
      })());
      drawView(v.spec.divId)((selector) => drawLinkFig(v)(ed)($Either("Left", (x2) => selector(v3._2._2._1(x2)))))(2)(view("left view")(v3._1))();
      drawView(v.spec.divId)((selector) => drawLinkFig(v)(ed)($Either("Right", (x2) => selector(v3._2._2._2._1(x2)))))(0)(view("right view")(v3._2._1))();
      drawView(v.spec.divId)(doNothing)(1)(view("common data")(v3._2._2._2._2))();
      return drawCode(ed)(intercalate4("\n")(prettyExpr(highlightableBoolean).pretty(v.e1).lines))();
    };
  };

  // output-es/App.Main/index.js
  var sequence4 = /* @__PURE__ */ (() => traversableArray.traverse(applicativeAff)(identity10))();
  var sequence_2 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray)(identity8);
  var botOf2 = /* @__PURE__ */ (() => functorVal.map((v) => false))();
  var linkingFig1 = { divId: "fig-1", file1: "bar-chart", file2: "line-chart", dataFile: "renewables", x: "data" };
  var fig2 = { divId: "fig-conv-2", file: "slicing/convolution/emboss-wrap", xs: ["image", "filter"] };
  var fig1 = { divId: "fig-conv-1", file: "slicing/convolution/emboss", xs: ["image", "filter"] };
  var drawLinkFigs = (loadFigs) => {
    const $1 = runAff((v) => {
      if (v.tag === "Left") {
        return log2(showErrorImpl(v._1));
      }
      if (v.tag === "Right") {
        const $2 = addEditorView("codemirror-expt");
        return () => {
          const ed = $2();
          return sequence_2(arrayMap((fig) => drawLinkFig(fig)(ed)($Either("Left", botOf2)))(v._1))();
        };
      }
      fail();
    })(sequence4(loadFigs));
    return () => {
      $1();
      return unit2;
    };
  };
  var drawFigs = (loadFigs) => {
    const $1 = runAff((v) => {
      if (v.tag === "Left") {
        return log2(showErrorImpl(v._1));
      }
      if (v.tag === "Right") {
        return sequence_2(arrayMap((a) => drawFig(a)(botOf2))(v._1));
      }
      fail();
    })(sequence4(loadFigs));
    return () => {
      $1();
      return unit2;
    };
  };
  var main = /* @__PURE__ */ (() => {
    const $0 = drawFigs([loadFig(fig1), loadFig(fig2)]);
    return () => {
      $0();
      return drawLinkFigs([loadLinkFig(linkingFig1)])();
    };
  })();

  // <stdin>
  main();
})();
