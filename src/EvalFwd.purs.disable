module EvalFwd where

import Prelude hiding (absurd)
import Data.Array (fromFoldable) as A
import Data.List (List(..), (:), length, range, singleton, zip)
import Data.Profunctor.Strong ((***), (&&&), first, second)
import Bindings (Bindings, (â†¦), find, key, val)
import Expl (Expl(..), Match(..), VarDef(..)) as T
import Expl (Expl, Match)
import Expr (Cont, Elim(..), Expr(..), RecDefs, VarDef(..), asElim, asExpr)
import Lattice (ğ”¹, (âˆ§))
import Primitive (match_fwd) as P
import Util (type (Ã—), (Ã—), (!), absurd, assert, error, mustLookup, successful)
import Util.SnocList (SnocList(..), (:-))
import Util.SnocList (unzip, zip, zipWith) as S
import Val (Env, PrimOp(..), Val)
import Val (Val(..)) as V

matchFwd :: Val ğ”¹ -> Elim ğ”¹ -> Match ğ”¹ -> Env ğ”¹ Ã— Cont ğ”¹ Ã— ğ”¹
matchFwd v (ElimVar _ Îº) (T.MatchVar x) = (Lin :- x â†¦ v) Ã— Îº Ã— true
matchFwd _ (ElimVar _ Îº) (T.MatchVarAnon _) = Lin Ã— Îº Ã— true
matchFwd (V.Constr Î± _ vs) (ElimConstr m) (T.MatchConstr c ws _) =
   second (_ âˆ§ Î±) (matchArgsFwd vs (mustLookup c m) ws)
matchFwd (V.Record Î± xvs) (ElimRecord _ Îº) (T.MatchRecord xws) =
   second (_ âˆ§ Î±) (matchRecordFwd xvs Îº xws)
matchFwd _ _ _ = error absurd

matchArgsFwd :: List (Val ğ”¹) -> Cont ğ”¹ -> List (Match ğ”¹) -> Env ğ”¹ Ã— Cont ğ”¹ Ã— ğ”¹
matchArgsFwd Nil Îº Nil = Lin Ã— Îº Ã— true
matchArgsFwd (v : vs) Ïƒ (w : ws) =
   let Ï Ã— Îº Ã— Î± = matchFwd v (asElim Ïƒ) w in
   (first (Ï <> _) *** (_ âˆ§ Î±)) (matchArgsFwd vs Îº ws)
matchArgsFwd _ _ _ = error absurd

matchRecordFwd :: Bindings (Val ğ”¹) -> Cont ğ”¹ -> Bindings (Match ğ”¹) -> Env ğ”¹ Ã— Cont ğ”¹ Ã— ğ”¹
matchRecordFwd Lin Îº Lin = Lin Ã— Îº Ã— true
matchRecordFwd (xvs :- x â†¦ v) Ïƒ (xws :- x' â†¦ w) | x == x' =
   let Ï Ã— Ïƒ' Ã— Î± = matchRecordFwd xvs Ïƒ xws in
   (first (Ï <> _) *** (_ âˆ§ Î±)) (matchFwd v (asElim Ïƒ') w)
matchRecordFwd _ _ _ = error absurd

closeDefsFwd :: Env ğ”¹ -> RecDefs ğ”¹ -> ğ”¹ -> RecDefs ğ”¹ -> Env ğ”¹
closeDefsFwd _ _ _ Lin = Lin
closeDefsFwd Ï Î´0 Î± (Î´ :- f â†¦ Ïƒ) = closeDefsFwd Ï Î´0 Î± Î´ :- f â†¦ V.Closure Ï Î´0 Î± Ïƒ

evalFwd :: Env ğ”¹ -> Expr ğ”¹ -> ğ”¹ -> Expl ğ”¹ -> Val ğ”¹
evalFwd Ï (Var _) _ (T.Var _ x) = successful (find x Ï)
evalFwd Ï (Op _) _ (T.Op _ op) = successful (find op Ï)
evalFwd _ (Int Î± _) Î±' (T.Int _ n) = V.Int (Î± âˆ§ Î±') n
evalFwd _ (Float Î± _) Î±' (T.Float _ n) = V.Float (Î± âˆ§ Î±') n
evalFwd _ (Str Î± _) Î±' (T.Str _ str) = V.Str (Î± âˆ§ Î±') str
evalFwd Ï (Record Î± xes) Î±' (T.Record _ xts) =
   let xs Ã— ts = xts <#> (key &&& val) # S.unzip
       es = xes <#> val
       vs = (\(e' Ã— t) -> evalFwd Ï e' Î±' t) <$> S.zip es ts in
   V.Record (Î± âˆ§ Î±') (S.zipWith (â†¦) xs vs)
evalFwd Ï (Constr Î± _ es) Î±' (T.Constr _ c ts) =
   V.Constr (Î± âˆ§ Î±') c ((\(e' Ã— t) -> evalFwd Ï e' Î±' t) <$> zip es ts)
evalFwd Ï (Matrix Î± e1 _ e2) Î±' (T.Matrix tss (x Ã— y) (i' Ã— j') t2) =
   case evalFwd Ï e2 Î±' t2 of
      V.Constr _ _ (v1 : v2 : Nil) ->
         let (i'' Ã— Î²) Ã— (j'' Ã— Î²') = P.match_fwd v1 Ã— P.match_fwd v2
             vss = assert (i'' == i' && j'' == j') $ A.fromFoldable $ do
                i <- range 1 i'
                singleton $ A.fromFoldable $ do
                   j <- range 1 j'
                   singleton (evalFwd (Ï :- x â†¦ V.Int Î² i :- y â†¦ V.Int Î²' j) e1 Î±' (tss!(i - 1)!(j - 1)))
         in V.Matrix (Î± âˆ§ Î±') (vss Ã— (i' Ã— Î²) Ã— (j' Ã— Î²'))
      _ -> error absurd
evalFwd Ï (LetRec Î´ e') Î± (T.LetRec _ t) =
   let Ï' = closeDefsFwd Ï Î´ Î± Î´ in
   evalFwd (Ï <> Ï') e' Î± t
evalFwd Ï (Lambda Ïƒ) Î± (T.Lambda _ _) = V.Closure Ï Lin Î± Ïƒ
evalFwd Ï (RecordLookup e' _) Î± (T.RecordLookup t xs x) =
   case evalFwd Ï e' Î± t of
      V.Record _ xvs -> assert ((xvs <#> key) == xs) $ successful (find x xvs)
      _ -> error absurd
evalFwd Ï (App e1 e2) Î± (T.App (t1 Ã— _ Ã— _) t2 w t3) =
   case evalFwd Ï e1 Î± t1 of
      V.Closure Ï1 Î´ Î² Ïƒ' ->
         let v = evalFwd Ï e2 Î± t2
             Ï2 = closeDefsFwd Ï1 Î´ Î² Î´
             Ï3 Ã— e3 Ã— Î²' = matchFwd v Ïƒ' w in
         evalFwd (Ï1 <> Ï2 <> Ï3) (asExpr e3) (Î² âˆ§ Î²') t3
      _ -> error absurd
evalFwd Ï (App e1 e2) Î± (T.AppPrim (t1 Ã— PrimOp Ï† Ã— _) (t2 Ã— _)) =
   case evalFwd Ï e1 Î± t1 of
      V.Primitive _ vs' ->
         let v2' = evalFwd Ï e2 Î± t2
             vs'' = vs' <> singleton v2' in
         if Ï†.arity > length vs'' then V.Primitive (PrimOp Ï†) vs'' else Ï†.op_fwd vs''
      _ -> error absurd
evalFwd Ï (App e1 e2) Î± (T.AppConstr (t1 Ã— c Ã— _) t2) =
   case evalFwd Ï e1 Î± t1 of
      V.Constr Î±' _ vs' ->
         let v = evalFwd Ï e2 Î± t2 in
         V.Constr (Î± âˆ§ Î±') c (vs' <> singleton v)
      _ -> error absurd
evalFwd Ï (Let (VarDef Ïƒ e1) e2) Î± (T.Let (T.VarDef w t1) t2) =
   let v = evalFwd Ï e1 Î± t1
       Ï' Ã— _ Ã— Î±' = matchFwd v Ïƒ w in
   evalFwd (Ï <> Ï') e2 Î±' t2
evalFwd _ _ _ _ = error absurd
