<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Fluid: Data-Transparent Visualisation</title>
  <script src="https://use.fontawesome.com/1091715d00.js"></script>
  <link href="css/styles.css" rel="stylesheet" type="text/css">
  <link href="css/simplegrid.css" rel="stylesheet" type="text/css">
  <link href="css/data-viz.css" rel="stylesheet" type="text/css">
  <script src="app.js"></script>
</head>
<body>

<div class="grid grid-pad">
   <div class="col-3-12 align-right">
      <img src="https://i.ytimg.com/vi/IjS2sVPR2Zc/maxresdefault.jpg" width="80%">
      <img src="https://i.ibb.co/zNqHKg7/University-of-Bristol-logo.png" width="80%">
   </div>
   <div class="col-9-12">
      <nav>
         <ul>
            <li>
               <a href="." class="active-page">Latest</a>
            </li>
            <li>
            <a href="https://f.luid.org/0.3.1">v0.3.1</a>
            </li>
         </ul>
      </nav><br>
      <p><a href="https://github.com/explorable-viz/fluid">GitHub</a> &#183;
      <a href="https://dl.acm.org/doi/10.1145/3498668">POPL 2022 paper</a> &#183;
      <a href="https://www.youtube.com/watch?v=M_ePrtD9axk">POPL talk</a>
      <h2>Fluid: language-integrated data provenance</h2>
   </div>
</div>

<div id="FLUID" class="grid grid-pad">
   <div class="col-3-12 align-right">
      <h3 class="title lowercase">fluid</h3>
   </div>
   <div class="col-9-12">
      <p>Understanding charts, diagrams and other visual information means understanding what visual elements <i>represent</i>: how specific visual elements relate to the data they were computed from. <b>Fluid</b> is an experimental programming language, implemented in <a href="https://www.purescript.org/">PureScript</a>, which integrates a bidirectional dynamic analysis into its runtime. A Fluid program is a plain ol' functional program, but instead of producing a plain ol' value, it produces a value equipped with an account of how parts of the output are connected to data sources in a fine-grained way. We can use that information to provide additional UI affordances automatically, so user can those explores those connections without the programmer having had to anticipate that need in advance. For example if the user selects a bar in a bar chart computed from a table of data, we can automatically provide a view of the underlying table containing only the data needed to compute the selected bar.
   </div>

   <div class="col-3-12 align-right">
      <h3 class="title lowercase">data-linked visualisations</h3>
   </div>
   <div class="col-9-12">
      <p></p>Try the data linking by selecting (clicking on) the bar for Germany in the left-hand chart below. When a view selection is active, we can automatically generate what we call a <b>data selection</b>: a restricted view of a dataset where only relevant rows are shown and relevant cells within those rows are highlighted. Now try selecting some of the data points for the years 2017 and 2018 in the right-hand chart. (Zoom in if it's hard to select the points.) The relationship between the output selection and the resulting input selection is <i>monotonic</i>: the more output you select, the more input is selected. (The UI doesn't support this yet, but it is also meaningful to select input and have the output selection be derived automatically.)

      <p><div class="parent"><div class="center" id="fig-1"></div></div></p>

      <p>Hand-crafting transparency features like these would involve manually tracking the dependencies between input and output. Fluid does this automatically, allowing the programmer to simply express the bar chart and line chart as pure functions, using standard functional programming features such as higher-order functions and list comprehensions. Take a look at the source code below:
         <details><summary>bar-chart.fld</summary>
            <script src="https://gist.github.com/rolyp/7d4c2240e6a588d9b3844c025b7db920.js"></script>
         </details>
         <details><summary>line-chart.fld</summary>
            <script src="https://gist.github.com/rolyp/a2bed1325ef0ace335d8fa0fd304acd5.js"></script>
         </details>
         <details><summary>dataset.fld</summary>
            <script src="https://gist.github.com/rolyp/367c33ce1c61eea77fe3dc37eb690f2c.js"></script>
         </details>
      <p>The mathematics of the bidirectional analysis is described by a <b>Galois connection</b>. This establishes that the forward and backward parts of the analysis are <i>adjoint</i>, meaning that they round-trip in a certain way: the data selection computed by the backwards analysis for a given view selection, if fed into the forward analysis, will suffice for (at least) the original view selection. Similarly, the view selection computed by the forwards analysis, if fed into the backwards analysis, will require (no more than) the original data selection. (&#8220;Require no more, promise no less&#8221; is an apt slogan.) See our <a href="https://dl.acm.org/doi/10.1145/3498668">paper</a> for more on the formal setting.
   </div>

   <div class="col-3-12 align-right">
      <h4 class="title lowercase">brushing and linking</h4>
   </div>
   <div class="col-9-12">
      <p>Because every selection has a complement, these Galois connections have a De Morgan dual. The dual is <i>contravariant</i>: it inverts the direction of the bidirectional dependency analysis, by transposing the roles of the adjoint analyses. Why invert something that is already bidirectional? Well, the De Morgan dual also changes the meaning of the analyses: under the dual interpretation, the backwards analysis propagates the absence of demand, rather than demand, and the forwards analysis propagates resource unavailability, rather than availability.

      <p>It turns out we can use this to link output selections to the related parts of other outputs generated from the same input. In data visualisation, this feature is called <b>brushing and linking</b>. Go back to the example above and select the bar for USA or China in the left-hand chart: all points relating to 2015 will be selected selected on the right. These are the parts of the right-hand chart which &#8220;compete for resources&#8221; with the selection on the left, the sense that they demand data which intersects in a non-empty way with the data demanded by the original selection. We compute the selection on the right not with the backwards analysis (which points in the wrong direction) nor with the forwards analysis (which computes the sufficiency relation), but instead with the De Morgan dual of the forwards analysis. This determines the output on the right that we <i>wouldn't</i> be able to compute if the data demanded by the selection on the left were <i>unavailable</i>: in other words, what the data selection is <i>necessary</i> for, rather than what it is <i>sufficient</i> for. You can play this game in the other direction by selecting any point from 2015 on the right, which will highlight both USA and China on the left: again, because these bars both consume data which is also needed for the original point. (We could making this clearer in the UI by showing the data selection induced by USA and China, perhaps greyed out, and highlighting how it overlaps with the data needed by the original point.)

      <p>Brushing and linking is a common feature in data visualisation, but existing approaches are ad hoc and somewhat limited. Building brushing and linking into a language has the potential to make it pervasive and robust. Moreover, we can always provide a view of the specific data elements which explain <i>why</i> the two visual elements are linked, providing another level of transparency.
   </div>

   <div class="col-3-12 align-right">
      <h3 class="title lowercase">infrastructure for <br>explorable explanations</h3>
   </div>
   <div class="col-9-12">
      <p>Another future application is language infrastructure for <i>explorable explanations</i>, interactive web essays that explains challenging technical ideas. How might programming languages make it easier to create explorable explanations? One idea would be to provide a fully open runtime which allows a user to drill down into a computed artefact such as an image, and explore the relationships between the stages of the computational pipeline using interactions like the ones above.

      <p>Consider the following implementation of <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution">matrix convolution</a>, an image processing technique which transforms an input matrix using a small matrix called a filter (or a kernel) to apply effects like blurring or embossing. Trying selecting different cells in the output (the matrix on right) to see how they demand cells in the input array and filter:

      <p><div class="parent"><div class="center" id="fig-conv-1"></div></div>

      <p>In particular, notice how only certain parts of the input are relevant. Can some of the irrelevant input cells be attributed to zeros in the filter? Also notice how the demand varies as we approach the edge of the output image: because this implementation of convolution treats the input as though it were padded with zeros at the boundary, parts of the filter are irrelevant to the computation of output cells near the edge. (As mentioned above, it is not yet possible to select input elements and have the output selection be derived automatically.)

      This could be made more useful if we could show the actual computation involved, but even this simple extensional view already reveals interesting things about the implementation. Here is the pure functional code here:

      <details><summary>convolution.fld</summary>
         <script src="https://gist.github.com/rolyp/64b04a6a6fc73164d7fbbd1b82365b67.js"></script>
      </details>
      <details><summary>emboss-zero-pad.fld</summary>
         <script src="https://gist.github.com/rolyp/8fc7054973476fdcbbc5f1e0b854913d.js"></script>
      </details>

      <p>Contrast the above with an implementation which uses <code>wrap</code> rather than <code>zero</code> as the boundary method. Here, selecting an output cell near the edge has a quite different behaviour: instead of some of the filter elements becoming irrelevant, we can see visually that the input image behaves as though opposite sides were connected. By making the input-output relationships &#8220;fine-grained&#8221; rather than monolithic, we can gain quite a lot insight into what the computation actually does.
      <p><div class="parent"><div class="center" id="fig-conv-2"></div></div>
      <details><summary>emboss-wrap.fld</summary>
         <script src="https://gist.github.com/rolyp/2bd783007d919d97e64ba66a6ede8c3a.js"></script>
      </details>
   </div>
</div>

</body>
</html>
