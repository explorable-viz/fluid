(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/0.3.1/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Lib.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/dist/tippy.css":
/*!************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/dist/tippy.css ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".tippy-tooltip[data-animation=fade][data-state=hidden]{opacity:0}.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{pointer-events:none;max-width:calc(100vw - 10px);transition-timing-function:cubic-bezier(.165,.84,.44,1);transition-property:transform}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;background-color:#333;transition-property:visibility,opacity,transform;outline:0}.tippy-tooltip[data-placement^=top]>.tippy-arrow{border-width:8px 8px 0;border-top-color:#333;margin:0 3px;transform-origin:50% 0;bottom:-7px}.tippy-tooltip[data-placement^=bottom]>.tippy-arrow{border-width:0 8px 8px;border-bottom-color:#333;margin:0 3px;transform-origin:50% 7px;top:-7px}.tippy-tooltip[data-placement^=left]>.tippy-arrow{border-width:8px 0 8px 8px;border-left-color:#333;margin:3px 0;transform-origin:0 50%;right:-7px}.tippy-tooltip[data-placement^=right]>.tippy-arrow{border-width:8px 8px 8px 0;border-right-color:#333;margin:3px 0;transform-origin:7px 50%;left:-7px}.tippy-tooltip[data-interactive][data-state=visible]{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{position:absolute;border-color:transparent;border-style:solid}.tippy-content{padding:5px 9px}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/themes/light-border.css":
/*!*********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/themes/light-border.css ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".tippy-tooltip.light-border-theme{background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,8,16,.15);color:#26323d;box-shadow:0 4px 14px -2px rgba(0,8,16,.08)}.tippy-tooltip.light-border-theme>.tippy-backdrop{background-color:#fff}.tippy-tooltip.light-border-theme>.tippy-arrow:after,.tippy-tooltip.light-border-theme>.tippy-arrow:before,.tippy-tooltip.light-border-theme>.tippy-svg-arrow:after,.tippy-tooltip.light-border-theme>.tippy-svg-arrow:before{content:\"\";position:absolute;z-index:-1}.tippy-tooltip.light-border-theme>.tippy-svg-arrow{fill:#fff}.tippy-tooltip.light-border-theme>.tippy-svg-arrow:after{background-image:url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNDE0IiB2aWV3Qm94PSIwIDAgMTggNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMCA3czIuMDIxLS4wMTUgNS4yNTMtNC4yMThDNi41ODQgMS4wNTEgNy43OTcuMDA3IDkgMGMxLjIwMy0uMDA3IDIuNDE2IDEuMDM1IDMuNzYxIDIuNzgyQzE2LjAxMiA3LjAwNSAxOCA3IDE4IDd6IiBmaWxsPSIjMzMzIiBmaWxsLW9wYWNpdHk9Ii4yMzUiIGZpbGwtcnVsZT0ibm9uemVybyIvPjwvc3ZnPg==);background-size:18px 7px;width:18px;height:7px;left:0;top:0;fill:rgba(0,8,16,.15)}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-svg-arrow:after{top:1px;transform:rotate(180deg)}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow{border-top-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:after{border-top:7px solid #fff;top:-7px}.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:before{border-top:7px solid rgba(0,8,16,.2);bottom:-1px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-svg-arrow:after{top:-1px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow{border-bottom-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:after{border-bottom:7px solid #fff;bottom:-7px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:before{border-bottom:7px solid rgba(0,8,16,.2);bottom:-6px}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-svg-arrow:after{left:1px;top:0;transform:rotate(90deg)}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow{border-left-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:after{border-left:7px solid #fff;left:-7px}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:before{border-left:7px solid rgba(0,8,16,.2);left:-6px}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-svg-arrow:after{left:-1px;top:0;transform:rotate(-90deg)}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow{border-right-color:#fff}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:after{border-right:7px solid #fff;right:-7px}.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:before{border-right:7px solid rgba(0,8,16,.2);right:-6px}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-svg-arrow,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-svg-arrow{transform:translateX(-1px)}.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=bottom]>.tippy-arrow:before,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=top]>.tippy-arrow:before{left:-7px;border-left:7px solid transparent;border-right:7px solid transparent}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-svg-arrow,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-svg-arrow{transform:translateY(-1px)}.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=left]>.tippy-arrow:before,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:after,.tippy-tooltip.light-border-theme[data-placement^=right]>.tippy-arrow:before{top:-7px;border-top:7px solid transparent;border-bottom:7px solid transparent}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/app/styles.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/app/styles.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(/*! ./inconsolata-webfont.woff */ "./src/app/inconsolata-webfont.woff");
var ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(/*! ./Slabo13px-Regular.woff */ "./src/app/Slabo13px-Regular.woff");
var ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(/*! ./AvenirLTStd-Book.woff */ "./src/app/AvenirLTStd-Book.woff");
exports = ___CSS_LOADER_API_IMPORT___(false);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);
// Module
exports.push([module.i, "@font-face {\n   font-family: \"inconsolata\";\n   font-style: normal;\n   font-weight: 400;\n   src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") format('woff');\n}\n\n@font-face {\n   font-family: \"Slabo 13px\";\n   font-style: normal;\n   font-weight: 400;\n   src: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") format('woff');\n}\n\n@font-face {\n   font-family: \"AvenirLTStd-Book\";\n   font-style: normal;\n   font-weight: 400;\n   src: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") format('woff');\n}\n\n.code {\n   font-family: \"inconsolata\";\n   stroke: none;\n}\n\n.label {\n   font-family: \"AvenirLTStd-Book\";\n   stroke: none;\n}\n\n.unchanged {\n   fill: black;\n}\n\n.changed {\n   fill: blue;\n}\n\n.new {\n   fill: limegreen;\n}\n\n.tippy-tooltip {\n   font-family: \"inconsolata\";\n}\n\n.tippy-tooltip.light-border-theme {\n   font-size: 9pt;\n}\n\n.focus {\n   stroke: black;\n   stroke-opacity: 0.1;\n   fill-opacity: 0.7;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/moo/moo.js":
/*!*********************************!*\
  !*** ./node_modules/moo/moo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) /* global define */
  } else {}
}(this, function() {
  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty
  var toString = Object.prototype.toString
  var hasSticky = typeof new RegExp().sticky === 'boolean'

  /***************************************************************************/

  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }
  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }

  function reEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
  }
  function reGroups(s) {
    var re = new RegExp('|' + s)
    return re.exec('').length - 1
  }
  function reCapture(s) {
    return '(' + s + ')'
  }
  function reUnion(regexps) {
    if (!regexps.length) return '(?!)'
    var source =  regexps.map(function(s) {
      return "(?:" + s + ")"
    }).join('|')
    return "(?:" + source + ")"
  }

  function regexpOrLiteral(obj) {
    if (typeof obj === 'string') {
      return '(?:' + reEscape(obj) + ')'

    } else if (isRegExp(obj)) {
      // TODO: consider /u support
      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')
      if (obj.global) throw new Error('RegExp /g flag is implied')
      if (obj.sticky) throw new Error('RegExp /y flag is implied')
      if (obj.multiline) throw new Error('RegExp /m flag is implied')
      return obj.source

    } else {
      throw new Error('Not a pattern: ' + obj)
    }
  }

  function objectToRules(object) {
    var keys = Object.getOwnPropertyNames(object)
    var result = []
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      var thing = object[key]
      var rules = [].concat(thing)
      if (key === 'include') {
        for (var j = 0; j < rules.length; j++) {
          result.push({include: rules[j]})
        }
        continue
      }
      var match = []
      rules.forEach(function(rule) {
        if (isObject(rule)) {
          if (match.length) result.push(ruleOptions(key, match))
          result.push(ruleOptions(key, rule))
          match = []
        } else {
          match.push(rule)
        }
      })
      if (match.length) result.push(ruleOptions(key, match))
    }
    return result
  }

  function arrayToRules(array) {
    var result = []
    for (var i = 0; i < array.length; i++) {
      var obj = array[i]
      if (obj.include) {
        var include = [].concat(obj.include)
        for (var j = 0; j < include.length; j++) {
          result.push({include: include[j]})
        }
        continue
      }
      if (!obj.type) {
        throw new Error('Rule has no type: ' + JSON.stringify(obj))
      }
      result.push(ruleOptions(obj.type, obj))
    }
    return result
  }

  function ruleOptions(type, obj) {
    if (!isObject(obj)) {
      obj = { match: obj }
    }
    if (obj.include) {
      throw new Error('Matching rules cannot also include states')
    }

    // nb. error and fallback imply lineBreaks
    var options = {
      defaultType: type,
      lineBreaks: !!obj.error || !!obj.fallback,
      pop: false,
      next: null,
      push: null,
      error: false,
      fallback: false,
      value: null,
      type: null,
      shouldThrow: false,
    }

    // Avoid Object.assign(), so we support IE9+
    for (var key in obj) {
      if (hasOwnProperty.call(obj, key)) {
        options[key] = obj[key]
      }
    }

    // type transform cannot be a string
    if (typeof options.type === 'string' && type !== options.type) {
      throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')")
    }

    // convert to array
    var match = options.match
    options.match = Array.isArray(match) ? match : match ? [match] : []
    options.match.sort(function(a, b) {
      return isRegExp(a) && isRegExp(b) ? 0
           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length
    })
    return options
  }

  function toRules(spec) {
    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)
  }

  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})
  function compileRules(rules, hasStates) {
    var errorRule = null
    var fast = Object.create(null)
    var fastAllowed = true
    var unicodeFlag = null
    var groups = []
    var parts = []

    // If there is a fallback rule, then disable fast matching
    for (var i = 0; i < rules.length; i++) {
      if (rules[i].fallback) {
        fastAllowed = false
      }
    }

    for (var i = 0; i < rules.length; i++) {
      var options = rules[i]

      if (options.include) {
        // all valid inclusions are removed by states() preprocessor
        throw new Error('Inheritance is not allowed in stateless lexers')
      }

      if (options.error || options.fallback) {
        // errorRule can only be set once
        if (errorRule) {
          if (!options.fallback === !errorRule.fallback) {
            throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')")
          } else {
            throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')")
          }
        }
        errorRule = options
      }

      var match = options.match.slice()
      if (fastAllowed) {
        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {
          var word = match.shift()
          fast[word.charCodeAt(0)] = options
        }
      }

      // Warn about inappropriate state-switching options
      if (options.pop || options.push || options.next) {
        if (!hasStates) {
          throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')")
        }
        if (options.fallback) {
          throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')")
        }
      }

      // Only rules with a .match are included in the RegExp
      if (match.length === 0) {
        continue
      }
      fastAllowed = false

      groups.push(options)

      // Check unicode flag is used everywhere or nowhere
      for (var j = 0; j < match.length; j++) {
        var obj = match[j]
        if (!isRegExp(obj)) {
          continue
        }

        if (unicodeFlag === null) {
          unicodeFlag = obj.unicode
        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
          throw new Error('If one rule is /u then all must be')
        }
      }

      // convert to RegExp
      var pat = reUnion(match.map(regexpOrLiteral))

      // validate
      var regexp = new RegExp(pat)
      if (regexp.test("")) {
        throw new Error("RegExp matches empty string: " + regexp)
      }
      var groupCount = reGroups(pat)
      if (groupCount > 0) {
        throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: … ) instead")
      }

      // try and detect rules matching newlines
      if (!options.lineBreaks && regexp.test('\n')) {
        throw new Error('Rule should declare lineBreaks: ' + regexp)
      }

      // store regex
      parts.push(reCapture(pat))
    }


    // If there's no fallback rule, use the sticky flag so we only look for
    // matches at the current index.
    //
    // If we don't support the sticky flag, then fake it using an irrefutable
    // match (i.e. an empty pattern).
    var fallbackRule = errorRule && errorRule.fallback
    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'
    var suffix = hasSticky || fallbackRule ? '' : '|'

    if (unicodeFlag === true) flags += "u"
    var combined = new RegExp(reUnion(parts) + suffix, flags)
    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}
  }

  function compile(rules) {
    var result = compileRules(toRules(rules))
    return new Lexer({start: result}, 'start')
  }

  function checkStateGroup(g, name, map) {
    var state = g && (g.push || g.next)
    if (state && !map[state]) {
      throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')")
    }
    if (g && g.pop && +g.pop !== 1) {
      throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')")
    }
  }
  function compileStates(states, start) {
    var all = states.$all ? toRules(states.$all) : []
    delete states.$all

    var keys = Object.getOwnPropertyNames(states)
    if (!start) start = keys[0]

    var ruleMap = Object.create(null)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      ruleMap[key] = toRules(states[key]).concat(all)
    }
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      var rules = ruleMap[key]
      var included = Object.create(null)
      for (var j = 0; j < rules.length; j++) {
        var rule = rules[j]
        if (!rule.include) continue
        var splice = [j, 1]
        if (rule.include !== key && !included[rule.include]) {
          included[rule.include] = true
          var newRules = ruleMap[rule.include]
          if (!newRules) {
            throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')")
          }
          for (var k = 0; k < newRules.length; k++) {
            var newRule = newRules[k]
            if (rules.indexOf(newRule) !== -1) continue
            splice.push(newRule)
          }
        }
        rules.splice.apply(rules, splice)
        j--
      }
    }

    var map = Object.create(null)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      map[key] = compileRules(ruleMap[key], true)
    }

    for (var i = 0; i < keys.length; i++) {
      var name = keys[i]
      var state = map[name]
      var groups = state.groups
      for (var j = 0; j < groups.length; j++) {
        checkStateGroup(groups[j], name, map)
      }
      var fastKeys = Object.getOwnPropertyNames(state.fast)
      for (var j = 0; j < fastKeys.length; j++) {
        checkStateGroup(state.fast[fastKeys[j]], name, map)
      }
    }

    return new Lexer(map, start)
  }

  function keywordTransform(map) {
    var reverseMap = Object.create(null)
    var byLength = Object.create(null)
    var types = Object.getOwnPropertyNames(map)
    for (var i = 0; i < types.length; i++) {
      var tokenType = types[i]
      var item = map[tokenType]
      var keywordList = Array.isArray(item) ? item : [item]
      keywordList.forEach(function(keyword) {
        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)
        if (typeof keyword !== 'string') {
          throw new Error("keyword must be string (in keyword '" + tokenType + "')")
        }
        reverseMap[keyword] = tokenType
      })
    }

    // fast string lookup
    // https://jsperf.com/string-lookups
    function str(x) { return JSON.stringify(x) }
    var source = ''
    source += 'switch (value.length) {\n'
    for (var length in byLength) {
      var keywords = byLength[length]
      source += 'case ' + length + ':\n'
      source += 'switch (value) {\n'
      keywords.forEach(function(keyword) {
        var tokenType = reverseMap[keyword]
        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\n'
      })
      source += '}\n'
    }
    source += '}\n'
    return Function('value', source) // type
  }

  /***************************************************************************/

  var Lexer = function(states, state) {
    this.startState = state
    this.states = states
    this.buffer = ''
    this.stack = []
    this.reset()
  }

  Lexer.prototype.reset = function(data, info) {
    this.buffer = data || ''
    this.index = 0
    this.line = info ? info.line : 1
    this.col = info ? info.col : 1
    this.queuedToken = info ? info.queuedToken : null
    this.queuedThrow = info ? info.queuedThrow : null
    this.setState(info ? info.state : this.startState)
    this.stack = info && info.stack ? info.stack.slice() : []
    return this
  }

  Lexer.prototype.save = function() {
    return {
      line: this.line,
      col: this.col,
      state: this.state,
      stack: this.stack.slice(),
      queuedToken: this.queuedToken,
      queuedThrow: this.queuedThrow,
    }
  }

  Lexer.prototype.setState = function(state) {
    if (!state || this.state === state) return
    this.state = state
    var info = this.states[state]
    this.groups = info.groups
    this.error = info.error
    this.re = info.regexp
    this.fast = info.fast
  }

  Lexer.prototype.popState = function() {
    this.setState(this.stack.pop())
  }

  Lexer.prototype.pushState = function(state) {
    this.stack.push(this.state)
    this.setState(state)
  }

  var eat = hasSticky ? function(re, buffer) { // assume re is /y
    return re.exec(buffer)
  } : function(re, buffer) { // assume re is /g
    var match = re.exec(buffer)
    // will always match, since we used the |(?:) trick
    if (match[0].length === 0) {
      return null
    }
    return match
  }

  Lexer.prototype._getGroup = function(match) {
    var groupCount = this.groups.length
    for (var i = 0; i < groupCount; i++) {
      if (match[i + 1] !== undefined) {
        return this.groups[i]
      }
    }
    throw new Error('Cannot find token type for matched text')
  }

  function tokenToString() {
    return this.value
  }

  Lexer.prototype.next = function() {
    var index = this.index

    // If a fallback token matched, we don't need to re-run the RegExp
    if (this.queuedGroup) {
      var token = this._token(this.queuedGroup, this.queuedText, index)
      this.queuedGroup = null
      this.queuedText = ""
      return token
    }

    var buffer = this.buffer
    if (index === buffer.length) {
      return // EOF
    }

    // Fast matching for single characters
    var group = this.fast[buffer.charCodeAt(index)]
    if (group) {
      return this._token(group, buffer.charAt(index), index)
    }

    // Execute RegExp
    var re = this.re
    re.lastIndex = index
    var match = eat(re, buffer)

    // Error tokens match the remaining buffer
    var error = this.error
    if (match == null) {
      return this._token(error, buffer.slice(index, buffer.length), index)
    }

    var group = this._getGroup(match)
    var text = match[0]

    if (error.fallback && match.index !== index) {
      this.queuedGroup = group
      this.queuedText = text

      // Fallback tokens contain the unmatched portion of the buffer
      return this._token(error, buffer.slice(index, match.index), index)
    }

    return this._token(group, text, index)
  }

  Lexer.prototype._token = function(group, text, offset) {
    // count line breaks
    var lineBreaks = 0
    if (group.lineBreaks) {
      var matchNL = /\n/g
      var nl = 1
      if (text === '\n') {
        lineBreaks = 1
      } else {
        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }
      }
    }

    var token = {
      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,
      value: typeof group.value === 'function' ? group.value(text) : text,
      text: text,
      toString: tokenToString,
      offset: offset,
      lineBreaks: lineBreaks,
      line: this.line,
      col: this.col,
    }
    // nb. adding more props to token object will make V8 sad!

    var size = text.length
    this.index += size
    this.line += lineBreaks
    if (lineBreaks !== 0) {
      this.col = size - nl + 1
    } else {
      this.col += size
    }

    // throw, if no rule with {error: true}
    if (group.shouldThrow) {
      throw new Error(this.formatError(token, "invalid syntax"))
    }

    if (group.pop) this.popState()
    else if (group.push) this.pushState(group.push)
    else if (group.next) this.setState(group.next)

    return token
  }

  if (typeof Symbol !== 'undefined' && Symbol.iterator) {
    var LexerIterator = function(lexer) {
      this.lexer = lexer
    }

    LexerIterator.prototype.next = function() {
      var token = this.lexer.next()
      return {value: token, done: !token}
    }

    LexerIterator.prototype[Symbol.iterator] = function() {
      return this
    }

    Lexer.prototype[Symbol.iterator] = function() {
      return new LexerIterator(this)
    }
  }

  Lexer.prototype.formatError = function(token, message) {
    if (token == null) {
      // An undefined token indicates EOF
      var text = this.buffer.slice(this.index)
      var token = {
        text: text,
        offset: this.index,
        lineBreaks: text.indexOf('\n') === -1 ? 0 : 1,
        line: this.line,
        col: this.col,
      }
    }
    var start = Math.max(0, token.offset - token.col + 1)
    var eol = token.lineBreaks ? token.text.indexOf('\n') : token.text.length
    var firstLine = this.buffer.substring(start, token.offset + eol)
    message += " at line " + token.line + " col " + token.col + ":\n\n"
    message += "  " + firstLine + "\n"
    message += "  " + Array(token.col).join(" ") + "^"
    return message
  }

  Lexer.prototype.clone = function() {
    return new Lexer(this.states, this.state)
  }

  Lexer.prototype.has = function(tokenType) {
    return true
  }


  return {
    compile: compile,
    states: compileStates,
    error: Object.freeze({error: true}),
    fallback: Object.freeze({fallback: true}),
    keywords: keywordTransform,
  }

}));


/***/ }),

/***/ "./node_modules/nearley/lib/nearley.js":
/*!*********************************************!*\
  !*** ./node_modules/nearley/lib/nearley.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(root, factory) {
    if ( true && module.exports) {
        module.exports = factory();
    } else {
        root.nearley = factory();
    }
}(this, function() {

    function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;        // a list of literal | regex class | nonterminal
        this.postprocess = postprocess;
        return this;
    }
    Rule.highestId = 0;

    Rule.prototype.toString = function(withCursorAt) {
        function stringifySymbolSequence (e) {
            return e.literal ? JSON.stringify(e.literal) :
                   e.type ? '%' + e.type : e.toString();
        }
        var symbolSequence = (typeof withCursorAt === "undefined")
                             ? this.symbols.map(stringifySymbolSequence).join(' ')
                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')
                                 + " ● "
                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );
        return this.name + " → " + symbolSequence;
    }


    // a State is a rule at a position from a given starting point in the input stream (reference)
    function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
    }

    State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    };

    State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
            state.data = state.build();
        }
        return state;
    };

    State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
            children.push(node.right.data);
            node = node.left;
        } while (node.left);
        children.reverse();
        return children;
    };

    State.prototype.finish = function() {
        if (this.rule.postprocess) {
            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
    };


    function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {}; // states indexed by the non-terminal they expect
        this.scannable = []; // list of states that expect a token
        this.completed = {}; // states that are nullable
    }


    Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;

        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration
            var state = states[w];

            if (state.isComplete) {
                state.finish();
                if (state.data !== Parser.fail) {
                    // complete
                    var wantedBy = state.wantedBy;
                    for (var i = wantedBy.length; i--; ) { // this line is hot
                        var left = wantedBy[i];
                        this.complete(left, state);
                    }

                    // special-case nullables
                    if (state.reference === this.index) {
                        // make sure future predictors of this rule get completed.
                        var exp = state.rule.name;
                        (this.completed[exp] = this.completed[exp] || []).push(state);
                    }
                }

            } else {
                // queue scannable states
                var exp = state.rule.symbols[state.dot];
                if (typeof exp !== 'string') {
                    this.scannable.push(state);
                    continue;
                }

                // predict
                if (wants[exp]) {
                    wants[exp].push(state);

                    if (completed.hasOwnProperty(exp)) {
                        var nulls = completed[exp];
                        for (var i = 0; i < nulls.length; i++) {
                            var right = nulls[i];
                            this.complete(state, right);
                        }
                    }
                } else {
                    wants[exp] = [state];
                    this.predict(exp);
                }
            }
        }
    }

    Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];

        for (var i = 0; i < rules.length; i++) {
            var r = rules[i];
            var wantedBy = this.wants[exp];
            var s = new State(r, 0, this.index, wantedBy);
            this.states.push(s);
        }
    }

    Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
    }


    function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
            if (!byName.hasOwnProperty(rule.name)) {
                byName[rule.name] = [];
            }
            byName[rule.name].push(rule);
        });
    }

    // So we can allow passing (rules, start) directly to Parser for backwards compatibility
    Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });
        var g = new Grammar(rules, start);
        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable
        return g;
    }


    function StreamLexer() {
      this.reset("");
    }

    StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
    }

    StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
            var ch = this.buffer[this.index++];
            if (ch === '\n') {
              this.line += 1;
              this.lastLineBreak = this.index;
            }
            return {value: ch};
        }
    }

    StreamLexer.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak,
      }
    }

    StreamLexer.prototype.formatError = function(token, message) {
        // nb. this gets called after consuming the offending token,
        // so the culprit is index-1
        var buffer = this.buffer;
        if (typeof buffer === 'string') {
            var nextLineBreak = buffer.indexOf('\n', this.index);
            if (nextLineBreak === -1) nextLineBreak = buffer.length;
            var line = buffer.substring(this.lastLineBreak, nextLineBreak)
            var col = this.index - this.lastLineBreak;
            message += " at line " + this.line + " col " + col + ":\n\n";
            message += "  " + line + "\n"
            message += "  " + Array(col).join(" ") + "^"
            return message;
        } else {
            return message + " at index " + (this.index - 1);
        }
    }


    function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
            var grammar = rules;
            var options = start;
        } else {
            var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;

        // Read options
        this.options = {
            keepHistory: false,
            lexer: grammar.lexer || new StreamLexer,
        };
        for (var key in (options || {})) {
            this.options[key] = options[key];
        }

        // Setup lexer
        this.lexer = this.options.lexer;
        this.lexerState = undefined;

        // Setup a table
        var column = new Column(grammar, 0);
        var table = this.table = [column];

        // I could be expecting anything.
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        // TODO what if start rule is nullable?
        column.process();
        this.current = 0; // token index
    }

    // create a reserved token for indicating a parse fail
    Parser.fail = {};

    Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);

        var token;
        while (token = lexer.next()) {
            // We add new states to table[current+1]
            var column = this.table[this.current];

            // GC unused states
            if (!this.options.keepHistory) {
                delete this.table[this.current - 1];
            }

            var n = this.current + 1;
            var nextColumn = new Column(this.grammar, n);
            this.table.push(nextColumn);

            // Advance all tokens that expect the symbol
            var literal = token.text !== undefined ? token.text : token.value;
            var value = lexer.constructor === StreamLexer ? token.value : token;
            var scannable = column.scannable;
            for (var w = scannable.length; w--; ) {
                var state = scannable[w];
                var expect = state.rule.symbols[state.dot];
                // Try to consume the token
                // either regex or literal
                if (expect.test ? expect.test(value) :
                    expect.type ? expect.type === token.type
                                : expect.literal === literal) {
                    // Add it
                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});
                    nextColumn.states.push(next);
                }
            }

            // Next, for each of the rules, we either
            // (a) complete it, and try to see if the reference row expected that
            //     rule
            // (b) predict the next nonterminal it expects by adding that
            //     nonterminal's start state
            // To prevent duplication, we also keep track of rules we have already
            // added

            nextColumn.process();

            // If needed, throw an error:
            if (nextColumn.states.length === 0) {
                // No states at all! This is not good.
                var err = new Error(this.reportError(token));
                err.offset = this.current;
                err.token = token;
                throw err;
            }

            // maybe save lexer state
            if (this.options.keepHistory) {
              column.lexerState = lexer.save()
            }

            this.current++;
        }
        if (column) {
          this.lexerState = lexer.save()
        }

        // Incrementally keep track of results
        this.results = this.finish();

        // Allow chaining, for whatever it's worth
        return this;
    };

    Parser.prototype.reportError = function(token) {
        var lines = [];
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);
        lines.push(this.lexer.formatError(token, "Syntax error"));
        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\n');
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states
            .filter(function(state) {
                var nextSymbol = state.rule.symbols[state.dot];
                return nextSymbol && typeof nextSymbol !== "string";
            });

        // Display a "state stack" for each expectant state
        // - which shows you how this state came to be, step by step.
        // If there is more than one derivation, we only display the first one.
        var stateStacks = expectantStates
            .map(function(state) {
                return this.buildFirstStateStack(state, []);
            }, this);
        // Display each state that is expecting a terminal symbol next.
        stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push('A ' + symbolDisplay + ' based on:');
            this.displayStateStack(stateStack, lines);
        }, this);

        lines.push("");
        return lines.join("\n");
    };

    Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
            var state = stateStack[j];
            var display = state.rule.toString(state.dot);
            if (display === lastDisplay) {
                sameDisplayCount++;
            } else {
                if (sameDisplayCount > 0) {
                    lines.push('    ⬆ ︎' + sameDisplayCount + ' more lines identical to this');
                }
                sameDisplayCount = 0;
                lines.push('    ' + display);
            }
            lastDisplay = display;
        }
    };

    Parser.prototype.getSymbolDisplay = function(symbol) {
        var type = typeof symbol;
        if (type === "string") {
            return symbol;
        } else if (type === "object" && symbol.literal) {
            return JSON.stringify(symbol.literal);
        } else if (type === "object" && symbol instanceof RegExp) {
            return 'character matching ' + symbol;
        } else if (type === "object" && symbol.type) {
            return symbol.type + ' token';
        } else {
            throw new Error('Unknown symbol type: ' + symbol);
        }
    };

    /*
    Builds a the first state stack. You can think of a state stack as the call stack
    of the recursive-descent parser which the Nearley parse algorithm simulates.
    A state stack is represented as an array of state objects. Within a
    state stack, the first item of the array will be the starting
    state, with each successive item in the array going further back into history.

    This function needs to be given a starting state and an empty array representing
    the visited states, and it returns an single state stack.

    */
    Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
            // Found cycle, return null
            // to eliminate this path from the results, because
            // we don't know how to display it meaningfully
            return null;
        }
        if (state.wantedBy.length === 0) {
            return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
            return null;
        }
        return [state].concat(childResult);
    };

    Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
    };

    Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;

        // Incrementally keep track of results
        this.results = this.finish();
    };

    // nb. deprecated: use save/restore instead!
    Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
            throw new Error('set option `keepHistory` to enable rewinding')
        }
        // nb. recall column (table) indicies fall between token indicies.
        //        col 0   --   token 0   --   col 1
        this.restore(this.table[index]);
    };

    Parser.prototype.finish = function() {
        // Return the possible parsings
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1]
        column.states.forEach(function (t) {
            if (t.rule.name === start
                    && t.dot === t.rule.symbols.length
                    && t.reference === 0
                    && t.data !== Parser.fail) {
                considerations.push(t);
            }
        });
        return considerations.map(function(c) {return c.data; });
    };

    return {
        Parser: Parser,
        Grammar: Grammar,
        Rule: Rule,
    };

}));


/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.chunk.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.chunk.esm.js ***!
  \*******************************************************/
/*! exports provided: B, R, _, a, b, c, d, e, f, g, h, i, j, k, l, m, n, r, s, t, u, w */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return BACKDROP_CLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return ROUND_ARROW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_", function() { return _extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isMouseEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return currentInput; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return errorWhen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return closestCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getOwnerDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getBasePlacement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return arrayFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return hideAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return createTippyWithPlugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return normalizeToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return removeProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return setVisibilityState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return tippy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return useIfDefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return warnWhen; });
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/**!
* tippy.js v5.2.1
* (c) 2017-2020 atomiks
* MIT License
*/


function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var version = "5.2.1";

/**
 * Triggers reflow
 */
function reflow(element) {
  void element.offsetHeight;
}
/**
 * Sets the innerHTML of an element
 */

function setInnerHTML(element, html) {
  element[innerHTML()] = html;
}
/**
 * Determines if the value is a reference element
 */

function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
/**
 * Returns an array of elements based on the value
 */

function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
/**
 * Returns a value at a given index depending on if it's an array or number
 */

function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */

function getModifier(obj, key) {
  return obj && obj.modifiers && obj.modifiers[key];
}
/**
 * Determines if the value is of type
 */

function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
/**
 * Determines if the value is of type Element
 */

function isElement(value) {
  return isType(value, 'Element');
}
/**
 * Determines if the value is of type NodeList
 */

function isNodeList(value) {
  return isType(value, 'NodeList');
}
/**
 * Determines if the value is of type MouseEvent
 */

function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick
 * it
 */

function innerHTML() {
  return 'innerHTML';
}
/**
 * Evaluates a function if one, or returns the value
 */

function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
/**
 * Sets a popperInstance modifier's property to a value
 */

function setModifierValue(modifiers, name, property, value) {
  modifiers.filter(function (m) {
    return m.name === name;
  })[0][property] = value;
}
/**
 * Returns a new `div` element
 */

function div() {
  return document.createElement('div');
}
/**
 * Applies a transition duration to a list of elements
 */

function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
/**
 * Sets the visibility state to elements so they can begin to transition
 */

function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */

function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
/**
 * Preserves the original function invocation when another function replaces it
 */

function preserveInvocation(originalFn, currentFn, args) {
  if (originalFn && originalFn !== currentFn) {
    originalFn.apply(void 0, args);
  }
}
/**
 * Deletes properties from an object (pure)
 */

function removeProperties(obj, keys) {
  var clone = _extends({}, obj);

  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */

function arrayFrom(value) {
  return [].slice.call(value);
}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */

function closestCallback(element, callback) {
  while (element) {
    if (callback(element)) {
      return element;
    }

    element = element.parentElement;
  }

  return null;
}
/**
 * Determines if an array or string includes a string
 */

function includes(a, b) {
  return a.indexOf(b) > -1;
}
/**
 * Creates an array from string of values separated by whitespace
 */

function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
/**
 * Returns the `nextValue` if `nextValue` is not `undefined`, otherwise returns
 * `currentValue`
 */

function useIfDefined(nextValue, currentValue) {
  return nextValue !== undefined ? nextValue : currentValue;
}
/**
 * Converts a value that's an array or single value to an array
 */

function normalizeToArray(value) {
  return [].concat(value);
}
/**
 * Returns the ownerDocument of the first available element, otherwise global
 * document
 */

function getOwnerDocument(elementOrElements) {
  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0];

  return element ? element.ownerDocument || document : document;
}
/**
 * Adds item to array if array does not contain it
 */

function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
/**
 * Adds `px` if value is a number, or returns it directly
 */

function appendPxIfNumber(value) {
  return typeof value === 'number' ? value + "px" : value;
}
/**
 * Filters out duplicate elements in an array
 */

function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
/**
 * Returns number from number or CSS units string
 */

function getNumber(value) {
  return typeof value === 'number' ? value : parseFloat(value);
}
/**
 * Gets number or CSS string units in pixels (e.g. `1rem` -> 16)
 */

function getUnitsInPx(doc, value) {
  var isRem = typeof value === 'string' && includes(value, 'rem');
  var html = doc.documentElement;
  var rootFontSize = 16;

  if (html && isRem) {
    return parseFloat(getComputedStyle(html).fontSize || String(rootFontSize)) * getNumber(value);
  }

  return getNumber(value);
}
/**
 * Adds the `distancePx` value to the placement of a Popper.Padding object
 */

function getComputedPadding(basePlacement, padding, distancePx) {
  if (padding === void 0) {
    padding = 5;
  }

  var freshPaddingObject = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  var keys = Object.keys(freshPaddingObject);
  return keys.reduce(function (obj, key) {
    obj[key] = typeof padding === 'number' ? padding : padding[key];

    if (basePlacement === key) {
      obj[key] = typeof padding === 'number' ? padding + distancePx : padding[basePlacement] + distancePx;
    }

    return obj;
  }, freshPaddingObject);
}

function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return "\n    " + method + "() was called on a" + txt + "destroyed instance. This is a no-op but\n    indicates a potential memory leak.\n  ";
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}

function getFormattedMessage(message) {
  return [getDevMessage(message), // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
  'line-height: 1.5', // footer
  'color: #a6a095;'];
}
/**
 * Helpful wrapper around `console.warn()`.
 * TODO: Should we use a cache so it only warns a single time and not spam the
 * console? (Need to consider hot reloading and invalidation though). Chrome
 * already batches warnings as well.
 */

function warnWhen(condition, message) {
  if (condition) {
    var _console;

    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
/**
 * Helpful wrapper around `console.error()`
 */

function errorWhen(condition, message) {
  if (condition) {
    var _console2;

    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
/**
 * Validates the `targets` value passed to `tippy()`
 */

function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element, Element[],', 'or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is no longer supported as an argument.', 'See: https://atomiks.github.io/tippyjs/misc/#custom-position'].join(' '));
}

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var defaultProps = _extends({
  allowHTML: true,
  animation: 'fade',
  appendTo: function appendTo() {
    return document.body;
  },
  aria: 'describedby',
  arrow: true,
  boundary: 'scrollParent',
  content: '',
  delay: 0,
  distance: 10,
  duration: [300, 250],
  flip: true,
  flipBehavior: 'flip',
  flipOnUpdate: false,
  hideOnClick: true,
  ignoreAttributes: false,
  inertia: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  lazy: true,
  maxWidth: 350,
  multiple: false,
  offset: 0,
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  role: 'tooltip',
  showOnCreate: false,
  theme: '',
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null,
  updateDuration: 0,
  zIndex: 9999
}, pluginProps);
var defaultKeys = Object.keys(defaultProps);
/**
 * If the setProps() method encounters one of these, the popperInstance must be
 * recreated
 */

var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
/**
 * Mutates the defaultProps object by setting the props specified
 */

var setDefaultProps = function setDefaultProps(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
/**
 * Returns an extended props object including plugin props
 */

function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return _extends({}, passedProps, {}, pluginProps);
}
/**
 * Returns an object of optional props from data-tippy-* attributes
 */

function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(_extends({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
/**
 * Evaluates the props object by merging data attributes and disabling
 * conflicting props where necessary
 */

function evaluateProps(reference, props) {
  var out = _extends({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));

  if (out.interactive) {
    out.aria = null;
  }

  return out;
}
/**
 * Validates props with the valid `defaultProps` object
 */

function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var value = partialProps[prop];
    var didSpecifyPlacementInPopperOptions = prop === 'popperOptions' && value !== null && typeof value === 'object' && hasOwnProperty(value, 'placement');
    var nonPluginProps = removeProperties(defaultProps, ['animateFill', 'followCursor', 'inlinePositioning', 'sticky']); // These props have custom warnings

    var customWarningProps = ['a11y', 'arrowType', 'showOnInit', 'size', 'target', 'touchHold'];
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop) && !includes(customWarningProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }

    warnWhen(prop === 'target', ['The `target` prop was removed in v5 and replaced with the delegate() addon', 'in order to conserve bundle size.', 'See: https://atomiks.github.io/tippyjs/addons/#event-delegation'].join(' '));
    warnWhen(prop === 'a11y', ['The `a11y` prop was removed in v5. Make sure the element you are giving a', 'tippy to is natively focusable, such as <button> or <input>, not <div>', 'or <span>.'].join(' '));
    warnWhen(prop === 'showOnInit', 'The `showOnInit` prop was renamed to `showOnCreate` in v5.');
    warnWhen(prop === 'arrowType', ['The `arrowType` prop was removed in v5 in favor of overloading the `arrow`', 'prop.', '\n\n', '"round" string was replaced with importing the string from the package.', '\n\n', "* import {roundArrow} from 'tippy.js'; (ESM version)\n", '* const {roundArrow} = tippy; (IIFE CDN version)', '\n\n', 'Before: {arrow: true, arrowType: "round"}\n', 'After: {arrow: roundArrow}`'].join(' '));
    warnWhen(prop === 'touchHold', ['The `touchHold` prop was removed in v5 in favor of overloading the `touch`', 'prop.', '\n\n', 'Before: {touchHold: true}\n', 'After: {touch: "hold"}'].join(' '));
    warnWhen(prop === 'size', ['The `size` prop was removed in v5. Instead, use a theme that specifies', 'CSS padding and font-size properties.'].join(' '));
    warnWhen(prop === 'theme' && value === 'google', 'The included theme "google" was renamed to "material" in v5.');
    warnWhen(didSpecifyPlacementInPopperOptions, ['Specifying placement in `popperOptions` is not supported. Use the base-level', '`placement` prop instead.', '\n\n', 'Before: {popperOptions: {placement: "bottom"}}\n', 'After: {placement: "bottom"}'].join(' '));
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's a", 'plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'In v5, the following props were turned into plugins:', '\n\n', '* animateFill\n', '* followCursor\n', '* sticky', '\n\n', 'All props: https://atomiks.github.io/tippyjs/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/plugins/'].join(' '));
  });
}

var PASSIVE = {
  passive: true
};
var ROUND_ARROW = '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>';
var IOS_CLASS = "tippy-iOS";
var POPPER_CLASS = "tippy-popper";
var TOOLTIP_CLASS = "tippy-tooltip";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var POPPER_SELECTOR = "." + POPPER_CLASS;
var TOOLTIP_SELECTOR = "." + TOOLTIP_CLASS;
var CONTENT_SELECTOR = "." + CONTENT_CLASS;
var ARROW_SELECTOR = "." + ARROW_CLASS;
var SVG_ARROW_SELECTOR = "." + SVG_ARROW_CLASS;

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
/**
 * Adds the needed global event listeners
 */

function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, _extends({}, PASSIVE, {
    capture: true
  }));
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);
var isIOS = isBrowser && /iPhone|iPad|iPod/.test(navigator.platform);
function updateIOSClass(isAdd) {
  var shouldAdd = isAdd && isIOS && currentInput.isTouch;
  document.body.classList[shouldAdd ? 'add' : 'remove'](IOS_CLASS);
}

/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */

function getBasePlacement(placement) {
  return placement.split('-')[0];
}
/**
 * Adds `data-inertia` attribute
 */

function addInertia(tooltip) {
  tooltip.setAttribute('data-inertia', '');
}
/**
 * Removes `data-inertia` attribute
 */

function removeInertia(tooltip) {
  tooltip.removeAttribute('data-inertia');
}
/**
 * Adds interactive-related attributes
 */

function addInteractive(tooltip) {
  tooltip.setAttribute('data-interactive', '');
}
/**
 * Removes interactive-related attributes
 */

function removeInteractive(tooltip) {
  tooltip.removeAttribute('data-interactive');
}
/**
 * Sets the content of a tooltip
 */

function setContent(contentEl, props) {
  if (isElement(props.content)) {
    setInnerHTML(contentEl, '');
    contentEl.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    var key = props.allowHTML ? 'innerHTML' : 'textContent';
    contentEl[key] = props.content;
  }
}
/**
 * Returns the child elements of a popper element
 */

function getChildren(popper) {
  return {
    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
    content: popper.querySelector(CONTENT_SELECTOR),
    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(SVG_ARROW_SELECTOR)
  };
}
/**
 * Creates an arrow element and returns it
 */

function createArrowElement(arrow) {
  var arrowElement = div();

  if (arrow === true) {
    arrowElement.className = ARROW_CLASS;
  } else {
    arrowElement.className = SVG_ARROW_CLASS;

    if (isElement(arrow)) {
      arrowElement.appendChild(arrow);
    } else {
      setInnerHTML(arrowElement, arrow);
    }
  }

  return arrowElement;
}
/**
 * Constructs the popper element and returns it
 */

function createPopperElement(id, props) {
  var popper = div();
  popper.className = POPPER_CLASS;
  popper.style.position = 'absolute';
  popper.style.top = '0';
  popper.style.left = '0';
  var tooltip = div();
  tooltip.className = TOOLTIP_CLASS;
  tooltip.id = "tippy-" + id;
  tooltip.setAttribute('data-state', 'hidden');
  tooltip.setAttribute('tabindex', '-1');
  updateTheme(tooltip, 'add', props.theme);
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');

  if (props.interactive) {
    addInteractive(tooltip);
  }

  if (props.arrow) {
    tooltip.setAttribute('data-arrow', '');
    tooltip.appendChild(createArrowElement(props.arrow));
  }

  if (props.inertia) {
    addInertia(tooltip);
  }

  setContent(content, props);
  tooltip.appendChild(content);
  popper.appendChild(tooltip);
  updatePopperElement(popper, props, props);
  return popper;
}
/**
 * Updates the popper element based on the new props
 */

function updatePopperElement(popper, prevProps, nextProps) {
  var _getChildren = getChildren(popper),
      tooltip = _getChildren.tooltip,
      content = _getChildren.content,
      arrow = _getChildren.arrow;

  popper.style.zIndex = '' + nextProps.zIndex;
  tooltip.setAttribute('data-animation', nextProps.animation);
  tooltip.style.maxWidth = appendPxIfNumber(nextProps.maxWidth);

  if (nextProps.role) {
    tooltip.setAttribute('role', nextProps.role);
  } else {
    tooltip.removeAttribute('role');
  }

  if (prevProps.content !== nextProps.content) {
    setContent(content, nextProps);
  } // arrow


  if (!prevProps.arrow && nextProps.arrow) {
    // false to true
    tooltip.appendChild(createArrowElement(nextProps.arrow));
    tooltip.setAttribute('data-arrow', '');
  } else if (prevProps.arrow && !nextProps.arrow) {
    // true to false
    tooltip.removeChild(arrow);
    tooltip.removeAttribute('data-arrow');
  } else if (prevProps.arrow !== nextProps.arrow) {
    // true to 'round' or vice-versa
    tooltip.removeChild(arrow);
    tooltip.appendChild(createArrowElement(nextProps.arrow));
  } // interactive


  if (!prevProps.interactive && nextProps.interactive) {
    addInteractive(tooltip);
  } else if (prevProps.interactive && !nextProps.interactive) {
    removeInteractive(tooltip);
  } // inertia


  if (!prevProps.inertia && nextProps.inertia) {
    addInertia(tooltip);
  } else if (prevProps.inertia && !nextProps.inertia) {
    removeInertia(tooltip);
  } // theme


  if (prevProps.theme !== nextProps.theme) {
    updateTheme(tooltip, 'remove', prevProps.theme);
    updateTheme(tooltip, 'add', nextProps.theme);
  }
}
/**
 * Add/remove transitionend listener from tooltip
 */

function updateTransitionEndListener(tooltip, action, listener) {
  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    tooltip[action + 'EventListener'](event, listener);
  });
}
/**
 * Adds/removes theme from tooltip's classList
 */

function updateTheme(tooltip, action, theme) {
  splitBySpaces(theme).forEach(function (name) {
    tooltip.classList[action](name + "-theme");
  });
}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */

function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        tooltipRect = _ref.tooltipRect,
        interactiveBorder = _ref.interactiveBorder;
    // Get min/max bounds of both the popper and tooltip rects due to
    // `distance` offset
    var mergedRect = {
      top: Math.min(popperRect.top, tooltipRect.top),
      right: Math.max(popperRect.right, tooltipRect.right),
      bottom: Math.max(popperRect.bottom, tooltipRect.bottom),
      left: Math.min(popperRect.left, tooltipRect.left)
    };
    var exceedsTop = mergedRect.top - clientY > interactiveBorder;
    var exceedsBottom = clientY - mergedRect.bottom > interactiveBorder;
    var exceedsLeft = mergedRect.left - clientX > interactiveBorder;
    var exceedsRight = clientX - mergedRect.right > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}

var idCounter = 1;
var mouseMoveListeners = [];
/**
 * Used by `hideAll()`
 */

var mountedInstances = [];
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */

function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, _extends({}, defaultProps, {}, getExtendedPassedProps(passedProps))); // If the reference shouldn't have multiple tippys, return null early

  if (!props.multiple && reference._tippy) {
    return null;
  }
  /* ======================= 🔒 Private members 🔒 ======================= */


  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isBeingDestroyed = false;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var popperUpdates = 0;
  var lastTriggerEvent;
  var currentMountCallback;
  var currentTransitionEndListener;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget; // Support iframe contexts
  // Static check that assumes any of the `triggerTarget` or `reference`
  // nodes will never change documents, even when they are updated

  var doc = getOwnerDocument(props.triggerTarget || reference);
  /* ======================= 🔑 Public members 🔑 ======================= */

  var id = idCounter++;
  var popper = createPopperElement(id, props);
  var popperChildren = getChildren(popper);
  var popperInstance = null;
  var plugins = unique(props.plugins); // These two elements are static

  var tooltip = popperChildren.tooltip,
      content = popperChildren.content;
  var transitionableElements = [tooltip, content];
  var state = {
    // The current real placement (`data-placement` attribute)
    currentPlacement: null,
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: popper,
    popperChildren: popperChildren,
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    enable: enable,
    disable: disable,
    destroy: destroy
  };
  /* ==================== Initial instance mutations =================== */

  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hadAriaExpandedAttributeOnCreate = reference.hasAttribute('aria-expanded');
  addListenersToTriggerTarget();
  handleAriaExpandedAttribute();

  if (!props.lazy) {
    createPopperInstance();
  }

  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function (event) {
    if (instance.props.interactive && includes(instance.props.trigger, 'mouseenter')) {
      debouncedOnMouseMove(event);
      doc.addEventListener('mousemove', debouncedOnMouseMove);
    }
  });
  return instance;
  /* ======================= 🔒 Private methods 🔒 ======================= */

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (hasOwnProperty(pluginHooks, hook)) {
        // @ts-ignore
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      // @ts-ignore
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaDescribedByAttribute() {
    var aria = instance.props.aria;

    if (!aria) {
      return;
    }

    var attr = "aria-" + aria;
    var id = tooltip.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    // If the user has specified `aria-expanded` on their reference when the
    // instance was created, we have to assume they're controlling it externally
    // themselves
    if (hadAriaExpandedAttributeOnCreate) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    doc.body.removeEventListener('mouseleave', scheduleHide);
    doc.removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentMouseDown(event) {
    // Clicked on interactive popper
    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
        return;
      }
    }

    if (instance.props.hideOnClick === true) {
      isVisibleFromClick = false;
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentMouseDownListener();
      }
    }
  }

  function addDocumentMouseDownListener() {
    doc.addEventListener('mousedown', onDocumentMouseDown, true);
  }

  function removeDocumentMouseDownListener() {
    doc.removeEventListener('mousedown', onDocumentMouseDown, true);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    function listener(event) {
      if (event.target === tooltip) {
        updateTransitionEndListener(tooltip, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(tooltip, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListenersToTriggerTarget() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, PASSIVE);
      on('touchend', onMouseLeave, PASSIVE);
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListenersFromTriggerTarget() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (!includes(instance.props.trigger, 'mouseenter') || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      var _getNormalizedTouchSe = getNormalizedTouchSettings(),
          value = _getNormalizedTouchSe[0],
          duration = _getNormalizedTouchSe[1];

      if (currentInput.isTouch && value === 'hold' && duration) {
        // We can hijack the show timeout here, it will be cleared by
        // `scheduleHide()` when necessary
        showTimeout = setTimeout(function () {
          scheduleShow(event);
        }, duration);
      } else {
        scheduleShow(event);
      }
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var isCursorOverReferenceOrPopper = closestCallback(event.target, function (el) {
      return el === reference || el === popper;
    });

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = arrayFrom(popper.querySelectorAll(POPPER_SELECTOR)).concat(popper).map(function (popper) {
      var instance = popper._tippy;
      var tooltip = instance.popperChildren.tooltip;
      var interactiveBorder = instance.props.interactiveBorder;
      return {
        popperRect: popper.getBoundingClientRect(),
        tooltipRect: tooltip.getBoundingClientRect(),
        interactiveBorder: interactiveBorder
      };
    });

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    if (isEventListenerStopped(event)) {
      return;
    }

    if (includes(instance.props.trigger, 'click') && isVisibleFromClick) {
      return;
    }

    if (instance.props.interactive) {
      doc.body.addEventListener('mouseleave', scheduleHide);
      doc.addEventListener('mousemove', debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (!includes(instance.props.trigger, 'focusin') && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    var supportsTouch = 'ontouchstart' in window;
    var isTouchEvent = includes(event.type, 'touch');
    var isCustomTouch = getIsCustomTouchBehavior();
    return supportsTouch && currentInput.isTouch && isCustomTouch && !isTouchEvent || currentInput.isTouch && !isCustomTouch && isTouchEvent;
  }

  function createPopperInstance() {
    var popperOptions = instance.props.popperOptions;
    var arrow = instance.popperChildren.arrow;
    var flipModifier = getModifier(popperOptions, 'flip');
    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
    var distancePx;

    function applyMutations(data) {
      var prevPlacement = instance.state.currentPlacement;
      instance.state.currentPlacement = data.placement;

      if (instance.props.flip && !instance.props.flipOnUpdate) {
        if (data.flipped) {
          instance.popperInstance.options.placement = data.placement;
        }

        setModifierValue(instance.popperInstance.modifiers, 'flip', 'enabled', false);
      }

      tooltip.setAttribute('data-placement', data.placement);

      if (data.attributes['x-out-of-boundaries'] !== false) {
        tooltip.setAttribute('data-out-of-boundaries', '');
      } else {
        tooltip.removeAttribute('data-out-of-boundaries');
      }

      var basePlacement = getBasePlacement(data.placement);
      var isVerticalPlacement = includes(['top', 'bottom'], basePlacement);
      var isSecondaryPlacement = includes(['bottom', 'right'], basePlacement); // Apply `distance` prop

      tooltip.style.top = '0';
      tooltip.style.left = '0';
      tooltip.style[isVerticalPlacement ? 'top' : 'left'] = (isSecondaryPlacement ? 1 : -1) * distancePx + 'px'; // Careful not to cause an infinite loop here
      // Fixes https://github.com/FezVrasta/popper.js/issues/784

      if (prevPlacement && prevPlacement !== data.placement) {
        instance.popperInstance.update();
      }
    }

    var config = _extends({
      eventsEnabled: false,
      placement: instance.props.placement
    }, popperOptions, {
      modifiers: _extends({}, popperOptions && popperOptions.modifiers, {
        // We can't use `padding` on the popper el because of these bugs when
        // flipping from a vertical to horizontal placement or vice-versa,
        // there is severe flickering.
        // https://github.com/FezVrasta/popper.js/issues/720
        // This workaround increases bundle size by 250B minzip unfortunately,
        // due to need to custom compute the distance (since Popper rect does
        // not get affected by the inner tooltip's distance offset)
        tippyDistance: {
          enabled: true,
          order: 0,
          fn: function fn(data) {
            // `html` fontSize may change while `popperInstance` is alive
            // e.g. on resize in media queries
            distancePx = getUnitsInPx(doc, instance.props.distance);
            var basePlacement = getBasePlacement(data.placement);
            var computedPreventOverflowPadding = getComputedPadding(basePlacement, preventOverflowModifier && preventOverflowModifier.padding, distancePx);
            var computedFlipPadding = getComputedPadding(basePlacement, flipModifier && flipModifier.padding, distancePx);
            var instanceModifiers = instance.popperInstance.modifiers;
            setModifierValue(instanceModifiers, 'preventOverflow', 'padding', computedPreventOverflowPadding);
            setModifierValue(instanceModifiers, 'flip', 'padding', computedFlipPadding);
            return data;
          }
        },
        preventOverflow: _extends({
          boundariesElement: instance.props.boundary
        }, preventOverflowModifier),
        flip: _extends({
          enabled: instance.props.flip,
          behavior: instance.props.flipBehavior
        }, flipModifier),
        arrow: _extends({
          element: arrow,
          enabled: !!arrow
        }, getModifier(popperOptions, 'arrow')),
        offset: _extends({
          offset: instance.props.offset
        }, getModifier(popperOptions, 'offset'))
      }),
      onCreate: function onCreate(data) {
        applyMutations(data);
        preserveInvocation(popperOptions && popperOptions.onCreate, config.onCreate, [data]);
        runMountCallback();
      },
      onUpdate: function onUpdate(data) {
        applyMutations(data);
        preserveInvocation(popperOptions && popperOptions.onUpdate, config.onUpdate, [data]);
        runMountCallback();
      }
    });

    instance.popperInstance = new popper_js__WEBPACK_IMPORTED_MODULE_0__["default"](reference, popper, config);
  }

  function runMountCallback() {
    // Only invoke currentMountCallback after 2 updates
    // This fixes some bugs in Popper.js (TODO: aim for only 1 update)
    if (popperUpdates === 0) {
      popperUpdates++; // 1

      instance.popperInstance.update();
    } else if (currentMountCallback && popperUpdates === 1) {
      popperUpdates++; // 2

      reflow(popper);
      currentMountCallback();
    }
  }

  function mount() {
    // The mounting callback (`currentMountCallback`) is only run due to a
    // popperInstance update/create
    popperUpdates = 0;
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper.js needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    if (true) {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard navigation', 'because it is not directly after the reference element in the DOM source', 'order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element solves', 'this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle keyboard', 'navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/accessibility/#interactivity'].join(' '));
    }

    setModifierValue(instance.popperInstance.modifiers, 'flip', 'enabled', instance.props.flip);
    instance.popperInstance.enableEventListeners(); // Mounting callback invoked in `onUpdate`

    instance.popperInstance.update();
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (!instance.popperInstance) {
      createPopperInstance();
    }

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentMouseDownListener();
    var delay = getDelay(true);

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentMouseDownListener();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (includes(instance.props.trigger, 'mouseenter') && includes(instance.props.trigger, 'click') && includes(['mouseleave', 'mousemove'], event.type) && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  }
  /* ======================= 🔑 Public methods 🔑 ======================= */


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    if (true) {
      validateProps(partialProps, plugins);
      warnWhen(partialProps.plugins ? partialProps.plugins.length !== plugins.length || plugins.some(function (p, i) {
        if (partialProps.plugins && partialProps.plugins[i]) {
          return p !== partialProps.plugins[i];
        } else {
          return true;
        }
      }) : false, "Cannot update plugins");
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListenersFromTriggerTarget();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, _extends({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    nextProps.ignoreAttributes = useIfDefined(partialProps.ignoreAttributes, prevProps.ignoreAttributes);
    instance.props = nextProps;
    addListenersToTriggerTarget();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }

    updatePopperElement(popper, prevProps, nextProps);
    instance.popperChildren = getChildren(popper); // Ensure stale aria-expanded attributes are removed

    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();

    if (instance.popperInstance) {
      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
        return hasOwnProperty(partialProps, prop) && partialProps[prop] !== prevProps[prop];
      })) {
        var currentReference = instance.popperInstance.reference;
        instance.popperInstance.destroy();
        createPopperInstance();
        instance.popperInstance.reference = currentReference;

        if (instance.state.isVisible) {
          instance.popperInstance.enableEventListeners();
        }
      } else {
        instance.popperInstance.update();
      }
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show(duration) {
    if (duration === void 0) {
      duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    }

    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    if (!instance.popperInstance) {
      createPopperInstance();
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    addDocumentMouseDownListener();
    popper.style.visibility = 'visible';
    instance.state.isVisible = true; // Prevent a transition of the popper from its previous position and of the
    // elements at a different placement
    // Check if the tippy was fully unmounted before `show()` was called, to
    // allow for smooth transition for `createSingleton()`

    if (!instance.state.isMounted) {
      setTransitionDuration(transitionableElements.concat(popper), 0);
    }

    currentMountCallback = function currentMountCallback() {
      if (!instance.state.isVisible) {
        return;
      }

      setTransitionDuration([popper], instance.props.updateDuration);
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, 'visible');
      handleAriaDescribedByAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      updateIOSClass(true);
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);
      onTransitionedIn(duration, function () {
        instance.state.isShown = true;
        invokeHook('onShown', [instance]);
      });
    };

    mount();
  }

  function hide(duration) {
    if (duration === void 0) {
      duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    }

    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out


    var isAlreadyHidden = !instance.state.isVisible && !isBeingDestroyed;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled && !isBeingDestroyed;

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
      return;
    }

    removeDocumentMouseDownListener();
    popper.style.visibility = 'hidden';
    instance.state.isVisible = false;
    instance.state.isShown = false;
    setTransitionDuration(transitionableElements, duration);
    setVisibilityState(transitionableElements, 'hidden');
    handleAriaDescribedByAttribute();
    handleAriaExpandedAttribute();
    onTransitionedOut(duration, function () {
      instance.popperInstance.disableEventListeners();
      instance.popperInstance.options.placement = instance.props.placement;
      popper.parentNode.removeChild(popper);
      mountedInstances = mountedInstances.filter(function (i) {
        return i !== instance;
      });

      if (mountedInstances.length === 0) {
        updateIOSClass(false);
      }

      instance.state.isMounted = false;
      invokeHook('onHidden', [instance]);
    });
  }

  function destroy() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    isBeingDestroyed = true;
    instance.clearDelayTimeouts();
    instance.hide(0);
    removeListenersFromTriggerTarget();
    delete reference._tippy;

    if (instance.popperInstance) {
      instance.popperInstance.destroy();
    }

    isBeingDestroyed = false;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps,
/** @deprecated use Props.plugins */
plugins) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  plugins = defaultProps.plugins.concat(optionalProps.plugins || plugins);

  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }

  bindGlobalEventListeners();

  var passedProps = _extends({}, optionalProps, {
    plugins: plugins
  });

  var elements = getArrayOfElements(targets);

  if (true) {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than one tippy', 'instance was created by this invocation. This means the content element will', 'only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that returns a', 'cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.version = version;
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
/**
 * Hides all visible poppers on the document
 */

var hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  mountedInstances.forEach(function (instance) {
    var isExcluded = false;

    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }

    if (!isExcluded) {
      instance.hide(duration);
    }
  });
};
/**
 * Returns a proxy wrapper function that passes the plugins
 * @deprecated use tippy.setDefaultProps({plugins: [...]});
 */

function createTippyWithPlugins(outerPlugins) {
  if (true) {
    warnWhen(true, ['createTippyWithPlugins([...]) has been deprecated.', '\n\n', 'Use tippy.setDefaultProps({plugins: [...]}) instead.'].join(' '));
  }

  var tippyPluginsWrapper = function tippyPluginsWrapper(targets, optionalProps, innerPlugins) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }

    if (innerPlugins === void 0) {
      innerPlugins = [];
    }

    innerPlugins = optionalProps.plugins || innerPlugins;
    return tippy(targets, _extends({}, optionalProps, {
      plugins: [].concat(outerPlugins, innerPlugins)
    }));
  };

  tippyPluginsWrapper.version = version;
  tippyPluginsWrapper.defaultProps = defaultProps;
  tippyPluginsWrapper.setDefaultProps = setDefaultProps;
  tippyPluginsWrapper.currentInput = currentInput; // @ts-ignore

  return tippyPluginsWrapper;
}


//# sourceMappingURL=tippy.chunk.esm.js.map


/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.css":
/*!**********************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./tippy.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/dist/tippy.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/*! exports provided: createTippyWithPlugins, default, hideAll, roundArrow, animateFill, createSingleton, delegate, followCursor, inlinePositioning, sticky */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateFill", function() { return animateFill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSingleton", function() { return createSingleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delegate", function() { return delegate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "followCursor", function() { return followCursor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inlinePositioning", function() { return inlinePositioning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sticky", function() { return sticky; });
/* harmony import */ var _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tippy.chunk.esm.js */ "./node_modules/tippy.js/dist/tippy.chunk.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTippyWithPlugins", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hideAll", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "roundArrow", function() { return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["R"]; });

/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/**!
* tippy.js v5.2.1
* (c) 2017-2020 atomiks
* MIT License
*/




/**
 * Re-uses a single tippy element for many different tippy instances.
 * Replaces v4's `tippy.group()`.
 */

var createSingleton = function createSingleton(tippyInstances, optionalProps,
/** @deprecated use Props.plugins */
plugins) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  if (true) {
    Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["e"])(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of tippy', 'instances. The passed value was', String(tippyInstances)].join(' '));
  }

  plugins = optionalProps.plugins || plugins;
  tippyInstances.forEach(function (instance) {
    instance.disable();
  });

  var userAria = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["d"], {}, optionalProps).aria;

  var currentAria;
  var currentTarget;
  var shouldSkipUpdate = false;
  var references = tippyInstances.map(function (instance) {
    return instance.reference;
  });
  var singleton = {
    fn: function fn(instance) {
      function handleAriaDescribedByAttribute(isShow) {
        if (!currentAria) {
          return;
        }

        var attr = "aria-" + currentAria;

        if (isShow && !instance.props.interactive) {
          currentTarget.setAttribute(attr, instance.popperChildren.tooltip.id);
        } else {
          currentTarget.removeAttribute(attr);
        }
      }

      return {
        onAfterUpdate: function onAfterUpdate(_, _ref) {
          var aria = _ref.aria;

          // Ensure `aria` for the singleton instance stays `null`, while
          // changing the `userAria` value
          if (aria !== undefined && aria !== userAria) {
            if (!shouldSkipUpdate) {
              userAria = aria;
            } else {
              shouldSkipUpdate = true;
              instance.setProps({
                aria: null
              });
              shouldSkipUpdate = false;
            }
          }
        },
        onDestroy: function onDestroy() {
          tippyInstances.forEach(function (instance) {
            instance.enable();
          });
        },
        onMount: function onMount() {
          handleAriaDescribedByAttribute(true);
        },
        onUntrigger: function onUntrigger() {
          handleAriaDescribedByAttribute(false);
        },
        onTrigger: function onTrigger(_, event) {
          var target = event.currentTarget;
          var index = references.indexOf(target); // bail-out

          if (target === currentTarget) {
            return;
          }

          currentTarget = target;
          currentAria = userAria;

          if (instance.state.isVisible) {
            handleAriaDescribedByAttribute(true);
          }

          instance.popperInstance.reference = target;
          instance.setContent(tippyInstances[index].props.content);
        }
      };
    }
  };
  return Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"])(Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["a"])(), Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, optionalProps, {
    plugins: [singleton].concat(plugins),
    aria: null,
    triggerTarget: references
  }));
};

var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props,
/** @deprecated use Props.plugins */
plugins) {
  if (plugins === void 0) {
    plugins = [];
  }

  if (true) {
    Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["e"])(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }

  plugins = props.plugins || plugins;
  var listeners = [];
  var childTippyInstances = [];
  var target = props.target;
  var nativeProps = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["r"])(props, ['target']);

  var parentProps = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, nativeProps, {
    plugins: plugins,
    trigger: 'manual'
  });

  var childProps = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["_"])({}, nativeProps, {
    plugins: plugins,
    showOnCreate: true
  });

  var returnValue = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"])(targets, parentProps);
  var normalizedReturnValue = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["n"])(returnValue);

  function onTrigger(event) {
    if (!event.target) {
      return;
    }

    var targetNode = event.target.closest(target);

    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`


    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["d"].trigger; // Only create the instance if the bubbling event matches the trigger type

    if (!Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["i"])(trigger, BUBBLING_EVENTS_MAP[event.type])) {
      return;
    }

    var instance = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["t"])(targetNode, childProps);

    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }

  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }

  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }

  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function applyMutations(instance) {
    var originalDestroy = instance.destroy;

    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }

      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }

      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };

    addEventListeners(instance);
  }

  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}

var animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$popperChild = instance.popperChildren,
        tooltip = _instance$popperChild.tooltip,
        content = _instance$popperChild.content;
    var backdrop = instance.props.animateFill ? createBackdropElement() : null;

    function addBackdropToPopperChildren() {
      instance.popperChildren.backdrop = backdrop;
    }

    return {
      onCreate: function onCreate() {
        if (backdrop) {
          addBackdropToPopperChildren();
          tooltip.insertBefore(backdrop, tooltip.firstElementChild);
          tooltip.setAttribute('data-animatefill', '');
          tooltip.style.overflow = 'hidden';
          instance.setProps({
            animation: 'shift-away',
            arrow: false
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = tooltip.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["s"])([backdrop], 'visible'); // Warn if the stylesheets are not loaded

          if (true) {
            Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["w"])(getComputedStyle(backdrop).position !== 'absolute', "The `tippy.js/dist/backdrop.css` stylesheet has not been\n              imported!\n              \n              The `animateFill` plugin requires this stylesheet to work.");
            Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["w"])(getComputedStyle(tooltip).transform === 'none', "The `tippy.js/animations/shift-away.css` stylesheet has not\n              been imported!\n              \n              The `animateFill` plugin requires this stylesheet to work.");
          }
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["s"])([backdrop], 'hidden');
        }
      },
      onAfterUpdate: function onAfterUpdate() {
        // With this type of prop, it's highly unlikely it will be changed
        // dynamically. We'll leave out the diff/update logic it to save bytes.
        // `popperChildren` is assigned a new object onAfterUpdate
        addBackdropToPopperChildren();
      }
    };
  }
};

function createBackdropElement() {
  var backdrop = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["a"])();
  backdrop.className = _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["B"];
  Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["s"])([backdrop], 'hidden');
  return backdrop;
}

var followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;
    var originalReference = null; // Support iframe contexts
    // Static check that assumes any of the `triggerTarget` or `reference`
    // nodes will never change documents, even when they are updated

    var doc = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["g"])(instance.props.triggerTarget || reference); // Internal state

    var lastMouseMoveEvent;
    var mouseCoords = null;
    var isInternallySettingControlledProp = false; // These are controlled by this plugin, so we need to store the user's
    // original prop value

    var userProps = instance.props;

    function setUserProps(props) {
      var keys = Object.keys(props);
      keys.forEach(function (prop) {
        userProps[prop] = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["u"])(props[prop], userProps[prop]);
      });
    }

    function getIsManual() {
      return instance.props.trigger.trim() === 'manual';
    }

    function getIsEnabled() {
      // #597
      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard "click"
      mouseCoords !== null && !(mouseCoords.clientX === 0 && mouseCoords.clientY === 0);
      return instance.props.followCursor && isValidMouseEvent;
    }

    function getIsInitialBehavior() {
      return _tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["c"].isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;
    }

    function resetReference() {
      if (instance.popperInstance && originalReference) {
        instance.popperInstance.reference = originalReference;
      }
    }

    function handlePlacement() {
      // Due to `getVirtualOffsets()`, we need to reverse the placement if it's
      // shifted (start -> end, and vice-versa)
      // Early bail-out
      if (!getIsEnabled() && instance.props.placement === userProps.placement) {
        return;
      }

      var placement = userProps.placement;
      var shift = placement.split('-')[1];
      isInternallySettingControlledProp = true;
      instance.setProps({
        placement: getIsEnabled() && shift ? placement.replace(shift, shift === 'start' ? 'end' : 'start') : placement
      });
      isInternallySettingControlledProp = false;
    }

    function handlePopperListeners() {
      if (!instance.popperInstance) {
        return;
      } // Popper's scroll listeners make sense for `true` only. TODO: work out
      // how to only listen horizontal scroll for "horizontal" and vertical
      // scroll for "vertical"


      if (getIsEnabled() && getIsInitialBehavior()) {
        instance.popperInstance.disableEventListeners();
      }
    }

    function handleMouseMoveListener() {
      if (getIsEnabled()) {
        addListener();
      } else {
        resetReference();
      }
    }

    function triggerLastMouseMove() {
      if (getIsEnabled()) {
        onMouseMove(lastMouseMoveEvent);
      }
    }

    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }

    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }

    function onMouseMove(event) {
      var _lastMouseMoveEvent = lastMouseMoveEvent = event,
          clientX = _lastMouseMoveEvent.clientX,
          clientY = _lastMouseMoveEvent.clientY;

      if (!instance.popperInstance || !instance.state.currentPlacement) {
        return;
      } // If the instance is interactive, avoid updating the position unless it's
      // over the reference element


      var isCursorOverReference = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["f"])(event.target, function (el) {
        return el === reference;
      });
      var followCursor = instance.props.followCursor;
      var isHorizontal = followCursor === 'horizontal';
      var isVertical = followCursor === 'vertical';
      var isVerticalPlacement = Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["i"])(['top', 'bottom'], Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["h"])(instance.state.currentPlacement)); // The virtual reference needs some size to prevent itself from overflowing

      var _getVirtualOffsets = getVirtualOffsets(popper, isVerticalPlacement),
          size = _getVirtualOffsets.size,
          x = _getVirtualOffsets.x,
          y = _getVirtualOffsets.y;

      if (isCursorOverReference || !instance.props.interactive) {
        // Preserve custom position ReferenceObjects, which may not be the
        // original targets reference passed as an argument
        if (originalReference === null) {
          originalReference = instance.popperInstance.reference;
        }

        instance.popperInstance.reference = {
          referenceNode: reference,
          // These `client` values don't get used by Popper.js if they are 0
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            var rect = reference.getBoundingClientRect();
            return {
              width: isVerticalPlacement ? size : 0,
              height: isVerticalPlacement ? 0 : size,
              top: (isHorizontal ? rect.top : clientY) - y,
              bottom: (isHorizontal ? rect.bottom : clientY) + y,
              left: (isVertical ? rect.left : clientX) - x,
              right: (isVertical ? rect.right : clientX) + x
            };
          }
        };
        instance.popperInstance.update();
      }

      if (getIsInitialBehavior()) {
        removeListener();
      }
    }

    return {
      onAfterUpdate: function onAfterUpdate(_, partialProps) {
        if (!isInternallySettingControlledProp) {
          setUserProps(partialProps);

          if (partialProps.placement) {
            handlePlacement();
          }
        } // A new placement causes the popperInstance to be recreated


        if (partialProps.placement) {
          handlePopperListeners();
        } // Wait for `.update()` to set `instance.state.currentPlacement` to
        // the new placement


        requestAnimationFrame(triggerLastMouseMove);
      },
      onMount: function onMount() {
        triggerLastMouseMove();
        handlePopperListeners();
      },
      onShow: function onShow() {
        if (getIsManual()) {
          // Since there's no trigger event to use, we have to use these as
          // baseline coords
          mouseCoords = {
            clientX: 0,
            clientY: 0
          }; // Ensure `lastMouseMoveEvent` doesn't access any other properties
          // of a MouseEvent here

          lastMouseMoveEvent = mouseCoords;
          handlePlacement();
          handleMouseMoveListener();
        }
      },
      onTrigger: function onTrigger(_, event) {
        // Tapping on touch devices can trigger `mouseenter` then `focus`
        if (mouseCoords) {
          return;
        }

        if (Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["b"])(event)) {
          mouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
          lastMouseMoveEvent = event;
        }

        handlePlacement();
        handleMouseMoveListener();
      },
      onUntrigger: function onUntrigger() {
        // If untriggered before showing (`onHidden` will never be invoked)
        if (!instance.state.isVisible) {
          removeListener();
          mouseCoords = null;
        }
      },
      onHidden: function onHidden() {
        removeListener();
        resetReference();
        mouseCoords = null;
      }
    };
  }
};
function getVirtualOffsets(popper, isVerticalPlacement) {
  var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
  return {
    size: size,
    x: isVerticalPlacement ? size : 0,
    y: isVerticalPlacement ? 0 : size
  };
}

// position. This will require the `followCursor` plugin's fixes for overflow
// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)

var inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;

    function getIsEnabled() {
      return !!instance.props.inlinePositioning;
    }

    return {
      onHidden: function onHidden() {
        if (getIsEnabled()) {
          instance.popperInstance.reference = reference;
        }
      },
      onShow: function onShow() {
        if (!getIsEnabled()) {
          return;
        }

        instance.popperInstance.reference = {
          referenceNode: reference,
          // These `client` values don't get used by Popper.js if they are 0
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            return getInlineBoundingClientRect(instance.state.currentPlacement && Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["h"])(instance.state.currentPlacement), reference.getBoundingClientRect(), Object(_tippy_chunk_esm_js__WEBPACK_IMPORTED_MODULE_0__["j"])(reference.getClientRects()));
          }
        };
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  }

  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }

    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;

        var _width = _right - _left;

        var _height = _bottom - _top;

        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }

    default:
      {
        return boundingRect;
      }
  }
}

var sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;

    function getReference() {
      return instance.popperInstance ? instance.popperInstance.reference : reference;
    }

    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }

    var prevRefRect = null;
    var prevPopRect = null;

    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        instance.popperInstance.update();
      }

      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }

    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};

function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }

  return true;
}


//# sourceMappingURL=tippy.esm.js.map


/***/ }),

/***/ "./node_modules/tippy.js/themes/light-border.css":
/*!*******************************************************!*\
  !*** ./node_modules/tippy.js/themes/light-border.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./light-border.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/tippy.js/themes/light-border.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/Annotation.ts":
/*!***************************!*\
  !*** ./src/Annotation.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ./util/Lattice */ "./src/util/Lattice.ts");
const Set_1 = __webpack_require__(/*! ./util/Set */ "./src/util/Set.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
function annotated(v) {
    return v instanceof Expr_1.Expr.SyntaxNode || v instanceof DataValue_1.ExplValue;
}
exports.annotated = annotated;
function isα(v) {
    return exports.__slice.is(v);
}
exports.isα = isα;
// Currently no deltas are associated with annotations.
function setα(α, v) {
    exports.__slice.set(v, α);
}
exports.setα = setα;
function setjoinα(α, v) {
    setα(Lattice_1.bool_.join(α, isα(v)), v);
}
exports.setjoinα = setjoinα;
function setmeetα(α, v) {
    setα(Lattice_1.bool_.meet(α, isα(v)), v);
}
exports.setmeetα = setmeetα;
var Direction;
(function (Direction) {
    Direction[Direction["Fwd"] = 0] = "Fwd";
    Direction[Direction["Bwd"] = 1] = "Bwd";
})(Direction = exports.Direction || (exports.Direction = {}));
class Annotations {
    constructor() {
        this.ann = new Set(); // unavailable nodes (fwd) or needed nodes (bwd)
        this.direction = Direction.Fwd;
    }
    // Whether v is needed (going backward) or available (going forward).
    is(v) {
        if (this.direction === Direction.Fwd) {
            return Lattice_1.bool_.negate(this.ann.has(v));
        }
        else {
            return this.ann.has(v);
        }
    }
    // Going forward, annotation updates must be decreasing; going backward, increasing. This is because 
    // forward slicing propagates non-availability, whereas backward slicing propagates demand.
    set(v, α) {
        const current = this.is(v);
        if (this.direction === Direction.Fwd && α < current ||
            this.direction === Direction.Bwd && α > current) {
            this.ann.add(v);
        }
        else if (this.direction === Direction.Fwd && α > current ||
            this.direction === Direction.Bwd && α < current) {
            Core_1.absurd(`Incompatible update of annotation from ${current} to ${α}.`, current, α);
        }
        else {
            // idempotent
        }
    }
    reset(direction) {
        this.direction = direction;
        this.ann = new Set();
    }
    restrictTo(tvs) {
        return Set_1.intersection(this.ann, Set_1.union(...tvs.map(tv => explDescendants(tv))));
    }
}
exports.Annotations = Annotations;
function explDescendants(tv) {
    const desc = new Set();
    explDescendants_aux(tv, desc);
    return desc;
}
function explDescendants_aux(tv, desc) {
    desc.add(tv);
    if (tv.v instanceof DataValue_1.DataValue) {
        const { t, v } = tv;
        Expl_1.Expl.explChildren(t, v).forEach((tv) => {
            explDescendants_aux(tv, desc);
        });
    }
}
exports.__slice = new Annotations();


/***/ }),

/***/ "./src/BaseTypes.ts":
/*!**************************!*\
  !*** ./src/BaseTypes.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// See Env for convention regarding instance members on reflected datatypes.
class Bool extends DataValue_1.DataValue {
}
exports.Bool = Bool;
class True extends Bool {
}
exports.True = True;
function true_() {
    return Versioned_1.at(True);
}
exports.true_ = true_;
class False extends Bool {
}
exports.False = False;
function false_() {
    return Versioned_1.at(False);
}
exports.false_ = false_;
class List extends DataValue_1.DataValue {
    static fromArray(x̅) {
        let x̅ʹ = nil();
        for (let n = x̅.length - 1; n >= 0; --n) {
            x̅ʹ = cons(x̅[n], x̅ʹ);
        }
        return x̅ʹ;
    }
    toArray() {
        const x̅ = [];
        this.toArray_(x̅);
        return x̅;
    }
    toArray_(x̅) {
        if (Cons.is(this)) {
            x̅.push(this.head);
            this.tail.toArray_(x̅);
        }
        else if (Nil.is(this)) {
        }
        else {
            return Core_1.absurd();
        }
    }
}
exports.List = List;
class Nil extends List {
    static is(xs) {
        return xs instanceof Nil;
    }
}
exports.Nil = Nil;
function nil() {
    return Value_1.make(Nil);
}
exports.nil = nil;
class Cons extends List {
    constructor() {
        super(...arguments);
        this.head = Value_1._;
        this.tail = Value_1._;
    }
    static is(xs) {
        return xs instanceof Cons;
    }
}
exports.Cons = Cons;
function cons(head, tail) {
    return Value_1.make(Cons, head, tail);
}
exports.cons = cons;
class Pair extends DataValue_1.DataValue {
    constructor() {
        super(...arguments);
        this.fst = Value_1._;
        this.snd = Value_1._;
    }
}
exports.Pair = Pair;
function pair(fst, snd) {
    return Value_1.make(Pair, fst, snd);
}
exports.pair = pair;
class Tree extends DataValue_1.DataValue {
    toArray() {
        const x̅ = [];
        this.toArray_(x̅);
        return x̅;
    }
    toArray_(x̅) {
        if (NonEmpty.is(this)) {
            this.left.toArray_(x̅);
            x̅.push(this.t);
            this.right.toArray_(x̅);
        }
        else if (Empty.is(this)) {
        }
        else {
            return Core_1.absurd();
        }
    }
}
exports.Tree = Tree;
class Empty extends Tree {
    static is(t) {
        return t instanceof Empty;
    }
}
exports.Empty = Empty;
function empty() {
    return Value_1.make(Empty);
}
exports.empty = empty;
class NonEmpty extends Tree {
    constructor() {
        super(...arguments);
        this.left = Value_1._;
        this.t = Value_1._;
        this.right = Value_1._;
    }
    static is(t) {
        return t instanceof NonEmpty;
    }
}
exports.NonEmpty = NonEmpty;
function nonEmpty(left, t, right) {
    return Value_1.make(NonEmpty, left, t, right);
}
exports.nonEmpty = nonEmpty;
class Option extends DataValue_1.DataValue {
}
exports.Option = Option;
class None extends Option {
    static is(o) {
        return o instanceof None;
    }
}
exports.None = None;
class Some extends Option {
    constructor() {
        super(...arguments);
        this.t = Value_1._;
    }
    static is(o) {
        return o instanceof Some;
    }
}
exports.Some = Some;
class Ordering extends DataValue_1.DataValue {
}
exports.Ordering = Ordering;
class LT extends Ordering {
}
exports.LT = LT;
class GT extends Ordering {
}
exports.GT = GT;
class EQ extends Ordering {
}
exports.EQ = EQ;
var BaseTypes;
(function (BaseTypes) {
    function initialise() {
        DataType_1.initDataType(Bool, [True, False]);
        DataType_1.initDataType(List, [Nil, Cons]);
        DataType_1.initDataType(Option, [Some, None]);
        DataType_1.initDataType(Ordering, [LT, GT, EQ]);
        DataType_1.initDataType(Pair, [Pair]);
        DataType_1.initDataType(Tree, [Empty, NonEmpty]);
    }
    BaseTypes.initialise = initialise;
})(BaseTypes = exports.BaseTypes || (exports.BaseTypes = {}));


/***/ }),

/***/ "./src/DataType.ts":
/*!*************************!*\
  !*** ./src/DataType.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
class PrimType {
    constructor(name, C) {
        this.name = name;
        this.C = C;
    }
}
exports.PrimType = PrimType;
// Neither of these is currently reflective because of non-standard fields.
class DataType {
    constructor(name, elimC, ctrs, exprC̅, explC̅) {
        this.name = name;
        this.elimC = elimC;
        this.ctrs = ctrs;
        this.exprC̅ = exprC̅;
        this.explC̅ = explC̅;
    }
}
exports.DataType = DataType;
// Constructor of a datatype, not to be confused with an instance of such a thing (DataValue) or name of such a thing
// (Lex.Ctr). Fields have a total ordering given by the order of definition in the corresponding class.
class Ctr {
    constructor(C, f̅) {
        this.C = C;
        this.f̅ = f̅;
    }
    get arity() {
        return this.f̅.length;
    }
    get c() {
        return this.C.name;
    }
}
exports.Ctr = Ctr;
function ctrFor(c) {
    return Core_1.__nonNull(exports.ctrToDataType.get(c), `Unknown constructor ${c}.`).ctrs.get(c);
}
exports.ctrFor = ctrFor;
function explClass(C) {
    return Core_1.__nonNull(exports.ctrToDataType.get(C.name)).explC̅.get(C.name);
}
exports.explClass = explClass;
function exprClass(C) {
    return Core_1.__nonNull(exports.ctrToDataType.get(C.name)).exprC̅.get(C.name);
}
exports.exprClass = exprClass;
function valueClass(C) {
    return ctrFor(C.name).C;
}
exports.valueClass = valueClass;
// Populated by initDataTypes(). Constructors are not yet first-class.
exports.types = new Map;
exports.ctrToDataType = new Map;
exports.elimToDataType = new Map;
// See https://stackoverflow.com/questions/33605775 for the dynamic class-naming idiom.
function initDataType(D, C̅) {
    C̅.sort((C, Cʹ) => C.name.localeCompare(Cʹ.name)); // consistent with Str.leq
    const ctrs = C̅.map((C) => [C.name, new Ctr(C, Value_1.fields(new C))]), elimC = {
        [D.name]: class extends Match_1.DataElim {
            constructor() {
                super();
                // lexicographical order hopefully preserved by getOwnPropertyNames()
                C̅.forEach((C) => {
                    this[C.name] = Value_1._;
                });
            }
        }
    }[D.name], exprC̅ = ctrs.map(([c_str, c]) => {
        return [c_str, {
                [c_str]: class extends Expr_1.Expr.DataExpr {
                    constructor() {
                        super();
                        c.f̅.forEach((f) => {
                            this[f] = Value_1._;
                        });
                    }
                }
            }[c_str]];
    }), explC̅ = ctrs.map(([c_str, c]) => {
        return [c_str, {
                [c_str]: class extends Expl_1.Expl.DataExpl {
                    constructor() {
                        super();
                        c.f̅.forEach((f) => {
                            this[f] = Value_1._;
                        });
                    }
                }
            }[c_str]];
    }), d = new DataType(Versioned_1.str(D.name)(Versioned_1.ν()), elimC, new Map(ctrs), new Map(exprC̅), new Map(explC̅));
    C̅.forEach((C) => {
        exports.ctrToDataType.set(C.name, d);
    });
    exports.elimToDataType.set(D.name, d);
    exports.types.set(d.name.val, d);
}
exports.initDataType = initDataType;
exports.types.set(Value_1.Num.name, new PrimType(Versioned_1.str(Value_1.Num.name)(Versioned_1.ν()), Value_1.Num));
exports.types.set(Value_1.Str.name, new PrimType(Versioned_1.str(Value_1.Str.name)(Versioned_1.ν()), Value_1.Str));


/***/ }),

/***/ "./src/DataValue.ts":
/*!**************************!*\
  !*** ./src/DataValue.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
// Value of a datatype constructor; children are always user-level values (i.e. not ES6 primitives).
class DataValue extends Value_1.Value {
    get ctr() {
        return Core_1.className(this);
    }
    __child(k) {
        return super.__child(k);
    }
    get __children() {
        return super.__children;
    }
}
exports.DataValue = DataValue;
// Here to break cyclic dependency.
class ExplValue extends DataValue {
    constructor() {
        super(...arguments);
        this.t = Value_1._;
        this.v = Value_1._;
    }
}
exports.ExplValue = ExplValue;
function explValue(t, v) {
    return Value_1.make(ExplValue, t, v);
}
exports.explValue = explValue;


/***/ }),

/***/ "./src/Delta.ts":
/*!**********************!*\
  !*** ./src/Delta.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
function leq(s1, s2) {
    return Object.keys(s1).every((prop) => {
        return s2.hasOwnProperty(prop) && s1[prop].before === s2[prop].before && s1[prop].after === s2[prop].after;
    });
}
exports.leq = leq;
function empty(ẟ) {
    return Value_1.fields(ẟ).length === 0;
}
class Deltas {
    constructor() {
        this.ẟ̅ = new Map();
    }
    get size() {
        return this.ẟ̅.size;
    }
    // Change sets must be disjoint at a given revision. Because of sharing within a revision, 
    // a node may first appear new (or reclassified) and then later appear changed, but the 
    // subsequent change sets must be empty.
    changed(v, s_ẟ) {
        let v_ẟ = this.ẟ̅.get(v);
        if (v_ẟ === undefined) {
            this.ẟ̅.set(v, new Change(s_ẟ));
        }
        else if (v_ẟ instanceof Change) {
            Value_1.mergeInto(v_ẟ.changed, s_ẟ);
        }
        else if (v_ẟ instanceof New || v_ẟ instanceof Reclassify) {
            Core_1.assert(empty(s_ẟ));
        }
        else {
            Core_1.absurd();
        }
    }
    // A value cannot be reclassified twice at the same revision.
    reclassified(v) {
        let v_ẟ = this.ẟ̅.get(v);
        if (v_ẟ === undefined) {
            this.ẟ̅.set(v, new Reclassify());
        }
        else {
            Core_1.absurd();
        }
    }
    // A value cannot be created twice at the same revision.
    created(v) {
        let v_ẟ = this.ẟ̅.get(v);
        if (v_ẟ === undefined) {
            this.ẟ̅.set(v, new New());
        }
        else {
            Core_1.absurd();
        }
    }
    clear() {
        this.ẟ̅.clear();
    }
}
exports.Deltas = Deltas;
exports.__deltas = new Deltas();
class Delta {
    eq(ẟ) {
        return this.leq(ẟ) && ẟ.leq(this);
    }
}
exports.Delta = Delta;
class New extends Delta {
    constructor() {
        super();
    }
    leq(ẟ) {
        return ẟ instanceof New;
    }
}
exports.New = New;
class Change extends Delta {
    constructor(changed) {
        super();
        this.changed = changed;
    }
    leq(ẟ) {
        return ẟ instanceof Change && leq(this.changed, ẟ.changed);
    }
    hasChanged(prop) {
        return Value_1.fields(this.changed).includes(prop);
    }
}
exports.Change = Change;
// Constructor has changed, and therefore fields may not align. More sophisticated reclassification
// delta could allow for fields to be shared when an object changes class.
class Reclassify extends Delta {
    constructor() {
        super();
    }
    leq(ẟ) {
        return ẟ instanceof Reclassify;
    }
}
exports.Reclassify = Reclassify;


/***/ }),

/***/ "./src/Env.ts":
/*!********************!*\
  !*** ./src/Env.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
// Environments are snoc lists; the values are "explained" because usage information is recorded on traces.
class Env extends DataValue_1.DataValue {
    get(k) {
        if (this instanceof EmptyEnv) {
            return undefined;
        }
        else if (this instanceof ExtendEnv) {
            if (this.k.val === k.val) {
                return this.tv;
            }
            else {
                return this.ρ.get(k);
            }
        }
        else {
            return Core_1.absurd();
        }
    }
    has(k) {
        return this.get(k) !== undefined;
    }
    static singleton(k, tv) {
        return extendEnv(emptyEnv(), k, tv);
    }
    concat(ρ) {
        if (ρ instanceof EmptyEnv) {
            return this;
        }
        else if (ρ instanceof ExtendEnv) {
            return extendEnv(this.concat(ρ.ρ), ρ.k, ρ.tv);
        }
        else {
            return Core_1.absurd();
        }
    }
    values() {
        const tvs = [];
        for (let ρ = this; ρ instanceof ExtendEnv; ρ = ρ.ρ) {
            tvs.push(ρ.tv);
        }
        return tvs;
    }
}
exports.Env = Env;
class EmptyEnv extends Env {
}
exports.EmptyEnv = EmptyEnv;
function emptyEnv() {
    return Value_1.make(EmptyEnv);
}
exports.emptyEnv = emptyEnv;
class ExtendEnv extends Env {
    constructor() {
        super(...arguments);
        this.ρ = Value_1._;
        this.k = Value_1._;
        this.tv = Value_1._;
    }
}
exports.ExtendEnv = ExtendEnv;
function extendEnv(ρ, k, tv) {
    return Value_1.make(ExtendEnv, ρ, k, tv);
}
exports.extendEnv = extendEnv;


/***/ }),

/***/ "./src/Eval.ts":
/*!*********************!*\
  !*** ./src/Eval.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ./util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ./util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ./Annotation */ "./src/Annotation.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const FiniteMap_1 = __webpack_require__(/*! ./FiniteMap */ "./src/FiniteMap.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Primitive_1 = __webpack_require__(/*! ./Primitive */ "./src/Primitive.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
var Eval;
(function (Eval) {
    // ρ plus bindings in δ are closing for f.
    class Closure extends DataValue_1.DataValue {
        constructor() {
            super(...arguments);
            this.ρ = Value_1._;
            this.δ = Value_1._;
            this.f = Value_1._;
        }
    }
    Eval.Closure = Closure;
    function closure(ρ, δ, f) {
        return Versioned_1.at(Closure, ρ, δ, f);
    }
    // Environments are snoc-lists, so this (inconsequentially) reverses declaration order.
    function recDefs(δ_0, ρ, δ) {
        if (BaseTypes_1.Cons.is(δ)) {
            const def = δ.head, [δₜ, ρ_ext] = recDefs(δ_0, ρ, δ.tail), k = Value_1.memoId(recDefs, arguments), tf = DataValue_1.explValue(Expl_1.Expl.fun(def.σ)(k.tag("t")), closure(ρ, δ_0, def.σ)(k.tag("v")));
            return [BaseTypes_1.cons(Expl_1.Expl.recDef(def.x, tf)(k), δₜ), Env_1.extendEnv(ρ_ext, def.x, tf)];
        }
        else if (BaseTypes_1.Nil.is(δ)) {
            return [BaseTypes_1.nil(), Env_1.emptyEnv()];
        }
        else {
            return Core_1.absurd();
        }
    }
    function recDefs_(dir, δ) {
        if (BaseTypes_1.Cons.is(δ)) {
            Array_1.zip(δ.head.tf.v.δ.toArray(), δ.toArray()).map(([def, defₜ]) => {
                Core_1.assert(def.x.eq(defₜ.x));
                if (dir === Annotation_1.Direction.Fwd) {
                    Annotation_1.setα(Annotation_1.isα(def), defₜ.tf);
                }
                else {
                    Annotation_1.setjoinα(Annotation_1.isα(defₜ.tf), def);
                }
            });
        }
        else if (BaseTypes_1.Nil.is(δ)) {
        }
        else {
            return Core_1.absurd();
        }
    }
    // Here we mustn't invert definition order.
    function defs(ρ, def̅, ρ_ext) {
        const k = Value_1.memoId(defs, arguments);
        if (BaseTypes_1.Cons.is(def̅)) {
            const def = def̅.head;
            if (def instanceof Expr_1.Expr.Let) {
                const tv = eval_(ρ.concat(ρ_ext), def.e), [def̅ₜ, ρ_extʹ] = defs(ρ, def̅.tail, Env_1.extendEnv(ρ_ext, def.x, tv));
                return [BaseTypes_1.cons(Expl_1.Expl.let_(def.x, tv)(k), def̅ₜ), ρ_extʹ];
            }
            else if (def instanceof Expr_1.Expr.Prim) {
                // first-class primitives currently happen to be unary
                if (Primitive_1.unaryOps.has(def.x.val)) {
                    const t_op = Primitive_1.unaryOps.get(def.x.val), [def̅ₜ, ρ_extʹ] = defs(ρ, def̅.tail, Env_1.extendEnv(ρ_ext, def.x, t_op));
                    return [BaseTypes_1.cons(Expl_1.Expl.prim(def.x, t_op)(k), def̅ₜ), ρ_extʹ];
                }
                else {
                    return Core_1.userError(`No implementation found for primitive "${def.x.val}".`);
                }
            }
            else if (def instanceof Expr_1.Expr.LetRec) {
                const [δ, ρᵟ] = recDefs(def.δ, ρ.concat(ρ_ext), def.δ), [def̅ₜ, ρ_extʹ] = defs(ρ, def̅.tail, ρ_ext.concat(ρᵟ));
                return [BaseTypes_1.cons(Expl_1.Expl.letRec(δ)(k), def̅ₜ), ρ_extʹ];
            }
            else {
                return Core_1.absurd();
            }
        }
        else if (BaseTypes_1.Nil.is(def̅)) {
            return [BaseTypes_1.nil(), ρ_ext];
        }
        else {
            return Core_1.absurd();
        }
    }
    Eval.defs = defs;
    function defs_fwd(def̅, def̅ₜ) {
        Array_1.zip(def̅.toArray(), def̅ₜ.toArray()).forEach(([def, defₜ]) => {
            if (def instanceof Expr_1.Expr.Let && defₜ instanceof Expl_1.Expl.Let) {
                eval_fwd(def.e, defₜ.tv);
                Annotation_1.setmeetα(Annotation_1.isα(def), defₜ.tv);
            }
            else if (def instanceof Expr_1.Expr.Prim && defₜ instanceof Expl_1.Expl.Prim) {
                Annotation_1.setα(Annotation_1.isα(def), defₜ.t_op);
            }
            else if (def instanceof Expr_1.Expr.LetRec && defₜ instanceof Expl_1.Expl.LetRec) {
                recDefs_(Annotation_1.Direction.Fwd, defₜ.δ);
            }
            else {
                Core_1.absurd();
            }
        });
    }
    function defs_bwd(def̅, def̅ₜ) {
        Array_1.zip(def̅.toArray(), def̅ₜ.toArray()).reverse().forEach(([def, defₜ]) => {
            if (def instanceof Expr_1.Expr.Let && defₜ instanceof Expl_1.Expl.Let) {
                Annotation_1.setjoinα(Annotation_1.isα(defₜ.tv), def);
                eval_bwd(def.e, defₜ.tv);
            }
            else if (def instanceof Expr_1.Expr.Prim && defₜ instanceof Expl_1.Expl.Prim) {
                Annotation_1.setjoinα(Annotation_1.isα(defₜ.t_op), def);
            }
            else if (def instanceof Expr_1.Expr.LetRec && defₜ instanceof Expl_1.Expl.LetRec) {
                recDefs_(Annotation_1.Direction.Bwd, defₜ.δ);
            }
            else {
                Core_1.absurd();
            }
        });
    }
    function eval_(ρ, e) {
        const k = Value_1.memoId(eval_, arguments), [kₜ, kᵥ] = [k.tag("t"), k.tag("v")];
        if (e instanceof Expr_1.Expr.ConstNum) {
            return DataValue_1.explValue(Expl_1.Expl.const_()(kₜ), Versioned_1.num(e.val.val)(kᵥ));
        }
        else if (e instanceof Expr_1.Expr.ConstStr) {
            return DataValue_1.explValue(Expl_1.Expl.const_()(kₜ), Versioned_1.str(e.val.val)(kᵥ));
        }
        else if (e instanceof Expr_1.Expr.Fun) {
            return DataValue_1.explValue(Expl_1.Expl.fun(e.σ)(kₜ), closure(ρ, BaseTypes_1.nil(), e.σ)(kᵥ));
        }
        else if (e instanceof Expr_1.Expr.DataExpr) {
            const tv̅ = e.__children.map((e) => eval_(ρ, e)), C = DataType_1.valueClass(Core_1.classOf(e)), t = Versioned_1.at(DataType_1.explClass(C), ...tv̅.map(({ t }) => t))(kₜ), v = Versioned_1.at(C, ...tv̅.map(({ v }) => v))(kᵥ);
            return DataValue_1.explValue(t, v);
        }
        else if (e instanceof Expr_1.Expr.Quote) {
            return DataValue_1.explValue(Expl_1.Expl.quote()(kₜ), e.e);
        }
        else if (e instanceof Expr_1.Expr.Var) {
            if (ρ.has(e.x)) {
                const { t, v } = ρ.get(e.x);
                return DataValue_1.explValue(Expl_1.Expl.var_(e.x, t)(kₜ), v);
            }
            else {
                return Core_1.userError(`Variable "${e.x.val}" not found.`);
            }
        }
        else if (e instanceof Expr_1.Expr.App) {
            const [tf, tu] = [eval_(ρ, e.f), eval_(ρ, e.e)], [v, u] = [tf.v, tu.v];
            if (v instanceof Closure) {
                const [δ, ρᵟ] = recDefs(v.δ, v.ρ, v.δ), [ρʹ, ξκ] = v.f.apply(tu), { t, v: vʹ } = eval_(v.ρ.concat(ρᵟ.concat(ρʹ)), ξκ.κ);
                return DataValue_1.explValue(Expl_1.Expl.app(tf, tu, δ, ξκ, t)(kₜ), vʹ);
            }
            else if (v instanceof Primitive_1.UnaryOp) {
                if (u instanceof Value_1.Num || u instanceof Value_1.Str) {
                    return DataValue_1.explValue(Expl_1.Expl.unaryApp(tf, tu)(kₜ), v.op(u)(kᵥ));
                }
                else {
                    return Core_1.userError(`Applying "${v.name}" to non-primitive value.`, u);
                }
            }
            else {
                return Core_1.userError(`Cannot apply ${Core_1.className(v)}`);
            }
        }
        else 
        // Binary operators are (currently) "syntax", rather than first-class.
        if (e instanceof Expr_1.Expr.BinaryApp) {
            if (Primitive_1.binaryOps.has(e.opName.val)) {
                const op = Primitive_1.binaryOps.get(e.opName.val).v, [tv1, tv2] = [eval_(ρ, e.e1), eval_(ρ, e.e2)], [v1, v2] = [tv1.v, tv2.v];
                if ((v1 instanceof Value_1.Num || v1 instanceof Value_1.Str) && (v2 instanceof Value_1.Num || v2 instanceof Value_1.Str)) {
                    const k = Value_1.memoId(op.op, [v1, v2]);
                    return DataValue_1.explValue(Expl_1.Expl.binaryApp(tv1, e.opName, tv2)(kₜ), op.op(v1, v2)(k));
                }
                else {
                    return Core_1.userError(`Applying "${e.opName.val}" to non-primitive value.`, v1, v2);
                }
            }
            else {
                return Core_1.userError(`Binary primitive "${e.opName.val}" not found.`);
            }
        }
        else if (e instanceof Expr_1.Expr.Defs) {
            const [def̅ₜ, ρʹ] = defs(ρ, e.def̅, Env_1.emptyEnv()), { t, v } = eval_(ρ.concat(ρʹ), e.e);
            return DataValue_1.explValue(Expl_1.Expl.defs(def̅ₜ, t)(kₜ), v);
        }
        else if (e instanceof Expr_1.Expr.MatchAs) {
            const tu = eval_(ρ, e.e), [ρʹ, ξκ] = e.σ.apply(tu), { t, v } = eval_(ρ.concat(ρʹ), ξκ.κ);
            return DataValue_1.explValue(Expl_1.Expl.matchAs(tu, ξκ, t)(kₜ), v);
        }
        else if (e instanceof Expr_1.Expr.Typematch) {
            const tu = eval_(ρ, e.e), d = DataType_1.ctrToDataType.get(Core_1.className(tu.v)) || DataType_1.types.get(Core_1.className(tu.v)), eʹ = FiniteMap_1.get(e.cases, d.name);
            if (eʹ === undefined) {
                return Core_1.userError(`Typecase mismatch: no clause for ${Core_1.className(tu.v)}.`);
            }
            else {
                const { t, v } = eval_(ρ, eʹ);
                return DataValue_1.explValue(Expl_1.Expl.typematch(tu, d.name, t)(kₜ), v);
            }
        }
        else {
            return Core_1.absurd(`Unimplemented expression form: ${Core_1.className(e)}.`);
        }
    }
    Eval.eval_ = eval_;
    function eval_fwd(e, tv) {
        const { t, v } = tv;
        if (t instanceof Expl_1.Expl.Const && (v instanceof Value_1.Num || v instanceof Value_1.Str)) {
            Annotation_1.setα(Annotation_1.isα(e), tv);
        }
        else if (t instanceof Expl_1.Expl.Fun && v instanceof Closure) {
            Annotation_1.setα(Annotation_1.isα(e), tv);
        }
        else if (t instanceof Expl_1.Expl.Quote) {
            Annotation_1.setα(Annotation_1.isα(e), tv);
        }
        else if (t instanceof Expl_1.Expl.Var) {
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            if (v instanceof DataValue_1.DataValue) {
                const eʹ = Core_1.as(e, Expr_1.Expr.DataExpr);
                Array_1.zip(Expl_1.Expl.explChildren(t, v), eʹ.__children).map(([tv, e]) => eval_fwd(e, tv));
                Annotation_1.setα(Annotation_1.isα(e), tv);
            }
            else {
                Core_1.absurd();
            }
        }
        else if (t instanceof Expl_1.Expl.App) {
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_fwd(eʹ.f, t.tf);
            eval_fwd(eʹ.e, t.tu);
            recDefs_(Annotation_1.Direction.Fwd, t.δ);
            eval_fwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(t.tf), Match_1.apply_fwd(t.ξ), Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.UnaryApp) {
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_fwd(eʹ.f, t.tf);
            eval_fwd(eʹ.e, t.tv);
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(t.tf), Annotation_1.isα(t.tv), Annotation_1.isα(e)), tv);
        }
        else if (t instanceof Expl_1.Expl.BinaryApp) {
            const eʹ = Core_1.as(e, Expr_1.Expr.BinaryApp);
            eval_fwd(eʹ.e1, t.tv1);
            eval_fwd(eʹ.e2, t.tv2);
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(t.tv1), Annotation_1.isα(t.tv2), Annotation_1.isα(e)), tv);
        }
        else if (t instanceof Expl_1.Expl.Defs) {
            const eʹ = Core_1.as(e, Expr_1.Expr.Defs);
            defs_fwd(eʹ.def̅, t.def̅);
            eval_fwd(eʹ.e, DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.MatchAs) {
            const eʹ = Core_1.as(e, Expr_1.Expr.MatchAs);
            eval_fwd(eʹ.e, t.tu);
            eval_fwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Match_1.apply_fwd(t.ξ), Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else if (t instanceof Expl_1.Expl.Typematch) {
            const eʹ = Core_1.as(e, Expr_1.Expr.Typematch);
            eval_fwd(eʹ.e, t.tu);
            eval_fwd(FiniteMap_1.get(eʹ.cases, t.d), DataValue_1.explValue(t.t, v));
            Annotation_1.setα(Lattice_1.bool_.meet(Annotation_1.isα(e), Annotation_1.isα(DataValue_1.explValue(t.t, v))), tv);
        }
        else {
            Core_1.absurd();
        }
    }
    Eval.eval_fwd = eval_fwd;
    // Avoid excessive joins via a merging implementation; requires all annotations to have been cleared first.
    function eval_bwd(e, tv) {
        const { t, v } = tv;
        if (t instanceof Expl_1.Expl.Const && (v instanceof Value_1.Num || v instanceof Value_1.Str)) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Fun && v instanceof Closure) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            if (v instanceof DataValue_1.DataValue) {
                const eʹ = Core_1.as(e, Expr_1.Expr.DataExpr);
                // reverse order but shouldn't matter in absence of side-effects:
                Array_1.zip(Expl_1.Expl.explChildren(t, v), eʹ.__children).map(([tv, e]) => eval_bwd(e, tv));
                Annotation_1.setjoinα(Annotation_1.isα(tv), e);
            }
            else {
                Core_1.absurd();
            }
        }
        else if (t instanceof Expl_1.Expl.Quote) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Var) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.App) {
            Core_1.assert(t.tf.v instanceof Closure);
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            eval_bwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Match_1.apply_bwd(t.ξ, Annotation_1.isα(tv));
            recDefs_(Annotation_1.Direction.Bwd, t.δ);
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tf);
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_bwd(eʹ.f, t.tf);
            eval_bwd(eʹ.e, t.tu);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.UnaryApp) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tf);
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tv);
            const eʹ = Core_1.as(e, Expr_1.Expr.App);
            eval_bwd(eʹ.f, t.tf);
            eval_bwd(eʹ.e, t.tv);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.BinaryApp) {
            Core_1.assert(Primitive_1.binaryOps.has(t.opName.val));
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tv1);
            Annotation_1.setjoinα(Annotation_1.isα(tv), t.tv2);
            const eʹ = Core_1.as(e, Expr_1.Expr.BinaryApp);
            eval_bwd(eʹ.e1, t.tv1);
            eval_bwd(eʹ.e2, t.tv2);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Defs) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            const eʹ = Core_1.as(e, Expr_1.Expr.Defs);
            eval_bwd(eʹ.e, DataValue_1.explValue(t.t, v));
            defs_bwd(eʹ.def̅, t.def̅);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.MatchAs) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            const eʹ = Core_1.as(e, Expr_1.Expr.MatchAs);
            eval_bwd(t.ξ.κ, DataValue_1.explValue(t.t, v));
            Match_1.apply_bwd(t.ξ, Annotation_1.isα(tv));
            eval_bwd(eʹ.e, t.tu);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else if (t instanceof Expl_1.Expl.Typematch) {
            Annotation_1.setjoinα(Annotation_1.isα(tv), DataValue_1.explValue(t.t, v));
            const eʹ = Core_1.as(e, Expr_1.Expr.Typematch);
            eval_bwd(FiniteMap_1.get(eʹ.cases, t.d), DataValue_1.explValue(t.t, v));
            eval_bwd(eʹ.e, t.tu);
            Annotation_1.setjoinα(Annotation_1.isα(tv), e);
        }
        else {
            Core_1.absurd();
        }
    }
    Eval.eval_bwd = eval_bwd;
})(Eval = exports.Eval || (exports.Eval = {}));
DataType_1.initDataType(Expr_1.Expr.Expr, [Expr_1.Expr.App, Expr_1.Expr.BinaryApp, Expr_1.Expr.ConstNum, Expr_1.Expr.ConstStr, Expr_1.Expr.DataExpr, Expr_1.Expr.Defs, Expr_1.Expr.Fun, Expr_1.Expr.MatchAs, Expr_1.Expr.Quote, Expr_1.Expr.Var]);


/***/ }),

/***/ "./src/Expl.ts":
/*!*********************!*\
  !*** ./src/Expl.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
var Expl;
(function (Expl_1) {
    class Expl extends DataValue_1.DataValue {
    }
    Expl_1.Expl = Expl;
    class NonTerminal extends Expl {
    }
    Expl_1.NonTerminal = NonTerminal;
    class Terminal extends Expl {
    }
    Expl_1.Terminal = Terminal;
    class App extends NonTerminal {
        constructor() {
            super(...arguments);
            this.tf = Value_1._;
            this.tu = Value_1._;
            this.δ = Value_1._; // additional recursive functions bound at this step
            this.ξ = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.App = App;
    function app(tf, tu, δ, ξ, t) {
        return Versioned_1.at(App, tf, tu, δ, ξ, t);
    }
    Expl_1.app = app;
    class UnaryApp extends Terminal {
        constructor() {
            super(...arguments);
            this.tf = Value_1._;
            this.tv = Value_1._;
        }
    }
    Expl_1.UnaryApp = UnaryApp;
    function unaryApp(tf, tv) {
        return Versioned_1.at(UnaryApp, tf, tv);
    }
    Expl_1.unaryApp = unaryApp;
    class BinaryApp extends Terminal {
        constructor() {
            super(...arguments);
            this.tv1 = Value_1._;
            this.opName = Value_1._;
            this.tv2 = Value_1._;
        }
    }
    Expl_1.BinaryApp = BinaryApp;
    function binaryApp(tv1, opName, tv2) {
        return Versioned_1.at(BinaryApp, tv1, opName, tv2);
    }
    Expl_1.binaryApp = binaryApp;
    // Has a concrete subclass for each datatype.
    class DataExpl extends Terminal {
        get ctr() {
            return Core_1.className(this);
        }
        get __children() {
            return super.__children;
        }
    }
    Expl_1.DataExpl = DataExpl;
    class Def extends DataValue_1.DataValue {
    }
    Expl_1.Def = Def;
    class Let extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.tv = Value_1._;
        }
    }
    Expl_1.Let = Let;
    function let_(x, tv) {
        return Versioned_1.at(Let, x, tv);
    }
    Expl_1.let_ = let_;
    class Prim extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.t_op = Value_1._;
        }
    }
    Expl_1.Prim = Prim;
    function prim(x, t_op) {
        return Versioned_1.at(Prim, x, t_op);
    }
    Expl_1.prim = prim;
    class RecDef extends DataValue_1.DataValue {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.tf = Value_1._;
        }
    }
    Expl_1.RecDef = RecDef;
    function recDef(x, tf) {
        return Versioned_1.at(RecDef, x, tf);
    }
    Expl_1.recDef = recDef;
    class LetRec extends Def {
        constructor() {
            super(...arguments);
            this.δ = Value_1._;
        }
    }
    Expl_1.LetRec = LetRec;
    function letRec(δ) {
        return Versioned_1.at(LetRec, δ);
    }
    Expl_1.letRec = letRec;
    class Defs extends NonTerminal {
        constructor() {
            super(...arguments);
            this.def̅ = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.Defs = Defs;
    function defs(def̅, t) {
        return Versioned_1.at(Defs, def̅, t);
    }
    Expl_1.defs = defs;
    class Const extends Terminal {
    }
    Expl_1.Const = Const;
    function const_() {
        return Versioned_1.at(Const);
    }
    Expl_1.const_ = const_;
    class Fun extends Terminal {
        constructor() {
            super(...arguments);
            this.σ = Value_1._;
        }
    }
    Expl_1.Fun = Fun;
    function fun(σ) {
        return Versioned_1.at(Fun, σ);
    }
    Expl_1.fun = fun;
    class MatchAs extends NonTerminal {
        constructor() {
            super(...arguments);
            this.tu = Value_1._;
            this.ξ = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.MatchAs = MatchAs;
    function matchAs(tu, ξ, t) {
        return Versioned_1.at(MatchAs, tu, ξ, t);
    }
    Expl_1.matchAs = matchAs;
    class Quote extends Terminal {
    }
    Expl_1.Quote = Quote;
    function quote() {
        return Versioned_1.at(Quote);
    }
    Expl_1.quote = quote;
    class Typematch extends NonTerminal {
        constructor() {
            super(...arguments);
            this.tu = Value_1._;
            this.d = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.Typematch = Typematch;
    function typematch(tu, d, t) {
        return Versioned_1.at(Typematch, tu, d, t);
    }
    Expl_1.typematch = typematch;
    class Var extends NonTerminal {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.t = Value_1._;
        }
    }
    Expl_1.Var = Var;
    function var_(x, t) {
        return Versioned_1.at(Var, x, t);
    }
    Expl_1.var_ = var_;
    // Should probably do a better job of restricting k to be a bona fide field name.
    function explChild(t, v, prop) {
        if (t instanceof Terminal) {
            Core_1.assert(t instanceof DataExpl);
            return DataValue_1.explValue(t.__child(prop), v.__child(prop));
        }
        else if (t instanceof NonTerminal) {
            return explChild(t.t, v, prop);
        }
        else {
            // Primitive applications are currently "terminal" forms, which is technically inconsistent with the fact 
            // that they can return structured data. In practice this doesn't matter because they only return values 
            // like True and False, which have no children. Probably primitives should be non-terminal.
            return Core_1.absurd();
        }
    }
    Expl_1.explChild = explChild;
    function explChildren(t, v) {
        return Value_1.fields(v).map(k => explChild(t, v, k));
    }
    Expl_1.explChildren = explChildren;
})(Expl = exports.Expl || (exports.Expl = {}));


/***/ }),

/***/ "./src/Expr.ts":
/*!*********************!*\
  !*** ./src/Expr.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Set_1 = __webpack_require__(/*! ./util/Set */ "./src/util/Set.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Constants used for parsing, and also for toString() implementations.
exports.strings = {
    arrow: "→",
    as: "as",
    bracketL: "[",
    bracketR: "]",
    comma: ",",
    curlyL: "{",
    curlyR: "}",
    ellipsis: "...",
    equals: "=",
    fun: "fun",
    in_: "in",
    let_: "let",
    letRec: "letrec",
    match: "match",
    primitive: "primitive",
    parenL: "(",
    parenR: ")",
    quotes: '"',
    semicolon: ";",
    typematch: "typematch"
};
var Expr;
(function (Expr_1) {
    class SyntaxNode extends DataValue_1.DataValue {
    }
    Expr_1.SyntaxNode = SyntaxNode;
    class Expr extends SyntaxNode {
    }
    Expr_1.Expr = Expr;
    class App extends Expr {
        constructor() {
            super(...arguments);
            this.f = Value_1._;
            this.e = Value_1._;
        }
    }
    Expr_1.App = App;
    function app(f, e) {
        return Versioned_1.at(App, f, e);
    }
    Expr_1.app = app;
    class BinaryApp extends Expr {
        constructor() {
            super(...arguments);
            this.e1 = Value_1._;
            this.opName = Value_1._;
            this.e2 = Value_1._;
        }
    }
    Expr_1.BinaryApp = BinaryApp;
    function binaryApp(e1, opName, e2) {
        return Versioned_1.at(BinaryApp, e1, opName, e2);
    }
    Expr_1.binaryApp = binaryApp;
    class ConstNum extends Expr {
        constructor() {
            super(...arguments);
            this.val = Value_1._;
        }
    }
    Expr_1.ConstNum = ConstNum;
    function constNum(val) {
        return Versioned_1.at(ConstNum, val);
    }
    Expr_1.constNum = constNum;
    class ConstStr extends Expr {
        constructor() {
            super(...arguments);
            this.val = Value_1._;
        }
    }
    Expr_1.ConstStr = ConstStr;
    function constStr(val) {
        return Versioned_1.at(ConstStr, val);
    }
    Expr_1.constStr = constStr;
    // Has a concrete subclass for each datatype. Should this be parameterised by T extends DataValue?
    class DataExpr extends Expr {
        get ctr() {
            return Core_1.className(this);
        }
        __child(prop) {
            return super.__child(prop);
        }
        get __children() {
            return super.__children;
        }
    }
    Expr_1.DataExpr = DataExpr;
    class Def extends SyntaxNode {
    }
    Expr_1.Def = Def;
    class Let extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.e = Value_1._;
        }
    }
    Expr_1.Let = Let;
    function let_(x, e) {
        return Versioned_1.at(Let, x, e);
    }
    Expr_1.let_ = let_;
    class Prim extends Def {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
        }
    }
    Expr_1.Prim = Prim;
    function prim(x) {
        return Versioned_1.at(Prim, x);
    }
    Expr_1.prim = prim;
    class RecDef extends SyntaxNode {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
            this.σ = Value_1._;
        }
    }
    Expr_1.RecDef = RecDef;
    function recDef(x, σ) {
        return Versioned_1.at(RecDef, x, σ);
    }
    Expr_1.recDef = recDef;
    class LetRec extends Def {
        constructor() {
            super(...arguments);
            this.δ = Value_1._;
        }
    }
    Expr_1.LetRec = LetRec;
    function letRec(δ) {
        return Versioned_1.at(LetRec, δ);
    }
    Expr_1.letRec = letRec;
    class Defs extends Expr {
        constructor() {
            super(...arguments);
            this.def̅ = Value_1._;
            this.e = Value_1._;
        }
    }
    Expr_1.Defs = Defs;
    function defs(def̅, e) {
        return Versioned_1.at(Defs, def̅, e);
    }
    Expr_1.defs = defs;
    class Fun extends Expr {
        constructor() {
            super(...arguments);
            this.σ = Value_1._;
        }
    }
    Expr_1.Fun = Fun;
    function fun(σ) {
        return Versioned_1.at(Fun, σ);
    }
    Expr_1.fun = fun;
    class MatchAs extends Expr {
        constructor() {
            super(...arguments);
            this.e = Value_1._;
            this.σ = Value_1._;
        }
    }
    Expr_1.MatchAs = MatchAs;
    function matchAs(e, σ) {
        return Versioned_1.at(MatchAs, e, σ);
    }
    Expr_1.matchAs = matchAs;
    class Quote extends Expr {
        constructor() {
            super(...arguments);
            this.e = Value_1._;
        }
    }
    Expr_1.Quote = Quote;
    function quote(e) {
        return Versioned_1.at(Quote, e);
    }
    Expr_1.quote = quote;
    // Bring in line with the current eliminator design, i.e. optimise into an object?
    class Typematch extends Expr {
        constructor() {
            super(...arguments);
            this.e = Value_1._;
            this.cases = Value_1._;
        }
    }
    Expr_1.Typematch = Typematch;
    function typematch(e, cases) {
        return Versioned_1.at(Typematch, e, cases);
    }
    Expr_1.typematch = typematch;
    class Var extends Expr {
        constructor() {
            super(...arguments);
            this.x = Value_1._;
        }
    }
    Expr_1.Var = Var;
    function var_(x) {
        return Versioned_1.at(Var, x);
    }
    Expr_1.var_ = var_;
    // used by Wrattler
    function freeVars(e) {
        if (e instanceof ConstNum) {
            return new Set();
        }
        else if (e instanceof ConstStr) {
            return new Set();
        }
        else if (e instanceof Fun) {
            return freeVarsElim(e.σ);
        }
        else if (e instanceof DataExpr) {
            return Set_1.union(...e.__children.map(freeVars));
        }
        else if (e instanceof Quote) {
            return freeVars(e.e);
        }
        else if (e instanceof Var) {
            return new Set([e.x.val]);
        }
        else if (e instanceof App) {
            return Set_1.union(freeVars(e.f), freeVars(e.e));
        }
        else if (e instanceof BinaryApp) {
            return Set_1.union(freeVars(e.e1), freeVars(e.e2));
        }
        else if (e instanceof Defs) {
            const [bound, free] = freeVarsDefs(e.def̅, new Set());
            return Set_1.union(Set_1.diff(freeVars(e.e), bound), free);
        }
        else if (e instanceof MatchAs) {
            return Set_1.union(freeVars(e.e), freeVarsElim(e.σ));
        }
        else if (e instanceof Typematch) {
            return Set_1.union(freeVars(e.e), ...e.cases.toArray().map(({ snd }) => freeVars(snd)));
        }
        else {
            return Core_1.absurd();
        }
    }
    Expr_1.freeVars = freeVars;
    function freeVarsCont(κ) {
        if (κ instanceof Expr) {
            return freeVars(κ);
        }
        else if (κ instanceof Match_1.Elim) {
            return freeVarsElim(κ);
        }
        else {
            return Core_1.absurd();
        }
    }
    function freeVarsElim(σ) {
        if (Match_1.VarElim.is(σ)) {
            return Set_1.diff(freeVarsCont(σ.κ), new Set([σ.x.val]));
        }
        else if (Match_1.DataElim.is(σ)) {
            return Set_1.union(...σ.__children.map(freeVarsCont));
        }
        else {
            return Core_1.absurd();
        }
    }
    // (bound, free) vars - not necessarily disjoint, because the defs nest
    function freeVarsDefs(def̅, bound) {
        if (BaseTypes_1.Cons.is(def̅)) {
            const def = def̅.head;
            if (def instanceof Prim) {
                const x̅ = new Set([def.x.val]), [boundʹ, free] = freeVarsDefs(def̅.tail, bound);
                return [boundʹ, Set_1.diff(free, x̅)];
            }
            else if (def instanceof Let) {
                const x̅ = new Set([def.x.val]), [boundʹ, free] = freeVarsDefs(def̅.tail, Set_1.union(bound, x̅));
                return [boundʹ, Set_1.union(Set_1.diff(free, x̅), freeVars(def.e))];
            }
            else if (def instanceof LetRec) {
                const f̅ = def.δ.toArray(), x̅ = new Set(f̅.map(f => f.x.val)), [boundʹ, free] = freeVarsDefs(def̅.tail, Set_1.union(bound, x̅));
                return [boundʹ, Set_1.diff(Set_1.union(free, ...f̅.map(f => freeVarsElim(f.σ))), x̅)];
            }
            else {
                return Core_1.absurd();
            }
        }
        else if (BaseTypes_1.Nil.is(def̅)) {
            return [bound, new Set()];
        }
        else {
            return Core_1.absurd();
        }
    }
})(Expr = exports.Expr || (exports.Expr = {}));


/***/ }),

/***/ "./src/FiniteMap.ts":
/*!**************************!*\
  !*** ./src/FiniteMap.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
function get(m, k) {
    if (BaseTypes_1.NonEmpty.is(m)) {
        if (k.leq(m.t.fst)) {
            if (m.t.fst.leq(k)) {
                return m.t.snd;
            }
            else {
                return get(m.left, k);
            }
        }
        else {
            return get(m.right, k);
        }
    }
    else if (BaseTypes_1.Empty.is(m)) {
        return undefined;
    }
    else {
        return Core_1.absurd();
    }
}
exports.get = get;
function insert(m, k, v) {
    if (BaseTypes_1.NonEmpty.is(m)) {
        if (k.leq(m.t.fst)) {
            if (m.t.fst.leq(k)) {
                return BaseTypes_1.nonEmpty(m.left, BaseTypes_1.pair(k, v), m.right);
            }
            else {
                return BaseTypes_1.nonEmpty(insert(m.left, k, v), m.t, m.right);
            }
        }
        else {
            return BaseTypes_1.nonEmpty(m.left, m.t, insert(m.right, k, v));
        }
    }
    else if (BaseTypes_1.Empty.is(m)) {
        return BaseTypes_1.nonEmpty(m, BaseTypes_1.pair(k, v), m);
    }
    else {
        return Core_1.absurd();
    }
}
exports.insert = insert;
function singleton(k, v) {
    return insert(BaseTypes_1.empty(), k, v);
}
exports.singleton = singleton;
// Union with a combining function. If keys are equal, right-hand key will be used in the output.
// Avoid primes in signature; seems to be incompatible with version of ts-loader used by Wrattler.
function unionWith(m1, m2, f) {
    if (BaseTypes_1.NonEmpty.is(m2)) {
        const k = m2.t.fst, v = m2.t.snd, vʹ = get(m1, k), u = vʹ === undefined ? v : f(v, vʹ);
        return unionWith(insert(unionWith(m1, m2.left, f), k, u), m2.right, f);
    }
    else if (BaseTypes_1.Empty.is(m2)) {
        return m1;
    }
    else {
        return Core_1.absurd();
    }
}
exports.unionWith = unionWith;


/***/ }),

/***/ "./src/Graphics.ts":
/*!*************************!*\
  !*** ./src/Graphics.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
class Point extends DataValue_1.DataValue {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
    }
}
exports.Point = Point;
// Isomorphic to Bool
class Orient extends DataValue_1.DataValue {
}
exports.Orient = Orient;
class Horiz extends Orient {
}
exports.Horiz = Horiz;
class Vert extends Orient {
}
exports.Vert = Vert;
class GraphicsElement extends DataValue_1.DataValue {
}
exports.GraphicsElement = GraphicsElement;
class Circle extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.radius = Value_1._;
        this.fill = Value_1._;
    }
}
exports.Circle = Circle;
class Group extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.gs = Value_1._;
    }
}
exports.Group = Group;
class Line extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.p1 = Value_1._;
        this.p2 = Value_1._;
        this.stroke = Value_1._;
        this.strokeWidth = Value_1._;
    }
}
exports.Line = Line;
class Polyline extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.points = Value_1._;
        this.stroke = Value_1._;
        this.strokeWidth = Value_1._;
    }
}
exports.Polyline = Polyline;
class Polymarkers extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.points = Value_1._;
        this.markers = Value_1._;
    }
}
exports.Polymarkers = Polymarkers;
class Rect extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.width = Value_1._;
        this.height = Value_1._;
        this.fill = Value_1._;
    }
}
exports.Rect = Rect;
class Text extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.str = Value_1._;
        this.anchor = Value_1._; // SVG text-anchor
        this.baseline = Value_1._; // SVG alignment-baseline
    }
}
exports.Text = Text;
class Viewport extends GraphicsElement {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
        this.width = Value_1._;
        this.height = Value_1._;
        this.fill = Value_1._;
        this.margin = Value_1._; // in *parent* reference frame
        this.scale = Value_1._;
        this.translate = Value_1._; // scaling applies to translated coordinates
        this.g = Value_1._;
    }
}
exports.Viewport = Viewport;
class Transform extends DataValue_1.DataValue {
}
exports.Transform = Transform;
class Scale extends Transform {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
    }
}
exports.Scale = Scale;
class Translate extends Transform {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.y = Value_1._;
    }
}
exports.Translate = Translate;
class Marker extends DataValue_1.DataValue {
}
exports.Marker = Marker;
class Arrowhead extends Marker {
}
exports.Arrowhead = Arrowhead;
DataType_1.initDataType(Point, [Point]);
DataType_1.initDataType(Orient, [Horiz, Vert]);
DataType_1.initDataType(GraphicsElement, [Circle, Group, Line, Polyline, Polymarkers, Rect, Text, Viewport]);
DataType_1.initDataType(Transform, [Scale, Translate]);
DataType_1.initDataType(Marker, [Arrowhead]);


/***/ }),

/***/ "./src/Lib.ts":
/*!********************!*\
  !*** ./src/Lib.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// "typings" property of package.json requires a single TypeScript interface.
__webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts"); // need these early because of a Webpack dependency problem
const Pane_1 = __webpack_require__(/*! ./app/Pane */ "./src/app/Pane.ts");
exports.Pane = Pane_1.Pane;
const PaneCoordinator_1 = __webpack_require__(/*! ./app/PaneCoordinator */ "./src/app/PaneCoordinator.ts");
exports.PaneCoordinator = PaneCoordinator_1.PaneCoordinator;
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
exports.Env = Env_1.Env;
exports.emptyEnv = Env_1.emptyEnv;
const Eval_1 = __webpack_require__(/*! ./Eval */ "./src/Eval.ts");
exports.Eval = Eval_1.Eval;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
exports.Expr = Expr_1.Expr;
const Module_1 = __webpack_require__(/*! ./Module */ "./src/Module.ts");
exports.bindDataset = Module_1.bindDataset;
exports.openDatasetAs = Module_1.openDatasetAs;
exports.parseWithImports = Module_1.parseWithImports;


/***/ }),

/***/ "./src/Match.ts":
/*!**********************!*\
  !*** ./src/Match.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ./util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Ord_1 = __webpack_require__(/*! ./util/Ord */ "./src/util/Ord.ts");
const Lattice_1 = __webpack_require__(/*! ./util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ./Annotation */ "./src/Annotation.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Unrelated to the annotation lattice. Expr case intentionally only defined for higher-order (function) case.
function join(κ, κʹ) {
    const k = Value_1.memoId(join, arguments);
    if (κ instanceof Elim && κʹ instanceof Elim) {
        return DataElim.join(κ, κʹ);
    }
    else if (κ instanceof Expr_1.Expr.Fun && κʹ instanceof Expr_1.Expr.Fun) {
        return Expr_1.Expr.fun(join(κ.σ, κʹ.σ))(k);
    }
    else {
        return Core_1.absurd("Undefined join.", κ, κʹ);
    }
}
class Match extends DataValue_1.DataValue {
    constructor() {
        super(...arguments);
        this.tv̅ = Value_1._;
        this.κ = Value_1._;
    }
}
exports.Match = Match;
function match(ξ, κ) {
    return Value_1.make(Match, ξ, κ);
}
exports.match = match;
// See GitHub issue #128.
class Elim extends DataValue_1.DataValue {
    // could have called this "match", but conflicts with factory method of same name
    apply(tv) {
        return apply_(this, tv, BaseTypes_1.nil());
    }
}
exports.Elim = Elim;
function apply_(σ, tv, u̅) {
    if (VarElim.is(σ)) {
        const ρ = σ.x.val === "_" ? Env_1.emptyEnv() : Env_1.Env.singleton(σ.x, tv);
        return [ρ, match(u̅, σ.κ)];
    }
    else if (DataElim.is(σ)) {
        const v = tv.v, c = Core_1.className(v);
        if (v instanceof DataValue_1.DataValue) {
            const κ = σ[c];
            if (κ !== undefined) {
                const tv̅ = Expl_1.Expl.explChildren(tv.t, v), [ρ, ξ] = matchArgs(κ, tv̅, u̅);
                return [ρ, match(BaseTypes_1.cons(tv, ξ.tv̅), ξ.κ)];
            }
            else {
                const d = DataType_1.elimToDataType.get(Core_1.className(σ));
                if (d.ctrs.has(c)) {
                    return Core_1.userError(`Pattern mismatch: "${c}" case undefined for ${d.name.val}.`);
                }
                else {
                    return Core_1.userError(`Pattern mismatch: found ${c}, expected ${d.name.val}.`);
                }
            }
        }
        else {
            return Core_1.userError(`Pattern mismatch: ${c} is not a datatype.`, v, σ);
        }
    }
    else {
        return Core_1.absurd();
    }
}
// Parser ensures constructor calls are saturated.
function matchArgs(κ, tv̅, u̅) {
    if (tv̅.length === 0) {
        return [Env_1.emptyEnv(), match(u̅, κ)];
    }
    else {
        const [tv, ...tv̅ʹ] = tv̅;
        if (κ instanceof Elim) {
            const σ = κ, // "unfold" K into Elim<K>
            [ρ, ξ] = apply_(σ, tv, u̅), [ρʹ, ξʹ] = matchArgs(ξ.κ, tv̅ʹ, ξ.tv̅);
            return [ρ.concat(ρʹ), ξʹ];
        }
        else {
            return Core_1.absurd("Too many arguments to constructor.");
        }
    }
}
// Concrete instances have a field per constructor, in *lexicographical* order.
class DataElim extends Elim {
    static is(σ) {
        return σ instanceof DataElim;
    }
    static join(σ, τ) {
        const k = Value_1.memoId(DataElim.join, arguments);
        if (VarElim.is(σ) && VarElim.is(τ) && Ord_1.eq(σ.x, τ.x)) {
            return varElim(σ.x, join(σ.κ, τ.κ))(k);
        }
        else if (DataElim.is(σ) && DataElim.is(τ)) {
            // Both maps (which are non-empty) can (inductively) be assumed to have keys taken from the 
            // same datatype. Ensure that invariant is preserved:
            const c_σ = Value_1.fields(σ)[0], c_τ = Value_1.fields(τ)[0];
            if (DataType_1.ctrToDataType.get(c_σ) !== DataType_1.ctrToDataType.get(c_τ)) {
                Core_1.userError(`${c_σ} and ${c_τ} are constructors of different datatypes.`);
            }
            const cκ̅1 = Array_1.zip(Value_1.fields(σ), σ.__children), cκ̅2 = Array_1.zip(Value_1.fields(τ), τ.__children);
            Core_1.assert(cκ̅1.length === cκ̅2.length);
            const cκ̅ = Array_1.zipWith(([c1, κ1], [c2, κ2]) => {
                Core_1.assert(c1 === c2);
                return [c1, κ1 === undefined ? κ2 : (κ2 === undefined ? κ1 : join(κ1, κ2))];
            })(cκ̅1, cκ̅2);
            return dataElim(...cκ̅)(k);
        }
        else {
            return Core_1.absurd("Undefined join.", σ, τ);
        }
    }
}
exports.DataElim = DataElim;
// cκ̅ non-empty and constructors all of the same datatype.
function dataElim(...cκ̅) {
    const d = Core_1.__nonNull(DataType_1.ctrToDataType.get(cκ̅[0][0])), c̅ = cκ̅.map((([c, _]) => c)), c̅ʹ = [...d.ctrs.keys()], // sorted
    f̅ = [];
    let n = 0;
    for (let nʹ = 0; nʹ < c̅ʹ.length; ++nʹ) {
        if (c̅.includes(c̅ʹ[nʹ])) {
            f̅.push(cκ̅[n++][1]);
        }
        else {
            f̅.push(undefined);
        }
    }
    return Versioned_1.at(d.elimC, ...f̅);
}
exports.dataElim = dataElim;
class VarElim extends Elim {
    constructor() {
        super(...arguments);
        this.x = Value_1._;
        this.κ = Value_1._;
    }
    static is(σ) {
        return σ instanceof VarElim;
    }
}
exports.VarElim = VarElim;
function varElim(x, κ) {
    return Versioned_1.at(VarElim, x, κ);
}
exports.varElim = varElim;
function apply_fwd(ξ) {
    return ξ.tv̅.toArray().reduce((α, tv) => Lattice_1.bool_.meet(α, Annotation_1.isα(tv)), Lattice_1.bool_.top);
}
exports.apply_fwd = apply_fwd;
function apply_bwd(ξ, α) {
    ξ.tv̅.toArray().forEach((tv) => Annotation_1.setjoinα(α, tv));
}
exports.apply_bwd = apply_bwd;


/***/ }),

/***/ "./src/Module.ts":
/*!***********************!*\
  !*** ./src/Module.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const nearley_1 = __webpack_require__(/*! nearley */ "./node_modules/nearley/lib/nearley.js");
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "./src/Env.ts");
const Eval_1 = __webpack_require__(/*! ./Eval */ "./src/Eval.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
__webpack_require__(/*! ./Graphics */ "./src/Graphics.ts"); // for datatypes
const Parse_1 = __webpack_require__(/*! ./Parse */ "./src/Parse.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Kindergarten modules.
var Module;
(function (Module) {
    function initialise(resourceServerUrl) {
        Core_1.assert(Module.resourceServerUrl === undefined);
        Module.resourceServerUrl = Core_1.__nonNull(resourceServerUrl, `resourceServerUrl is ${resourceServerUrl}`);
        BaseTypes_1.BaseTypes.initialise();
        console.log("Initialising base types");
        Module.prelude = loadModule(Env_1.emptyEnv(), "prelude");
        Module.graphics = loadModule(Module.prelude, "graphics");
    }
    Module.initialise = initialise;
})(Module = exports.Module || (exports.Module = {}));
function import_(...modules) {
    if (modules.length === 0) {
        return Env_1.emptyEnv();
    }
    else {
        const [m, ...ms] = modules;
        return m.concat(import_(...ms));
    }
}
function loadFile(folder, file) {
    Core_1.assert(Module.resourceServerUrl !== undefined, "Module system not initialised.");
    let text;
    const xmlhttp = new XMLHttpRequest;
    const url = Module.resourceServerUrl + "/" + folder + "/" + file + ".fld";
    console.log(`Opening ${url}`);
    xmlhttp.open("GET", url, false);
    xmlhttp.send();
    if (xmlhttp.status === 200) {
        text = xmlhttp.responseText;
    }
    if (text === undefined) {
        return Core_1.assert(false, `${url} could not be loaded.`);
    }
    else {
        return text;
    }
}
exports.loadFile = loadFile;
// Not sure if Nearley can parse arbitrary non-terminal, as opposed to root.
function loadModule(ρ, file) {
    const src = loadFile("fluid/lib", file);
    const srcʹ = src + " in 0";
    const e = Core_1.as(successfulParse(srcʹ), Expr_1.Expr.Defs);
    return Eval_1.Eval.defs(ρ, e.def̅, Env_1.emptyEnv())[1];
}
exports.loadModule = loadModule;
function openWithImports(file, ...modules) {
    return parseWithImports(loadFile("fluid/example", file), ...modules);
}
exports.openWithImports = openWithImports;
function openDatasetAs(file, x) {
    const [ρ, e] = parseWithImports(loadFile("fluid/dataset", file));
    return Env_1.Env.singleton(Versioned_1.str(x)(Versioned_1.ν()), Eval_1.Eval.eval_(ρ, e));
}
exports.openDatasetAs = openDatasetAs;
function parseWithImports(src, ...modules) {
    Core_1.assert(Module.resourceServerUrl !== undefined, "Module system not initialised.");
    return [import_(Core_1.__nonNull(Module.prelude), Core_1.__nonNull(Module.graphics), ...modules), successfulParse(src)];
}
exports.parseWithImports = parseWithImports;
// https://github.com/kach/nearley/issues/276#issuecomment-324162234
function successfulParse(str) {
    const { results } = new nearley_1.Parser(nearley_1.Grammar.fromCompiled(Parse_1.default)).feed(str);
    if (results.length > 1) {
        Core_1.userError("Ambiguous parse.");
    }
    else if (results.length === 0) {
        Core_1.userError("Unsuccessful parse.");
    }
    return results[0];
}
exports.successfulParse = successfulParse;
// create an expression and evaluate it, so we have an explained value
function bindDataset(ρ, vs, x) {
    return Env_1.extendEnv(ρ, Versioned_1.str(x)(Versioned_1.ν()), Eval_1.Eval.eval_(ρ, asList(vs.map(asRecord))));
}
exports.bindDataset = bindDataset;
function asRecord(v) {
    return asList(Object.getOwnPropertyNames(v).map(k => asPair(k, v[k])));
}
function asPair(k, v) {
    return Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Pair), asPrimValue(k), asPrimValue(v))(Versioned_1.ν());
}
function asList(e̅) {
    let e̅ʹ = Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Nil))(Versioned_1.ν());
    for (let e of [...e̅].reverse()) {
        e̅ʹ = Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Cons), e, e̅ʹ)(Versioned_1.ν());
    }
    return e̅ʹ;
}
function asPrimValue(v) {
    if (typeof v === "number") {
        return Expr_1.Expr.constNum(Versioned_1.num(v)(Versioned_1.ν()))(Versioned_1.ν());
    }
    else if (typeof v === "string") {
        return Expr_1.Expr.constStr(Versioned_1.str(v)(Versioned_1.ν()))(Versioned_1.ν());
    }
    else {
        return Core_1.userError(`Ill-formed data: expected string or number, found ${typeof v}.`);
    }
}


/***/ }),

/***/ "./src/Parse.ts":
/*!**********************!*\
  !*** ./src/Parse.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Generated automatically by nearley, version 2.19.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
const moo = __webpack_require__(/*! moo */ "./node_modules/moo/moo.js");
const lexer = moo.compile({
    ident: {
        match: /[a-zA-Z_][0-9a-zA-Z_]*'*/,
        type: moo.keywords({
            keyword: ["_", "as", "match", "fun", "in", "let", "letrec", "primitive", "typematch"],
        })
    },
    whitespace: {
        match: /[ \f\t\r\n]+/,
        lineBreaks: true
    },
    singleLineComment: /\/\/.*$/,
    // JSON grammar for numbers, https://tools.ietf.org/html/rfc7159.html#section-6.
    // Seems Moo requires us to use non-capturing groups (?:)
    number: /\-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[e|E][-|+]?[0-9]+)?/,
    string: /"(?:\\["\\]|[^\n"\\])*"/,
    // not quite sure why I can't use literals here:
    sumOp: /\-|\+\+|\+/,
    exponentOp: /\*\*/,
    productOp: /\*|\//,
    compareOp: /==|<=|<|>=|>/,
    symbol: ["(", ")", "=", "→", ";", "{", "}", ",", "[", "]", "..."],
});
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ./DataType */ "./src/DataType.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./src/Expr.ts");
const FiniteMap_1 = __webpack_require__(/*! ./FiniteMap */ "./src/FiniteMap.ts");
const Match_1 = __webpack_require__(/*! ./Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// Constructors must start with an uppercase letter, a la Haskell. Will fix this as part of issue #49.
function isCtr(str) {
    const ch = str.charAt(0);
    return ch === ch.toUpperCase() && ch !== ch.toLowerCase();
}
function compose(mk_κ1, mk_κ2) {
    return (κ) => mk_κ1(mk_κ2(κ));
}
;
;
;
;
const grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "rootExpr", "symbols": ["_", "expr"], "postprocess": ([, e]) => e },
        { "name": "rootExpr", "symbols": ["expr"], "postprocess": id },
        { "name": "_$ebnf$1$subexpression$1", "symbols": [(lexer.has("whitespace") ? { type: "whitespace" } : whitespace)] },
        { "name": "_$ebnf$1$subexpression$1", "symbols": [(lexer.has("singleLineComment") ? { type: "singleLineComment" } : singleLineComment)] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1$subexpression$1"] },
        { "name": "_$ebnf$1$subexpression$2", "symbols": [(lexer.has("whitespace") ? { type: "whitespace" } : whitespace)] },
        { "name": "_$ebnf$1$subexpression$2", "symbols": [(lexer.has("singleLineComment") ? { type: "singleLineComment" } : singleLineComment)] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "_$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_", "symbols": ["_$ebnf$1"] },
        { "name": "expr", "symbols": ["compareExpr"], "postprocess": id },
        { "name": "expr", "symbols": ["defs1"], "postprocess": id },
        { "name": "expr", "symbols": ["fun"], "postprocess": id },
        { "name": "expr", "symbols": ["matchAs"], "postprocess": id },
        { "name": "expr", "symbols": ["typematch"], "postprocess": id },
        { "name": "defs1$macrocall$2", "symbols": [{ "literal": "in" }] },
        { "name": "defs1$macrocall$1$macrocall$2", "symbols": ["defs1$macrocall$2"] },
        { "name": "defs1$macrocall$1$macrocall$1", "symbols": ["defs1$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "defs1$macrocall$1$macrocall$1", "symbols": ["defs1$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "defs1$macrocall$1", "symbols": ["defs1$macrocall$1$macrocall$1"] },
        { "name": "defs1", "symbols": ["defList", "defs1$macrocall$1", "expr"], "postprocess": ([defs, , e]) => Expr_1.Expr.defs(defs, e)(Versioned_1.ν()) },
        { "name": "compareExpr", "symbols": ["compareExpr", "compareOp", "sumExpr"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "compareExpr", "symbols": ["sumExpr"], "postprocess": id },
        { "name": "sumExpr", "symbols": ["sumExpr", "sumOp", "productExpr"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "sumExpr", "symbols": ["productExpr"], "postprocess": id },
        { "name": "productExpr", "symbols": ["productExpr", "productOp", "exponentExpr"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "productExpr", "symbols": ["exponentExpr"], "postprocess": id },
        { "name": "exponentExpr", "symbols": ["exponentExpr", "exponentOp", "appChain"], "postprocess": ([e1, op, e2]) => Expr_1.Expr.binaryApp(e1, Versioned_1.str(op)(Versioned_1.ν()), e2)(Versioned_1.ν()) },
        { "name": "exponentExpr", "symbols": ["appChain"], "postprocess": id },
        { "name": "appChain", "symbols": ["simpleExpr"], "postprocess": id },
        { "name": "appChain", "symbols": ["appChain", "simpleExpr"], "postprocess": ([e1, e2]) => Expr_1.Expr.app(e1, e2)(Versioned_1.ν()) },
        { "name": "simpleExpr", "symbols": ["variable"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["string"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["number"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["parenthExpr"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["pair"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["list"], "postprocess": id },
        { "name": "simpleExpr", "symbols": ["constr"], "postprocess": id },
        { "name": "variable", "symbols": ["var"], "postprocess": ([x]) => Expr_1.Expr.var_(x)(Versioned_1.ν()) },
        { "name": "var$macrocall$2", "symbols": [(lexer.has("ident") ? { type: "ident" } : ident)] },
        { "name": "var$macrocall$1", "symbols": ["var$macrocall$2"], "postprocess": id },
        { "name": "var$macrocall$1", "symbols": ["var$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "var", "symbols": ["var$macrocall$1"], "postprocess": ([[x]], _, reject) => {
                if (isCtr(x.value)) {
                    return reject;
                }
                return Versioned_1.str(x.value)(Versioned_1.ν());
            } },
        { "name": "string$macrocall$2", "symbols": [(lexer.has("string") ? { type: "string" } : string)] },
        { "name": "string$macrocall$1", "symbols": ["string$macrocall$2"], "postprocess": id },
        { "name": "string$macrocall$1", "symbols": ["string$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "string", "symbols": ["string$macrocall$1"], "postprocess": ([[lit]]) => Expr_1.Expr.constStr(Versioned_1.str(lit.value.slice(1, -1))(Versioned_1.ν()))(Versioned_1.ν()) },
        { "name": "number$macrocall$2", "symbols": [(lexer.has("number") ? { type: "number" } : number)] },
        { "name": "number$macrocall$1", "symbols": ["number$macrocall$2"], "postprocess": id },
        { "name": "number$macrocall$1", "symbols": ["number$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "number", "symbols": ["number$macrocall$1"], "postprocess": ([[lit]]) => Expr_1.Expr.constNum(Versioned_1.num(new Number(lit.value).valueOf())(Versioned_1.ν()))(Versioned_1.ν()) },
        { "name": "parenthExpr$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "parenthExpr$macrocall$1", "symbols": ["parenthExpr$macrocall$2"], "postprocess": id },
        { "name": "parenthExpr$macrocall$1", "symbols": ["parenthExpr$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "parenthExpr$macrocall$4", "symbols": [{ "literal": ")" }] },
        { "name": "parenthExpr$macrocall$3", "symbols": ["parenthExpr$macrocall$4"], "postprocess": id },
        { "name": "parenthExpr$macrocall$3", "symbols": ["parenthExpr$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "parenthExpr", "symbols": ["parenthExpr$macrocall$1", "expr", "parenthExpr$macrocall$3"], "postprocess": ([, e,]) => e },
        { "name": "pair$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "pair$macrocall$1", "symbols": ["pair$macrocall$2"], "postprocess": id },
        { "name": "pair$macrocall$1", "symbols": ["pair$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "pair$macrocall$4", "symbols": [{ "literal": "," }] },
        { "name": "pair$macrocall$3", "symbols": ["pair$macrocall$4"], "postprocess": id },
        { "name": "pair$macrocall$3", "symbols": ["pair$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "pair$macrocall$6", "symbols": [{ "literal": ")" }] },
        { "name": "pair$macrocall$5", "symbols": ["pair$macrocall$6"], "postprocess": id },
        { "name": "pair$macrocall$5", "symbols": ["pair$macrocall$6", "_"], "postprocess": ([x,]) => x },
        { "name": "pair", "symbols": ["pair$macrocall$1", "expr", "pair$macrocall$3", "expr", "pair$macrocall$5"], "postprocess": ([, e1, , e2,]) => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Pair), e1, e2)(Versioned_1.ν()) },
        { "name": "list$macrocall$2", "symbols": [{ "literal": "[" }] },
        { "name": "list$macrocall$1", "symbols": ["list$macrocall$2"], "postprocess": id },
        { "name": "list$macrocall$1", "symbols": ["list$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "list$macrocall$4", "symbols": [{ "literal": "]" }] },
        { "name": "list$macrocall$3", "symbols": ["list$macrocall$4"], "postprocess": id },
        { "name": "list$macrocall$3", "symbols": ["list$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "list", "symbols": ["list$macrocall$1", "listOpt", "list$macrocall$3"], "postprocess": ([, e,]) => e },
        { "name": "constr", "symbols": ["ctr", "args"], "postprocess": ([c, e̅], _, reject) => {
                Core_1.assert(c instanceof Value_1.Str);
                const ctr = DataType_1.ctrFor(c.val);
                if (ctr.arity !== e̅.length) {
                    return reject;
                }
                return Versioned_1.at(DataType_1.exprClass(ctr.C), ...e̅)(Versioned_1.ν());
            } },
        { "name": "ctr$macrocall$2", "symbols": [(lexer.has("ident") ? { type: "ident" } : ident)] },
        { "name": "ctr$macrocall$1", "symbols": ["ctr$macrocall$2"], "postprocess": id },
        { "name": "ctr$macrocall$1", "symbols": ["ctr$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "ctr", "symbols": ["ctr$macrocall$1"], "postprocess": ([[x]], _, reject) => {
                if (!isCtr(x.value)) {
                    return reject;
                }
                return Versioned_1.str(x.value)(Versioned_1.ν());
            } },
        { "name": "args", "symbols": [], "postprocess": () => [] },
        { "name": "args$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "args$macrocall$1", "symbols": ["args$macrocall$2"], "postprocess": id },
        { "name": "args$macrocall$1", "symbols": ["args$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args$ebnf$1", "symbols": [] },
        { "name": "args$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "args$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "args$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args$ebnf$1$subexpression$1", "symbols": ["args$ebnf$1$subexpression$1$macrocall$1", "expr"], "postprocess": ([, e]) => e },
        { "name": "args$ebnf$1", "symbols": ["args$ebnf$1", "args$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "args$macrocall$4", "symbols": [{ "literal": ")" }] },
        { "name": "args$macrocall$3", "symbols": ["args$macrocall$4"], "postprocess": id },
        { "name": "args$macrocall$3", "symbols": ["args$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "args", "symbols": ["args$macrocall$1", "expr", "args$ebnf$1", "args$macrocall$3"], "postprocess": ([, e, es,]) => [e, ...es] },
        { "name": "typematch$macrocall$2", "symbols": [{ "literal": "typematch" }] },
        { "name": "typematch$macrocall$1$macrocall$2", "symbols": ["typematch$macrocall$2"] },
        { "name": "typematch$macrocall$1$macrocall$1", "symbols": ["typematch$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "typematch$macrocall$1$macrocall$1", "symbols": ["typematch$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typematch$macrocall$1", "symbols": ["typematch$macrocall$1$macrocall$1"] },
        { "name": "typematch$macrocall$4", "symbols": [{ "literal": "as" }] },
        { "name": "typematch$macrocall$3$macrocall$2", "symbols": ["typematch$macrocall$4"] },
        { "name": "typematch$macrocall$3$macrocall$1", "symbols": ["typematch$macrocall$3$macrocall$2"], "postprocess": id },
        { "name": "typematch$macrocall$3$macrocall$1", "symbols": ["typematch$macrocall$3$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typematch$macrocall$3", "symbols": ["typematch$macrocall$3$macrocall$1"] },
        { "name": "typematch", "symbols": ["typematch$macrocall$1", "expr", "typematch$macrocall$3", "typeMatches"], "postprocess": ([, e, , m]) => Expr_1.Expr.typematch(e, m)(Versioned_1.ν()) },
        { "name": "defList$ebnf$1", "symbols": [] },
        { "name": "defList$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "defList$ebnf$1$subexpression$1$macrocall$1", "symbols": ["defList$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "defList$ebnf$1$subexpression$1$macrocall$1", "symbols": ["defList$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "defList$ebnf$1$subexpression$1", "symbols": ["defList$ebnf$1$subexpression$1$macrocall$1", "def"], "postprocess": ([, def]) => def },
        { "name": "defList$ebnf$1", "symbols": ["defList$ebnf$1", "defList$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "defList", "symbols": ["def", "defList$ebnf$1"], "postprocess": ([def, defs]) => BaseTypes_1.List.fromArray([def, ...defs]) },
        { "name": "def", "symbols": ["let"], "postprocess": id },
        { "name": "def", "symbols": ["letrec"], "postprocess": id },
        { "name": "def", "symbols": ["prim"], "postprocess": id },
        { "name": "let$macrocall$2", "symbols": [{ "literal": "let" }] },
        { "name": "let$macrocall$1$macrocall$2", "symbols": ["let$macrocall$2"] },
        { "name": "let$macrocall$1$macrocall$1", "symbols": ["let$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "let$macrocall$1$macrocall$1", "symbols": ["let$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "let$macrocall$1", "symbols": ["let$macrocall$1$macrocall$1"] },
        { "name": "let$macrocall$4", "symbols": [{ "literal": "=" }] },
        { "name": "let$macrocall$3", "symbols": ["let$macrocall$4"], "postprocess": id },
        { "name": "let$macrocall$3", "symbols": ["let$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "let", "symbols": ["let$macrocall$1", "var", "let$macrocall$3", "expr"], "postprocess": ([, x, , e]) => Expr_1.Expr.let_(x, e)(Versioned_1.ν()) },
        { "name": "letrec$macrocall$2", "symbols": [{ "literal": "letrec" }] },
        { "name": "letrec$macrocall$1$macrocall$2", "symbols": ["letrec$macrocall$2"] },
        { "name": "letrec$macrocall$1$macrocall$1", "symbols": ["letrec$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "letrec$macrocall$1$macrocall$1", "symbols": ["letrec$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "letrec$macrocall$1", "symbols": ["letrec$macrocall$1$macrocall$1"] },
        { "name": "letrec$ebnf$1", "symbols": [] },
        { "name": "letrec$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "letrec$ebnf$1$subexpression$1$macrocall$1", "symbols": ["letrec$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "letrec$ebnf$1$subexpression$1$macrocall$1", "symbols": ["letrec$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "letrec$ebnf$1$subexpression$1", "symbols": ["letrec$ebnf$1$subexpression$1$macrocall$1", "recDef"], "postprocess": ([, recDef]) => recDef },
        { "name": "letrec$ebnf$1", "symbols": ["letrec$ebnf$1", "letrec$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "letrec", "symbols": ["letrec$macrocall$1", "recDef", "letrec$ebnf$1"], "postprocess": ([, recDef, δ]) => Expr_1.Expr.letRec(BaseTypes_1.List.fromArray([recDef, ...δ]))(Versioned_1.ν()) },
        { "name": "prim$macrocall$2", "symbols": [{ "literal": "primitive" }] },
        { "name": "prim$macrocall$1$macrocall$2", "symbols": ["prim$macrocall$2"] },
        { "name": "prim$macrocall$1$macrocall$1", "symbols": ["prim$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "prim$macrocall$1$macrocall$1", "symbols": ["prim$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "prim$macrocall$1", "symbols": ["prim$macrocall$1$macrocall$1"] },
        { "name": "prim", "symbols": ["prim$macrocall$1", "var"], "postprocess": ([, x]) => Expr_1.Expr.prim(x)(Versioned_1.ν()) },
        { "name": "recDef$macrocall$2", "symbols": [{ "literal": "fun" }] },
        { "name": "recDef$macrocall$1$macrocall$2", "symbols": ["recDef$macrocall$2"] },
        { "name": "recDef$macrocall$1$macrocall$1", "symbols": ["recDef$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "recDef$macrocall$1$macrocall$1", "symbols": ["recDef$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "recDef$macrocall$1", "symbols": ["recDef$macrocall$1$macrocall$1"] },
        { "name": "recDef", "symbols": ["recDef$macrocall$1", "var", "matches"], "postprocess": ([, f, σ]) => Expr_1.Expr.recDef(f, σ)(Versioned_1.ν()) },
        { "name": "fun$macrocall$2", "symbols": [{ "literal": "fun" }] },
        { "name": "fun$macrocall$1$macrocall$2", "symbols": ["fun$macrocall$2"] },
        { "name": "fun$macrocall$1$macrocall$1", "symbols": ["fun$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "fun$macrocall$1$macrocall$1", "symbols": ["fun$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "fun$macrocall$1", "symbols": ["fun$macrocall$1$macrocall$1"] },
        { "name": "fun", "symbols": ["fun$macrocall$1", "matches"], "postprocess": ([, σ]) => Expr_1.Expr.fun(σ)(Versioned_1.ν()) },
        { "name": "matchAs$macrocall$2", "symbols": [{ "literal": "match" }] },
        { "name": "matchAs$macrocall$1$macrocall$2", "symbols": ["matchAs$macrocall$2"] },
        { "name": "matchAs$macrocall$1$macrocall$1", "symbols": ["matchAs$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "matchAs$macrocall$1$macrocall$1", "symbols": ["matchAs$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matchAs$macrocall$1", "symbols": ["matchAs$macrocall$1$macrocall$1"] },
        { "name": "matchAs$macrocall$4", "symbols": [{ "literal": "as" }] },
        { "name": "matchAs$macrocall$3$macrocall$2", "symbols": ["matchAs$macrocall$4"] },
        { "name": "matchAs$macrocall$3$macrocall$1", "symbols": ["matchAs$macrocall$3$macrocall$2"], "postprocess": id },
        { "name": "matchAs$macrocall$3$macrocall$1", "symbols": ["matchAs$macrocall$3$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matchAs$macrocall$3", "symbols": ["matchAs$macrocall$3$macrocall$1"] },
        { "name": "matchAs", "symbols": ["matchAs$macrocall$1", "expr", "matchAs$macrocall$3", "matches"], "postprocess": ([, e, , σ]) => Expr_1.Expr.matchAs(e, σ)(Versioned_1.ν()) },
        { "name": "matches", "symbols": ["match"], "postprocess": id },
        { "name": "matches$macrocall$2", "symbols": [{ "literal": "{" }] },
        { "name": "matches$macrocall$1", "symbols": ["matches$macrocall$2"], "postprocess": id },
        { "name": "matches$macrocall$1", "symbols": ["matches$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matches$ebnf$1", "symbols": [] },
        { "name": "matches$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "matches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["matches$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "matches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["matches$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "matches$ebnf$1$subexpression$1", "symbols": ["matches$ebnf$1$subexpression$1$macrocall$1", "match"], "postprocess": ([, m]) => m },
        { "name": "matches$ebnf$1", "symbols": ["matches$ebnf$1", "matches$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "matches$macrocall$4", "symbols": [{ "literal": "}" }] },
        { "name": "matches$macrocall$3", "symbols": ["matches$macrocall$4"], "postprocess": id },
        { "name": "matches$macrocall$3", "symbols": ["matches$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "matches", "symbols": ["matches$macrocall$1", "match", "matches$ebnf$1", "matches$macrocall$3"], "postprocess": ([, m, ms,]) => [m, ...ms].reduce(Match_1.DataElim.join) },
        { "name": "match$macrocall$2", "symbols": [{ "literal": "→" }] },
        { "name": "match$macrocall$1", "symbols": ["match$macrocall$2"], "postprocess": id },
        { "name": "match$macrocall$1", "symbols": ["match$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "match", "symbols": ["pattern", "match$macrocall$1", "expr"], "postprocess": ([mk_κ, , e]) => mk_κ(e) },
        { "name": "match", "symbols": ["pattern", "matches"], "postprocess": ([mk_κ1, σ]) => mk_κ1(Expr_1.Expr.fun(σ)(Versioned_1.ν())) },
        { "name": "typeMatches", "symbols": ["typeMatch"], "postprocess": id },
        { "name": "typeMatches$macrocall$2", "symbols": [{ "literal": "{" }] },
        { "name": "typeMatches$macrocall$1", "symbols": ["typeMatches$macrocall$2"], "postprocess": id },
        { "name": "typeMatches$macrocall$1", "symbols": ["typeMatches$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatches$ebnf$1", "symbols": [] },
        { "name": "typeMatches$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ";" }] },
        { "name": "typeMatches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["typeMatches$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "typeMatches$ebnf$1$subexpression$1$macrocall$1", "symbols": ["typeMatches$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatches$ebnf$1$subexpression$1", "symbols": ["typeMatches$ebnf$1$subexpression$1$macrocall$1", "typeMatch"], "postprocess": ([, m]) => m },
        { "name": "typeMatches$ebnf$1", "symbols": ["typeMatches$ebnf$1", "typeMatches$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "typeMatches$macrocall$4", "symbols": [{ "literal": "}" }] },
        { "name": "typeMatches$macrocall$3", "symbols": ["typeMatches$macrocall$4"], "postprocess": id },
        { "name": "typeMatches$macrocall$3", "symbols": ["typeMatches$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatches", "symbols": ["typeMatches$macrocall$1", "typeMatch", "typeMatches$ebnf$1", "typeMatches$macrocall$3"], "postprocess": ([, m, ms,]) => [m, ...ms].reduce((m1, m2) => FiniteMap_1.unionWith(m1, m2, (e, eʹ) => Core_1.userError("Overlapping typecase branches."))) },
        { "name": "typeMatch$macrocall$2", "symbols": [{ "literal": "→" }] },
        { "name": "typeMatch$macrocall$1", "symbols": ["typeMatch$macrocall$2"], "postprocess": id },
        { "name": "typeMatch$macrocall$1", "symbols": ["typeMatch$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typeMatch", "symbols": ["typename", "typeMatch$macrocall$1", "expr"], "postprocess": ([x, , e]) => {
                Core_1.assert(x instanceof Value_1.Str);
                if (!DataType_1.types.has(x.val)) {
                    Core_1.userError(`Type name ${x.val} not found.`);
                }
                return FiniteMap_1.singleton(x, e);
            } },
        { "name": "typename$macrocall$2", "symbols": [(lexer.has("ident") ? { type: "ident" } : ident)] },
        { "name": "typename$macrocall$1", "symbols": ["typename$macrocall$2"], "postprocess": id },
        { "name": "typename$macrocall$1", "symbols": ["typename$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "typename", "symbols": ["typename$macrocall$1"], "postprocess": ([[x]]) => Versioned_1.str(x.value)(Versioned_1.ν()) },
        { "name": "listOpt", "symbols": [], "postprocess": () => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Nil))(Versioned_1.ν()) },
        { "name": "listOpt$ebnf$1", "symbols": [] },
        { "name": "listOpt$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "listOpt$ebnf$1$subexpression$1$macrocall$1", "symbols": ["listOpt$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "listOpt$ebnf$1$subexpression$1$macrocall$1", "symbols": ["listOpt$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "listOpt$ebnf$1$subexpression$1", "symbols": ["listOpt$ebnf$1$subexpression$1$macrocall$1", "expr"], "postprocess": ([, e]) => e },
        { "name": "listOpt$ebnf$1", "symbols": ["listOpt$ebnf$1", "listOpt$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "listOpt", "symbols": ["expr", "listOpt$ebnf$1", "listRestOpt"], "postprocess": ([e, es, eʹ]) => [e, ...es, eʹ].reverse().reduce((e̅, e) => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Cons), e, e̅)(Versioned_1.ν())) },
        { "name": "listRestOpt", "symbols": [], "postprocess": () => Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Nil))(Versioned_1.ν()) },
        { "name": "listRestOpt$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "listRestOpt$macrocall$1", "symbols": ["listRestOpt$macrocall$2"], "postprocess": id },
        { "name": "listRestOpt$macrocall$1", "symbols": ["listRestOpt$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt$macrocall$4", "symbols": [{ "literal": "..." }] },
        { "name": "listRestOpt$macrocall$3", "symbols": ["listRestOpt$macrocall$4"], "postprocess": id },
        { "name": "listRestOpt$macrocall$3", "symbols": ["listRestOpt$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt", "symbols": ["listRestOpt$macrocall$1", "listRestOpt$macrocall$3", "expr"], "postprocess": ([, , e]) => e },
        { "name": "pattern", "symbols": ["variable_pattern"], "postprocess": id },
        { "name": "pattern", "symbols": ["pair_pattern"], "postprocess": id },
        { "name": "pattern", "symbols": ["list_pattern"], "postprocess": id },
        { "name": "pattern", "symbols": ["constr_pattern"], "postprocess": id },
        { "name": "variable_pattern$macrocall$2", "symbols": [{ "literal": "_" }] },
        { "name": "variable_pattern$macrocall$1$macrocall$2", "symbols": ["variable_pattern$macrocall$2"] },
        { "name": "variable_pattern$macrocall$1$macrocall$1", "symbols": ["variable_pattern$macrocall$1$macrocall$2"], "postprocess": id },
        { "name": "variable_pattern$macrocall$1$macrocall$1", "symbols": ["variable_pattern$macrocall$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "variable_pattern$macrocall$1", "symbols": ["variable_pattern$macrocall$1$macrocall$1"] },
        { "name": "variable_pattern", "symbols": ["variable_pattern$macrocall$1"], "postprocess": () => (κ) => Match_1.varElim(Versioned_1.str("_")(Versioned_1.ν()), κ)(Versioned_1.ν()) },
        { "name": "variable_pattern", "symbols": ["var"], "postprocess": ([x]) => (κ) => Match_1.varElim(x, κ)(Versioned_1.ν()) },
        { "name": "pair_pattern$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "pair_pattern$macrocall$1", "symbols": ["pair_pattern$macrocall$2"], "postprocess": id },
        { "name": "pair_pattern$macrocall$1", "symbols": ["pair_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "pair_pattern$macrocall$4", "symbols": [{ "literal": "," }] },
        { "name": "pair_pattern$macrocall$3", "symbols": ["pair_pattern$macrocall$4"], "postprocess": id },
        { "name": "pair_pattern$macrocall$3", "symbols": ["pair_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "pair_pattern$macrocall$6", "symbols": [{ "literal": ")" }] },
        { "name": "pair_pattern$macrocall$5", "symbols": ["pair_pattern$macrocall$6"], "postprocess": id },
        { "name": "pair_pattern$macrocall$5", "symbols": ["pair_pattern$macrocall$6", "_"], "postprocess": ([x,]) => x },
        { "name": "pair_pattern", "symbols": ["pair_pattern$macrocall$1", "pattern", "pair_pattern$macrocall$3", "pattern", "pair_pattern$macrocall$5"], "postprocess": ([, mk_κ1, , mk_κ2, ,]) => (κ) => Match_1.dataElim([BaseTypes_1.Pair.name, compose(mk_κ1, mk_κ2)(κ)])(Versioned_1.ν()) },
        { "name": "list_pattern$macrocall$2", "symbols": [{ "literal": "[" }] },
        { "name": "list_pattern$macrocall$1", "symbols": ["list_pattern$macrocall$2"], "postprocess": id },
        { "name": "list_pattern$macrocall$1", "symbols": ["list_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "list_pattern$macrocall$4", "symbols": [{ "literal": "]" }] },
        { "name": "list_pattern$macrocall$3", "symbols": ["list_pattern$macrocall$4"], "postprocess": id },
        { "name": "list_pattern$macrocall$3", "symbols": ["list_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "list_pattern", "symbols": ["list_pattern$macrocall$1", "listOpt_pattern", "list_pattern$macrocall$3"], "postprocess": ([, mk_κ,]) => mk_κ },
        { "name": "listOpt_pattern", "symbols": [], "postprocess": () => (κ) => Match_1.dataElim([BaseTypes_1.Nil.name, κ])(Versioned_1.ν()) },
        { "name": "listOpt_pattern", "symbols": ["list1_pattern"], "postprocess": id },
        { "name": "list1_pattern", "symbols": ["pattern", "listRestOpt_pattern"], "postprocess": ([mk_κ1, mk_κ2]) => (κ) => Match_1.dataElim([BaseTypes_1.Cons.name, compose(mk_κ1, mk_κ2)(κ)])(Versioned_1.ν()) },
        { "name": "listRestOpt_pattern", "symbols": [], "postprocess": () => (κ) => Match_1.dataElim([BaseTypes_1.Nil.name, κ])(Versioned_1.ν()) },
        { "name": "listRestOpt_pattern$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "listRestOpt_pattern$macrocall$1", "symbols": ["listRestOpt_pattern$macrocall$2"], "postprocess": id },
        { "name": "listRestOpt_pattern$macrocall$1", "symbols": ["listRestOpt_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt_pattern$macrocall$4", "symbols": [{ "literal": "..." }] },
        { "name": "listRestOpt_pattern$macrocall$3", "symbols": ["listRestOpt_pattern$macrocall$4"], "postprocess": id },
        { "name": "listRestOpt_pattern$macrocall$3", "symbols": ["listRestOpt_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt_pattern", "symbols": ["listRestOpt_pattern$macrocall$1", "listRestOpt_pattern$macrocall$3", "pattern"], "postprocess": ([, , mk_κ]) => mk_κ },
        { "name": "listRestOpt_pattern$macrocall$6", "symbols": [{ "literal": "," }] },
        { "name": "listRestOpt_pattern$macrocall$5", "symbols": ["listRestOpt_pattern$macrocall$6"], "postprocess": id },
        { "name": "listRestOpt_pattern$macrocall$5", "symbols": ["listRestOpt_pattern$macrocall$6", "_"], "postprocess": ([x,]) => x },
        { "name": "listRestOpt_pattern", "symbols": ["listRestOpt_pattern$macrocall$5", "list1_pattern"], "postprocess": ([, mk_κ]) => mk_κ },
        { "name": "constr_pattern", "symbols": ["ctr", "args_pattern"], "postprocess": ([c, mk_κs], _, reject) => {
                Core_1.assert(c instanceof Value_1.Str);
                if (DataType_1.ctrFor(c.val).arity !== mk_κs.length) {
                    return reject;
                }
                return (κ) => Match_1.dataElim([c.val, mk_κs.reduce(compose, (κ) => κ)(κ)])(Versioned_1.ν());
            } },
        { "name": "args_pattern", "symbols": [], "postprocess": () => [] },
        { "name": "args_pattern$macrocall$2", "symbols": [{ "literal": "(" }] },
        { "name": "args_pattern$macrocall$1", "symbols": ["args_pattern$macrocall$2"], "postprocess": id },
        { "name": "args_pattern$macrocall$1", "symbols": ["args_pattern$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args_pattern$ebnf$1", "symbols": [] },
        { "name": "args_pattern$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": "," }] },
        { "name": "args_pattern$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args_pattern$ebnf$1$subexpression$1$macrocall$2"], "postprocess": id },
        { "name": "args_pattern$ebnf$1$subexpression$1$macrocall$1", "symbols": ["args_pattern$ebnf$1$subexpression$1$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "args_pattern$ebnf$1$subexpression$1", "symbols": ["args_pattern$ebnf$1$subexpression$1$macrocall$1", "pattern"], "postprocess": ([, mk_κ]) => mk_κ },
        { "name": "args_pattern$ebnf$1", "symbols": ["args_pattern$ebnf$1", "args_pattern$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "args_pattern$macrocall$4", "symbols": [{ "literal": ")" }] },
        { "name": "args_pattern$macrocall$3", "symbols": ["args_pattern$macrocall$4"], "postprocess": id },
        { "name": "args_pattern$macrocall$3", "symbols": ["args_pattern$macrocall$4", "_"], "postprocess": ([x,]) => x },
        { "name": "args_pattern", "symbols": ["args_pattern$macrocall$1", "pattern", "args_pattern$ebnf$1", "args_pattern$macrocall$3"], "postprocess": ([, mk_κ, mk_κs,]) => [mk_κ, ...mk_κs] },
        { "name": "compareOp$macrocall$2", "symbols": [(lexer.has("compareOp") ? { type: "compareOp" } : compareOp)] },
        { "name": "compareOp$macrocall$1", "symbols": ["compareOp$macrocall$2"], "postprocess": id },
        { "name": "compareOp$macrocall$1", "symbols": ["compareOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "compareOp", "symbols": ["compareOp$macrocall$1"], "postprocess": ([[x]]) => x.value },
        { "name": "exponentOp$macrocall$2", "symbols": [(lexer.has("exponentOp") ? { type: "exponentOp" } : exponentOp)] },
        { "name": "exponentOp$macrocall$1", "symbols": ["exponentOp$macrocall$2"], "postprocess": id },
        { "name": "exponentOp$macrocall$1", "symbols": ["exponentOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "exponentOp", "symbols": ["exponentOp$macrocall$1"], "postprocess": ([[x]]) => x.value },
        { "name": "productOp$macrocall$2", "symbols": [(lexer.has("productOp") ? { type: "productOp" } : productOp)] },
        { "name": "productOp$macrocall$1", "symbols": ["productOp$macrocall$2"], "postprocess": id },
        { "name": "productOp$macrocall$1", "symbols": ["productOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "productOp", "symbols": ["productOp$macrocall$1"], "postprocess": ([[x]]) => x.value },
        { "name": "sumOp$macrocall$2", "symbols": [(lexer.has("sumOp") ? { type: "sumOp" } : sumOp)] },
        { "name": "sumOp$macrocall$1", "symbols": ["sumOp$macrocall$2"], "postprocess": id },
        { "name": "sumOp$macrocall$1", "symbols": ["sumOp$macrocall$2", "_"], "postprocess": ([x,]) => x },
        { "name": "sumOp", "symbols": ["sumOp$macrocall$1"], "postprocess": ([[x]]) => x.value }
    ],
    ParserStart: "rootExpr",
};
exports.default = grammar;


/***/ }),

/***/ "./src/Primitive.ts":
/*!**************************!*\
  !*** ./src/Primitive.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ./BaseTypes */ "./src/BaseTypes.ts");
const DataValue_1 = __webpack_require__(/*! ./DataValue */ "./src/DataValue.ts");
const Expl_1 = __webpack_require__(/*! ./Expl */ "./src/Expl.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ./Versioned */ "./src/Versioned.ts");
// In the following two classes, we store the operation without generic type parameters, as fields can't
// have polymorphic type. Then access the operation via a method and reinstate the polymorphism via a cast.
class PrimOp extends Value_1.Value {
    constructor() {
        super(...arguments);
        this.name = Value_1._;
    }
}
exports.PrimOp = PrimOp;
class UnaryOp extends PrimOp {
    constructor() {
        super(...arguments);
        this.op = Value_1._;
    }
}
exports.UnaryOp = UnaryOp;
class BinaryOp extends PrimOp {
    constructor() {
        super(...arguments);
        this.op = Value_1._;
    }
}
exports.BinaryOp = BinaryOp;
const ceiling = x => Versioned_1.num(Math.ceil(x.val));
// Used to take arbitrary value as additional argument, but now primitives have primitive arguments.
const debugLog = v => (k) => {
    console.log(v);
    return v;
};
const floor = x => Versioned_1.num(Math.floor(x.val));
const log = x => Versioned_1.num(Math.log(Core_1.as(x, Value_1.Num).val));
const numToStr = x => Versioned_1.str(x.val.toString());
// No longer support overloaded functions, since the pattern-matching semantics is non-trivial; might require typecase.
// If we want integer division, apparently ~~(x / y) will round in the right direction.
const div = (x, y) => (k) => {
    const n = Versioned_1.num(Core_1.as(x, Value_1.Num).val / Core_1.as(y, Value_1.Num).val)(k);
    if (!isFinite(n.val)) {
        Core_1.userError("Division by zero", x, y);
    }
    return n;
};
const concat = (x, y) => Versioned_1.str(Core_1.as(x, Value_1.Str).val + Core_1.as(y, Value_1.Str).val);
const equal = (x, y) => {
    if (x instanceof Value_1.Num && y instanceof Value_1.Num) {
        return x.val === y.val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else if (x instanceof Value_1.Str && y instanceof Value_1.Str) {
        return x.val === y.val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else {
        return Core_1.userError(`Expected ${Value_1.Num.name} or ${Value_1.Str.name}.`);
    }
};
const error = message => Core_1.assert(false, "Fluid error:\n" + message.val);
const greaterEq = (x, y) => {
    if (x instanceof Value_1.Num && y instanceof Value_1.Num) {
        return x.val >= y.val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else if (x instanceof Value_1.Str && y instanceof Value_1.Str) {
        // string comparison delegates to central implementation for consistency
        return x.geq(y) ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else {
        return Core_1.userError(`Expected ${Value_1.Num.name} or ${Value_1.Str.name}.`);
    }
};
const greater = (x, y) => Core_1.as(x, Value_1.Num).val > Core_1.as(y, Value_1.Num).val ? BaseTypes_1.true_() : BaseTypes_1.false_();
const lessEq = (x, y) => {
    if (x instanceof Value_1.Num && y instanceof Value_1.Num) {
        return Core_1.as(x, Value_1.Num).val <= Core_1.as(y, Value_1.Num).val ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else if (x instanceof Value_1.Str && y instanceof Value_1.Str) {
        return x.leq(y) ? BaseTypes_1.true_() : BaseTypes_1.false_();
    }
    else {
        return Core_1.userError(`Expected ${Value_1.Num.name} or ${Value_1.Str.name}.`);
    }
};
const less = (x, y) => Core_1.as(x, Value_1.Num).val < Core_1.as(y, Value_1.Num).val ? BaseTypes_1.true_() : BaseTypes_1.false_();
const minus = (x, y) => Versioned_1.num(Core_1.as(x, Value_1.Num).val - Core_1.as(y, Value_1.Num).val);
const plus = (x, y) => Versioned_1.num(Core_1.as(x, Value_1.Num).val + Core_1.as(y, Value_1.Num).val);
const pow = (x, y) => Versioned_1.num(Math.pow(Core_1.as(x, Value_1.Num).val, Core_1.as(y, Value_1.Num).val));
const times = (x, y) => Versioned_1.num(Core_1.as(x, Value_1.Num).val * Core_1.as(y, Value_1.Num).val);
// Convenience methods for building the maps. Export to allow other modules to provide operations.
function unary_(op) {
    return DataValue_1.explValue(Expl_1.Expl.const_()(Versioned_1.ν()), Versioned_1.at(UnaryOp, op.name, op)(Versioned_1.ν()));
}
exports.unary_ = unary_;
function binary_(op) {
    return DataValue_1.explValue(Expl_1.Expl.const_()(Versioned_1.ν()), Versioned_1.at(BinaryOp, op.name, op)(Versioned_1.ν()));
}
exports.binary_ = binary_;
// Primitives with identifiers as names are unary and first-class.
exports.unaryOps = new Map([
    [ceiling.name, unary_(ceiling)],
    [debugLog.name, unary_(debugLog)],
    [error.name, unary_(error)],
    [floor.name, unary_(floor)],
    [log.name, unary_(log)],
    [numToStr.name, unary_(numToStr)]
]);
exports.binaryOps = new Map([
    ["-", binary_(minus)],
    ["+", binary_(plus)],
    ["*", binary_(times)],
    ["**", binary_(pow)],
    ["/", binary_(div)],
    ["==", binary_(equal)],
    [">", binary_(greater)],
    [">=", binary_(greaterEq)],
    ["<", binary_(less)],
    ["<=", binary_(lessEq)],
    ["++", binary_(concat)]
]);


/***/ }),

/***/ "./src/Value.ts":
/*!**********************!*\
  !*** ./src/Value.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
// Use to initialise fields for reflection, without requiring constructors.
exports._ = undefined;
// Value in the metalanguage.
class Value {
    __child(k) {
        return this[k];
    }
    // Probably confusingly, "children" isn't a user-level notion; specifically, wrappers
    // like Num and Str have children which are not observable through pattern-matching.
    get __children() {
        return fields(this).map(k => this.__child(k));
    }
}
exports.Value = Value;
// Address or location of persistent object.
class Id extends Value {
    tag(tag) {
        return taggedId(this, tag);
    }
}
exports.Id = Id;
class FunctionId extends Id {
    constructor() {
        super(...arguments);
        this.f = exports._;
    }
}
function functionId(f) {
    return make(FunctionId, f);
}
class ApplicationId extends Id {
    constructor() {
        super(...arguments);
        this.k = exports._;
        this.v = exports._;
    }
}
exports.ApplicationId = ApplicationId;
function applicationId(k, v) {
    return make(ApplicationId, k, v);
}
class TaggedId extends Id {
    constructor() {
        super(...arguments);
        this.k = exports._;
        this.prop = exports._;
    }
}
exports.TaggedId = TaggedId;
function taggedId(k, prop) {
    return make(TaggedId, k, prop);
}
function memoId(f, v̅) {
    const fʹ = functionId(f);
    let k = fʹ;
    for (let v of v̅) {
        k = applicationId(k, v);
    }
    return k;
}
exports.memoId = memoId;
function isPrim(v) {
    return v instanceof Num || v instanceof Str;
}
exports.isPrim = isPrim;
class Num extends Value {
    constructor() {
        super(...arguments);
        this.val = exports._;
    }
    toString() {
        return this.val.toString();
    }
}
exports.Num = Num;
class Str extends Value {
    constructor() {
        super(...arguments);
        this.val = exports._;
    }
    toString() {
        return `"${this.val}"`;
    }
    leq(str) {
        return this.val.localeCompare(str.val) <= 0;
    }
    eq(str) {
        return this.val.localeCompare(str.val) === 0;
    }
    geq(str) {
        return this.val.localeCompare(str.val) >= 0;
    }
}
exports.Str = Str;
// Mergeable state deltas are disjoint.
function mergeInto(tgt, src) {
    Object.keys(src).forEach((prop) => {
        if (!tgt.hasOwnProperty(prop)) {
            tgt[prop] = src[prop];
        }
        else {
            Core_1.absurd(`Incompatible update of field "${prop}" at revision.`, tgt[prop], src[prop]);
        }
    });
}
exports.mergeInto = mergeInto;
// Hash-consed constructors are invariant across worlds.
const __ctrMemo = new Map;
function lookupArg(f, m, v̅, n) {
    // for memoisation purposes, treat f's key as argument -1
    const k = n === -1 ? f.key : v̅[n];
    let v = m.get(k);
    if (v === undefined) {
        if (n === v̅.length - 1) {
            v = f.call(v̅);
            v = v; // TS confused; thinks v can be undefined here
        }
        else {
            v = new Map;
        }
        m.set(k, v);
    }
    return v;
}
class MemoCtr {
    constructor(C) {
        this.C = C;
    }
    get key() {
        return this.C;
    }
    call(v̅) {
        const v = new this.C;
        construct(false, v, v̅);
        Object.freeze(v);
        return v;
    }
}
function memoCall(memo, f, v̅) {
    let v = lookupArg(f, memo, v̅, -1);
    for (let n = 0; n < v̅.length; ++n) {
        // since there are more arguments, the last v was a (possibly nested) map
        v = lookupArg(f, v, v̅, n);
    }
    return v;
}
exports.memoCall = memoCall;
// Experimented with dictionary-based construction pattern; eliminates field order mismatch as a possible
// source of error, but the benefit is very small and doesn't really suit the memoisation pattern.
function make(C, ...v̅) {
    return memoCall(__ctrMemo, new MemoCtr(C), v̅);
}
exports.make = make;
// Depends heavily on (1) getOwnPropertyNames() returning fields in definition-order; and (2)
// constructor functions supplying arguments in the same order.
function construct(compare, tgt, v̅) {
    const f̅ = fields(tgt), ẟ = compare ? {} : null;
    Core_1.assert(f̅.length === v̅.length);
    let n = 0;
    f̅.forEach((prop) => {
        const src = v̅[n++];
        if (compare && tgt.__child(prop) !== src) {
            ẟ[prop] = { before: tgt.__child(prop), after: src };
        }
        tgt[prop] = src;
    });
    return ẟ;
}
exports.construct = construct;
// Exclude metadata according to our convention.
function isField(prop) {
    return !prop.startsWith("__");
}
exports.isField = isField;
function fields(v) {
    return Object.getOwnPropertyNames(v).filter(isField);
}
exports.fields = fields;
function metadataFields(v) {
    return Object.getOwnPropertyNames(v).filter(f => !isField(f) && f !== "__id");
}
exports.metadataFields = metadataFields;


/***/ }),

/***/ "./src/Versioned.ts":
/*!**************************!*\
  !*** ./src/Versioned.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./util/Core */ "./src/util/Core.ts");
const Delta_1 = __webpack_require__(/*! ./Delta */ "./src/Delta.ts");
const Value_1 = __webpack_require__(/*! ./Value */ "./src/Value.ts");
function versioned(v) {
    return v.__id !== undefined;
}
exports.versioned = versioned;
function asVersioned(v) {
    if (versioned(v)) {
        return v;
    }
    else {
        return Core_1.assert(false, `${v} is not versioned.`);
    }
}
exports.asVersioned = asVersioned;
const __versioned = new Map();
const __reachable = new Set(); // subset of __versioned reachable at current revision
// The (possibly already extant) versioned object uniquely identified by a memo-key. As an idempotent side-effect,
// record how the object differs from its previous version. External nodes are always created fresh.
function at(C, ...v̅) {
    return (k) => {
        let v = __versioned.get(k);
        if (v === undefined) {
            const v = create(C, ...v̅)(k);
            if (!(k instanceof Extern)) {
                __versioned.set(k, v);
                __reachable.add(v);
            }
            return v;
        }
        else {
            Core_1.assert(!(k instanceof Extern));
            __reachable.add(v);
            reset(v, C, ...v̅);
            return v;
        }
    };
}
exports.at = at;
function create(C, ...v̅) {
    return (k) => {
        const v = new C;
        Object.defineProperty(v, "__id", {
            value: k,
            enumerable: false
        });
        Object.defineProperty(v, "__ẟ", {
            // The delta map is partial; the absence of an entry is equivalent to an empty delta. This allows
            // deltas to be cleared simply by removing all entries from the map.
            get: function () {
                let ẟ = Delta_1.__deltas.ẟ̅.get(this);
                if (ẟ === undefined) {
                    ẟ = new Delta_1.Change({});
                    Delta_1.__deltas.ẟ̅.set(this, ẟ);
                    return ẟ;
                }
                else {
                    return ẟ;
                }
            },
            enumerable: false
        });
        Value_1.construct(false, v, v̅);
        Delta_1.__deltas.created(v);
        return v;
    };
}
exports.create = create;
function reset(v, C, ...v̅) {
    if (v instanceof C) {
        Delta_1.__deltas.changed(v, Value_1.construct(true, v, v̅));
    }
    else {
        reclassify(v, C);
        Value_1.construct(false, v, v̅);
        Delta_1.__deltas.reclassified(v);
    }
}
exports.reset = reset;
// Should emulate the post-state of "new C". Probably need to worry about how this works with inherited properties.
function reclassify(v, ctr) {
    const proto = Object.getPrototypeOf(new ctr);
    Core_1.assert(Object.getPrototypeOf(v) !== proto);
    for (const k of Value_1.fields(v)) {
        Core_1.assert(delete v[k]);
    }
    Object.setPrototypeOf(v, proto);
}
// A memo key which is sourced externally to the system. (The name "External" is already taken.)
class Extern extends Value_1.Id {
    constructor() {
        super(...arguments);
        this.id = Value_1._;
    }
}
exports.Extern = Extern;
function extern(id) {
    return Value_1.make(Extern, id);
}
// Fresh keys represent inputs to the system, e.g. addresses of syntax nodes provided by an external structure editor.
exports.ν = (() => {
    let count = 0;
    return () => {
        return extern(count++);
    };
})();
function num(val) {
    return at(Value_1.Num, val);
}
exports.num = num;
function str(val) {
    return at(Value_1.Str, val);
}
exports.str = str;
const __funMemo = new Map;
// Should clear memo table at each revision, but there are no memo-functions at the moment.
function newRevision() {
    Delta_1.__deltas.clear();
    __versioned.forEach((v, k) => {
        if (!__reachable.has(v)) {
            __versioned.delete(k);
        }
    });
    __reachable.clear();
}
exports.newRevision = newRevision;
class MemoFun {
    constructor(f) {
        this.f = f;
    }
    get key() {
        return this.f;
    }
    call(v̅) {
        return this.f.apply(null, v̅);
        // for an "instance" version where v̅[0] is "this", use:
        // return this.f.apply(v̅[0], v̅.slice(1))
    }
}
// Memoisation.
function memo(f, ...v̅) {
    return Value_1.memoCall(__funMemo, new MemoFun(f), v̅);
}
exports.memo = memo;


/***/ }),

/***/ "./src/app/AvenirLTStd-Book.woff":
/*!***************************************!*\
  !*** ./src/app/AvenirLTStd-Book.woff ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:font/woff;base64,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"

/***/ }),

/***/ "./src/app/Core.ts":
/*!*************************!*\
  !*** ./src/app/Core.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// First-class module.
class SVG {
    constructor() {
        this.hiddenMetricsElement = document.createElementNS(SVG.NS, "svg");
        this.hiddenMetricsElement.setAttribute("width", "0");
        this.hiddenMetricsElement.setAttribute("height", "0");
        this.hiddenMetricsElement.style.visibility = "hidden";
        document.body.appendChild(this.hiddenMetricsElement);
    }
    textWidth(text) {
        this.hiddenMetricsElement.appendChild(text);
        const width = text.getBBox().width;
        text.remove();
        return width;
    }
    textHeight(text) {
        this.hiddenMetricsElement.appendChild(text);
        const height = text.getBBox().height;
        text.remove();
        return height;
    }
}
exports.SVG = SVG;
SVG.NS = "http://www.w3.org/2000/svg";


/***/ }),

/***/ "./src/app/Cursor.ts":
/*!***************************!*\
  !*** ./src/app/Cursor.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ../../src/util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ../../src/util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ../../src/util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ../../src/Annotation */ "./src/Annotation.ts");
const BaseTypes_1 = __webpack_require__(/*! ../../src/BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ../../src/DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ../../src/DataValue */ "./src/DataValue.ts");
const Delta_1 = __webpack_require__(/*! ../../src/Delta */ "./src/Delta.ts");
const Expl_1 = __webpack_require__(/*! ../../src/Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ../../src/Expr */ "./src/Expr.ts");
const Match_1 = __webpack_require__(/*! ../../src/Match */ "./src/Match.ts");
const Value_1 = __webpack_require__(/*! ../../src/Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ../../src/Versioned */ "./src/Versioned.ts");
var Let = Expr_1.Expr.Let;
var LetRec = Expr_1.Expr.LetRec;
var Prim = Expr_1.Expr.Prim;
class Cursor {
    notAnnotated() {
        return Core_1.userError("Not an annotated node.", this.on);
    }
    assert(C, pred) {
        return this.at(C, v => Core_1.assert(pred(v)));
    }
    αset() {
        if (Annotation_1.annotated(this.on)) {
            Core_1.assert(Annotation_1.isα(this.on) === Lattice_1.bool_.top);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    αclear() {
        if (Annotation_1.annotated(this.on)) {
            Core_1.assert(Annotation_1.isα(this.on) === Lattice_1.bool_.bot);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    setα() {
        if (Annotation_1.annotated(this.on)) {
            Annotation_1.setα(Lattice_1.bool_.top, this.on);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    clearα() {
        if (Annotation_1.annotated(this.on)) {
            Annotation_1.setα(Lattice_1.bool_.bot, this.on);
            return this;
        }
        else {
            return this.notAnnotated();
        }
    }
    // Helpers specific to certain datatypes.
    treeNodeValue() {
        return this.to(BaseTypes_1.NonEmpty, "t")
            .to(BaseTypes_1.Pair, "snd");
    }
    nth(n) {
        if (n === 0) {
            return this.to(BaseTypes_1.Cons, "head");
        }
        else {
            return this.to(BaseTypes_1.Cons, "tail").nth(n - 1);
        }
    }
}
exports.Cursor = Cursor;
class ExplValueCursor extends Cursor {
    constructor(ancestors, tv) {
        super();
        this.ancestors = ancestors;
        this.tv = tv;
    }
    static descendant(prev, tv) {
        return new ExplValueCursor(prev === null ? [] : [...prev.ancestors, prev.tv], tv);
    }
    static parent(child) {
        Core_1.assert(child.ancestors.length > 0);
        return new ExplValueCursor(child.ancestors.slice(0, child.ancestors.length - 1), Array_1.last(child.ancestors));
    }
    get on() {
        return this.tv;
    }
    to(C, k) {
        return ExplValueCursor.descendant(this, Expl_1.Expl.explChild(this.tv.t, Core_1.as(this.tv.v, C), k));
    }
    toChild(n) {
        if (this.tv.v instanceof DataValue_1.DataValue) {
            const tvs = Expl_1.Expl.explChildren(this.tv.t, this.tv.v);
            if (0 <= n && n < tvs.length) {
                return ExplValueCursor.descendant(this, Array_1.nth(tvs, n));
            }
            else {
                return this;
            }
        }
        else {
            return Core_1.userError("Not a data value");
        }
    }
    toChildOffset(tv, offset) {
        if (this.tv.v instanceof DataValue_1.DataValue) {
            const tvs = Expl_1.Expl.explChildren(this.tv.t, this.tv.v);
            const n = tvs.findIndex(tv_ => tv_ === tv);
            if (n === -1) {
                return Core_1.userError("Not a child");
            }
            else {
                return this.toChild(n + offset);
            }
        }
        else {
            return Core_1.userError("Not a data value");
        }
    }
    nextSibling() {
        if (this.hasParent()) {
            return this.up().toChildOffset(this.tv, 1);
        }
        else {
            return this;
        }
    }
    prevSibling() {
        if (this.hasParent()) {
            return this.up().toChildOffset(this.tv, -1);
        }
        else {
            return this;
        }
    }
    hasParent() {
        return this.ancestors.length > 0;
    }
    up() {
        return ExplValueCursor.parent(this);
    }
    toBinaryArg1(opName) {
        const t = Core_1.as(this.tv.t, Expl_1.Expl.BinaryApp);
        Core_1.assert(t.opName.val === opName);
        return ExplValueCursor.descendant(this, t.tv1);
    }
    toBinaryArg2(opName) {
        const t = Core_1.as(this.tv.t, Expl_1.Expl.BinaryApp);
        Core_1.assert(t.opName.val === opName);
        return ExplValueCursor.descendant(this, t.tv2);
    }
    at(C, f) {
        f(Core_1.as(this.tv.v, C));
        return this;
    }
    isChanged(s_ẟ) {
        Core_1.assert(Versioned_1.asVersioned(this.tv.v).__ẟ.eq(new Delta_1.Change(s_ẟ)));
        return this;
    }
    isUnchanged() {
        Core_1.assert(Versioned_1.asVersioned(this.tv.v).__ẟ.eq(new Delta_1.Change({})));
        return this;
    }
    isNew() {
        Core_1.assert(Versioned_1.asVersioned(this.tv.v).__ẟ instanceof Delta_1.New);
        return this;
    }
    toTerminal() {
        let t = this.tv.t;
        while (t instanceof Expl_1.Expl.NonTerminal) {
            t = t.t;
        }
        return ExplValueCursor.descendant(this, DataValue_1.explValue(t, this.tv.v));
    }
}
exports.ExplValueCursor = ExplValueCursor;
class ExprCursor extends Cursor {
    constructor(v) {
        super();
        this.v = v;
    }
    get on() {
        return this.v;
    }
    // No way to specify only "own" properties statically.
    to(C, prop) {
        const vʹ = Core_1.as(this.v, C)[prop]; // TypeScript nonsense
        return new ExprCursor(vʹ);
    }
    // Allow the data value class to be used to navigate the data expression form.
    constr_to(C, prop) {
        return this.to(DataType_1.exprClass(C), prop);
    }
    toCase(C) {
        const vʹ = Core_1.__nonNull(Core_1.as(this.v, Match_1.DataElim)[C.name]);
        return new ExprCursor(vʹ);
    }
    static defs(defs) {
        const defsʹ = new Map;
        for (; BaseTypes_1.Cons.is(defs); defs = defs.tail) {
            const def = defs.head;
            if (def instanceof Let || def instanceof Prim) {
                defsʹ.set(def.x.val, def);
            }
            else if (def instanceof LetRec) {
                for (let recDefs = def.δ; BaseTypes_1.Cons.is(recDefs); recDefs = recDefs.tail) {
                    const recDef = recDefs.head;
                    defsʹ.set(recDef.x.val, recDef);
                }
            }
            else {
                Core_1.absurd();
            }
        }
        return defsʹ;
    }
    toDef(x) {
        const here = this.to(Expr_1.Expr.Defs, "def̅"), defs = ExprCursor.defs(here.v);
        Core_1.assert(defs.has(x), `No definition of "${x}" found.`);
        return new ExprCursor(defs.get(x));
    }
    at(C, f) {
        f(Core_1.as(this.v, C));
        return this;
    }
    var_(x) {
        this.assert(Match_1.VarElim, σ => σ.x.val === x);
        return this.to(Match_1.VarElim, "κ");
    }
    // Editing API.
    setNum(n) {
        Versioned_1.reset(this.v, Value_1.Num, n);
        return this;
    }
    setStr(str_) {
        Versioned_1.reset(this.v, Value_1.Str, str_);
        return this;
    }
    constr_splice(C, props, makeNode) {
        return this.splice(DataType_1.exprClass(C), props, (e̅) => makeNode(e̅.map(e => Core_1.as(e, Expr_1.Expr.Expr))));
    }
    splice(C, props, makeNode) {
        const v = Core_1.as(this.v, C), v̅ = v.__children, n̅ = props.map(prop => Core_1.__check(Value_1.fields(v).indexOf(prop), n => n != -1)), v̅ʹ = makeNode(n̅.map((n) => v̅[n]));
        n̅.forEach((n, m) => {
            v̅[n] = v̅ʹ[m];
        });
        Versioned_1.reset(v, C, ...v̅);
        return this;
    }
}
exports.ExprCursor = ExprCursor;


/***/ }),

/***/ "./src/app/GraphicsRenderer.ts":
/*!*************************************!*\
  !*** ./src/app/GraphicsRenderer.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Array_1 = __webpack_require__(/*! ../util/Array */ "./src/util/Array.ts");
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const BaseTypes_1 = __webpack_require__(/*! ../BaseTypes */ "./src/BaseTypes.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Primitive_1 = __webpack_require__(/*! ../Primitive */ "./src/Primitive.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Core_2 = __webpack_require__(/*! ./Core */ "./src/app/Core.ts");
const Cursor_1 = __webpack_require__(/*! ./Cursor */ "./src/app/Cursor.ts");
const Interactor_1 = __webpack_require__(/*! ./Interactor */ "./src/app/Interactor.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
const fontSize = 12;
exports.svg = new Core_2.SVG();
function scale(x_scale, y_scale) {
    return ([x, y]) => {
        return [x * x_scale, y * y_scale];
    };
}
function translate(x_inc, y_inc) {
    return ([x, y]) => {
        return [x + x_inc, y + y_inc];
    };
}
function invertScale(scale) {
    return ([x, y]) => {
        const [x_scale, y_scale] = scale([1, 1]);
        return [x / x_scale, y / y_scale];
    };
}
function transformFun(t) {
    if (t instanceof Graphics_1.Scale) {
        Core_1.assert(t.x.val >= 0 && t.y.val >= 0);
        return scale(t.x.val, t.y.val);
    }
    else if (t instanceof Graphics_1.Translate) {
        Core_1.assert(isFinite(t.x.val) && isFinite(t.y.val));
        return translate(t.x.val, t.y.val);
    }
    else {
        return Core_1.absurd();
    }
}
function postcompose(f1, f2) {
    return ([x, y]) => {
        return f1(f2([x, y]));
    };
}
class GraphicsRenderer {
    // transform attribute isn't supported on SVGElement, so it contains a group element with the inversion transform.
    constructor(editor, root, initialAncestor) {
        this.showInvisible = false;
        this.editor = editor;
        this.root = root;
        this.ancestors = [initialAncestor];
        this.translations = [Core_1.id];
        this.scalings = [Core_1.id];
    }
    get current() {
        return this.ancestors[this.ancestors.length - 1];
    }
    // scaling applies to translated coordinates
    get transform() {
        return postcompose(this.scale, Array_1.last(this.translations));
    }
    get scale() {
        return Array_1.last(this.scalings);
    }
    render(tg, [w, h]) {
        Core_1.assert(this.ancestors.length === 1);
        const root = this.current;
        while (root.firstChild !== null) {
            root.removeChild(root.firstChild);
        }
        const width = parseFloat(Core_1.__nonNull(root.getAttribute("width")));
        const height = parseFloat(Core_1.__nonNull(root.getAttribute("height")));
        this.withLocalFrame(scale(width / w, height / h), Core_1.id, () => {
            this.renderElement(Cursor_1.ExplValueCursor.descendant(null, tg));
        });
    }
    renderElement(tg /*<GraphicsElement>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.GraphicsElement);
        if (g instanceof Graphics_1.Circle) {
            return this.circle(tg);
        }
        else if (g instanceof Graphics_1.Group) {
            return this.group(tg);
        }
        else if (g instanceof Graphics_1.Line) {
            return this.line(tg);
        }
        else if (g instanceof Graphics_1.Polyline) {
            return this.polyline(tg);
        }
        else if (g instanceof Graphics_1.Polymarkers) {
            return this.polymarkers(tg);
        }
        else if (g instanceof Graphics_1.Rect) {
            return this.rect(tg);
        }
        else if (g instanceof Graphics_1.Text) {
            return this.text(tg);
        }
        else if (g instanceof Graphics_1.Viewport) {
            return this.viewport(tg);
        }
        else {
            return Core_1.absurd();
        }
    }
    // Scalings accumulate as we go down. Translations don't, because we use nested SVGs.
    withLocalFrame(scale, translate, localRender) {
        let result;
        this.scalings.push(postcompose(Array_1.last(this.scalings), scale));
        this.translations.push(translate);
        result = localRender();
        this.translations.pop();
        this.scalings.pop();
        return result;
    }
    // Scale circle by product of x, y scaling factors to maintain ratio of area to fixed rectangle as an invariant.
    circle(tg /*<Rect>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Circle);
        const [x, y] = this.transform([g.x.val, g.y.val]);
        const [x_scale, y_scale] = this.scale([1, 1]);
        const r = Renderer_1.circle(x, y, g.radius.val * x_scale * y_scale, "none", g.fill.val, this.circle);
        this.current.appendChild(r);
        return r;
    }
    group(tg /*<Group>*/) {
        const g = Renderer_1.group();
        this.current.appendChild(g);
        this.ancestors.push(g);
        for (let tg̅ = tg.to(Graphics_1.Group, "gs"); BaseTypes_1.Cons.is(Core_1.as(tg̅.tv.v, BaseTypes_1.List)); tg̅ = tg̅.to(BaseTypes_1.Cons, "tail")) {
            this.renderElement(tg̅.to(BaseTypes_1.Cons, "head"));
        }
        this.ancestors.pop();
        return g;
    }
    // For line/polyline, each point is considered a "child", and therefore subject to my local scaling.
    line(tg /*<Polyline>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Line);
        const [[x1, y1], [x2, y2]] = [
            this.transform([g.p1.x.val, g.p1.y.val]),
            this.transform([g.p2.x.val, g.p2.y.val])
        ];
        const l = Renderer_1.lineRounded(x1, y1, x2, y2, g.stroke.val, g.strokeWidth.val);
        this.current.appendChild(l);
        return l;
    }
    polyline(tg /*<Polyline>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Polyline);
        const ps = g.points.toArray().map((p) => {
            return this.transform([p.x.val, p.y.val]);
        });
        const l = Renderer_1.polyline(ps, g.stroke.val, g.strokeWidth.val);
        this.current.appendChild(l);
        return l;
    }
    // Polymarkers have coordinates relative to the points, in the *parent* scaling.
    polymarkers(tg /*<Polymarkers>*/) {
        const g = Renderer_1.group();
        this.current.appendChild(g);
        this.ancestors.push(g);
        const invScale = invertScale(this.scale);
        for (let tg̅ = tg.to(Graphics_1.Polymarkers, "markers"), tps = tg.to(Graphics_1.Polymarkers, "points"); BaseTypes_1.Cons.is(Core_1.as(tg̅.tv.v, BaseTypes_1.List)) || BaseTypes_1.Cons.is(Core_1.as(tps.tv.v, BaseTypes_1.List)); tg̅ = tg̅.to(BaseTypes_1.Cons, "tail"), tps = tps.to(BaseTypes_1.Cons, "tail")) {
            if (!BaseTypes_1.Cons.is(Core_1.as(tg̅.tv.v, BaseTypes_1.List)) || !BaseTypes_1.Cons.is(Core_1.as(tps.tv.v, BaseTypes_1.List))) {
                Core_1.userError(`${Graphics_1.Polymarkers.name}: more markers than points.`);
            }
            else {
                const tp = tps.to(BaseTypes_1.Cons, "head");
                const p = Core_1.as(tp.tv.v, Graphics_1.Point);
                const [x, y] = this.transform([p.x.val, p.y.val]);
                const markerViewport = Renderer_1.svgElement(true, x, y, 10, 10, false, this.polymarkers);
                this.current.appendChild(markerViewport);
                this.ancestors.push(markerViewport);
                this.withLocalFrame(invScale, Core_1.id, () => {
                    const marker = this.renderElement(tg̅.to(BaseTypes_1.Cons, "head"));
                    if (marker instanceof SVGCircleElement) {
                        new Interactor_1.PointInteractor(this.editor, tp, marker);
                    }
                });
                this.ancestors.pop();
            }
        }
        this.ancestors.pop();
        return g;
    }
    rect(tg /*<Rect>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Rect);
        const [x, y] = this.transform([g.x.val, g.y.val]);
        const [width, height] = this.scale([g.width.val, g.height.val]);
        Core_1.assert(width >= 0 && height >= 0);
        const r = Renderer_1.rect(x, y, width, height, "none", g.fill.val, this.rect);
        new Interactor_1.RectInteractor(this.editor, tg, r);
        this.current.appendChild(r);
        return r;
    }
    text(tg /*<Text>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Text), [x, y] = this.transform([g.x.val, g.y.val]), t = Renderer_1.textElement_graphical(x, y, fontSize, g.str.val);
        this.current.appendChild(t);
        t.setAttribute("fill", "black");
        t.setAttribute("text-anchor", `${g.anchor.val}`);
        t.setAttribute("alignment-baseline", `${g.baseline.val}`);
        return t;
    }
    viewport(tg /*<Viewport>*/) {
        const g = Core_1.as(tg.tv.v, Graphics_1.Viewport);
        // dimensions are relative to parent coordinate space, so not transformed by g's scaling
        const [x, y] = this.transform([g.x.val, g.y.val]);
        const [width, height] = this.scale([g.width.val, g.height.val]);
        Core_1.assert(width >= 0 && height >= 0);
        const outerSvg = Renderer_1.svgElement(false, x, y, width, height, false, this.viewport);
        if (g.fill.val !== "none") {
            outerSvg.appendChild(Renderer_1.rect(0, 0, width, height, "none", g.fill.val, this.viewport));
        }
        this.current.appendChild(outerSvg);
        if (this.showInvisible) {
            this.current.appendChild(Renderer_1.border(x, y, width, height, "gray", true));
        }
        this.ancestors.push(outerSvg);
        const margin = g.margin.val;
        const [widthʹ, heightʹ] = [Math.max(width - margin * 2), height - margin * 2];
        const innerScale = ([x, y]) => {
            return [x * widthʹ / width, y * heightʹ / height];
        };
        const innerViewport = Renderer_1.svgElement(true, margin, margin, widthʹ, heightʹ, false, this.viewport);
        this.current.appendChild(innerViewport);
        this.ancestors.push(innerViewport);
        this.withLocalFrame(postcompose(innerScale, transformFun(g.scale)), transformFun(g.translate), () => {
            this.renderElement(tg.to(Graphics_1.Viewport, "g"));
        });
        this.ancestors.pop();
        this.ancestors.pop();
        return outerSvg;
    }
    setMarkerMid(el, C, colour) {
        const markerId = Renderer_1.markerEnsureDefined(this.root, C, colour); // revisit cast
        el.setAttribute("marker-mid", `url(#${markerId})`);
    }
}
exports.GraphicsRenderer = GraphicsRenderer;
{
    // Additional primitives that rely on offline rendering to compute text metrics. Combining these would 
    // require more general primitives that can return tuples.
    const textWidth = (str) => {
        return Versioned_1.num(exports.svg.textWidth(Renderer_1.textElement_graphical(0, 0, fontSize, str.val)));
    };
    const textHeight = (str) => {
        return Versioned_1.num(exports.svg.textHeight(Renderer_1.textElement_graphical(0, 0, fontSize, str.val)));
    };
    Primitive_1.unaryOps.set(textWidth.name, Primitive_1.unary_(textWidth));
    Primitive_1.unaryOps.set(textHeight.name, Primitive_1.unary_(textHeight));
}


/***/ }),

/***/ "./src/app/Interactor.ts":
/*!*******************************!*\
  !*** ./src/app/Interactor.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tippy_js_1 = __webpack_require__(/*! tippy.js */ "./node_modules/tippy.js/dist/tippy.esm.js");
__webpack_require__(/*! tippy.js/dist/tippy.css */ "./node_modules/tippy.js/dist/tippy.css");
__webpack_require__(/*! tippy.js/themes/light-border.css */ "./node_modules/tippy.js/themes/light-border.css");
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Lattice_1 = __webpack_require__(/*! ../util/Lattice */ "./src/util/Lattice.ts");
const Annotation_1 = __webpack_require__(/*! ../Annotation */ "./src/Annotation.ts");
const Expl_1 = __webpack_require__(/*! ../Expl */ "./src/Expl.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Value_1 = __webpack_require__(/*! ../Value */ "./src/Value.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
function createTooltip(element, placement) {
    return tippy_js_1.default(element, { theme: "light-border", placement });
}
class Interactor {
    constructor(editor, C, cursor /*<Pair<Num, Num>>*/, element) {
        this.propFocus = null;
        this.editor = editor;
        this.C = C;
        this.tooltip = createTooltip(element, editor.tooltipPlacement);
        this.editor.tooltips.add(this.tooltip);
        this.cursor = cursor;
        this.element = element;
        const p = Core_1.as(cursor.tv.v, C);
        const propsFocus = this.focusedProps(cursor.tv);
        if (propsFocus.length > 0) {
            this.tooltip.setContent(this.propValues(p, propsFocus));
            this.tooltip.show();
            element.classList.add("focus");
        }
        element.addEventListener("mousemove", (e) => {
            e.stopPropagation();
            this.onMouseMove(e);
        });
        element.addEventListener("mouseout", (e) => {
            e.stopPropagation();
            this.onMouseOut(e);
        });
    }
    // Non-primitive dependencies render as a bullet.
    propValues(g, props) {
        const lines = props.map((prop) => {
            const propVal = g.__child(prop);
            const propStr = propVal instanceof Value_1.Num ?
                Renderer_1.round(propVal.val) :
                propVal instanceof Value_1.Str ?
                    propVal.val : "•";
            return `${prop}: ${propStr}`;
        });
        return lines.join("</br>");
    }
    focusedProps(tv) {
        return Value_1.fields(tv.v).filter((prop) => {
            const tv_ = Expl_1.Expl.explChild(tv.t, tv.v, prop);
            return Core_1.__nonNull(this.editor.direction) === Annotation_1.Direction.Fwd ? Lattice_1.bool_.negate(Annotation_1.isα(tv_)) : Annotation_1.isα(tv_);
        });
    }
    onMouseMove(e) {
        const v = Core_1.as(this.cursor.tv.v, this.C);
        const rect = this.element.getBoundingClientRect();
        // invert sign on y axis because of global inversion for SVG graphics
        const x_prop = Math.max(e.clientX - rect.left, 0) / rect.width;
        const y_prop = Math.min(rect.bottom - e.clientY, rect.height) / rect.height;
        const propFocus = this.propFor(x_prop, y_prop);
        if (this.propFocus !== propFocus) {
            this.propFocus = propFocus;
            this.editor.bwdSlice(() => {
                Annotation_1.setα(Lattice_1.bool_.top, this.cursor.to(this.C, propFocus).tv);
            });
            this.tooltip.setContent(this.propValues(v, [propFocus]));
            this.element.classList.add("focus");
        }
    }
    onMouseOut(e) {
        this.propFocus = null;
        this.editor.bwdSlice(() => { });
        this.element.classList.remove("focus");
    }
}
class PointInteractor extends Interactor {
    constructor(editor, tp /*<Point>*/, marker) {
        super(editor, Graphics_1.Point, tp, marker);
    }
    propFor(x_prop, y_prop) {
        return "y";
    }
}
exports.PointInteractor = PointInteractor;
class RectInteractor extends Interactor {
    constructor(editor, tg /*<Rect>*/, r) {
        super(editor, Graphics_1.Rect, tg, r);
    }
    // Determine which "diagonal quadrant" of the unit square [1, 1] contains [x, y], and
    // then map to the corresponding attribute of the rectangle.
    propFor(x, y) {
        const corner = y > x ? ["x", "height"] : ["y", "width"];
        return y < 1 - x ? corner[0] : corner[1];
    }
}
exports.RectInteractor = RectInteractor;


/***/ }),

/***/ "./src/app/Pane.ts":
/*!*************************!*\
  !*** ./src/app/Pane.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Annotation_1 = __webpack_require__(/*! ../Annotation */ "./src/Annotation.ts");
const DataValue_1 = __webpack_require__(/*! ../DataValue */ "./src/DataValue.ts");
const Eval_1 = __webpack_require__(/*! ../Eval */ "./src/Eval.ts");
const Expl_1 = __webpack_require__(/*! ../Expl */ "./src/Expl.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Cursor_1 = __webpack_require__(/*! ./Cursor */ "./src/app/Cursor.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
const View_1 = __webpack_require__(/*! ./View */ "./src/app/View.ts");
__webpack_require__(/*! ./styles.css */ "./src/app/styles.css");
// Previously Editor, but clashes a bit with the Wrattler class of the same name.
var Pane;
(function (Pane_1) {
    function initialise(resourceServerUrl) {
        View_1.View.initialise(resourceServerUrl);
    }
    Pane_1.initialise = initialise;
    class Pane {
        constructor(listener, appRoot, [width, height], tooltipPlacement, ρ_external, ρ_imports, e) {
            this.slice = new Set();
            this.listener = listener;
            this.rootPane = Renderer_1.svgRootElement(width, height);
            this.tooltips = new Set();
            this.tooltipPlacement = tooltipPlacement;
            Renderer_1.markerEnsureDefined(this.rootPane, Graphics_1.Arrowhead, "blue");
            appRoot.appendChild(this.rootPane);
            this.ρ_external = ρ_external;
            this.ρ_imports = ρ_imports;
            this.e = e;
            // evaluate twice so we can start with an empty delta
            this.tv = Eval_1.Eval.eval_(this.ρ, this.e);
            this.here = Cursor_1.ExplValueCursor.descendant(null, this.tv);
            this.direction = Annotation_1.Direction.Fwd;
            Versioned_1.newRevision();
            Eval_1.Eval.eval_(this.ρ, this.e); // reestablish reachable nodes
        }
        get ρ() {
            return this.ρ_external.concat(this.ρ_imports);
        }
        visibleTooltips() {
            return [...this.tooltips].filter(tooltip => tooltip.state.isVisible);
        }
        initialise() {
            this.render();
            const this_ = this;
            // https://stackoverflow.com/questions/5597060
            document.onkeydown = function (ev) {
                if (ev.shiftKey) {
                    if (ev.keyCode == 37) { // left
                        this_.here = this_.here.prevSibling();
                        this_.render();
                    }
                    else if (ev.keyCode == 38) { // up
                        if (this_.here.hasParent()) {
                            this_.here = this_.here.up();
                            this_.render();
                        }
                    }
                    else if (ev.keyCode == 39) { // right
                        this_.here = this_.here.nextSibling();
                        this_.render();
                    }
                    else if (ev.keyCode == 40) { // down
                        if (this_.here.tv.v instanceof DataValue_1.DataValue) {
                            this_.here = this_.here.toChild(0);
                            this_.render();
                        }
                    }
                }
            };
            document.onkeypress = function (ev) {
                if (ev.shiftKey) {
                    if (ev.key === "V") {
                        View_1.View.existingView(this_.here.tv).toggleValue();
                        this_.render();
                    }
                    else if (ev.key === "E") {
                        View_1.View.existingView(this_.here.tv).toggleExpl();
                        this_.render();
                    }
                }
            };
        }
        bwdSlice(setNeeded) {
            Annotation_1.__slice.reset(Annotation_1.Direction.Bwd);
            setNeeded();
            Eval_1.Eval.eval_bwd(this.e, this.tv);
            Annotation_1.__slice.ann = Annotation_1.__slice.restrictTo(this.ρ_external.values());
            this.listener.onBwdSlice(this, Annotation_1.__slice.ann);
            this.direction = Annotation_1.Direction.Bwd;
            this.slice = Annotation_1.__slice.ann;
        }
        // Forward-slice with respect to supplied slice of ρ_external.
        fwdSlice(externDeps) {
            Annotation_1.__slice.direction = Annotation_1.Direction.Fwd;
            Annotation_1.__slice.ann = externDeps;
            Eval_1.Eval.eval_fwd(this.e, this.tv);
            Annotation_1.__slice.ann = Annotation_1.__slice.restrictTo([this.tv]);
            this.direction = Annotation_1.Direction.Fwd;
            this.slice = Annotation_1.__slice.ann;
        }
        render() {
            // https://stackoverflow.com/questions/48310643
            const children = Array.from(this.rootPane.childNodes);
            children.forEach((child) => {
                if (!(child instanceof SVGDefsElement)) {
                    this.rootPane.removeChild(child);
                }
            });
            this.tooltips.forEach(tooltip => tooltip.destroy());
            this.tooltips.clear();
            View_1.View.render(this);
        }
        onEdit() {
            this.tv = Eval_1.Eval.eval_(this.ρ, this.e);
            this.here = Cursor_1.ExplValueCursor.descendant(null, DataValue_1.explValue(Core_1.as(this.tv.t, Expl_1.Expl.Defs).t, this.tv.v));
            // cursor may no longer be valid, how to deal with that?
            this.render();
        }
        onViewChange() {
            this.render();
        }
    }
    Pane_1.Pane = Pane;
})(Pane = exports.Pane || (exports.Pane = {}));


/***/ }),

/***/ "./src/app/PaneCoordinator.ts":
/*!************************************!*\
  !*** ./src/app/PaneCoordinator.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Annotation_1 = __webpack_require__(/*! ../Annotation */ "./src/Annotation.ts");
const Pane_1 = __webpack_require__(/*! ./Pane */ "./src/app/Pane.ts");
const View_1 = __webpack_require__(/*! ./View */ "./src/app/View.ts");
class PaneCoordinator {
    constructor(appRoot, ρ_external) {
        this.panes = new Set();
        this.appRoot = appRoot;
        this.ρ_external = ρ_external;
    }
    addPane(ρ, e, tooltipPlacement = "top") {
        const pane = new Pane_1.Pane.Pane(this, this.appRoot, View_1.View.defaultDims, tooltipPlacement, this.ρ_external, ρ, e);
        pane.initialise();
        this.panes.add(pane);
        return pane;
    }
    removePane(pane) {
        Core_1.assert(this.panes.has(pane));
        this.panes.delete(pane);
    }
    onBwdSlice(editor, externDeps) {
        // consider availability of ρ_external only; treat ρ and e as unlimited resources
        [...this.panes]
            .filter(editor_ => editor_ !== editor)
            .forEach((editor_) => {
            editor_.fwdSlice(externDeps);
            editor_.render(); // TODO: just redo selection rendering
        });
        Annotation_1.__slice.reset(Annotation_1.Direction.Fwd);
    }
}
exports.PaneCoordinator = PaneCoordinator;


/***/ }),

/***/ "./src/app/Renderer.ts":
/*!*****************************!*\
  !*** ./src/app/Renderer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Delta_1 = __webpack_require__(/*! ../Delta */ "./src/Delta.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "./src/Expr.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Value_1 = __webpack_require__(/*! ../Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Core_2 = __webpack_require__(/*! ./Core */ "./src/app/Core.ts");
__webpack_require__(/*! ./styles.css */ "./src/app/styles.css");
exports.svg = new Core_2.SVG();
const fontSize = 18;
const classes = "code";
// bizarrely, if I do this later, font metrics are borked:
const lineHeight = exports.svg.textHeight(textElement(fontSize, classes, "m")); // representative character 
// ASCII spaces seem to be trimmed; only Unicode space that seems to render monospaced is this: 
const space_char = "\u00a0";
const shapeRendering = "geometricPrecision";
exports.__dimensions = new Map();
function arrow(ẟ_style) {
    return keyword("arrow", ẟ_style);
}
exports.arrow = arrow;
function border(x, y, width, height, stroke, dashed) {
    const b = rect(x, y, width, height, stroke, "none", border);
    b.setAttribute("stroke-width", "0.5");
    if (dashed) {
        b.setAttribute("stroke-dasharray", "1,1");
    }
    return b;
}
exports.border = border;
function addBorder_changed(g) {
    const { width, height } = Core_1.__nonNull(exports.__dimensions.get(g));
    const b = border(g.x.baseVal.value, g.y.baseVal.value, width, height, "blue", true);
    g.appendChild(b);
    return g;
}
exports.addBorder_changed = addBorder_changed;
function addBorder_focus(g) {
    const { width, height } = Core_1.__nonNull(exports.__dimensions.get(g));
    const b = border(g.x.baseVal.value, g.y.baseVal.value, width, height, "gray", false);
    g.appendChild(b);
    return g;
}
exports.addBorder_focus = addBorder_focus;
function bracket(gs, ẟ_style) {
    return horiz(keyword("bracketL", ẟ_style), ...gs, keyword("bracketR", ẟ_style));
}
exports.bracket = bracket;
function centreDot(ẟ_style) {
    return text("•", ẟ_style);
}
exports.centreDot = centreDot;
function comma(ẟ_style) {
    return keyword("comma", ẟ_style);
}
exports.comma = comma;
// Whether the centre of r1 is to the left of the centre of r2.
function leftOf(r1, r2) {
    return r1.x + r1.width / 2 <= r2.x + r2.width;
}
// TODO: remember what this is for.
function blah(x, length, proportion) {
    return x + proportion * length;
}
// Offset might be better computed as a function of distance between p1 and p2.
function curvedLine(p1, p2, offset) {
    const mp = { x: (p2.x + p1.x) * 0.5, y: (p2.y + p1.y) * 0.5 };
    // angle of perpendicular to line
    const theta = Math.atan2(p2.y - p1.y, p2.x - p1.x) - Math.PI / 2;
    const control = { x: mp.x + offset * Math.cos(theta), y: mp.y + offset * Math.sin(theta) };
    return `M ${p1.x} ${p1.y} Q ${control.x} ${control.y} ${p2.x} ${p2.y}`;
}
// Factor all element creation through this so we can tag with extra metadata.
function createElement(name, createdBy) {
    const e = document.createElementNS(Core_2.SVG.NS, name);
    e.setAttribute("data-created-by", createdBy.name);
    return e;
}
function connector(g1, g2) {
    const g1_ = dims(g1);
    const g2_ = dims(g2);
    const [fromBottom, fromTop] = [0.1, 0.9];
    const connector_ = createElement("path", connector);
    const curveOffset = 5; // somewhat arbitrary
    if (leftOf(g1_, g2_)) {
        connector_.setAttribute("d", curvedLine({ x: g1_.x + g1_.width, y: blah(g1_.y, g1_.height, fromBottom) }, { x: g2_.x, y: blah(g2_.y, g2_.height, fromBottom) }, curveOffset));
    }
    else {
        connector_.setAttribute("d", curvedLine({ x: g1_.x, y: blah(g1_.y, g1_.height, fromTop) }, { x: g2_.x + g2_.width, y: blah(g2_.y, g2_.height, fromTop) }, curveOffset));
    }
    connector_.setAttribute("shape-rendering", shapeRendering);
    connector_.setAttribute("fill", "none");
    connector_.setAttribute("stroke", "blue"); // hardcoded
    connector_.setAttribute("stroke-width", "1");
    connector_.setAttribute("stroke-dasharray", "1,1");
    connector_.setAttribute("marker-end", "url(#Arrowhead-blue)"); // extract to helper function
    return connector_;
}
exports.connector = connector;
// Couldn't get getScreenCTM or getBoundingClientRect to work properly (perhaps because of nested SVGs?) so just use this to compute 
// coordinates of g relative to root SVG.
function coordinates(g) {
    if (g instanceof SVGSVGElement) {
        const { x, y } = g.parentElement instanceof SVGSVGElement ? coordinates(g.parentElement) : { x: 0, y: 0 };
        return { x: x + g.x.baseVal.value, y: y + g.y.baseVal.value };
    }
    else {
        return { x: 0, y: 0 };
    }
}
function delimit(delimiter, ...gs) {
    const gsʹ = [];
    gs.forEach((g, n) => {
        gsʹ.push(g);
        if (n < gs.length - 1) {
            gsʹ.push(delimiter());
        }
    });
    return gsʹ;
}
exports.delimit = delimit;
function dims(g) {
    const { width, height } = Core_1.__nonNull(exports.__dimensions.get(g));
    const { x, y } = coordinates(g);
    return { x, y, width, height };
}
function edge_left(g) {
    const { height } = exports.__dimensions.get(g);
    const edge = line(g.x.baseVal.value, g.y.baseVal.value, g.x.baseVal.value, g.y.baseVal.value + height, "gray", 1);
    edge.setAttribute("stroke-width", "4");
    //   edge.setAttribute("stroke-dasharray", "2,2")
    g.appendChild(edge);
    return g;
}
exports.edge_left = edge_left;
function edge_bottom(g) {
    const { width, height } = exports.__dimensions.get(g);
    const edge = line(g.x.baseVal.value, g.y.baseVal.value + height, g.y.baseVal.value + width, g.y.baseVal.value + height, "gray", 1);
    edge.setAttribute("stroke-width", "2");
    //   edge.setAttribute("stroke-dasharray", "2,2")
    g.appendChild(edge);
    return g;
}
exports.edge_bottom = edge_bottom;
function ellipsis(ẟ_style) {
    return text("…", ẟ_style);
}
exports.ellipsis = ellipsis;
function group() {
    return createElement("g", group);
}
exports.group = group;
function horiz(...gs) {
    const g = createElement("svg", horiz);
    let width_sum = 0, height_max = 0;
    gs.forEach((gʹ) => {
        gʹ.setAttribute("x", `${width_sum}`);
        gʹ.setAttribute("y", `0`);
        const { width, height } = exports.__dimensions.get(gʹ);
        width_sum += width;
        height_max = Math.max(height_max, height);
        g.appendChild(gʹ);
    });
    exports.__dimensions.set(g, { width: width_sum, height: height_max });
    return g;
}
exports.horiz = horiz;
function horizSpace(...gs) {
    return horiz(...delimit(space, ...gs));
}
exports.horizSpace = horizSpace;
function keyword(str, ẟ_style) {
    return text(Expr_1.strings[str], ẟ_style);
}
exports.keyword = keyword;
function line(x1, y1, x2, y2, stroke, strokeWidth) {
    const l = createElement("line", line);
    l.setAttribute("shape-rendering", shapeRendering);
    l.setAttribute("x1", `${round(x1)}`);
    l.setAttribute("y1", `${round(y1)}`);
    l.setAttribute("x2", `${round(x2)}`);
    l.setAttribute("y2", `${round(y2)}`);
    l.setAttribute("stroke", stroke);
    l.setAttribute("stroke-width", `${round(strokeWidth)}`);
    return l;
}
exports.line = line;
function lineRounded(x1, y1, x2, y2, stroke, strokeWidth) {
    const l = line(x1, y1, x2, y2, stroke, strokeWidth);
    l.setAttribute("stroke-linecap", "round");
    return l;
}
exports.lineRounded = lineRounded;
function marker(C, colour) {
    const m = createElement("marker", marker);
    m.setAttribute("id", markerId(C, colour));
    m.setAttribute("orient", "auto");
    m.setAttribute("fill", colour);
    m.setAttribute("stroke", colour);
    return m;
}
exports.marker = marker;
function markerId(C, colour) {
    return `${C.name}-${colour}`;
}
let markerFactory;
{
    markerFactory = new Map();
    markerFactory.set(Graphics_1.Arrowhead.name, marker_arrowhead);
}
// Assume root has a unique defs element called "defs". Return composite marker id.
function markerEnsureDefined(root, C, colour) {
    const id = markerId(C, colour);
    let marker = root.getElementById(id);
    if (marker === null) {
        marker = Core_1.__nonNull(markerFactory.get(C.name))(colour);
        const defs = Core_1.as(root.getElementById("defs"), SVGDefsElement);
        defs.appendChild(marker);
        Core_1.assert(root.getElementById(id) === marker);
    }
    else {
        Core_1.assert(marker instanceof SVGMarkerElement);
    }
    return id;
}
exports.markerEnsureDefined = markerEnsureDefined;
function marker_arrowhead(colour) {
    const m = marker(Graphics_1.Arrowhead, colour);
    const length = 6, width = 4;
    m.setAttribute("refX", `${length}`);
    m.setAttribute("refY", `${width / 2}`);
    m.setAttribute("markerWidth", "16");
    m.setAttribute("markerHeight", "16");
    const path = createElement("path", marker_arrowhead);
    m.appendChild(path);
    path.setAttribute("shape-rendering", shapeRendering);
    path.setAttribute("d", `M ${length} ${width / 2} L 0 ${width} L 0 0 Z`);
    return m;
}
exports.marker_arrowhead = marker_arrowhead;
function circle(x, y, radius, stroke, fill, createdBy) {
    const r = createElement("circle", createdBy);
    r.setAttribute("shape-rendering", shapeRendering);
    r.setAttribute("cx", `${round(x)}`);
    r.setAttribute("cy", `${round(y)}`);
    r.setAttribute("r", `${round(radius)}`);
    r.setAttribute("stroke", stroke);
    r.setAttribute("fill", fill);
    return r;
}
exports.circle = circle;
function parenthesise(g, ẟ_style) {
    return horiz(keyword("parenL", ẟ_style), g, keyword("parenR", ẟ_style));
}
exports.parenthesise = parenthesise;
function parenthesiseIf(parens, g, ẟ_style) {
    return parens ? parenthesise(g, ẟ_style) : g;
}
exports.parenthesiseIf = parenthesiseIf;
// TODO: use Point consistently everywhere?
function pointsToString(p̅) {
    return p̅.map(([x, y]) => `${round(x)},${round(y)}`).join(" ");
}
function polyline(p̅, stroke, strokeWidth) {
    const l = createElement("polyline", polyline);
    l.setAttribute("shape-rendering", shapeRendering);
    l.setAttribute("points", pointsToString(p̅));
    l.setAttribute("stroke", stroke);
    l.setAttribute("stroke-width", `${round(strokeWidth)}`);
    l.setAttribute("stroke-linecap", "round");
    l.setAttribute("fill", "none");
    return l;
}
exports.polyline = polyline;
function rect(x, y, width, height, stroke, fill, createdBy) {
    const r = createElement("rect", createdBy);
    r.setAttribute("shape-rendering", shapeRendering);
    r.setAttribute("x", `${round(x)}`);
    r.setAttribute("y", `${round(y)}`);
    r.setAttribute("width", `${round(width)}`);
    r.setAttribute("height", `${round(height)}`);
    r.setAttribute("stroke", stroke);
    r.setAttribute("fill", fill);
    return r;
}
exports.rect = rect;
// Rounding to pixel boundaries (although often desirable for SVG, e.g. to get sharp lines) doesn't work well 
// for small shapes, but we don't need to maintain the full monstrosity that are floating-point numbers. Round 
// to an appropriate number of decimal places, cast to number to strip trailing zeros, and then cast back to string.
// This seems to be sufficient precision for SVG but is also human-friendly.
function round(n) {
    return (+n.toFixed(3)).toString();
}
exports.round = round;
// Needs to be at the bottom in the z-order, and opaque.
function shading(g, fill) {
    const svg = createElement("svg", shading);
    const { width, height } = exports.__dimensions.get(g);
    const background = rect(g.x.baseVal.value, g.y.baseVal.value, width, height, "none", fill, shading);
    background.setAttribute("pointer-events", "none");
    svg.appendChild(background);
    svg.appendChild(g);
    exports.__dimensions.set(svg, { width, height });
    return svg;
}
exports.shading = shading;
function space() {
    return text(`${space_char}`, DeltaStyle.Unchanged);
}
exports.space = space;
// Content below or to the left is clipped automatically; content to above or to the right is clipped 
// if we set width and height.
function svgElement(overflow, x, y, width, height, defs, createdBy) {
    const svg = createElement("svg", createdBy);
    svg.setAttribute("x", `${round(x)}`);
    svg.setAttribute("y", `${round(y)}`);
    svg.setAttribute("width", `${round(width)}`);
    svg.setAttribute("height", `${round(height)}`);
    // use inline style rather than an attribute, otherwise any active styling will override
    svg.setAttribute("style", `overflow: ${overflow ? "visible" : "hidden"}`);
    if (defs) {
        const d = createElement("defs", createdBy);
        d.setAttribute("id", "defs");
        svg.appendChild(d);
    }
    return svg;
}
exports.svgElement = svgElement;
// Chrome doesn't appear to fully support SVG 2.0 yet; in particular, transform attributes on svg elements are 
// ignored (except at the root). To invert the y-axis, we have to add a nested g element containing the transform.
function svgElement_inverted(w, h) {
    const svg = svgElement(false, 0, 0, w, h, true, svgElement_inverted);
    const g = createElement("g", svgElement_inverted);
    g.setAttribute("transform", `scale(1,-1) translate(0,${-h})`);
    g.setAttribute("width", `${w}`);
    g.setAttribute("height", `${h}`);
    svg.appendChild(g);
    return [svg, g];
}
exports.svgElement_inverted = svgElement_inverted;
// Top-level SVG node with a "defs" element with id "defs".
function svgRootElement(w, h) {
    const svg = svgElement(false, 0, 0, w, h, true, svgRootElement);
    // See https://vecta.io/blog/guide-to-getting-sharp-and-crisp-svg-images
    svg.setAttribute("viewBox", `-0.5 -0.5 ${w.toString()} ${h.toString()}`);
    svg.style.verticalAlign = "top";
    svg.style.display = "inline-block";
    return svg;
}
exports.svgRootElement = svgRootElement;
function text(str, ẟ_style) {
    const text = textElement(fontSize, [classes, ẟ_style].join(" "), str);
    text.setAttribute("transform", `translate(${0},${lineHeight / 2})`);
    text.setAttribute("alignment-baseline", "central");
    const width = exports.svg.textWidth(text);
    exports.__dimensions.set(text, { width, height: lineHeight });
    text.remove();
    return text;
}
exports.text = text;
function textElement(fontSize, class_, str) {
    const text = createElement("text", textElement);
    text.setAttribute("stroke", "none");
    text.setAttribute("font-size", fontSize.toString()); // wasn't able to set this through CSS for some reason
    text.setAttribute("class", class_); // set styling before creating text node, for font metrics to be correct
    text.setAttribute("pointer-events", "none");
    text.appendChild(document.createTextNode(str));
    return text;
}
// Flip text vertically to cancel out the global vertical flip. Don't set x and y but express
// position through a translation so that the scaling doesn't affect the position.
function textElement_graphical(x, y, fontSize, str) {
    const text = textElement(fontSize, "label", str);
    let transform = `translate(${round(x)},${round(y)})`;
    text.setAttribute("transform", transform + " scale(1,-1)");
    return text;
}
exports.textElement_graphical = textElement_graphical;
function unimplemented(v) {
    return horiz(text(`TODO: ${Core_1.className(v)}`, DeltaStyle.Unchanged));
}
exports.unimplemented = unimplemented;
function vert(...gs) {
    const g = createElement("svg", vert);
    let height_sum = 0, width_max = 0;
    gs.forEach((gʹ) => {
        gʹ.setAttribute("y", `${height_sum}`);
        gʹ.setAttribute("x", `0`);
        const { width, height } = exports.__dimensions.get(gʹ);
        height_sum += height;
        width_max = Math.max(width_max, width);
        g.appendChild(gʹ);
    });
    exports.__dimensions.set(g, { width: width_max, height: height_sum });
    return g;
}
exports.vert = vert;
var DeltaStyle;
(function (DeltaStyle) {
    DeltaStyle["New"] = "new";
    DeltaStyle["Changed"] = "changed";
    DeltaStyle["Unchanged"] = "unchanged";
})(DeltaStyle = exports.DeltaStyle || (exports.DeltaStyle = {}));
// Delta-styling for the constructor component of a value (not its child pointers). In particular, primitives appear changed
// iff their value has changed, whereas non-primitives appear changed iff reclassified. Changes to child pointers must be
// visualised separately.
function deltaStyle(v) {
    if (Versioned_1.versioned(v)) {
        if (v.__ẟ instanceof Delta_1.New) {
            return DeltaStyle.New;
        }
        else if (v.__ẟ instanceof Delta_1.Change) {
            if (Object.keys(v.__ẟ.changed).length > 0 && Value_1.isPrim(v)) {
                return DeltaStyle.Changed;
            }
            else {
                return DeltaStyle.Unchanged;
            }
        }
        else if (v.__ẟ instanceof Delta_1.Reclassify) {
            return DeltaStyle.Changed;
        }
        else {
            return Core_1.absurd();
        }
    }
    else {
        return Core_1.absurd();
    }
}
exports.deltaStyle = deltaStyle;


/***/ }),

/***/ "./src/app/Slabo13px-Regular.woff":
/*!****************************************!*\
  !*** ./src/app/Slabo13px-Regular.woff ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:font/woff;base64,d09GRgABAAAAAF3YABIAAAAAw8AAAQACAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAABdvAAAABwAAAAccq/j0kdERUYAAFhkAAAAHQAAAB4AJgGzR1BPUwAAWvwAAAK+AAAFykUUsQpHU1VCAABYhAAAAnUAAAQQipmvtk9TLzIAAAIQAAAAWQAAAGBq+GQrY21hcAAABLAAAAJOAAADTlMmbV1jdnQgAAAIQAAAACIAAAAiAJgIKmZwZ20AAAcAAAAA9wAAAWGSQdr6Z2FzcAAAWFQAAAAQAAAAEAAbAAlnbHlmAAALuAAAQ/QAAJdIhK+t+mhlYWQAAAGUAAAANgAAADYBExUhaGhlYQAAAcwAAAAhAAAAJAYbBRNobXR4AAACbAAAAkIAAAayu6rgUmxvY2EAAAhkAAADUQAAA1zJRO7ibWF4cAAAAfAAAAAgAAAAIAPHAfluYW1lAABPrAAAAvIAAAaoVnILNHBvc3QAAFKgAAAFsgAACmlnvpTDcHJlcAAAB/gAAABHAAAATNKmThoAAQAAAAEFHnWZlbxfDzz1AB8DDAAAAADO6WmHAAAAAM+uZDn+rP9MBJwC7gAAAAgAAgAAAAAAAHicY2BkYGC68F+AgYHlzb81/7NY5jAARZAB4xoAo2AHNAAAAAABAAABrQBNAAQAVgAHAAEAAAAAAAoAAAIAAVQABAABeJxjYGbcwziBgZWBgamfyZOBgWEalN7CYMRwCSjKxsrMzMrKxMKygIEh34GBwZsBCkI8g/wZHBh4f7MwXfgvAFR5geGDAgPDZJAc4xImGSClwMACAMEUDuUAAAB4nI1VsYobQQzVrK9yDnLFEs5wmDRHXAxpk8J1SJEPyCfMh+QT/AlbXpHiOEKqK9xdY0gIWxoTUoQtUi0BB0/eSJo5ee2YGB7akUYjzZNGdg3J79bIXzRzni7dmsg1cTv6QHX1nmrYLqF/BZAL8XeyY28NZB+CjteuoTFAijrp+TvJB97zhn3WbCMG/KtV0sVlWldXNAEo25HDBCCJF9tsg0+ysb3su5LcdU3pzNF5XIqPnI94c+djq/fpcOZHnD3OfiZvuZPmqvG7/J3ia451kZ79p8JJ7HFmWy0QSzhtXZD7wn+uezP3LzTuTM6KPe9J3PnYj85xx4D8hEuOzzqPvL3mEQSwTbGe674Z8Exrw7WoFpI7/NPZW+HlENWKeZuUOq1z7MSZ1ALYJG5zHYaw9bMotViTY96PALxtNec9mPiblMMe/4dQPWph0ZiapFwa5cFIvjvinZCpV2vtx9r0zkmpvJySue8z3xtFp/gO/ND3V2Dq09IXqcujbl+WnvHFpx/GPSKP5jt6i/qulAfPnOxJqSd68l/S5hPMTJA+6f9X8jtflHq2pcfC4OygdR/EB2cd5yE4w7t8CvmcvhXdlGh3TxQvIO8UWO8+Q+cgbwDs3n0VW3xC87jE9x/gJ9avc45DWXJu5F3yTLjVt5xzCpxrrXPmGveenXVlDhNiveQ+C8z9GPNbapv05v3y3Fwd9gXPhHtB/rYy+2ZpuLhRWE4+AfGRj/iOZ1yaN/m/xOsM9GUmks4p4cCsif4CT7vjxgAAeJytk1dPlEEUhp+zH66IiEpRBFyHVRGsoCKCDZHeFRV7F5HejKBCjIq9EmussRfEEnuNmOiNP8AbhY/4CyxXJvs57npBvPDKk8yZM5OZd2aecwYw8LQwRHskWY/EPfaSSN2nkkgP7DrqQ5PESbo0SYst1BZne2/7ZHgZ3oav4W8EGZGOZsc3FahClEM5VYSKVgkqWVWpOtUa7nT6O4N+elnW7xO0juKCxEum1gnWOu9sHw0Mu+Hj1olwbHV8VQEqWIUp5daJ/0sHrWNYP6wv1lur3XpjtVlRlp9rq6vKlevKcWW70lwprtiuz101ZoGZb+aZuWaWmWQmmDGm3TQ6P3QWdhR3FNm3eN77H8xu83GT83DsboLtT2Tj3+a5i5ebdE+86YUPvfHVrPzoSz/6408AgQQxgIEEM4gQQnWOBuNgiOYZjpOhDGM4EYwgkihGMorRjGEs44gmhvFMYCKxTCKOycSTwBSmMo3pzNAZnkkSs0gmRec7jXQyyCSLbHLIJY98ZjOHAuYyj/kUsoCFLGIxS1jKMpazgpWs0vffxW72sp+jnOI8l7nEFa5xlevcpJVb3KaNu9zhHvd5wCMe8pinPOElL3jFa6mglrUUUSJVNHCRasqkgY2Uau09nNa+zs2pmPpu7Mpp1P4Gz9nGGio1zET3fIWu12pWs52dnJQACZQiWSelUibFsp5nekW7rsINUi+1UieNuq4r2SQlUi41NHOAHRxkH4c5QguHOM4JveMYZznHGb5LqmRTo39DhmSyWXIkS9J+AX22lsEAAHicXZA9TsQwEIVjEhZyAyQLySNrKVa26KlSOJFQmrCh8DT8SLsS2TsgpaFxwVnedilzMQTeBFZA4/F7o/n0ZpCYGnnj90K88yA+3+Au93n6+GAhjFJl5yCeLE4MxIosUqMqpMtq7TWroMLtJqhKvTxvkC2nGhvbwNcKSeu7+N57QsHy+N0y31hkB0w2YQJHwO4bsJsAcf7D4tTUCulV4+88eidROJZEqsTYeIxOErPF4pgx1tfuYk57ZrBYWZzPhNajkEg4hFlpQh+CDHGDHz3+1YNI/hvFbyNeoBxE30ydXpM8GJo0xYTsLHJTt76MEYntF+Vga1wAeJzbwKDNsImRkUmbcRMTiNzO5GFnoCzKwKHNsJ3RD8bcxMzOrr2BQcG1NlPCZZMBO2PxpgJOIMHPCyQS+IGEPpAAAEQgENYAABAANwA8AAAACv9MAAoAtAAKAZ8ADwHgAAoCHAAKAlgACgAAeJw9wm9IGgsAAHBTMzNzauZMLe3uvDvP887uv6dzzlemdzFkSMQYIUPiEfGQR4QMPzxEIvZBYkgMiZDHiIh4jIiQETEiHiP2QcYj/BAR8RgSj5CQiBjx3qfH76dQKCr/+0tx0TXd9aWrqSwpq8oD5bnKqmJUcdW0akW1obpVW9Wz6gN1qxvurnR/0kQ1Vc19j9CT7lnsWdXqtFvam95078feax2jy+vO+8b7Fvu29Fq9qP9df9M/1b/a/92QMnwxPDyaflQxKo0LxrqxZTKYIFPClDUVTMumtvmleX8AGlgZuLcULf8M4oOlwaZVbS1brx7HHu/bUFvO1hoaH3o/1LRH7R8ceofoKDlqjisn+p/XzvowMDw3fDGiHimPvHfpXIuu31zvXFU34464i+5td2d0bjQ32hi9A8yAE+CAN8AysAZsAvugBXSDOCiA42AKfAX+CX4Dz8Er8BZSQgbIDsEQBYlQHHoBzULz0BJUhGoeyBPwhD0JT9qT8dThNJyBF+A8XIJX4XUkjrxAZpF5ZAkpImWkimwiuyiDRtEpdAbNojm0gO56GW/UO+Wd8Wa9OW/b+wPTYhbMjeFYDdvB6tgx1sDOsBbW8Sl8ep/NB/nyvltciRtwOw7jFB7BJfwSv8bv/Rq/2T/ix/ycP+Z/7n/pn/P/SuiIIlEmqsQmsUscEifEKXFJXJN2EiYpMkJK5DT5mvyFfEMuk+/IDXKbvAlQgULgJHAauAxcB+7HNGPmsaWxB0pHWSmAIiiRilN79BQ9Q2fpHF2gV+gKXaN36Dp9TDfoM7pFdxgFo2dsTIlpsAk2zWbYBTbPlthVdp3dYvfYz9wMl+VyXIFb4Spcjdvh6twx1+DOuBYv8ON8in/F/8z/wdf5I/4rf8pf8Fd8h38QnIIozAprwkfhe1AZFIJzwbXgcfA82BGNYkpcF7fEPfGz+FVsin+LbfFHyBByh4TQ81AmtBDKh0qhg7A2TIXXwtvhw/C3cPuJ9GQpoo6sR3Yie08zTy+j88/wZ52YNmaMQbHyT4Fx84RzAp1g4ob4w+Tu5OHkSSKbtCSJZCI5n3ybPEreSQaJkdLShnQkNaULqSW1pTtZIWtlo2yTYZmRY3JKzsg5+a384V8BfBT8AAAAeJzFvQt4G9d1IDx3ABAESRCD95MASJAA+CYBAgOS4FMUSYl6UC+TlkxJlmSLcmzLlmULduLEUW2LceVHYsWiE2+qbZSHHDcGIUQN8zeP3WZbN1/+Fk3dNH9X2yrdJN22SavdOP3aJAb33DMPzECgzORvd22R4L24M3Pvueee9znDaBj4jyyyPqaW6WWGmA8wWWbzfLax27vSaBi+ExvV0Kg2ig0WGqxm+M6rXWRQ256t5lZs5J38FduqjV0YtVfbXLaoLWWbts3bFm0Z25Jt2VazkGW5lQR5Z9SuTzgTkQSfmErMJY4nziTOJS4mahbyn01cS7ALPb0ttlBjU8LcF2+M2TXDJNHXxYaaqvRVdpsjHuOHSTzmsNuq9PWkgdCeZEIvfPSFYRhZ9Bb/xOcjvd5834Q52N3YmtbX1tfo9FUtDV1NXSGbtZ6r56acFovLZbE4vV4v+ZHXW/yfVRMxR7vfatMbjLUWlq0PuYJBDWusHzfV1ZkeMLtcZriAYZkoAOp5gJOGMTGTApQYgAUjAcYIDSMAZkVP3rl2Rn9Of1GvWbi2U39IfxL+GDXo9U59RM/rtbBe/TU9Xa81rgnp+5LCskJN4disKeb2upxen8vpYX3FFx53+bxOl9fLrK0xLnKK+R4b5sKwUwxXxdRm6NaxuH9vkhuMlwkwHxHmZYep2GvFebmh4ZYaemjoNWKjFhq1dCu1RAdb6eay5PoKQ97J6rms5npWx2UNBfrbWMhquKypkOUKWcJlzYWspZBluKwVfzuhn8v6CtkG6Oey/kI2UOjpJfqQPg4/IR5/+Dj+xPXwYyLQIG/qDtTt1+03Jo0Z+KF/wU99oj5Tn6z/eqYuQw7GMrGz8J/48XqG0az9Yu2z5AH2MaaRCTPtzCFhtSZYhknaBQs0LFKDQINIqw1CI0gbhFuphkVauBU3eSfXTExmSz/gcbalkGsVGgCJNliDMxGOJOJ2hzPRBbiY5PFvewh67X5CEdHO90XsSY3Nmaj66NapdKRr67at2/iZsXRzx9yOO3YeO3bs5r59+/ezDQ9MGcnXHZODA9sM+/drGu6fqmP/H/cUPzGt3/+jcc9KDdk16n6jBnYS9tnGMJo+1seFyWOwzxHyKLkMn3ryGLmxth2wD75nfYCHUTivaeZ1xXmVlm2GhllatgMaDmGTNbDJsJFVhayZW6nD81jnrIvU8XVTdXN1x+vO1J2ru1hHz2PdtTp2IVtfyNZ3Zxvx7OavJFYTeMITrkQ0kUpMJ+YTi4lMYimxDEc41+pIUMjVc9muQm6wqxEaOW/rIP2I4Aec7iQfAhCGqvR+OMm8nWJ8hP5K9PEIYPF4OyLigQ/zeLCh4UySTDObvBTX9QLwjfVmWygWnTix+/ip9sDseHrrQHrvR/ZO8jP8LntHKNTlbd//UrKf53dsCtnYeFWweWLn+Fy6PRFITAwk2sebdiXbRroS3Zt/4W8MBhxt0R44Qni+DrNhgLC17HSz1+lR1Ydc01yUDedhLL+2jbnJzjMGpoEpnSuTkkTqhu/s6eVtzhBdXrwqk0k/+WQ68/YPLue+82dfugz3YOAeq8p74GUm5UEV7tEXiQNc9KGkdI8bl7/0Z9/JwT3W/oX5VxKHOdczfWVzrrqeI1UMBb9e+KjRE7pBNVxWi6fYCAhu1fNOpEoRPsI7I1+uf9T2oTtTI2PJuQ/az3Bs+KnEuONI9JFHokdco4mn6JwZG7lMrgIFsjNXCWEAoeBWOqQDerjhEInDDsMewynJp/P59Ft8Pg//KHxta59lnmeOAXyrmRzRaNrhgAFBsEV3je3/2teQjMHPKpNnbsIYA70/q4VBFGXy+Zs8/R5pMHMPPL9fWK8B1mugRFdDia7mnOaihhJdzSHNSQ0SXY1TE9HwGkp0Ndc0lOjyCoIblYhtr0Ro6b58lrhgXzQMp4CpiW4FpdfX09fT7Py7O5D2wlkkLwHtrWWczL3CaA2M1kjkVp6eCU+byWmKmHjTlGnOdNx0xnTOdNFET5vpmglOm4ZbsdNzZl+14zmzu+xRe8o+bZ+3L9oz9iX7sr2mbPq8gv3Z7rtzz70n5u64d2x8MD02NJIev/ng2Q/ef/Lc0yfnj907t/fugwhfhsnAfHVMc4XZ4kIp3YCpEPJOT2/cDAfWnE5nyBW+GITrgUSRvXC9g9mqoL23XG9CCpu/Ur1ajUupdlVHq1PV09Xz1YvVmeql6uVqEAoYXHBPbytJUF4Pi9AD2khUIE72Fq89mWmPd7UMTO3YvPuxe292H355oLHD0j/XPtY//tou3KslnE+Y2SXMxwVTcMF8rrKkGZDTxa2Y6UTMq2aciNlljppT5mnzvHnRnDEvmZfNQLuqm80CCwBC/E7OX12D5MouwradJCQgl+anFzhAqCkyOj4+vWk85Ogf6unqjgxs3rFl7u6hTWcOjg+1O0YG+1OJFN/ZZU3NtW8bvauNmGZSs0dtAt9e+yb5AMy9BuSJJvVuXK3Do1WnPFpAO61xMx6tSDwR0t+8+Yve2dn07/wO+4WxHnKyuMw/mX/3F3jOBJi4mU6mxOYFmDi17VfNpFrbnuOqyUK2llsxwoo5MwHEcsq4pDc3wmNkNIvYUj2bZ2a2h1qJ63tm6+HFx+/ui3VZt01t3lxFavhX2cN3HXzIVDoPcHYcwKEfFp5ug6fbTEpmJDXqoVFPOVM1CcJqHRzKHmwhV1VvoxTrEJ1iPbfiwbPjcXoiHt4z5ZnzHPec8ZzzXPTQs+O55mEXcoeCdAWEngO9s3Q+kKc4CWU3wsrIYrPn+H06TXrv9N1H9x04ceE3fI3Ff9SNp+ObhpMzbIP2g4+TkcPTO049f/bVrK74W7tPTAwmN4u0CeC6CHDlYJWlww1wXdFRLHYOa3hK9hrt9Rr9/WxLcjTwT/1kMTgaaySZ6QsvnE3MnO3in3phWeThCCcn7Hwn8wxTEl0k4FRBo4qeJRBTwhSFw6thROGwKxwNp8LT4fnwYjgTXgovhwGFG6vCFIWruBUvQsvr9Ea8vHfKO+c97j3jPee96KXQ8l7zArQ6vHRwjmnsoB+1+AHQEzGa8qtEiR+biERkIlVKfmwZHX7wjr3HHk/xJ3ZvP3z6qyOD6Ynx3ff+dCzRNz49foSkAjO9E3fuG7tnkG2Y7BjZvW1o/+ClrkQy0j4Y7v2v0e7OUOtgoJviDMD1JaQpjcwMU8IMAWNtgLFBirGgQ2QZOA3dIkrkr3hWPQgRj8sT9aQ80555z6In41nyLHtqJHzmIzIeiMhMuoiwhngs3eS/d1GnGdi79fDRvQuLL3/Y30Qs2k1DyZF0alta98T7ydDdMzsf+MjZT71ZRQ7NH9ucTE0JMvck/P4CyGWU7j+ioISGcrq/UbZESSal/pTKswsSEzBITEALf4/aZ+2H7Q/B32omYFb8PSnxs3K+RvZJDA7nHwVeLMzfxIwraA/MP2c0aaiYuGIARDIsGjKGJcOyASZ6xbBqwDkZXIaoIUW7Rg2zBtRjFFPQAE+Xp+EH5k4eEh9d3AZsHugT4wcZ4gqjl/irDp6sM6Coo7O3JFrsulmg/Q+Rl4pvfP9c+vXkF9JLgp7zJFy3FU6PHmjbVR3RAmqgDJIbZchCbpRQGmCGA6iDH3K5eBcMt/L8KzwvyhZ+wDPFc1Hewud2koQOrmqBx74Bj32I7P3hUvoLydfT5wT9ivkZyNteJsI8KVzJwZWcJG23QKOFnlSOW6mleFm7Wot4Weuqjdamaqdr52sXazO1S7XLtXBSjS0cysb4kW3hVgIURQLnAhcDFEUChwInA4giAWcgEuADFEUC1wIouVBE5iVeKXPKeji3TqUaOVYT8vobuzs6OmM9Y7ubQw0h3Yy0I6873A1dDldHQyhiSVrHBlr7PY5Ob5358TL8WGLvhzPZxQwwrzIlI0BtGenGhhUaVkrHO6jAdtVNemFLzPXVdJmcW6DhQaRKQWcwEuSDU8G54PHgmeC54MUgpUrBa0E4AdUbInRcL9wwyGV5YIm68rMdKhF9ajSQZSNBndDIfyZ58s6+3R957TMfef8n79g0o9dEN3XGDmzvGDDowqH4maMPPPPEYzt2399g7eWdztCA/pD75bPPfvXV0/PvP3Bgy9iBU5ZTgw0TuyaPnbnwyIkn3GSiatdEW8eJCYTd2jcB2W4AvphAj5hVYHhFpVQiFFetxIjCNPJATYEK6fpCtrqQrS1k66gWvsJRLsMDh4lb4X/6GQnpraBlZ/L8lzflk/nhnre7P6nd+wbP8+SHRS/Pnz1LfutHMCfBxvMSzMnK+JgWZq8wqzp4dp2xjN9cbSAe2L5uD5yo7gb4xXgaRM5CleY6lJGotmwrUJ0f1IlQIdtckNgHFZao0Ig7YiKiAGW3Sn+Q0ED8vgdW0+nfPXFXtPfeLVtGpmcnRkYHdgySgGlzbGYHT77ID0+2D3L/0B3vSb7FrLX3dLe8Sc+vG359G9bgZB5SYGS5WYqikYmikWnVhGhkcpmippRp2jRvWjRlTEumZZNgkLIjStqd9oidt0/Z5+zH7Wfs5+wX7RQl7deA/uacbLWguZbwiqr/MkaRb8/vP/38i4/OzacTmxbuXlyYXYjHP/b+D7/Q9twx98lj9z7aJ9pn/hDmXQc604Awcy1MVmsss8Lgzmu5FRY+GDS6gP7NIqDtBaoGyXBtJ7wkmqbTX3n6I698OJsZPnb/0ftHKPQ+/MEXX+BPPrR4XJD3cd+dzBRTQj5j+cGtViIfiJxVhVx3NUUAIxw2KwIU5pB1FAT6GkqE7FTPkz4bYW7kpfT1Y+n0sevp4kNp8kP+0ok30/mxt05cgilJup0wF7ukOyDKGct0h6tGYMHtVDegcACs08JHDT0GOJtct4UsKKASDyFcyuYEimdamlCawkScDSPiEdpPGphHb4NHVz3ELZg3/62wiVqVfIX1kSmBxhFy48DBJy688sSBu9Kp6aPHTx5LjaTz6fZ2JVbZn0WWJsAU1+JlPlThTKPoXX7AseGBhoeu0kxJNgUz3XkCMGYBvEB7dEh7DAXpwAMqmuBbUBSo7c9KcYEa/gxc1lXIuumq4rAJSJXMuA5ACvykGgtZTBffhlXAP9KBn/xbb/F0X/g33+T54m5eXAuTRzs0X+GU1ECjpuyUVCGNhLOCU5WOiPDMtPAc+gzh/mvfW1vC+5uZDvW+g5RpUsqXsOdVEtL19OpR+hVvjFwmauQiQbg9P2U1jZL2XvIteMbgtm2akj2W0n8jYNqpChi2voUSlVfRQlliA8rpwMqFrQDVjVpjzQXhIID4KOwIbARyBsHSpnc2KkBCbuTb//yv+vLJ/+8vi/tE+PD8977L83/630pwwvlfxvlX2gdEsA3vAyUO9Ek308W7xL04cUnE2wuIt++vQJfQYi01VBZrycauIl8UXBq0WlNNjCJtTSFXh+auHCdYvQSTNZIwagEFzHVRUFlFyNAJa+B/s4zAVrLz2ot05trV9i9rKawu5u8hv0thxJOl4hj5ejGDGFzcojyHdma/QrasuOOqcyhBk1IQBCiePOWZo/Z33GjgsAJQQ0QxTxInl+nsit/DSWZIVAvEly96yZvFJWGCuwEnKc3T4NlS26mM5frKv52dyrqOncq9dOrkh5dOPvjM2OG9+w4dmJ87SEyPX3gh89QrLz91LJM5duiRk6VzdAXmzMHshxQatzRnXAClYW40lgg2K4F7AV2iXhhpn/kSYRJmxEviSIYC7ebd88cPaUY2pcceubmKMJue3DHLd8d6O75GYQeycA/ubaOkKyExMqLUJki8HEygBkX5/JXAagDhEnAFooFUYDowH1gMZAJLgeUAhQsVWiNKc7cdJQkFhNie1o5PLtz1IAXUyYXh97WFi20SrN5nfML04snMx18888hHjbp0LZm4BWaU9gSZVmbhNjBTewZa1wNgjmNaBeFPJDN6LhspZKO3wpTawwIEurpIN+nSlEP4yNyL5qBjdOQ+o7O2yeL1+Kz8yKbBcRne0x9waQzB8Ene1WpNN4ZtOr4rTqFP6fYv4NcDsKZO5rSwIifM21kuN9DpAuaKPrYp/Zz+uF5wwtVI/rask1vx0x3yr/pxh/wuf9Sf8k/75/2L/ox/yb/sBw3DxPgp5QjrnSj7xZvQB4S708VGujRlrNvPOv0a2MdP7dyZ7hoe2WwKxkL+oXjgfXfu3pQOD6ZHzE2xJv9Qr//Bxg/tN/U023wOW22NqynePDbb9ME7ud4mR4PTCj2NvaHJ7Qr6a5Lor0pOkjQvJBdVAv0VWAPQX1AUqFmfh22xi0IRJRWZdCYNZCKD/PDEpUsnkNIr6ZZbogoqbEEEkRqo84omDQC0aMCY0sxpjmsEC0eNbMwQj5+gugiYI4oJIiVQsNOw2MjMTkztAmR5+Oihh+Hj/90yu2eaOICU/fjgI/cfIh4QeYhCt5pajzdJDeS5FRmVAC6krhRWVnw8Jf/08zvai2P5/mubcqn88CT5LSSlP5SeramDZ/skWUul1eG+VAScisVLghdV6JBnoZxF0NpCtSrcQZGzg3AlyFpmTg1EIk0WFMFIiBf+kFZBjj226U2Y/Me1mdAAmx9+TfsyLCi36TEyVPx95A13k7GD+CGsbkjEuRvIj5+pwL9USCHhQekolvOvXBXHUqqh0F9zNuzKGW1V9BuOW6mnHlhcncCV3YWsp5Dz4vfAPHA1TkmKEbRdPX7w/f35xOlH0/n+j38c/nr0NPx1ga7r9dd5/i/+guevXOH57ypwxc7sqcDx0EdaLlyqaWCNqPLillRJDnArxWiYoTA3jUAGE8J+OL/7Yn8+Lf7f9Rxx/jFA+Jcwr8+TKp7/Y7UeZGTaK+CRLBHohKnU4SRApiKNeKRJI5WpyHTxHdBwil8mdaBv9ZL8iUu9xW0gWsH906JvUi/dX/JflYiJjjaUGhZ1bYlycz6TybPz/LtHeJSZP4v30qhsZugLc4Y08Zvp6+n9bE6yj28D+Zo+N6qgWyYlnYbnqh7qFDlInj40z7Ofos/8MXOTjAJ8ZDuddMYpWugR1S+yJ0bPp8+PksIN0lF8G5+/ll17jWjX/hjm6hR9h3mGcIRdyDMsx1L7mb7R3khNi2/EYmtrTA25wbzCzoOEuINsZQTbDeU1p8hloIdNkv9CshKqiIpKGL1qoSYTUU7P1VYj8sOBcFJe41x1Iq9xupxRZ8o57Zx3LjozziXnshN4jVsYDMhFYyasVCRooFxUsmQNirY+Z5OoI9pmdkxsTp/WapJb06N/3tbaOb4j91xLaDRJPhwa3vz3/NDQUPLZtuZwaGkmGBzaIckE1NdQw3iYDzMlAVvlhpEWiCqjRtgmoPKsk42wPDvFzrHH2TPsOfYiS6k8e41l0az33l6+XB0aAkH5pfAAelvyMiXiJcsdxYJMc/OWyaFksoskx7bMnTg6NJPODFXP7pja09rXceqOu99vZetFvkX9J4uwT2pbkLSI/zu2oMWRLQcePrOwaSjd0L5569bpsdFg8P67733YczBVs316djYk+scuw17YmIDERZA9mJTEVVoG0gVNOYmSrDTIP3LVOo1IUDeAbVaOijRUAWqg2JZAd6LSaBpP2EsLupkBPGN7hrccOrGnq4Nt7R4ZHUoNRthG/t2/5uPxU/NHz1hf+gPL9u3bZrsl3x/dEwvjYh5TeB7LlwNCM1W3dbgOgDpsYgREnSlmjjnOnGHOMRcZCnXmGgNQZ3W1dMq1G/SNi1ElgnDdQBr9hEef4F+NjYxN7V88vnfLbPEnmrGXdYdivJ5vHWx5+MC9p47OBzbv+Nb9/fESfe6APfIyL1c4LSpEw9NiGFZLZrkAIdTYQ0lc/op2VYsz1rq0UW1KO62d1y5qM9ol7bKWypp6amGlfs5qUefDwBxRAKgRBYAcY4NhJgf6OAWcQypRUgNFR2cHb3O2R44dozJ3emY83kNuDFb1dAb54rdAzk7yjtkddsFPu7ZNPD9NzOcUOo1BiYc6sYH0l9KE9zbi51htkPJ5K1cjouUG7GI1G/PntSQUmCpYYhKUmJgVZ7AD8XXx8PCOOw6lB/nRcb61Y3x0OJVqNTd0nZo7mnEWnz5xl3nA1k8+V7N9x/Yd7aU9/yLsuQ/Qr7Rmk1L+kUCDfj7pVHqh4VULmTm9SUvXLptwBdsDiMQOukjHqgMX6XA5oo6UY9ox71h0ZBxLjmUHkCILJwhCsg0lLrMEuskYgoDGrQzpn0n3wz5HGzfFqFz/w/RP+ifSP+H5H3WGhv+FF/1WeXaYMZTZnct52VUjsQrsS22ARmFZmghFNaVGn6baRNRts7npD8Wt4ss8a3R6PDaHx4O89McgD5yF55vgJC0wt7IaFMd0SuKgQ+LgFnTRakScamd1pJqvnqqeqz5efab6XPXFaoo41deqBQZUh2JECRlQmYgoJprhk5ypuq7Zlc7MStP17dmsSZDOHvI8f0KaMSvqXfNMHeNg7mZKQqJJOUWDUpyRsADDLW8R6hnhRItIIBjR6zlJfmyMiAZfKt22yDAm039wYSDf99Jr6eJdCOPvP8fy/LNZOL5/T+mubCelcWO9FXC1ktpTaTPTgjoo3FTWBT8FNKGT+Q8VsEV1BiqKDNiQgyxpowMaHeWnw0ZPR67OJh0SpTmZ5bJe+EMMIs02FahzyYs2hxANycy2y2twxpFhVTwe6qMCTCyxdadPk9rZPwgHJhwa6ZU/KOL294+Pjw78lOf/e0dk9J+lDwVdAJj4gDW9B0x+TbrAouG2/Nyvs7B0+lFN+cFP8oOD0sEX5y3FpV2+xd53S3zC/4G4tAf37b3nfXfsPT42Pjw4MjLaP144cup9h489+tCJ2d1AgbdPYSzUNpwvjQF5RhFRKc0XtSKpgRKTRDjQtnqLzVwwBedq9DoKciHSF9bpdrojbt495Z5zH3efcZ9zX3TTdbqvuYF12S1uOlgnyOJOibU6FVKq3p4oia/UyXRaq+0bnt5/Ynd3B9vSMzwxlEx0P4lntafn4TvvftxKXvwv5i2zM7vjjMx3L8M6zYBRz1WgiaqlycpGuTtgAwFRVdUeIRx3A9H5Pb06RDMle9UomOrlfFpmq2mJn8IqvyBw1Hf/mdwo56VaWKON2cmU9CSDcr8qyk+Sob9kxM8aMaIix+mNQoRS6YCXSADR2m0TgTRuBhuZMHHkkHbkJyjuDA1pYD5+jFm8DNrwmQonQTbIaJBc56/UrNYgqGpcNdGaVM10zXzNYk2mZqlmuQYYtIdbaUToNzobI41841TjXOPxxjON5xovNlLoN15rBOhbGjUY+OwRIgmtlS2GIYVlMRzp0vgPbBnenA61RpNGEIDcsaj74PbNY+mWtrbBRI873uYhvXzacaTf4PFydlN9dbXFE2lIjXgX+g3ehoCvXm/xRkX+8HO0ezxWwaaHSrm0eJXMJ7M0QTvPzRpALBWMHwyGUcKqzU5zxMybp8xz5uPmM+Zz5otmumrzNTOs2soYRIupYNNLoI3YjEhkr/qd3lEQSs+ebfY0hlp6YqSWf6A2wxfXfG5LgpKrtX+m/Bf2ycUcqKB5Iys2KBdRnsUg2aDE6RuqWJHcCnYbLYf+axJSqj1D2BRlx7Sg8MwMjaYzHaGJdvIAFWoGBoYHfsYX/6Y7mBLsDN+DXx+AeZokP7aKJ6golQxSpf0xZ2CQEajMkPGSRQ8/vzVytvdSzz2a+zvOR2EefPH7JCDEMdHns/cjTzqjjp+6lZygHVJFW25rh8zVEKSXCiNkzip0qeyPLXp5tnxENW1NKELajwwLcz9qil3qvQuX8NzQ7M9/Lqzjf3VKqym+/HPZ3wjraZAi6VTnE5UvFb5qyin/uka7nKlG0I4VjtIq0ftHBQ3qjR8hKhtjSDQyCsty/sWBrkvJD2QG8h272f2xS90ffIzP9+z619M8/4nXeP6xx3j+k5/k+dPCvgBtp3jhV0W+SlP3QcNXcStUBlXZPOeTkdkgWNLVolLOXUVjZEFkgIVQi3C9RhSBh1lejUtk729ywXBfk8vtclm9Xp9ZL6MWeaD4UvumDmdVUqd393YoEU3Ug2E9ajulCs8r2SmtgutBg77fv/rtNOmAX8W3O8nozNnO4jdmzkq2QmpXDEkyrErHRoKlQ8OaGZQB0ZvgxthWEDT8mP41SOx4gIEXJ2JJ+ExiD2jGtir9SDjid3bHkqn2lpb2gWRPj8sXCRcMiZ7X/U4+2f96R6Qv0nmlHzTiwJXevhpGsptm0NbZUMFuWsrpsALzAUrGzv/yHabiWnD6JiX+6jDSwlJhLV2ErgBDzB2Y1GYXViAEndNV8SuV1vL27dfCMK+Afl/PuJkIc9VA3ZNXNcShbc+ZNKIlIVfnQB7l5gSincDsOieGSvP2ekJzczBSVu+JuxvazOZGmy9h9fR6Glrhb4c3af1vHqfdaLS2eDZ7HDb8Q5BxImtLzHnAG5onN6CWAOja80v6ZT0NcdWv6jGcVO/SR/UpPYa46mf1h/UP6WmIq5NSl1IUt+OsMjcuQ04pAhapXPVZWG8R5Ecvs7sCtqqsNqrTJ+tu1WKYEwba5Sx2tFoCkfB2YyIYDYqW07/MAKIqvV0DzNy5+pnP8MMDaU/T4NDAMH/s2P4D9q9caziwn3UdTFWzxT9iQ+kGzX7yB+annzczYg4L2v9bmAcq+Pf80PALVjIb7FePFSOwskwhR/xVYiCekcopxlUjyilGlzFqTBmnjfPGRWPGuGRcNtYs5HpscJ0fRcWsjcMAPWu83GxJaR76boUgLhBDIqHoEHd0Zuum/raeWML80rOasR/0F5dnNNOkaSgyvcP/4KSpq8M/E7PY9vPsvvOxxILbirqzBWj4lxgPE4Zdv+ontYBxLpqCAbTJqacPceojKEJH+HAfzTbCIE1l+uYTbds8nm1t2yKJZHib/Hci8o1Ed1cy2dWdIF8SOmbaZjwe+BW5L4Ljnu0eHOzuTaUkGQJg28R8skLkjSpRsAEaDRTQLmpxuKpDh4HJFXCByuOiAAflJ8B2s5qFayZdQNet0yyoQnFydQ2IIkplTofqPah09kLe5A6AVpFtwJNOtdlggUaANaLPMYG8RunjoiFT4g8VxaPnz598MP5634l7kpe6Tzx0/vz50d8bPZ9Px36f57/+dZ7//Vg6NsPzMwD7NEA/g3mpeoD+rR6lErpjSqf2OkaRDrFxeyadvn79+rHr14XYgbUlcifcp5fZxMwL9+mCS7tonIOP2IF4daGskL+iWdUg6mlcmqgmpZnWzGsWNRnNkmZZA6hn8HVRwtJkR/rSL7TGsQXIIFnMUQTWOyqIwXDSJETVC9Kywyn43sPEEIl0DIwkXX2tnrHOA7MgHWNHwhOXOv4qbPG3Opsb8KONvDRT4w81NdsMDn+7f1OoKTkw4Xx0ezXts9bQvvGWID8w4Tp9yNdu89rMhvq6hjarD/7gmLW1NVBtQJbu5/Rkn+gj0jDutW+yvwf0nurW3cxdCpkFaP5VEzEANnVSj9DVIIkItqz31p8xgyXH0F+HIvSvCLlNDA1Zxwfh/uqFj3/1qx+/8FV++TfOLi+f/Y1lcnlw2+EHHj08OsI3R6Z2zk5ODJP6l77ylZde+L3fe+GJT33qiSc/8YnijZb77zz8Ps+pnbUz09O7ougHy6MPrtwPpnKu65V+MP2tfrCqf08/2PBQP2p8bX296Tca/eH40PP3NLmjraToH+S/GYtE+rofDgcagqeGvJ7AHppXyzBp4BGLXJg8gvm0jzB5kVfagFutMToh55ChNGsIva3kcvot/h/yeC3mJVqqGErDtSocSDIjkl+tDAvcIhYE4DdPEhvFBSFQNHcoQJRowfDwK5rgxfzkjgLootmuQjbAZYcK66OKVR36JMfphLtJF2kncpxOOeo888r16Plo9PKeLZ0DtTZjvG2fyRg1e1xNfam+rsTQrUj0k1iMdMSSychQHau1OPfEgo4Jv6W7qSnkfwbzmqm/9UesBSC/W/K3UgkTZCchLi2t9tILMNyo9cm8zvI3JRKb6A8f8vtD9Idcph19ExN9gUgkEAyHxbgpv5jXSq3VV42kTsotUee3mhOl/FY9SLmY45qHS7V8JgP/fiTnmuSJC9alzpNUxSzR0/Or5Um2NFbOk3QV/8fdD4ejbf7YwFR66tgd38x3jix2eL3G/vlgX3viRD+jmlOLlMWC4abSnELQCNFDXIvpgUzIRREtxG3EEbyxLEt/da0gad4+r1JkCbGRnsG+Ab890dUUjvpi/ERqanTvwS1jPb+w+/xuT6ff53Qb27YEe9r6XSw33j1gozjmBxx7HX36O0H6ZSS5HvVLuyrWtKJkKAUpqDUc2fwgGqcAHDqnLqLjdVO6Od1x3RndOd1FHQWH7pqO+rNQPDAxGIBqww8QIc1xM6Vc5pL1IRKyp9OuoaEmSsg0zXy/l82z88W3x4ZJd/FlfmiI/wcp71CIB/MoLKOwb6gZovhBb48hhVQFMtP/83ML+w/+OE0dRYvsjq0TO/h3P80uvPtpgFGUucQ8T3RWPWMB+FxigkxOY9C057s1I8DWcydBQ8h3G0YM9G8D5UJwjQN0nEtMDcD1LjixMj6h3KGT8iGlkyvkDvNS7nCeJGPFZcku/RrZ+29x3tcjd7aDk5N37J+emhuLd3X29PS0x8n+/YtH5g+8797DW2amJ6emxtS84DTygtOUF2A/w87T2gvMB8TaC/X4/RnSsbZd/P4p1fda+j3zKFmUvy/g91LthmfF6y+vbad8FXSjm4CLNJdsWlg/po8Z8OCBmpY71AKCu5AVlqcho1RTEiJKDVJEKWpKgdnA4cBDAUwGlLPAHPGSAxzzxCJKDerN26SF/fw90sJAFhLiqQqWMFAQuqaP0roUFfo/tk7/y6r+Vbn/46r+Fbn/lXXu8wnaL+RZ0b0Abb1RyuRYP89KClS72ki8QNrr0LCgsqvr0NKS664D+HvRaGjqFhIetKLTTnDR0LA8scaJkIxVMR8mIadm/UyVGXN17J2GJy5ihlYpQ+bsWfLFnyH+uYFWfZv1wVojuNa7gJ6JeAk6I4VBqxL2t/R/bJ3+l1X9K3K/BOMfo0+Rju8U798hjWfeUvR/TOinNkjmuqL/ZbH/b6D/O3j/TvH+8n3ID2FdVcyfyefMhzgQE3FAWKcQp07vGxfnUbn/Y+v0v6zqX5X71fdfkftfof1IywT9tZbWpmC0GkFtlStjgG76+c9L/0AN/fzn2j4H/6CB+sB1uOcoY4VTHWI+qqbRKhKn4iQl0ZnGjDjMeiE0h3qq8lfcq26kfm6XO+pOuafd8+5Fd8a95F52g0Bg5FZ8yIZ8Tl/Ex/umfHO+474zvnO+iz7KhnzXfEC8G/GWkveBd0rKFtXAeZvTitIhpZsRjcO9dGor39Xau2Xp5AzfE41vG+v+u+jg3MH8vkMd/9BKA/QbN3u2TH/oqVdCU+6ZrR+5Z4DMeU4W/1Pm2KFU8YpPsad0L/pVe1fe/7F1+l9W9a/I/a8I/Qo6MFTCddFv/3GgAzagBAcrRAWrOLyc8mbHICQrd0t4cC5gIlTmElT6XMAuBOeguU5ObpLy8KgoKIvQNF3kGM0lmEvnv0PTCQ5hysvY9OSOmUk+3xbr7VgFXCNinME4s6SwjqniM9cXTjRKcU1TCuOsFhLldIVcmDEKelc2ig60EYpPI6sjiE8jrpHoSGpkemR+ZHEkM7I0sjxCuWlcDiMaZnFp9azAT0qOKqV+Pszyw/BB1c7MmcHBQVfrQGhqyujwGG2eSMTS7LfsnW5ra+/qCbeGzSGvudbsqKuzc4Y9QDJJktf2bGqzjvW7WjxWg9Fr83itBqu3yZUcNfab/C5/g7na4m5yWRvs5upqzuqxbEkM0v3H2Ex2HvZ/M+7/DnKKqdS/c53+WVX/mNy/S9XfL/fvU/U/LPffQftpLSoqKwAOtjDdTIL5qsKObVDa8m4bzXe1hzT9CrFw1EGdq8aPbA/yKPdGHLw5h3ClT7iyicuGUaNpL1DbYIx6dAS5oVzdTihiLBr9JCJq3+FEC0bVkT+aGBufPh1np+9Kj/55d3vP+I6ZHfe42L6DW3YVf6Cd+NpzLaEtQ7XEqj3c219Fw+3m5sTwVD40Pn50PjK8/TdngsGZJj9/emCA1r4S4tIA1lMi/7ss1cQCOZbu5RZx7yv371ynf1bV3y/371PxPzr+HfH+Sv5X6t+p4nOl/lkVX+yX+/ehtFyqi+KB7V2qEI2uMgGr4nlUhaXkiik2KsXkSD3G0mB0IOOFX06vTfT6v7eTmoawh+FclziDaFGCXr1TSpQH7hD+yOTg/JltU4GR+47etW/xwf3xbtbat6tnfGxyYGhIy5NvJYIsr4knw91H3jj1Gw/smrvHQXZ2DB0cGx+d2XVPYwP1C4gywBfx3O0Wz11pT15CWO65ZW+V/TvX6Z9V9Y/J/er798v9uOeYE29T6Px25qoGjTYYgCZYANRBLRHQ91sU7d/2OB0er9Ph/m1yuViUGuMur8fh9Hg+wfNfFv+k9V7W/oa8RP5zBRlBFQ1n+L8lI/CVZQQMnnUiFugdtgf3paLh5kjyfXekWiPNUX7M8/mGtv7xpwZH3J9vKBw55eZd/ckjxx71pFyD/APT0Z+ap/5px/bN4XcseDYE2zzdtzvFff5Exf6d6/TPqvr75f59Yj/6X3H8gnifZ0W79ja5JtGnKnj2VO57VeCr7G7WYgGL/JXgahBBHnQFo8FUcDo4H1wMZoJLweVgjRT7qk5uYZA+iyGu7xG0AyfSrgo2kkx3Vrus4GaE2Hgab4T5nkLQUZKdv9Fxau4IjTfiaRpF8ce/NG/ZtWVPCS79Mlz2UbjI8tRzsl51UaSFAr+zyPxut8gHy/WwZdX4Ep/dg/wR9DN47g3MlwoyT1fQz9A9rqukrMlFMYJoUK5QFMPGbSByLWe26YSIrpWGstoZVSpdmVcX0jgybOfsDk+gqfe+PnVFjdZOm7U2bopGZza9KNTWoOuHdZ5CniWsf4EWPBB0DdDlCrIuJ8m9Jd40paJr5eNfXmf8rGr8NXn8q6rxw/L4vevc/8I6959X6Ip/iOOj4vgSPf1Xdp4LM9PYvx91KFbS8RgO5PA7Kng25XQZDdbs6aY1e7o1IF2LRR6MggNW8KRpxcICNFnBg8KKT6iBhq4zUfpODLKS7I3Bken0N176+Kef/1I6vflk5sHMZCbzM361VA9jlZd58WXkxS0SJVbRA1WEmir7vGQRpPVRUe6+JdCwgdKJhtUGpBMNroZoQ6phumG+YbEh07DUsNxQQwMNG8Q0DDnq1YW+wxCN5LCLgf3qvAy6cGWg+2I6rcrOyGTk/Iz5yVhxjo/HH567+zHr3thksWjZtm3rzu6S/v+crP9fVMlFFlku2r2OHWF5Hflqj2r8NXn8q6rxw/J4CScF2uyTxy+QbzPK/IQmwL3fVVirVYFA5SGgV0PEJ+Rhv7eRNqevcYk7toGsBs6CWQ1NwjUubqWF7nLLagvucourJdqSaplumW9ZbMm0LLUst2C+QjmRKctMga8ighh9cFYiOEPEE7hTTlPZPDYSw0yVltFBgfA09yfYajlnpfU/YtJKhX26sM4+zZdogah7t4u05h1hPIU7jp8ppzWq8cvrjN+jGn9NHv+qavywPF6mTWvbaB6yPP6AavwRefydJTwT59NRbjsAGfMH0L9N7P8MwIAVx/tA9oowf8iUYuNUURfGSgQAA+WkRhM0mgxKuaGcNFxtxlp1TbfaFfJMNVcNuNRDs30UsX+UmAgBag5BVhDonlBPOVjINhZyPc1kIc80c83sAs0FbimA/kYjGYX8H2XdlYSq9oo9Tn1UrI8aJoQCLKUSLJni2+QBmha0uoqxsmM8P0Z/npycVOTDNDGvVMgxUAX0ylU4aCMAjYAgMWWZ6xhZWFWqDJKrtWLkoxX9RWLir3Ej2T8AGwoOPwVHtqkgJAiLnrj1cgDoajNleTJpciM2ORl7on8i/T94/vudoeGf8ryoz/0p2gs7RXthSc/7U9Qp3hF1ig5ZX3wL6WinSEeV/RZ5/G6x/wfQX1DYS5fFflqd648VeuQeSe/EXFqfPH6Buanop+dnu7of9ddr8vhXSScj19SBM6POFSnPANpgrgjm+Ii6nOCT4sTnMV2l+YEsOMyJ82N2CP1Ye0ewF3ep7cWwHtSjiWSjkddPZUcY3y3Sg/8s9ws6wU6xv8R3LuP9e5R2alF//0fon5X7/fJ9fPL4AyV+JNoBZsX+DsX9S+NfU9AbA8pCwvj9dL1yLhH1c7mZ0Qo1A6VKP4LOSTkKZv0pNYc6ucYVUSidOlVpHeL2OpxeH6iexb+VyuyQPpfPZ3f6fH8n19sR5tOAOUPqXLDyrKFfPxfs90u5YJhTRDpKuWClmhZyLr4qLktOOoaH5lgbFg7U4EdZxJXwlVH4ipEL48C51yfEdCo7bxfj2QRqd/481h76I66PW+H5T4f7wn9B0+SFWDHmawATM3Mk56klCxVSVnGWqtxceZacUN6QBSFWI/6tIVKEWK6Gk6YoxncD1KQpwgTxUE1OpjPwAwer1hP3vMH/iTfuLX6fL+NvsXKbOaXLsg1lZwlvRf4ZE/H2hnxevoi6ye7y86K6/4V17o/yguCDRv4ZZI4pMuOk/VMVZKkYmw947ge8quVKPmsxJS5nq8Liy4oqED29OkcMizSqCh0pS3CRUX19dbBZoyh7BJ+pSVqQq6FZUfuInIEz0DUi1OYiAn1CufJ3KlRtVQVsYwqXJGJisKCuTD2lWuh75/iqi6FoxeyvnMWLbxrwbkT+BICYFYxNkZWkSIMlSZHFSTliUuJjkAxhZpiUKlb8hpD+WPKHPSf7wy4qdMKXkI/tUekD5f62ZdX4kk1uzzrjP7nO+DnRl0PH/wvgmR/k2MUK79jAKHpjmdxfEucopump5Y7aXWgSSDfNr0aXrkOgraZCzuaop5AP4GZg5cpKHtyS8qWJ8ZLmRS6TvbIz943x3Y88vXRm+8jH7kin99518BDrk126vb0X3v/+j7UXJ9NkIHXy6NHHxfc2XMD8gFbgapcrRCmr0nHk0iryuunq2kg96M7VTlQ3ndyKBZHH4rRELLxlyjJnOW45YzlnuWihyGO5ZgGB04aDcx7hmib0dEco2kZWI4i2EVckGklFpiPzkcVIJrIUWY4A2nZQfRv9QQoPQFzpJ5DiLgA2OlRkbL7Y5rajvWz86PTO4k3N6ObR4dGp+/vY5JE9R8aG06nBx/khVqNbAHJd6N3B+3fuFNSYwZY9e07et2vX9h2fnAwLefgiLRLsTclbfNtaxJ07RBq4tUxmSJbzdJqPJo9X8nTl/S+sc/954f5iHSo6nhfng3Y0Ib8Mx8+V7I4Vxr+8zvhZaTzM8wGcPy/6Pj4gjIf+vTj/OWX/Lfe/sM7958X+ksyTUvlWqMzzc+yfF/sXy2SqVAk+oiyxGXm5W8phXL9q1L97uhlV9134roKKWWf0tR2YeTZy9zHMPOseC8XKs8/g4CpkFKdkvZKqvKnpCwaKi8Xqcz2U//foCBYxqCqr2cdy4ntyRDlOCPtOyKW5pHjvDKgpQoGuDJWzv8av0hpdq/CHLMPfxDiXSwp/sbESTFXJX3JFVT2tlJ0/qf0QcKncTi3MeCeQxfxJ/Yf0QvWFagp+WupV0EP1nGiBs+FWbCB11ssYpcw/zKhLyPuAP+JefK5rKC0oZZlMoysQDPXE3sefwI04wd8t5AGqYkP6lbEbot1/TLb77xLs/uL45+TxF1XjLfL43arxpbiDZdX4kr9hzzrjP6Ea/7A8/o51xn9ynfvP0fGCTIKyVbtk6VKdpig0olIDjRGSGCLr2rJl4tepzubZWPEbDz1ruWAT5tPVoQM5UpAy8suLuukrWr7UZd6mkjOS0WuMVFeX13zbetyc6BFtXoMdLBErwCEchXhOGY4LpfgQTR3CfVCgt2xY8smy9yPcD4j09p0yf8aQSJ8vV/Qjzar8JSvy+FdusZEOi3xBxgNaRwb6D4p8YVEx/po8/lXV+GF5/F7V+NL9L6xz/3k6XqhzizGWAWakgqdZcsFcdVFND/S9eiH+gBKv6gItUOGjNpmsnxpZaE6YE0sCmah9RU/TwgRpE9MmP6Sf3eG1u82pmE732OPG6h3TPhvniXXp6/vTZHFuQctrU1tSsU/dc1KX1G7b/R9iFfncgXX4nNRfzrcOrMO3Dojrp3VHMpifO7fRqiP/P+uNKGqMKEqL4BwBN29iPPKsEPOu6puX+7TQ92Ps2yP3maDvBDuMmFAv9gWhr8A+jNRGvh+s9zzG5i4wbyme8U/sGFJJaZyf3CBN+Iw5Mf6eFL9BbgD1oTmPTer6brlZWgiauZ5jqJuGwVcraEKReD62f5LcyFA4c3Dta8prJS9KbpahNbrhWsodGQ1eC3z49cn9MXaeXlu8Btd+FmvFhdSZE7lZqkWT6/hIIaUXLtaH+LgzFHl7IL3Qd2hokO3emcnslO7zGXaMsYJEfbWKSv652Sp0KVFexnULsVEFUORzs1QLqEPWZukGoZ+K9pRIxVGgpdpVqHjN19bodAMNM8EfLpe9mTOxvhanq3OA/hLh9RprgTW7xBpzuVlCMyrpSinI4MZwUIrfuH6dtcQEGH8FrvltWKtcT/nWenwm1JBr6N0ouCkMcB252Rq8pZCVGReyMot/p2vyBxp13bp0PD4EkmpTc0tjanSU5r8ReNYBdpippbksaFsC6ClMNWuSlUZZqodhi2/AdVm2H+OyA+KV4jSoWCa8/c/A3WKOUsZHFN9w2W0ut93q+oLLbnW77TYnW2dzu+gTreInfdZ34VnPsg/js0yMmCqjoQlmZfdWhHUXvxtrjXT1tkU7YzaLzWKxWuxsFHYt2NjWGjTbHZzZZqH3fhvu/T3EST1wgXV8/TKKgmgmYmlWU8jNainiCIYuiq4R+LlvfH8sNraPom0mo8LbZIXqbUhO8O4UeQl1EiL6o6g4q8NzwOOdnQUJlQ0CKsPe1cK9D7NHELcqnkV6Avl4HgRYcuMs4hZ9gxTjxty/Su+so6uIwnCUb4u/XNu2tgu4oQZ2uHR/oH5oxcrPsodpLgd9DH1x4024Lnqe4u/fw3WnmRp4Qlph+6EpzQb0dZg3kiNCbTribgIEpHdnFf/earPY/R5fL+fzplod1vfrjfUWy/auqhZXc2u1sMYUPP+b8Hwzc1ghl+vK1QjZmkMbG/UB0jfj0drp3HU0JJbHBSTiadk1N5vubBUFknRbXQV546PryBs7SvKGavzH1hm/UzV+RR7/imp8vzx+3zryzEfXkWd2YFwMvmsPOGbZu/Ya7Y1ksbh8U65/tMoWKoxhC+/2yGPIKeZkxfcmEvreRKDdJ6NTY2yYvgWw4vhS7XcYbwb0gOHkVJ6+Z9G/lq30zkA/jJjF+yGvO8X8LX0vKuX/XBVZzJT3n8D+E2I/3JPomGPQfx/235cR5oXvocKcvkkFnqnql5bH5eYOCWREGT1M35tB31wmllQNoU4av3npUhr+kctCPeG84nlWCa9V1uaKirMYOhGooc+oEbROMez3EGUXgSpZh9ag6Rlt5KW4CcljRvPX8pcu4ZzgV5r/OX1NI/yicGhhvsZ8G2BZy4SFzKDcISwaQH/10F8PYdNA52Aoz1Jt6Yy2dHZGwx2Ea+3uamnt6mJorB3Nef9nfG+jEzj+XQo955Y8fNrAt5nShgEzjpXvy5JfoiW/Vkt+g5ZQCoNfhz1VfO1j3udy+OAP75eEHodXemGWo+yTkeyW2tdueTdrRHg3K5ytxzTTa0IN7zSTBxjqKN6ymE+QALx1hh6cfPDBye+88sor0vlSjNMydBwf4oE/TNJxD6aFgWSNQvE7SOcbKlhFpeAp2AoSIt8pXhwk97G+d38AF2C8S17OuVq39r/+/0jtf9v+rVv20OysdF9PdyJGqxof33f48M47jh7dk56eTg9u3sSINqY86Da+W96NaKz8bkRrCKBrl96NGNHn81+LpdPpxx5jHyX1nd+/Htt//jz5TfH9lfQdQq3M5xXunvI3eV31kQaQSarxrcg+LL7QraM4j7/wxTji2xMtFBiWVQsCw+KyRC0py7Rl3rJoyViWLMuWmgXxVUk6DPZp2VC0SVML1jxt4IRC+7RsA315sqCMYbo3ZdBYv0EfktkVzSYkZHPtmCVzbPNYf6j9Rf//rP0xCIQ1f9J0fnhq08Q9j3PbbxpNHBfbd8JzMFl7LmY0WrjYOU/Kfd9eAeaaYcwzbGeuVojfQh+IUXlCVbXPpWxwlA6kBhqxpUYEGhHaqOfWr16fs9VXlfmD6LtOsFpPLih8h2+counPGAmRbS3g25rLq95jlXShnI9VDvwTX5yVTo/xpIMfS+fZ58+0PqSpjl0aqBlYepA9/cFYTeyVjuofEe1kJjNZ/GWMOIt/R8x/HYsRbaz4U2KMQV/sh3h238K8cU1Z3ji5/BbGFIhn1lJFHpXseKwP6H2c+TOmBEOJ3vdCo7dikVlV5SAsqVhecVZloMz2bqjy7HsWnS2rOk+LkGCxoRzjE3LiooWcqZ0qeB3r1aUtr09rl8cIbdZXqlebx/CULeOtUd5Q296Wv7V6bamGbf19I2xbPIjVbCW77TzTKJ1pVdVOVT0uFShVjkq5bqXwKiRhkT7Z/618IxLLie5ohmqUZjQ/56+4Vl0IbZfLFXWlXNOuedeiK+Naci27aJ1fL1lQJg7eFjj0m5siQPbesXko7W8b6r6JERglGFjvQdhgRIYSBjmmxE4lGGC0wfrhzhWra0keJ1oQh6ELZFYZXCBoJ1EmxUwz88wik2GWmGWmRpQOGC1ihuCxLyueL7xAiuEIDU0XMEmChnWdcsZ8XOwJ/2W8WyxqvHdLW2usBv5sYRvVhY0Nhnf/Gv7+vkE6axcAHv3MP1WoL9UKjVapoXL6NkOjWWr0QaOvIraoDl4KGikl6vTBGvtuizoUFZRveqhVFnqmOT0biDY3hSjEm2F8D57VZAHfidiiQK33On9qlCM3pDcXqA5iRQysdBaVGKneg19W0MTD0AhLjSQ0khWjy5BGGpQ0UmXIu+VVULLn/pbCcEmMPZDeYmqX3mI6bZiXX3JKyaIRERQjkas41XujTFLlOIdYrFWMSHNxQnWfHNMoHPJOIIw9dHN6kTBKSPyrUkeenad43ini/i37Qk8COy8i/e3JpMEgxmx9mS2IMVsRIWYLZFeMlUJ9VM7jxBizKhrDJdpfv4wxTu/g+M3idTvF63bS66S6n1g3/elfq276Bkumb6xa+nsUStfyVTXNjSJNGU83h8mNUQKwUtCTOtHXyT4Fa4owMaB/t2IxSowVC0SrlojcRWrI9Spljw5ttGDdsfwVbpXDxXMuLsqluGlunlvkMtwSt8zRQ2+leEWJhA3riVP3DbAfMVrUITIYLBhD5cc2kIy60SSpfNXCumCxlorbkoM18lsYZBQUyG9aek0DJp3gaxl0hjJa/O4/Cu9tEGGoeQhgOMJsJRpFLLcENvRwSY12aLRX1LnxiEsNTH+VGj3Q6KmYZql6XRwSGZpHxYhKO5FfoyBmlRiQPIPALrjGhLqhNVImMENLsbk28pKvnKmJbhMQ6Owg3IPLjhey4920yPM0RvhvnARU2jjlLn17Xcqg3r6b8qs1Lt+WTKg2tPiquIl4tjUvwB5uI3srnIJ+aPRLjS3Q2FJR2FCdAhVznYDGREUxRJZqZZ4hNbA2Gd1OVrDiqQQO7UYq0lBBRCnhbsGUufwV36oPL/K5fFFfyjftm/ct+jK+Jd+yr0YoxkT5rVCc3E1DiKgeEkU9RKpSnm3FCk2dBcqce6GHptlm4wVBOACVchR4xCaKJBNIq9YNYv612EZZzPN7sRDViwM2wkxkvxPl75Yw+ZDgh2ULUr9mN+UXQj+zg/aLfu55SgeI+F4fPMQSpsShEZcaqsRp3GipMQyN4dv78mS5VsIU+bWaG/Ly5Zhh2KLh20TkUlVIyNwRxFg7J9DfHOOHK0PcShvForbVNsSiNldbtC3VNt0237bYlmlbaltuoxSik25+F4wfoPGOKofiry6+sfOSB/L2ElzJO/meYpxkh2E0T+M7ESZJe4VqBapd2wSNTRWZoSqJYv39VNnyVVuoeq0AMoz1XrcgBOAIG7ZpI+/cyDEeFChEHmpVv3ygQTrfIVXMA7Br4XwLewiMdwAO9BARsKfs7Q6/vgSoicpvg3j7PQ+y9KaIDcuE0jsfYH/7mL/+9fVGNAxVpN6lKhXQ6IZG97+LRpnz1tixFCcnpIeIdiGgvl1IfWO3VTJvQ3vL9c5ywnqrDnoLLWUUMQyUVj6pjFlBmngEaeWTAq2U6tEIeVUgd/4RU9JpTEqmaFAyxV+BIm6QCIYB8OHbEMEc48BCSStNdCubVptwK5tcTdGmVNN003zTYlOmaalpuYluZQs9E5WJ3K24TxaVxExpAiknXwo7iCirX0AbSJeEzSopBZlKRSVTVbQDrZTvrWRKAVdqJdO/ISXTVEc2pGnmGDeMiXArYRjThvI9Ep3bKJUyWltVFGhRST1EbP5LibZUIBiiQeXzEk3BWBF2HrC1UPJPy75vzXU8raUIEYzywBgRuOY15TWST5uGlpgYVWRIQbim+AZck4Vr9Iy/8nOEkoyKsJDx4cXYfaPj7KdnMpmZsnt41fElNLTEJISWKJzx0g2eEW5Aitfg+s+wq4wVdOWSGRGuR0pUFlry60SVXChFldC4Bfq8z7Ir6vgLk+Rn22D8xTUp/uKiHH/x9C3xF8I+vsY+h/5XMYbFJMWwKMJXnovBWND71y4DHI1SjT/JJ0oZ7y2BKX+ra/YHQrpu3XA8PqJlC3JgCu7JGtzrAHsN1mi9ZYXqVRXXPDabh/6wz8jvZyp+lx1ZexbmQmE0pcjeEIJn7DSlnCKHSXUETerDp1/I0zMJBK7bXv7U94o3OVcp3gTW9D3Ebz3QnYoYTg2ALCfEMYlRJSfGxKiSAo0qoedkG/nA2n+8bRzHJSGOA3hGBK44j7XUjjEZIQ6cxgdD+yxtMzytMchegHYdkxbsPswqto3YTsvfj8jf57E9JreF7w+Vte8W2swakydJK62FO0n9locQcUTb0W2/I4v0O3Jvpe/YAn53vMJ3GZrDCN89wqRhDTlOJwZdwwDV96fF72kMVQ+j+J7mkmPd37RZqPubBhzKcTQUuof+4mrpX7XCI9XXnMZrTsvXSPfOcdTh3lMlXvO/AbgtI/p4nKWUy27TQBSGfye93yRoBRJiMUKialE7uZSClF1bKWqriFISVWxN7CRWXdvYk5q+BU+AxIIXYIfYs+ABuoNX4A0Q/0yGNi0FRSKW5W/G5zb/OQ6A+84RHAx+TxBZdjCDz5YLmMS55SIeOo8sj2HG6Vgex13nveUJ3HK+WZ7EWmHP8hQWC+8sT2O28NXyLPd/Wp7DYrFmeR5vxxLLC7g3/pTZnbFprkJTiWYHS/hguUCrL5aL2Md3y2NYcp5bHod0XluewAPnk+VJvHR+WJ7CcuHU8jTuFD5anuX+ueU5LBdvW553RPGZ5QU8HnewgxgJzpAiQBc9KAisoI1VPqsoo4INrJFbfJ/SVtMZPXzkXKU4Rsa9Bv0845mbS3I9sJeMFeOE8SSwEydnadDtKbHSXhXVcmVjTbSCNBats8TP4/Q4Ew3liZU8z6XivmzHJ6v0a1JGF69Mel1QgjfcDN1XsahsJOQXrKeLvjFLufS7/dAljFK1RI18U4rakAb4s05ZE5c11MxxRij1iEWkTB/QJDJGkimqpG0eIKC7FrLMa5OBcOSnWRBHoiLLVbHdD0JPlMub7nCi32nWr8tg0uqs6xeCDJcXGBFc3orWLvP6bJRr5BG06IzYdqlbOzhikAlXqNT1/BM3PRZx54b2SjlqX27SHPxaYs6plm6XR/XooYXEftyLxG7fy2Iu9Bwrxq2hxOtvM4meUkmtVBoet//zbdF7IGvdVKXMZGkpFaNoaf0L4UM+21xHXPmm6X2yZ8ZDt6RnbJvYox4CB0al6ErkxpUI+iu9abj0LYYqu5r3cgxOeQd2PELzJuda1zEYkjq2cGhYmS/jqk4ZY+r/kIR7GTNmJpY0Xe3y/QH9GxSoxxGpx5ESzbijcjf19cyEQduPMt8T/cjzU6F6vmjuNcRB4kcD48bAYE1cfg4VKUww62tG79QNOIahL/JA9TiJ9a1D4aqasL3K2mmQqExmQSjjtFs6qDeut3vEY/wj4C+7oUYNAAB4nG2VB3RTVRjH//82TWjTssUtwwGI1CSduKAjlA5bLA0VFPE1eU1e+/JSkvcoxQHKUtx7K8OtLHED7r097r33nkc9ruTda/I4x3fOu7//d9837nfvewnyYF//XIkA/ufihsyAPOYhHy4UwA0PBqEQRfCiGCUYjCEYimEYjhEYiV0wCrtiN+yOPbAn9sLe2AejMQZjMQ77Yj/sjwMwHhMwEQdiEg7CZJTiYPjgT1cvQzkqUIkqVGMKDsGhOAyH4whMxTTUoBZ1qEcQ09GAGWhEE5rRgiPRijbMxFFoxyx0IITZ6MTRmIO5OAbHYh6Ow3wcD4X5WI/lWIEduBifYyXOxhm4CjfhWrqwGm9iGS7Aj/gJZ7EAp+FhvIsfcDVuxi/4Gb9iHTbgSTyOjehCGOcigqeh4gk8hefxDJ7Fc/gC3XgJL+BFbEIU3+M8vIqX8Qpi+Arf4HT0QEMv4tBhYA0SWIA+JJGCBRML0Y8vsQiLMYATcBJOxN1YiyU4GUtxCr7Gt7iXbno4iIUsohd/4W8Ws4SDOQT/EBzKYRxOcgRHcheO4q7cjbtzD+7Jvbg398Fv+J2jOYZjOY77cj/uzwM4nhM4kQdyEg/iZJbiD7zGg+mjnwGWsZwVrGQVqzmFh/BQHoYP8REP5xGcymmsYS3rWM8gp7OBM9jIJmzGFjazhUeylW2cyaPYzlnsYAh/4mN8wtns5NGcw7k8hsdyHo/jfB5PhV0MM0KV3YwyRo097MU26ozTYAKf4jP2cQGTTNGkhdfxAd7C23gH7+MNvMeF7OciDnAxT+CJPIkncwmX8hSeymVczhVcyVU8jadzNc/gmTwLt2Er7sRdeAS34w48ilPxEFbhFjyG+3A/tvNsnsNzcSa+43k8nxfwQl7Ei3kJL+VlvJxX8Epexat5DddwLddxPa/ldbyeN/BG3sSbeQtv5QZu5CZu5hbexq28nXfwTt7Fu3kP7+U2bucO3sf7+QAf5EOu1lBLi8cyNJ+vxidZL1hb4amJK+FkwvAogu6arqS6UHUrNjw1iWjCUHs9iqC3Lqwlw1a8W1cXecM5XVQXSZhKOKwaZlE4K931YSWTMiJQn86vmJ6gLKjKgkFRULVRFMwlUrPSE5TLUAXdQZFRteFtcCwq6lhUQy5XNCuLG8KJeFyRRtRheGc48sRy2jWjS0m6YunB3WhqekR1azY8jbITTXbSKDrRxNY1yjVrgnmNTXlaj7fJUaMnp4ubnavqdRjuFiVsmapbt1Hc4vTTd/ITe6LbcLWkG3bp6cHdKuINEd/qjDec8a0i3rCRHzSi+aoR9bTJHhOyxzbRY8JGSVvMMqJK0orrimWWJJyWu13UTYq67c66SWfddlE3KTBLRKVseGc5diuV0/bL668IClYGBplhNaLpuuLuEFlMsQkdmYMzMwcXEgdniYMLyaYs2VRINGXZKAglNSNaYGXGktBODVpOyxOSB2zJb6PTsdh+h57j0AM57Z4rWl1so2hu7mVdnHvx7QanBGwG/NXFKec2djgN02EI97Iqm2U+n6RfMiBZJlkuWSn5X1y1ZI1krWSdoF/m8VcIBmR8QMYHqt2d0aSS3th+gU7RcL+Nws6IpibVlJYq7P9PuecIxwEbmSwBX5VPstwVtJIJ2wj4K/K753enby196wVpPV+zR91r71hZINNugVba0d4sZ8oyG1HQXaroZjqmy/YWY8xrx8ufFlv32A/E2Jt2jxVmHVyZx+mpzN3rlRtcGlb6pPY7dMCh6xy6zKGrHbrcoSsdusqhaxy6Nqf9FRk9RF0U1pV4JNFvpM2UOmyBpaZMLWFkZwb3KUnV0NVu0zaH2GZSi8aEPbQr/b32qmbWYZicyLkMzsyouQy2mXvsjQ30xVRRrFj+2YgHqhFRUjGp41k9PGppeir9senZnCOyU7m8tpuuxhPmzm72VM7tX5ngICkAAAAAAAMACAACABQAAf//AAN4nGNgZGBg4AFiMSBmYgDyGNcASRYwjwEACwEA2wAAAHicVVLZS9RRGD3nNy5ji6ht0oMNKT3VPERFiGjmIDHNhkiERDWMudRo4ha4jaPlVpkP0lub7Qu0/Ae99Vf00FNERAgNEZGd3zc/Sh/uOd9y73fP/e4HAtiEEXwE08nBXvixF4VNja0BBKPxSAB1sUgogHBLPCq7teVkAG3A2hp8OudDgdlCcIPn2oXmCeGYX7QhWwx/KjlwAQdTqZ4+HDWs7+hPphBKd3cmEU5fTqXRYnja8KzdUuzd5WL+Xr/dUOjWl0dDGDp62U5UYR+COIJ6NCOGU6qTP5fw9vZ6POnFr3q87HFOlf0gb+f3OVX5uHPe7qbzQVxld203TT9kB83KyYqZjgOICktRwEYeZxNDbp57GGA1a2QX8bBpj2pV5Osq7+jMiMVdrW3SUQH9C2r1koTtyGrFEdRyvWnzYp6XVZf+Z3zr4s6/aN4qMn1LeCPtOfkrpqAcNdiPQ6hDCBG04gzacRF9GMYYpjCHRSxzUnXDSPC6cZwLxjHOG+c4Z7zKjHGUs8YRzhg3c0kvjPOW2ycuCnO8KVzluDDKG8IIJ4QJjgnDvCZsto6EvRlwu1VpP1Pixan+uNNQgs3Yqp5X4xgakUQPhkz7ODL666xe+Vovfot3eK/p/4TP+IKv+Ibv6sFP/MJv/FFBhwXczQZ2sZuXmGY/h3mFGU5yitOc4SznOM8FdcDRnJXxHu/zMR9whQ/5iHf4kk/4inf5lM/4nC+krgxbpKscDVJ1TrraNYF9mMAUO9jJAQ5qT5fN0wm9onTdBLvd3iZfzCGPR8UZi1e6rHieR8U+/WKZOOvls14+6+XdydyBXTZ/tfnu/QVAfZEAAAAAeJy11MtLVGEYx/Hf884o4sAwDbYTEcVNRLVIvLdQxNR2IkIXMTFQHAIjdRazCLxv+wNC0CytjPJS4tLxgoiIiIiIiIiriFbRbvrOGY2gcBE0Pz6PZ97znnPe85w5yiRlKkdXZZGHTx8rQ35GlEgoucc6Hz1Jjin1jX2Ob06ZvnGZL+LNvaybpNWe2XPbIN/drDt2s7bB31lvJLl17PP7bimg9MSwAuhOxNWDWCJu7Ylh60AnImDceplTo0xmhNgKo4DtatTgNmpRjwY0ogn30Yd+DGAQQxjGCMYwjpeYwCu8xiSm8AZv8Q7TmMEc5vEJn7GARSwhjmWsYBVrWMcGNrGFbexgF3vYxwEOcYRjnOCUuw4ihDCykI0c5CIPleiiQ8m1+1VMLUUZKhCkV3F6Ffd6dVEfls7WveqdL84vIF/l6kYPYviAj/iCr/iGH7h+Yf/v4h4e/EM//3ffkj0L/HGf7y+41wylUYOKclSUo6IcFeWoqHG09Xr7kjPSEfC+lZ/N/HV+a0cHOhHB+ZEBFVD70I8BDGIIwxjBEpaxCuMtCymsK7rBu1aqMsYqVKdRK7QiK7Fma7FWa7OY9dsLOdv03sw7mmd96fr7J+q95/GU809qOxFPhU2nSyomzruqj6tWcO46Yholfsu3fK5YYAXUQiuUjxUVMV5iJdQqq2K82ZoZb7EWaqu1Utusjb0xi8lYcz9nc7rGWtNZcYCkcb8hrhQmflUT4/9BLbPqiVMDcWokTk3EpzFNMmdK04zMEKc5LVAXiRPvKntXiGmNmNaJ0wZx2iROW8RpmzjtEKdd4rRHnPaJ0wFxOiROR8TpmDidEKdT4ixoQWrIQtSwhalZlkXNtmzuPMdyqLmWS82zPGqlVVLb+Z2kWSe/kjTrsi66M2ETnNPoQLHX/dQTz6fXqade9ftz/wn25uDOAAAAAAABAAAAANQYFhEAAAAAzulphwAAAADPrmQ5"

/***/ }),

/***/ "./src/app/View.ts":
/*!*************************!*\
  !*** ./src/app/View.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ../util/Core */ "./src/util/Core.ts");
const Array_1 = __webpack_require__(/*! ../util/Array */ "./src/util/Array.ts");
const BaseTypes_1 = __webpack_require__(/*! ../BaseTypes */ "./src/BaseTypes.ts");
const DataType_1 = __webpack_require__(/*! ../DataType */ "./src/DataType.ts");
const DataValue_1 = __webpack_require__(/*! ../DataValue */ "./src/DataValue.ts");
const Delta_1 = __webpack_require__(/*! ../Delta */ "./src/Delta.ts");
const Env_1 = __webpack_require__(/*! ../Env */ "./src/Env.ts");
const Eval_1 = __webpack_require__(/*! ../Eval */ "./src/Eval.ts");
const Expl_1 = __webpack_require__(/*! ../Expl */ "./src/Expl.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "./src/Expr.ts");
const Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/Graphics.ts");
const Match_1 = __webpack_require__(/*! ../Match */ "./src/Match.ts");
const Module_1 = __webpack_require__(/*! ../Module */ "./src/Module.ts");
const Value_1 = __webpack_require__(/*! ../Value */ "./src/Value.ts");
const Versioned_1 = __webpack_require__(/*! ../Versioned */ "./src/Versioned.ts");
const Cursor_1 = __webpack_require__(/*! ./Cursor */ "./src/app/Cursor.ts");
const GraphicsRenderer_1 = __webpack_require__(/*! ./GraphicsRenderer */ "./src/app/GraphicsRenderer.ts");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./src/app/Renderer.ts");
var Closure = Eval_1.Eval.Closure;
var View;
(function (View_1) {
    View_1.defaultDims = [320, 360];
    function initialise(resourceServerUrl) {
        Module_1.Module.initialise(resourceServerUrl);
        // Shenanigans to call an internal function. Will extract this into a (reverse) FFI.
        const x = "g";
        const [ρ, dimsExpr] = Module_1.parseWithImports(`dimensions ${x}`);
        View_1.dimensions = function (tg) {
            const tv = Eval_1.Eval.eval_(ρ.concat(Env_1.Env.singleton(Versioned_1.str(x)(Versioned_1.ν()), tg)), dimsExpr);
            if (tv.v instanceof Graphics_1.Point) {
                return [tv.v.x.val, tv.v.y.val];
            }
            else {
                return Core_1.absurd();
            }
        };
    }
    View_1.initialise = initialise;
    // Prefer globals to threading parameters everywhere.
    let __currentEditor = null;
    const __links = new Set();
    const __svgs = new Map(); // memoised render within a single update
    function render(editor) {
        __svgs.clear();
        __links.clear();
        Core_1.assert(__currentEditor === null);
        __currentEditor = editor;
        const g = view(editor.tv, true, false).render();
        editor.rootPane.appendChild(g); // need to render main view so links can make use of getBoundingClientRect
        renderLinks(__links).forEach((link) => {
            editor.rootPane.appendChild(link);
        });
        __currentEditor = null;
    }
    View_1.render = render;
    const views = new Map(); // persists across edits
    function existingView(tv) {
        return Core_1.__nonNull(views.get(tv));
    }
    View_1.existingView = existingView;
    function isExprFor(e, C) {
        return Core_1.classOf(e) === DataType_1.exprClass(C);
    }
    // Unpack evaluation memo-key to recover original expression. TODO: make generic
    // and move near to memo code.
    function exprFor(t) {
        if (Versioned_1.versioned(t)) {
            return Core_1.as(Core_1.as(Core_1.as(t.__id, Value_1.TaggedId).k, Value_1.ApplicationId).v, Expr_1.Expr.Expr);
        }
        else {
            return Core_1.absurd();
        }
    }
    function renderLinks(links) {
        return [...links].map(((link) => {
            return Renderer_1.connector(Core_1.__nonNull(__svgs.get(link.from)), Core_1.__nonNull(__svgs.get(link.to)));
        }));
    }
    class View {
        render() {
            const g = this.render_();
            __svgs.set(this, g);
            return g;
        }
    }
    class ExprView extends View {
        constructor(parens, e) {
            super();
            this.parens = parens;
            this.e = e;
        }
        render_() {
            const parens = this.parens;
            const e = this.e;
            if (e instanceof Expr_1.Expr.ConstNum) {
                // ouch: disregard delta-info on expression itself
                return Renderer_1.horiz(num_(e.val, e.val));
            }
            else if (e instanceof Expr_1.Expr.ConstStr) {
                // ouch: disregard delta-info on expression itself
                return Renderer_1.horiz(str_(e.val));
            }
            else if (e instanceof Expr_1.Expr.Fun) {
                const g = Renderer_1.horizSpace(Renderer_1.keyword("fun", Renderer_1.deltaStyle(e)), elim(e.σ));
                return Renderer_1.parenthesiseIf(parens, g, Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.DataExpr) {
                if (isExprFor(e, BaseTypes_1.Pair)) {
                    return pair_expr(e);
                }
                else if (isExprFor(e, BaseTypes_1.Nil) || isExprFor(e, BaseTypes_1.Cons)) {
                    return list_expr(parens, e);
                }
                else {
                    return dataConstr_expr(parens, e);
                }
            }
            else if (e instanceof Expr_1.Expr.Quote) {
                return Renderer_1.unimplemented(e);
            }
            else if (e instanceof Expr_1.Expr.Var) {
                // ouch: disregard delta-info on Var.x
                return Renderer_1.horiz(Renderer_1.text(e.x.val, Renderer_1.deltaStyle(e)));
            }
            else if (e instanceof Expr_1.Expr.App) {
                return Renderer_1.parenthesiseIf(parens, Renderer_1.horizSpace(expr(!(e.f instanceof Expr_1.Expr.App), e.f), expr(true, e.e)), Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.BinaryApp) {
                // ignore operator precedence, but allow function application to take priority over any binary operation
                return Renderer_1.parenthesiseIf(parens, Renderer_1.horizSpace(expr(!(e.e1 instanceof Expr_1.Expr.App), e.e1), Renderer_1.text(e.opName.val, Renderer_1.deltaStyle(e)), // what about changes associated with e.opName
                expr(!(e.e2 instanceof Expr_1.Expr.App), e.e2)), Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.Defs) {
                return Renderer_1.parenthesiseIf(parens, Renderer_1.vert(Renderer_1.vert(...e.def̅.toArray().map(def_ => def(def_))), expr(false, e.e)), Renderer_1.deltaStyle(e));
            }
            else if (e instanceof Expr_1.Expr.MatchAs) {
                return Renderer_1.vert(Renderer_1.horizSpace(Renderer_1.keyword("match", Renderer_1.deltaStyle(e)), expr(false, e.e), Renderer_1.keyword("as", Renderer_1.deltaStyle(e))), elim(e.σ));
            }
            else if (e instanceof Expr_1.Expr.Typematch) {
                return Renderer_1.vert(Renderer_1.horizSpace(Renderer_1.keyword("typematch", Renderer_1.deltaStyle(e)), expr(false, e.e), Renderer_1.keyword("as", Renderer_1.deltaStyle(e))), ...e.cases.toArray().map(({ fst: x, snd: e }) => Renderer_1.horizSpace(Renderer_1.text(x.val, Renderer_1.deltaStyle(x)), Renderer_1.arrow(Renderer_1.deltaStyle(e)), expr(false, e))));
            }
            else {
                return Core_1.absurd(`Unimplemented expression form: ${Core_1.className(e)}.`);
            }
        }
    }
    class ExplValueView extends View {
        constructor(tv, show_v, show_ts) {
            super();
            this.tv = tv;
            this.show_v = show_v;
            this.show_ts = show_ts;
            this.initialise();
        }
        assertValid() {
            Core_1.assert(this.show_v || this.show_ts);
        }
        initialise() {
            const ts = splitExpls(this.tv.t);
            if (ts.length === 0 || !this.show_ts) {
                this.t_visible = false;
                this.v_visible = true;
            }
            else {
                this.t_visible = true;
                this.v_visible = this.show_v;
            }
            return [ts, splitValue(this.tv)];
        }
        render_() {
            this.assertValid();
            const [ts, tv] = this.initialise();
            let g;
            if (!this.v_visible) {
                g = expls(ts);
            }
            else if (!this.t_visible) {
                g = valueView(tv).render();
            }
            else {
                g = Renderer_1.vert(expls(ts), Renderer_1.horizSpace(Renderer_1.text("▸", Renderer_1.deltaStyle(Array_1.nth(ts, ts.length - 1))), valueView(tv).render()));
            }
            if (this.tv === __currentEditor.here.tv) {
                return Renderer_1.addBorder_focus(!this.t_visible && ts.length > 0 ? Renderer_1.edge_left(g) : g);
            }
            else {
                return g;
            }
        }
        toggleValue() {
            if (!this.show_v) {
                this.show_v = true;
            }
            else if (this.show_ts) {
                this.show_v = false;
            }
        }
        toggleExpl() {
            if (!this.show_ts) {
                this.show_ts = true;
            }
            else if (this.show_v) {
                this.show_ts = false;
            }
        }
    }
    class ExplView extends View {
        constructor(t) {
            super();
            this.t = t;
            this.bodyVisible = false;
        }
        render_() {
            let g;
            if (this.t instanceof Expl_1.Expl.Var) {
                g = Renderer_1.horiz(Renderer_1.text(this.t.x.val, Renderer_1.deltaStyle(this.t)));
            }
            else if (this.t instanceof Expl_1.Expl.UnaryApp) {
                g = view(this.t.tf, false, true).render();
            }
            else if (this.t instanceof Expl_1.Expl.BinaryApp) {
                g = Renderer_1.horizSpace(view(this.t.tv1, false, true).render(), Renderer_1.text(this.t.opName.val, Renderer_1.deltaStyle(this.t)), // what about changes associated with t.opName?
                view(this.t.tv2, false, true).render());
            }
            else if (this.t instanceof Expl_1.Expl.App) {
                g = Renderer_1.vert(Renderer_1.horizSpace(view(this.t.tf, false, true).render(), view(this.t.tu, false, true).render()), this.appBody());
            }
            else if (this.t instanceof Expl_1.Expl.Defs) {
                g = Renderer_1.vert(...this.t.def̅.toArray().map(defₜ));
            }
            else if (this.t instanceof Expl_1.Expl.MatchAs) {
                g = Renderer_1.vert(Renderer_1.horizSpace(Renderer_1.keyword("match", Renderer_1.deltaStyle(this.t)), view(this.t.tu, false, true).render(), Renderer_1.keyword("as", Renderer_1.deltaStyle(this.t))), elimMatch(this.t.ξ));
            }
            else if (this.t instanceof Expl_1.Expl.Typematch) {
                return Renderer_1.unimplemented(this.t);
            }
            else {
                return Core_1.absurd("Unknown explanation form", this.t);
            }
            return Renderer_1.shading(g, "white");
        }
        appBody() {
            const app = Core_1.as(this.t, Expl_1.Expl.App);
            const ts = splitExpls(app.t);
            if (ts.length === 0 || this.bodyVisible) {
                return expls(ts);
            }
            else {
                const g = Renderer_1.ellipsis(Renderer_1.deltaStyle(app.t));
                g.addEventListener("click", (ev) => {
                    ev.stopPropagation();
                    this.bodyVisible = true;
                    __currentEditor.onViewChange();
                });
                return g;
            }
        }
    }
    View_1.ExplView = ExplView;
    class ValueView extends View {
        constructor(tv) {
            super();
            this.tv = tv;
        }
        render_() {
            let g;
            if (this.tv.v instanceof Value_1.Num) {
                const e = exprFor(this.tv.t);
                g = Renderer_1.horiz(num_(this.tv.v, e instanceof Expr_1.Expr.ConstNum ? e.val : undefined));
            }
            else if (this.tv.v instanceof Value_1.Str) {
                g = Renderer_1.horiz(str_(this.tv.v));
            }
            else if (this.tv.v instanceof Closure) {
                // treat closures as their function literals, for now
                g = Renderer_1.horizSpace(Renderer_1.keyword("fun", Renderer_1.deltaStyle(this.tv.v)), elim(this.tv.v.f));
            }
            else if (this.tv.v instanceof DataValue_1.DataValue) {
                if (this.tv.v instanceof Graphics_1.GraphicsElement) {
                    const tg = this.tv;
                    const dim = { width: View_1.defaultDims[0], height: View_1.defaultDims[1] };
                    let g1;
                    [g, g1] = Renderer_1.svgElement_inverted(dim.width, dim.height);
                    new GraphicsRenderer_1.GraphicsRenderer(__currentEditor, g, g1).render(tg, Core_1.__nonNull(View_1.dimensions)(tg));
                    Renderer_1.__dimensions.set(g, dim);
                }
                else if (this.tv.v instanceof BaseTypes_1.Pair) {
                    g = pair(this.tv);
                }
                else if (this.tv.v instanceof BaseTypes_1.List) {
                    g = list(this.tv);
                }
                else {
                    g = dataConstr(false, this.tv);
                }
            }
            else {
                g = Renderer_1.unimplemented(this.tv.v);
            }
            return Renderer_1.shading(g, "lavender");
        }
    }
    View_1.ValueView = ValueView;
    // Values are treated slightly differently because the "key" of a value view is the value (to distinguish
    // it from the view of the ExplValue), but the Expl is also required to render the value.
    function valueView(tv) {
        let w = views.get(Core_1.__nonNull(tv).v);
        if (w === undefined) {
            w = new ValueView(tv);
            views.set(tv.v, w);
            return w;
        }
        else {
            return w;
        }
    }
    View_1.valueView = valueView;
    function view(tv, show_v, show_ts) {
        let w = views.get(tv);
        if (w === undefined) {
            w = new ExplValueView(tv, show_v, show_ts);
            views.set(tv, w);
            return w;
        }
        else {
            return w;
        }
    }
    View_1.view = view;
    function view_child(C, tv, prop_, show_v, show_ts) {
        if (Versioned_1.versioned(tv.v) && Versioned_1.versioned(tv.t)) {
            const prop = prop_;
            const w = view(Expl_1.Expl.explChild(tv.t, tv.v, prop_), show_v, show_ts);
            const g = w.render();
            if (tv.v.__ẟ instanceof Delta_1.Change && tv.v.__ẟ.hasChanged(prop)) {
                // All a bit hacky, need to rethink:
                const t_prev = tv.t.__ẟ instanceof Delta_1.Change && tv.t.__ẟ.hasChanged(prop) ?
                    Core_1.as(tv.t.__ẟ.changed[prop].before, Expl_1.Expl.Expl) :
                    tv.t;
                const w_existing = views.get(DataValue_1.explValue(t_prev, Core_1.as(tv.v.__ẟ.changed[prop].before, Value_1.Value)));
                if (w_existing) {
                    __links.add({ from: w, to: w_existing });
                }
                return Renderer_1.addBorder_changed(g);
            }
            else {
                return g;
            }
        }
        else {
            return Core_1.absurd();
        }
    }
    function explView(t) {
        let w = views.get(t);
        if (w === undefined) {
            w = new ExplView(t);
            views.set(t, w);
            return w;
        }
        else {
            return w;
        }
    }
    View_1.explView = explView;
    function splitExpls(t) {
        if (t instanceof Expl_1.Expl.Const) {
            return [];
        }
        else if (t instanceof Expl_1.Expl.Fun) {
            return [];
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            return [];
        }
        else if (t instanceof Expl_1.Expl.Var) {
            // values of variables themselves have explanations, but ignore those for now
            return [t];
        }
        else 
        // don't recurse into App as it has its own expansion state
        if (t instanceof Expl_1.Expl.UnaryApp || t instanceof Expl_1.Expl.BinaryApp) {
            return [t];
        }
        else if (t instanceof Expl_1.Expl.App) {
            return [t];
        }
        else if (t instanceof Expl_1.Expl.NonTerminal) {
            return [t, ...splitExpls(t.t)];
        }
        else {
            return Core_1.absurd("Unknown explanation form", t);
        }
    }
    View_1.splitExpls = splitExpls;
    // The value part must be an ExplValue, because in the data value case we need the explanation as well to
    // render the value.
    function splitValue(tv) {
        const { t, v } = tv;
        if (t instanceof Expl_1.Expl.Const) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.Fun) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.DataExpl) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.Var) {
            // values of variables themselves have explanations, but ignore those for now
            return splitValue(DataValue_1.explValue(t.t, v));
        }
        else 
        // don't recurse into App as it has its own expansion state
        if (t instanceof Expl_1.Expl.UnaryApp || t instanceof Expl_1.Expl.BinaryApp) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.App) {
            return tv;
        }
        else if (t instanceof Expl_1.Expl.NonTerminal) {
            return splitValue(DataValue_1.explValue(t.t, v));
        }
        else {
            return Core_1.absurd();
        }
    }
    View_1.splitValue = splitValue;
    function expls(ts) {
        return Renderer_1.vert(...ts.map(t => explView(t).render()));
    }
    function compareCtr(c1, c2) {
        const n = DataType_1.ctrFor(c1).arity - DataType_1.ctrFor(c2).arity;
        return n === 0 ? c1.localeCompare(c2) : n;
    }
    function cont(κ) {
        if (κ instanceof Expr_1.Expr.Expr) {
            return [[[], κ]];
        }
        else if (κ instanceof Match_1.Elim) {
            return clauses(κ);
        }
        else {
            return Core_1.absurd();
        }
    }
    function clauses(σ) {
        if (Match_1.VarElim.is(σ)) {
            const cs = cont(σ.κ);
            // disregard any delta information on x :-/
            return cs.map(([cxs, e]) => [[[σ.x, Renderer_1.deltaStyle(σ)], ...cxs], e]);
        }
        else if (Match_1.DataElim.is(σ)) {
            const cκs = Array_1.zip(Value_1.fields(σ), σ.__children).sort(([c1,], [c2,]) => compareCtr(c1, c2));
            return Array_1.flatten(cκs.filter(([c, κ]) => κ !== undefined).map(([c, κ]) => cont(Core_1.__nonNull(κ)).map(([cxs, e]) => [[[DataType_1.ctrFor(c), Renderer_1.deltaStyle(σ)], ...cxs], e])));
        }
        else {
            return Core_1.absurd();
        }
    }
    function consComma(ẟ_style, src) {
        const g = Renderer_1.comma(ẟ_style);
        g.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (src !== undefined) {
                Versioned_1.newRevision();
                if (ev.metaKey) {
                    if (ev.altKey) {
                        // if my tail is another cons, swap the two head elements
                        const e = Core_1.as(new Cursor_1.ExprCursor(src).constr_to(BaseTypes_1.Cons, "tail").v, Expr_1.Expr.Expr);
                        if (isExprFor(e, BaseTypes_1.Cons)) {
                            const e1 = Core_1.as(new Cursor_1.ExprCursor(src).constr_to(BaseTypes_1.Cons, "head").v, Expr_1.Expr.Expr);
                            const e2 = Core_1.as(new Cursor_1.ExprCursor(e).constr_to(BaseTypes_1.Cons, "head").v, Expr_1.Expr.Expr);
                            // constr_splice on src, replacing head with head of src.tail
                            // constr_splice on src.tail, replacing head with head of src
                            new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Cons, ["head"], ([e]) => {
                                return [e2];
                            });
                            new Cursor_1.ExprCursor(e).constr_splice(BaseTypes_1.Cons, ["head"], ([e]) => {
                                return [e1];
                            });
                        }
                    }
                    else {
                        new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Cons, ["head"], ([e]) => {
                            const eʹ = Expr_1.Expr.app(Expr_1.Expr.var_(Versioned_1.str("sq")(Versioned_1.ν()))(Versioned_1.ν()), Expr_1.Expr.var_(Versioned_1.str("x")(Versioned_1.ν()))(Versioned_1.ν()))(Versioned_1.ν());
                            return [Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Pair), e, eʹ)(Versioned_1.ν())];
                        });
                    }
                }
                else {
                    new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Cons, ["tail"], ([e]) => {
                        const eʹ = Expr_1.Expr.constNum(Versioned_1.num(0)(Versioned_1.ν()))(Versioned_1.ν());
                        return [Versioned_1.at(DataType_1.exprClass(BaseTypes_1.Cons), eʹ, e)(Versioned_1.ν())];
                    });
                }
                __currentEditor.onEdit();
            }
        });
        return g;
    }
    function dataConstr(parens, { t, v }) {
        const tvs = Expl_1.Expl.explChildren(t, v);
        // a constructor expression makes its value, so their root delta highlighting must agree
        const gs = tvs.map(tvʹ => view(tvʹ, true, false).render());
        const g = Renderer_1.horizSpace(Renderer_1.text(v.ctr, Renderer_1.deltaStyle(v)), ...(tvs.length > 2 ? [Renderer_1.vert(...gs)] : gs));
        return Renderer_1.parenthesiseIf(tvs.length > 0 && parens, g, Renderer_1.deltaStyle(t));
    }
    function dataConstr_expr(parens, e) {
        const es = e.__children;
        const gs = es.map(eʹ => expr(true, eʹ));
        const g = Renderer_1.horizSpace(Renderer_1.text(e.ctr, Renderer_1.deltaStyle(e)), ...(es.length > 2 ? [Renderer_1.vert(...gs)] : gs));
        return Renderer_1.parenthesiseIf(es.length > 0 && parens, g, Renderer_1.deltaStyle(e));
    }
    function def(def) {
        if (def instanceof Expr_1.Expr.Prim) {
            return Renderer_1.horizSpace(Renderer_1.keyword("primitive", Renderer_1.deltaStyle(def)), patternVar(def.x));
        }
        else if (def instanceof Expr_1.Expr.Let) {
            if (def.e instanceof Expr_1.Expr.Fun) {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), elim(def.e.σ));
            }
            else {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), Renderer_1.keyword("equals", Renderer_1.deltaStyle(def)), expr(false, def.e));
            }
        }
        else if (def instanceof Expr_1.Expr.LetRec) {
            return Renderer_1.horizSpace(Renderer_1.keyword("letRec", Renderer_1.deltaStyle(def)), Renderer_1.vert(...def.δ.toArray().map(def => recDef(def))));
        }
        else {
            return Core_1.absurd();
        }
    }
    function defₜ(def) {
        if (def instanceof Expl_1.Expl.Prim) {
            return Renderer_1.horizSpace(Renderer_1.keyword("primitive", Renderer_1.deltaStyle(def)), patternVar(def.x));
        }
        else if (def instanceof Expl_1.Expl.Let) {
            if (def.tv.t instanceof Expl_1.Expl.Fun && def.tv.v instanceof Closure) {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), elim(def.tv.v.f));
            }
            else {
                return Renderer_1.horizSpace(Renderer_1.keyword("let_", Renderer_1.deltaStyle(def)), patternVar(def.x), Renderer_1.keyword("equals", Renderer_1.deltaStyle(def)), view(def.tv, false, true).render());
            }
        }
        else if (def instanceof Expl_1.Expl.LetRec) {
            return Renderer_1.horizSpace(Renderer_1.keyword("letRec", Renderer_1.deltaStyle(def)), Renderer_1.vert(...def.δ.toArray().map(def => recDefₜ(def))));
        }
        else {
            return Core_1.absurd();
        }
    }
    function elim(σ) {
        return Renderer_1.vert(...clauses(σ).map(([cxs, e]) => {
            const [[g], cxsʹ] = patterns(false, 1, cxs);
            Core_1.assert(cxsʹ.length === 0);
            const gʹ = e instanceof Expr_1.Expr.Fun ?
                elim(e.σ) : // curried function resugaring
                Renderer_1.horizSpace(Renderer_1.arrow(Renderer_1.deltaStyle(e)), expr(false, e));
            return Renderer_1.horizSpace(g, gʹ);
        }));
    }
    // Hack just to support Bool, Ordering, etc.
    function elimMatch(ξ) {
        const tv = Array_1.nth(ξ.tv̅.toArray(), 0);
        // don't think the contination is needed; already stored in the trace
        return Renderer_1.horizSpace(Renderer_1.text(tv.v.ctr, Renderer_1.deltaStyle(tv.v)), Renderer_1.arrow(Renderer_1.deltaStyle(tv.v)));
    }
    function expr_(parens, e) {
        let w = views.get(e);
        if (w === undefined) {
            w = new ExprView(parens, e);
            views.set(e, w);
            return w;
        }
        else {
            return w;
        }
    }
    function expr(parens, e) {
        return expr_(parens, e).render();
    }
    // Really want some kind of view typeclass, so this isn't specific to expression. Also: consolidate with ExprCursor.
    function expr_child(C, parens, e, prop) {
        if (Versioned_1.versioned(e)) {
            const w = expr_(parens, e.__child(prop));
            const g = w.render();
            if (e.__ẟ instanceof Delta_1.Change && e.__ẟ.hasChanged(prop)) {
                const w_existing = views.get(Core_1.as(e.__ẟ.changed[prop].before, Expr_1.Expr.Expr));
                if (w_existing) {
                    __links.add({ from: w, to: w_existing });
                }
                return Renderer_1.addBorder_changed(g);
            }
            else {
                return g;
            }
        }
        else {
            return Core_1.absurd();
        }
    }
    function list({ t, v }) {
        if (BaseTypes_1.Cons.is(v)) {
            const vʹ = v;
            const e = exprFor(t);
            return Renderer_1.horiz(view_child(BaseTypes_1.Cons, DataValue_1.explValue(t, vʹ), "head", true, false), consComma(Renderer_1.deltaStyle(v), isExprFor(e, BaseTypes_1.Cons) ? e : undefined), Renderer_1.space(), view(Expl_1.Expl.explChild(t, vʹ, "tail"), true, false).render());
        }
        else if (BaseTypes_1.Nil.is(v)) {
            return Renderer_1.horiz(Renderer_1.centreDot(Renderer_1.deltaStyle(v)));
        }
        else {
            return Core_1.absurd();
        }
    }
    function list_expr(parens, e) {
        if (isExprFor(e, BaseTypes_1.Cons)) {
            return Renderer_1.parenthesiseIf(parens, Renderer_1.horiz(expr_child(BaseTypes_1.Cons, false, e, "head"), consComma(Renderer_1.deltaStyle(e), e), Renderer_1.space(), list_expr(false, e.__child("tail"))), Renderer_1.deltaStyle(e));
        }
        else if (isExprFor(e, BaseTypes_1.Nil)) {
            return Renderer_1.horiz(Renderer_1.centreDot(Renderer_1.deltaStyle(e)));
        }
        else {
            return Renderer_1.horiz(expr(false, e)); // promote to nested SVG; need to rethink
        }
    }
    function num_(n, src) {
        const g = Renderer_1.text(n.toString(), Renderer_1.deltaStyle(n));
        if (src && Number.isInteger(src.val)) {
            g.addEventListener("click", (ev) => {
                Versioned_1.newRevision();
                new Cursor_1.ExprCursor(src).setNum(ev.metaKey ? src.val - 1 : src.val + 1);
                ev.stopPropagation();
                __currentEditor.onEdit();
            });
        }
        return g;
    }
    function pair(tv) {
        return Renderer_1.parenthesise(Renderer_1.horiz(view_child(BaseTypes_1.Pair, tv, "fst", true, false), pairComma(Renderer_1.deltaStyle(tv.t), exprFor(tv.t)), Renderer_1.space(), view_child(BaseTypes_1.Pair, tv, "snd", true, false)), Renderer_1.deltaStyle(tv.t));
    }
    function pairComma(ẟ_style, src) {
        const g = Renderer_1.comma(ẟ_style);
        g.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (src !== undefined) {
                Versioned_1.newRevision();
                if (ev.metaKey) {
                    new Cursor_1.ExprCursor(src).constr_splice(BaseTypes_1.Pair, ["fst", "snd"], ([e1, e2]) => {
                        return [e2, e1];
                    });
                }
                __currentEditor.onEdit();
            }
        });
        return g;
    }
    function pair_expr(e) {
        return Renderer_1.parenthesise(Renderer_1.horiz(expr_child(BaseTypes_1.Pair, false, e, "fst"), pairComma(Renderer_1.deltaStyle(e), e), Renderer_1.space(), expr_child(BaseTypes_1.Pair, false, e, "snd")), Renderer_1.deltaStyle(e));
    }
    function patterns(parens, n, cxs) {
        if (n === 0) {
            return [[], cxs];
        }
        else {
            const [ctr_x, ẟ_style] = cxs[0];
            if (ctr_x instanceof DataType_1.Ctr) {
                if (ctr_x.C === BaseTypes_1.Pair) {
                    const [[g1, g2], cxsʹ] = patterns(false, 2, cxs.slice(1));
                    const [gsʹ, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[Renderer_1.parenthesise(Renderer_1.horiz(g1, Renderer_1.comma(ẟ_style), Renderer_1.space(), g2), ẟ_style), ...gsʹ], cxsʹʹ];
                }
                else if (ctr_x.C === BaseTypes_1.Nil) {
                    const [g, cxsʹ] = [Renderer_1.centreDot(ẟ_style), cxs.slice(1)];
                    const [gs, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[g, ...gs], cxsʹʹ];
                }
                else if (ctr_x.C === BaseTypes_1.Cons) {
                    const [[g_head, g_tail], cxsʹ] = patterns(false, ctr_x.arity, cxs.slice(1));
                    const g = Renderer_1.horiz(g_head, Renderer_1.comma(ẟ_style), Renderer_1.space(), g_tail);
                    const [gsʹ, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[Renderer_1.parenthesiseIf(ctr_x.arity > 0 && parens, g, ẟ_style), ...gsʹ], cxsʹʹ];
                }
                else {
                    const [gs, cxsʹ] = patterns(true, ctr_x.arity, cxs.slice(1));
                    const g = Renderer_1.horizSpace(Renderer_1.text(ctr_x.c, ẟ_style), ...gs);
                    const [gsʹ, cxsʹʹ] = patterns(parens, n - 1, cxsʹ);
                    return [[Renderer_1.parenthesiseIf(ctr_x.arity > 0 && parens, g, ẟ_style), ...gsʹ], cxsʹʹ];
                }
            }
            else if (ctr_x instanceof Value_1.Str) {
                const [gs, cxsʹ] = patterns(parens, n - 1, cxs.slice(1));
                // ouch, ignore ẟ_style coming from trie and use variable instead :-/
                return [[patternVar(ctr_x), ...gs], cxsʹ];
            }
            else {
                return Core_1.absurd();
            }
        }
    }
    function patternVar(x) {
        return Renderer_1.text(x.val, Renderer_1.deltaStyle(x));
    }
    function recDef(def) {
        return Renderer_1.horizSpace(patternVar(def.x), elim(def.σ));
    }
    function recDefₜ(def) {
        return Renderer_1.horizSpace(patternVar(def.x), elim(def.tf.v.f));
    }
    function str_(str) {
        return Renderer_1.text(str.toString(), Renderer_1.deltaStyle(str));
    }
})(View = exports.View || (exports.View = {}));


/***/ }),

/***/ "./src/app/inconsolata-webfont.woff":
/*!******************************************!*\
  !*** ./src/app/inconsolata-webfont.woff ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:font/woff;base64,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"

/***/ }),

/***/ "./src/app/styles.css":
/*!****************************!*\
  !*** ./src/app/styles.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./styles.css */ "./node_modules/css-loader/dist/cjs.js!./src/app/styles.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./src/util/Array.ts":
/*!***************************!*\
  !*** ./src/util/Array.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./Core */ "./src/util/Core.ts");
function flatten(x̅̅) {
    const x̅ = []; // otherwise TS is confused
    return x̅.concat.apply([], x̅̅);
}
exports.flatten = flatten;
function counts(x̅) {
    const counts = new Map;
    x̅.forEach(x => {
        if (counts.has(x)) {
            counts.set(x, Core_1.__nonNull(counts.get(x)) + 1);
        }
        else {
            counts.set(x, 1);
        }
    });
    return counts;
}
exports.counts = counts;
function zip(x̅, y̅) {
    return zipWith((t, u) => [t, u])(x̅, y̅);
}
exports.zip = zip;
function zipWith(f) {
    return (x̅, y̅) => x̅.map((x, n) => f(x, y̅[n]));
}
exports.zipWith = zipWith;
function includes(x̅, y̅) {
    return y̅.every(y => x̅.includes(y));
}
exports.includes = includes;
function eq(x̅, y̅) {
    let n = x̅.length;
    if (n != y̅.length) {
        return false;
    }
    else {
        while (n--) {
            if (x̅[n] !== y̅[n])
                return false;
        }
        return true;
    }
}
exports.eq = eq;
function nth(x̅, n) {
    Core_1.assert(0 <= n && n < x̅.length);
    return x̅[n];
}
exports.nth = nth;
function last(x̅) {
    Core_1.assert(x̅.length > 0);
    return x̅.slice(-1)[0];
}
exports.last = last;


/***/ }),

/***/ "./src/util/Core.ts":
/*!**************************!*\
  !*** ./src/util/Core.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function classOf(x) {
    return __nonNull(x).constructor; // weirdly failing on CircleCI without cast
}
exports.classOf = classOf;
function className(o) {
    return classOf(o).name;
}
exports.className = className;
function as(x, C) {
    if (__nonNull(x) instanceof C) {
        return x;
    }
    else {
        return assert(false, "[as] Expected " + C.name + ", got " + className(x));
    }
}
exports.as = as;
function asOpt(x, cls) {
    if (x === null || x === undefined) {
        return x;
    }
    else {
        return as(x, cls);
    }
}
exports.asOpt = asOpt;
function assert(b, msg, ...x̅) {
    if (!b) {
        if (x̅.length > 0) {
            console.warn("Assertion data:\n");
            x̅.forEach(x => console.warn(x));
        }
        throw new Error(msg || "Assertion failure");
    }
}
exports.assert = assert;
function absurd(msg, ...x̅) {
    assert(false, msg, ...x̅);
}
exports.absurd = absurd;
function id(x) {
    return x;
}
exports.id = id;
// User-level error.
function userError(msg, ...x̅) {
    if (x̅.length > 0) {
        console.warn("Error data:\n");
        x̅.forEach(x => console.warn(x));
    }
    throw new Error("User error: " + msg);
}
exports.userError = userError;
function notYetImplemented() {
    throw new Error("Not yet implemented");
}
exports.notYetImplemented = notYetImplemented;
// Useful when a notionally abstract class needs to be concrete.
function abstractMethodError(this_) {
    return assert(false, "Abstract method in " + this_);
}
exports.abstractMethodError = abstractMethodError;
function __nonNull(x, msg) {
    if (x !== null && x !== undefined) {
        return x;
    }
    else {
        return assert(false, `Unexpected null | undefined.${msg === undefined ? "" : `\n${msg}`}`);
    }
}
exports.__nonNull = __nonNull;
function __log(x, msg, transform = (it) => it) {
    const x_ = transform(x);
    if (msg) {
        console.log(msg(x_));
    }
    console.log(x_);
    return x;
}
exports.__log = __log;
function __check(x, predicate) {
    assert(predicate(x));
    return x;
}
exports.__check = __check;


/***/ }),

/***/ "./src/util/Lattice.ts":
/*!*****************************!*\
  !*** ./src/util/Lattice.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Core_1 = __webpack_require__(/*! ./Core */ "./src/util/Core.ts");
// Actually a boolean lattice...
class LatticeImpl {
    join(...t̅) {
        return t̅.reduce((t1, t2) => this.join2(t1, t2));
    }
    meet(...t̅) {
        return t̅.reduce((t1, t2) => this.meet2(t1, t2));
    }
}
class BoolLattice extends LatticeImpl {
    constructor() {
        super(...arguments);
        this.bot = false;
        this.top = true;
    }
    // Important to assert that arguments are defined since undefined propagates in an unhelpful way.
    join2(b1, b2) {
        return Core_1.__nonNull(b1) || Core_1.__nonNull(b2);
    }
    meet2(b1, b2) {
        return Core_1.__nonNull(b1) && Core_1.__nonNull(b2);
    }
    negate(b) {
        return !b;
    }
}
exports.BoolLattice = BoolLattice;
exports.bool_ = new BoolLattice();


/***/ }),

/***/ "./src/util/Ord.ts":
/*!*************************!*\
  !*** ./src/util/Ord.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function eq(a, b) {
    return a.leq(b) && b.leq(a);
}
exports.eq = eq;


/***/ }),

/***/ "./src/util/Set.ts":
/*!*************************!*\
  !*** ./src/util/Set.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function diff(x̅, y̅) {
    return filter(x̅, x => !(y̅.has(x)));
}
exports.diff = diff;
function every(x̅, pred) {
    return Array.from(x̅).every(pred);
}
exports.every = every;
function filter(x̅, pred) {
    return new Set([...x̅].filter(pred));
}
exports.filter = filter;
function map(x̅, f) {
    return new Set([...x̅].map(f));
}
exports.map = map;
function some(x̅, pred) {
    return Array.from(x̅).some(pred);
}
exports.some = some;
function union(...x̅̅) {
    const y̅ = new Set();
    x̅̅.forEach(x̅ => {
        x̅.forEach(x => {
            y̅.add(x);
        });
    });
    return y̅;
}
exports.union = union;
function intersection(x̅̅, y̅) {
    const zs = new Set();
    x̅̅.forEach(x => {
        if (y̅.has(x)) {
            zs.add(x);
        }
    });
    return zs;
}
exports.intersection = intersection;


/***/ })

/******/ })));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aXBweS5qcy90aGVtZXMvbGlnaHQtYm9yZGVyLmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb28vbW9vLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWFybGV5L2xpYi9uZWFybGV5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5jaHVuay5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzP2NiY2MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aXBweS5qcy90aGVtZXMvbGlnaHQtYm9yZGVyLmNzcz8yZDdkIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Fubm90YXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Jhc2VUeXBlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRGF0YVR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0RhdGFWYWx1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRGVsdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Vudi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRXZhbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRXhwbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRXhwci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvRmluaXRlTWFwLnRzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaGljcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvTGliLnRzIiwid2VicGFjazovLy8uL3NyYy9NYXRjaC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvTW9kdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9QYXJzZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvUHJpbWl0aXZlLnRzIiwid2VicGFjazovLy8uL3NyYy9WYWx1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvVmVyc2lvbmVkLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvQXZlbmlyTFRTdGQtQm9vay53b2ZmIiwid2VicGFjazovLy8uL3NyYy9hcHAvQ29yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL0N1cnNvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL0dyYXBoaWNzUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9JbnRlcmFjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvUGFuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL1BhbmVDb29yZGluYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL1JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvU2xhYm8xM3B4LVJlZ3VsYXIud29mZiIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL1ZpZXcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9pbmNvbnNvbGF0YS13ZWJmb250LndvZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zdHlsZXMuY3NzPzNhMzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvQXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvQ29yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9MYXR0aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy91dGlsL09yZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9TZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsMkZBQXNDO0FBQ2hGO0FBQ0E7QUFDQSxjQUFjLFFBQVMsMERBQTBELFVBQVUsV0FBVyx5QkFBeUIsd0NBQXdDLGNBQWMsb0JBQW9CLDZCQUE2Qix3REFBd0QsOEJBQThCLGVBQWUsa0JBQWtCLFdBQVcsa0JBQWtCLGVBQWUsZ0JBQWdCLHNCQUFzQixpREFBaUQsVUFBVSxpREFBaUQsdUJBQXVCLHNCQUFzQixh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LHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtDQUErQyxjQUFjLEVBQUU7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDbmVEO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsbUJBQW1CO0FBQ3ZEO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Qsa0JBQWtCLHdDQUF3Qzs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQSxHQUFHOztBQUVIOztBQUVB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RUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw2REFBZ0Isc0VBQXNFLDZEQUFTO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFMkY7QUFDM0Y7Ozs7Ozs7Ozs7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QUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsV0FBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsZUFBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGFBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBQyxFQUFFLENBQUMsRUFBQztRQUM1SixFQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUUsU0FBUyxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUN2RSxFQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLENBQUMsY0FBYyxFQUFFLFlBQVksRUFBRSxVQUFVLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFdBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLGVBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLGFBQUMsRUFBRSxDQUFDLEVBQUM7UUFDM0osRUFBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUM7UUFDcEUsRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUM7UUFDbEUsRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsV0FBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBQyxFQUFFLENBQUMsRUFBQztRQUMvRyxFQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLENBQUMs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QUFFLGFBQWEsRUFBRSxFQUFFLEVBQUM7UUFDcEksRUFBQyxNQUFNLEVBQUUsNENBQTRDLEVBQUUsU0FBUyxFQUFFLENBQUMsNENBQTRDLEVBQUUsR0FBRyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFDO1FBQ25KLEVBQUMsTUFBTSxFQUFFLGdDQUFnQyxFQUFFLFNBQVMsRUFBRSxDQUFDLDRDQUE0QyxFQUFFLE1BQU0sQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFDO1FBQzFJLEVBQUMsTUFBTSxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLGdDQUFnQyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQztRQUN0SSxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLGdCQUFnQixFQUFFLGFBQWEsQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsY0FBRSxDQUFDLG9CQUFTLENBQUMsZ0JBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxhQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUM7UUFDdEwsRUFBQyxNQUFNLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLEdBQUcsRUFBRSxDQUFDLGNBQUUsQ0FB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QUFFLHFDQUFxQyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQztRQUNySixFQUFDLE1BQU0sRUFBRSwwQkFBMEIsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFDLFNBQVMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDO1FBQ2xFLEVBQUMsTUFBTSxFQUFFLDBCQUEwQixFQUFFLFNBQVMsRUFBRSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBQztRQUNoRyxFQUFDLE1BQU0sRUFBRSwwQkFBMEIsRUFBRSxTQUFTLEVBQUUsQ0FBQywwQkFBMEIsRUFBRSxHQUFHLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUM7UUFDL0csRUFBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxDQUFDLDBCQUEwQixFQUFFLFNBQVMsRUFBRSxxQkFBcUIsRUFBRSwwQkFBMEIsQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUM7UUFDdEwsRUFBQyxNQUFNLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLElBQUksRUFBRSxXQUFXLEVBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBQztRQUMxRyxFQUFDLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUM7UUFDMUYsRUFBQyxNQUFNLEVBQUUsdUJBQXVCLEVBQUUsU0FB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Q0FBQyxDQUFDLENBQUMsRUFBRTtZQUNaLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ1g7SUFDSixDQUFDLENBQUM7SUFDRixPQUFPLEVBQUU7QUFDWixDQUFDO0FBUkQsb0NBUUMiLCJmaWxlIjoibGliLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiLzAuMy4xL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9MaWIudHNcIik7XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudGlwcHktdG9vbHRpcFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowfS50aXBweS1pT1N7Y3Vyc29yOnBvaW50ZXIhaW1wb3J0YW50Oy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudH0udGlwcHktcG9wcGVye3BvaW50ZXItZXZlbnRzOm5vbmU7bWF4LXdpZHRoOmNhbGMoMTAwdncgLSAxMHB4KTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE2NSwuODQsLjQ0LDEpO3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtfS50aXBweS10b29sdGlwe3Bvc2l0aW9uOnJlbGF0aXZlO2NvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czo0cHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS40O2JhY2tncm91bmQtY29sb3I6IzMzMzt0cmFuc2l0aW9uLXByb3BlcnR5OnZpc2liaWxpdHksb3BhY2l0eSx0cmFuc2Zvcm07b3V0bGluZTowfS50aXBweS10b29sdGlwW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1hcnJvd3tib3JkZXItd2lkdGg6OHB4IDhweCAwO2JvcmRlci10b3AtY29sb3I6IzMzMzttYXJnaW46MCAzcHg7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMDtib3R0b206LTdweH0udGlwcHktdG9vbHRpcFtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktYXJyb3d7Ym9yZGVyLXdpZHRoOjAgOHB4IDhweDtib3JkZXItYm90dG9tLWNvbG9yOiMzMzM7bWFyZ2luOjAgM3B4O3RyYW5zZm9ybS1vcmlnaW46NTAlIDdweDt0b3A6LTdweH0udGlwcHktdG9vbHRpcFtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LWFycm93e2JvcmRlci13aWR0aDo4cHggMCA4cHggOHB4O2JvcmRlci1sZWZ0LWNvbG9yOiMzMzM7bWFyZ2luOjNweCAwO3RyYW5zZm9ybS1vcmlnaW46MCA1MCU7cmlnaHQ6LTdweH0udGlwcHktdG9vbHRpcFtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvd3tib3JkZXItd2lkdGg6OHB4IDhweCA4cHggMDtib3JkZXItcmlnaHQtY29sb3I6IzMzMzttYXJnaW46M3B4IDA7dHJhbnNmb3JtLW9yaWdpbjo3cHggNTAlO2xlZnQ6LTdweH0udGlwcHktdG9vbHRpcFtkYXRhLWludGVyYWN0aXZlXVtkYXRhLXN0YXRlPXZpc2libGVde3BvaW50ZXItZXZlbnRzOmF1dG99LnRpcHB5LXRvb2x0aXBbZGF0YS1pbmVydGlhXVtkYXRhLXN0YXRlPXZpc2libGVde3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNTQsMS41LC4zOCwxLjExKX0udGlwcHktYXJyb3d7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1zdHlsZTpzb2xpZH0udGlwcHktY29udGVudHtwYWRkaW5nOjVweCA5cHh9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7YmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JvcmRlcjoxcHggc29saWQgcmdiYSgwLDgsMTYsLjE1KTtjb2xvcjojMjYzMjNkO2JveC1zaGFkb3c6MCA0cHggMTRweCAtMnB4IHJnYmEoMCw4LDE2LC4wOCl9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lPi50aXBweS1iYWNrZHJvcHtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lPi50aXBweS1hcnJvdzphZnRlciwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWU+LnRpcHB5LWFycm93OmJlZm9yZSwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWU+LnRpcHB5LXN2Zy1hcnJvdzphZnRlciwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWU+LnRpcHB5LXN2Zy1hcnJvdzpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Oi0xfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZT4udGlwcHktc3ZnLWFycm93e2ZpbGw6I2ZmZn0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWU+LnRpcHB5LXN2Zy1hcnJvdzphZnRlcntiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ2MzUnliMnRsTFd4cGJtVnFiMmx1UFNKeWIzVnVaQ0lnYzNSeWIydGxMVzFwZEdWeWJHbHRhWFE5SWpFdU5ERTBJaUIyYVdWM1FtOTRQU0l3SURBZ01UZ2dOeUlnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQmtQU0pOTUNBM2N6SXVNREl4TFM0d01UVWdOUzR5TlRNdE5DNHlNVGhETmk0MU9EUWdNUzR3TlRFZ055NDNPVGN1TURBM0lEa2dNR014TGpJd015MHVNREEzSURJdU5ERTJJREV1TURNMUlETXVOell4SURJdU56Z3lRekUyTGpBeE1pQTNMakF3TlNBeE9DQTNJREU0SURkNklpQm1hV3hzUFNJak16TXpJaUJtYVd4c0xXOXdZV05wZEhrOUlpNHlNelVpSUdacGJHd3RjblZzWlQwaWJtOXVlbVZ5YnlJdlBqd3ZjM1puUGc9PSk7YmFja2dyb3VuZC1zaXplOjE4cHggN3B4O3dpZHRoOjE4cHg7aGVpZ2h0OjdweDtsZWZ0OjA7dG9wOjA7ZmlsbDpyZ2JhKDAsOCwxNiwuMTUpfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktc3ZnLWFycm93OmFmdGVye3RvcDoxcHg7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3d7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3c6YWZ0ZXJ7Ym9yZGVyLXRvcDo3cHggc29saWQgI2ZmZjt0b3A6LTdweH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXRvcF0+LnRpcHB5LWFycm93OmJlZm9yZXtib3JkZXItdG9wOjdweCBzb2xpZCByZ2JhKDAsOCwxNiwuMik7Ym90dG9tOi0xcHh9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1zdmctYXJyb3c6YWZ0ZXJ7dG9wOi0xcHh9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1hcnJvd3tib3JkZXItYm90dG9tLWNvbG9yOiNmZmZ9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1hcnJvdzphZnRlcntib3JkZXItYm90dG9tOjdweCBzb2xpZCAjZmZmO2JvdHRvbTotN3B4fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktYXJyb3c6YmVmb3Jle2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHJnYmEoMCw4LDE2LC4yKTtib3R0b206LTZweH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1zdmctYXJyb3c6YWZ0ZXJ7bGVmdDoxcHg7dG9wOjA7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1sZWZ0XT4udGlwcHktYXJyb3d7Ym9yZGVyLWxlZnQtY29sb3I6I2ZmZn0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvdzphZnRlcntib3JkZXItbGVmdDo3cHggc29saWQgI2ZmZjtsZWZ0Oi03cHh9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1sZWZ0XT4udGlwcHktYXJyb3c6YmVmb3Jle2JvcmRlci1sZWZ0OjdweCBzb2xpZCByZ2JhKDAsOCwxNiwuMik7bGVmdDotNnB4fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1zdmctYXJyb3c6YWZ0ZXJ7bGVmdDotMXB4O3RvcDowO3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKX0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXJpZ2h0XT4udGlwcHktYXJyb3d7Ym9yZGVyLXJpZ2h0LWNvbG9yOiNmZmZ9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93OmFmdGVye2JvcmRlci1yaWdodDo3cHggc29saWQgI2ZmZjtyaWdodDotN3B4fS50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvdzpiZWZvcmV7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCByZ2JhKDAsOCwxNiwuMik7cmlnaHQ6LTZweH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93LC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktc3ZnLWFycm93LC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3csLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj10b3BdPi50aXBweS1zdmctYXJyb3d7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTFweCl9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1ib3R0b21dPi50aXBweS1hcnJvdzphZnRlciwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93OmJlZm9yZSwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXRvcF0+LnRpcHB5LWFycm93OmFmdGVyLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3c6YmVmb3Jle2xlZnQ6LTdweDtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvdywudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1zdmctYXJyb3csLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93LC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1zdmctYXJyb3d7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCl9LnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1sZWZ0XT4udGlwcHktYXJyb3c6YWZ0ZXIsLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lW2RhdGEtcGxhY2VtZW50Xj1sZWZ0XT4udGlwcHktYXJyb3c6YmVmb3JlLC50aXBweS10b29sdGlwLmxpZ2h0LWJvcmRlci10aGVtZVtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvdzphZnRlciwudGlwcHktdG9vbHRpcC5saWdodC1ib3JkZXItdGhlbWVbZGF0YS1wbGFjZW1lbnRePXJpZ2h0XT4udGlwcHktYXJyb3c6YmVmb3Jle3RvcDotN3B4O2JvcmRlci10b3A6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHRyYW5zcGFyZW50fVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gcmVxdWlyZShcIi4vaW5jb25zb2xhdGEtd2ViZm9udC53b2ZmXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fID0gcmVxdWlyZShcIi4vU2xhYm8xM3B4LVJlZ3VsYXIud29mZlwiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyA9IHJlcXVpcmUoXCIuL0F2ZW5pckxUU3RkLUJvb2sud29mZlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAZm9udC1mYWNlIHtcXG4gICBmb250LWZhbWlseTogXFxcImluY29uc29sYXRhXFxcIjtcXG4gICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICBzcmM6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gKyBcIikgZm9ybWF0KCd3b2ZmJyk7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgIGZvbnQtZmFtaWx5OiBcXFwiU2xhYm8gMTNweFxcXCI7XFxuICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgc3JjOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fICsgXCIpIGZvcm1hdCgnd29mZicpO1xcbn1cXG5cXG5AZm9udC1mYWNlIHtcXG4gICBmb250LWZhbWlseTogXFxcIkF2ZW5pckxUU3RkLUJvb2tcXFwiO1xcbiAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICBmb250LXdlaWdodDogNDAwO1xcbiAgIHNyYzogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyArIFwiKSBmb3JtYXQoJ3dvZmYnKTtcXG59XFxuXFxuLmNvZGUge1xcbiAgIGZvbnQtZmFtaWx5OiBcXFwiaW5jb25zb2xhdGFcXFwiO1xcbiAgIHN0cm9rZTogbm9uZTtcXG59XFxuXFxuLmxhYmVsIHtcXG4gICBmb250LWZhbWlseTogXFxcIkF2ZW5pckxUU3RkLUJvb2tcXFwiO1xcbiAgIHN0cm9rZTogbm9uZTtcXG59XFxuXFxuLnVuY2hhbmdlZCB7XFxuICAgZmlsbDogYmxhY2s7XFxufVxcblxcbi5jaGFuZ2VkIHtcXG4gICBmaWxsOiBibHVlO1xcbn1cXG5cXG4ubmV3IHtcXG4gICBmaWxsOiBsaW1lZ3JlZW47XFxufVxcblxcbi50aXBweS10b29sdGlwIHtcXG4gICBmb250LWZhbWlseTogXFxcImluY29uc29sYXRhXFxcIjtcXG59XFxuXFxuLnRpcHB5LXRvb2x0aXAubGlnaHQtYm9yZGVyLXRoZW1lIHtcXG4gICBmb250LXNpemU6IDlwdDtcXG59XFxuXFxuLmZvY3VzIHtcXG4gICBzdHJva2U6IGJsYWNrO1xcbiAgIHN0cm9rZS1vcGFjaXR5OiAwLjE7XFxuICAgZmlsbC1vcGFjaXR5OiAwLjc7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXBhcmFtLXJlYXNzaWduXG5cblxuICB1cmwgPSB1cmwgJiYgdXJsLl9fZXNNb2R1bGUgPyB1cmwuZGVmYXVsdCA6IHVybDtcblxuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLCBcIlxcXCJcIik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KSAvKiBnbG9iYWwgZGVmaW5lICovXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICB9IGVsc2Uge1xuICAgIHJvb3QubW9vID0gZmFjdG9yeSgpXG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgdmFyIGhhc1N0aWNreSA9IHR5cGVvZiBuZXcgUmVnRXhwKCkuc3RpY2t5ID09PSAnYm9vbGVhbidcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIGZ1bmN0aW9uIGlzUmVnRXhwKG8pIHsgcmV0dXJuIG8gJiYgdG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuICBmdW5jdGlvbiBpc09iamVjdChvKSB7IHJldHVybiBvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiAhaXNSZWdFeHAobykgJiYgIUFycmF5LmlzQXJyYXkobykgfVxuXG4gIGZ1bmN0aW9uIHJlRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKVxuICB9XG4gIGZ1bmN0aW9uIHJlR3JvdXBzKHMpIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCd8JyArIHMpXG4gICAgcmV0dXJuIHJlLmV4ZWMoJycpLmxlbmd0aCAtIDFcbiAgfVxuICBmdW5jdGlvbiByZUNhcHR1cmUocykge1xuICAgIHJldHVybiAnKCcgKyBzICsgJyknXG4gIH1cbiAgZnVuY3Rpb24gcmVVbmlvbihyZWdleHBzKSB7XG4gICAgaWYgKCFyZWdleHBzLmxlbmd0aCkgcmV0dXJuICcoPyEpJ1xuICAgIHZhciBzb3VyY2UgPSAgcmVnZXhwcy5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwiKD86XCIgKyBzICsgXCIpXCJcbiAgICB9KS5qb2luKCd8JylcbiAgICByZXR1cm4gXCIoPzpcIiArIHNvdXJjZSArIFwiKVwiXG4gIH1cblxuICBmdW5jdGlvbiByZWdleHBPckxpdGVyYWwob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyByZUVzY2FwZShvYmopICsgJyknXG5cbiAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKG9iaikpIHtcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIC91IHN1cHBvcnRcbiAgICAgIGlmIChvYmouaWdub3JlQ2FzZSkgdGhyb3cgbmV3IEVycm9yKCdSZWdFeHAgL2kgZmxhZyBub3QgYWxsb3dlZCcpXG4gICAgICBpZiAob2JqLmdsb2JhbCkgdGhyb3cgbmV3IEVycm9yKCdSZWdFeHAgL2cgZmxhZyBpcyBpbXBsaWVkJylcbiAgICAgIGlmIChvYmouc3RpY2t5KSB0aHJvdyBuZXcgRXJyb3IoJ1JlZ0V4cCAveSBmbGFnIGlzIGltcGxpZWQnKVxuICAgICAgaWYgKG9iai5tdWx0aWxpbmUpIHRocm93IG5ldyBFcnJvcignUmVnRXhwIC9tIGZsYWcgaXMgaW1wbGllZCcpXG4gICAgICByZXR1cm4gb2JqLnNvdXJjZVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgcGF0dGVybjogJyArIG9iailcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RUb1J1bGVzKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KVxuICAgIHZhciByZXN1bHQgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIHZhciB0aGluZyA9IG9iamVjdFtrZXldXG4gICAgICB2YXIgcnVsZXMgPSBbXS5jb25jYXQodGhpbmcpXG4gICAgICBpZiAoa2V5ID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtpbmNsdWRlOiBydWxlc1tqXX0pXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHZhciBtYXRjaCA9IFtdXG4gICAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJ1bGUpKSB7XG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCkgcmVzdWx0LnB1c2gocnVsZU9wdGlvbnMoa2V5LCBtYXRjaCkpXG4gICAgICAgICAgcmVzdWx0LnB1c2gocnVsZU9wdGlvbnMoa2V5LCBydWxlKSlcbiAgICAgICAgICBtYXRjaCA9IFtdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2gucHVzaChydWxlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKG1hdGNoLmxlbmd0aCkgcmVzdWx0LnB1c2gocnVsZU9wdGlvbnMoa2V5LCBtYXRjaCkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5VG9SdWxlcyhhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBhcnJheVtpXVxuICAgICAgaWYgKG9iai5pbmNsdWRlKSB7XG4gICAgICAgIHZhciBpbmNsdWRlID0gW10uY29uY2F0KG9iai5pbmNsdWRlKVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluY2x1ZGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7aW5jbHVkZTogaW5jbHVkZVtqXX0pXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmICghb2JqLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlIGhhcyBubyB0eXBlOiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSlcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHJ1bGVPcHRpb25zKG9iai50eXBlLCBvYmopKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBydWxlT3B0aW9ucyh0eXBlLCBvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgIG9iaiA9IHsgbWF0Y2g6IG9iaiB9XG4gICAgfVxuICAgIGlmIChvYmouaW5jbHVkZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRjaGluZyBydWxlcyBjYW5ub3QgYWxzbyBpbmNsdWRlIHN0YXRlcycpXG4gICAgfVxuXG4gICAgLy8gbmIuIGVycm9yIGFuZCBmYWxsYmFjayBpbXBseSBsaW5lQnJlYWtzXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBkZWZhdWx0VHlwZTogdHlwZSxcbiAgICAgIGxpbmVCcmVha3M6ICEhb2JqLmVycm9yIHx8ICEhb2JqLmZhbGxiYWNrLFxuICAgICAgcG9wOiBmYWxzZSxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBwdXNoOiBudWxsLFxuICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgZmFsbGJhY2s6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgc2hvdWxkVGhyb3c6IGZhbHNlLFxuICAgIH1cblxuICAgIC8vIEF2b2lkIE9iamVjdC5hc3NpZ24oKSwgc28gd2Ugc3VwcG9ydCBJRTkrXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IG9ialtrZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHlwZSB0cmFuc2Zvcm0gY2Fubm90IGJlIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICdzdHJpbmcnICYmIHR5cGUgIT09IG9wdGlvbnMudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSB0cmFuc2Zvcm0gY2Fubm90IGJlIGEgc3RyaW5nICh0eXBlICdcIiArIG9wdGlvbnMudHlwZSArIFwiJyBmb3IgdG9rZW4gJ1wiICsgdHlwZSArIFwiJylcIilcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGFycmF5XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaFxuICAgIG9wdGlvbnMubWF0Y2ggPSBBcnJheS5pc0FycmF5KG1hdGNoKSA/IG1hdGNoIDogbWF0Y2ggPyBbbWF0Y2hdIDogW11cbiAgICBvcHRpb25zLm1hdGNoLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGlzUmVnRXhwKGEpICYmIGlzUmVnRXhwKGIpID8gMFxuICAgICAgICAgICA6IGlzUmVnRXhwKGIpID8gLTEgOiBpc1JlZ0V4cChhKSA/ICsxIDogYi5sZW5ndGggLSBhLmxlbmd0aFxuICAgIH0pXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvUnVsZXMoc3BlYykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNwZWMpID8gYXJyYXlUb1J1bGVzKHNwZWMpIDogb2JqZWN0VG9SdWxlcyhzcGVjKVxuICB9XG5cbiAgdmFyIGRlZmF1bHRFcnJvclJ1bGUgPSBydWxlT3B0aW9ucygnZXJyb3InLCB7bGluZUJyZWFrczogdHJ1ZSwgc2hvdWxkVGhyb3c6IHRydWV9KVxuICBmdW5jdGlvbiBjb21waWxlUnVsZXMocnVsZXMsIGhhc1N0YXRlcykge1xuICAgIHZhciBlcnJvclJ1bGUgPSBudWxsXG4gICAgdmFyIGZhc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdmFyIGZhc3RBbGxvd2VkID0gdHJ1ZVxuICAgIHZhciB1bmljb2RlRmxhZyA9IG51bGxcbiAgICB2YXIgZ3JvdXBzID0gW11cbiAgICB2YXIgcGFydHMgPSBbXVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBmYWxsYmFjayBydWxlLCB0aGVuIGRpc2FibGUgZmFzdCBtYXRjaGluZ1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChydWxlc1tpXS5mYWxsYmFjaykge1xuICAgICAgICBmYXN0QWxsb3dlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBydWxlc1tpXVxuXG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIC8vIGFsbCB2YWxpZCBpbmNsdXNpb25zIGFyZSByZW1vdmVkIGJ5IHN0YXRlcygpIHByZXByb2Nlc3NvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaGVyaXRhbmNlIGlzIG5vdCBhbGxvd2VkIGluIHN0YXRlbGVzcyBsZXhlcnMnKVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5lcnJvciB8fCBvcHRpb25zLmZhbGxiYWNrKSB7XG4gICAgICAgIC8vIGVycm9yUnVsZSBjYW4gb25seSBiZSBzZXQgb25jZVxuICAgICAgICBpZiAoZXJyb3JSdWxlKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmZhbGxiYWNrID09PSAhZXJyb3JSdWxlLmZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBcIiArIChvcHRpb25zLmZhbGxiYWNrID8gXCJmYWxsYmFja1wiIDogXCJlcnJvclwiKSArIFwiIHJ1bGVzIG5vdCBhbGxvd2VkIChmb3IgdG9rZW4gJ1wiICsgb3B0aW9ucy5kZWZhdWx0VHlwZSArIFwiJylcIilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFsbGJhY2sgYW5kIGVycm9yIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgKGZvciB0b2tlbiAnXCIgKyBvcHRpb25zLmRlZmF1bHRUeXBlICsgXCInKVwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvclJ1bGUgPSBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2guc2xpY2UoKVxuICAgICAgaWYgKGZhc3RBbGxvd2VkKSB7XG4gICAgICAgIHdoaWxlIChtYXRjaC5sZW5ndGggJiYgdHlwZW9mIG1hdGNoWzBdID09PSAnc3RyaW5nJyAmJiBtYXRjaFswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YXIgd29yZCA9IG1hdGNoLnNoaWZ0KClcbiAgICAgICAgICBmYXN0W3dvcmQuY2hhckNvZGVBdCgwKV0gPSBvcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2FybiBhYm91dCBpbmFwcHJvcHJpYXRlIHN0YXRlLXN3aXRjaGluZyBvcHRpb25zXG4gICAgICBpZiAob3B0aW9ucy5wb3AgfHwgb3B0aW9ucy5wdXNoIHx8IG9wdGlvbnMubmV4dCkge1xuICAgICAgICBpZiAoIWhhc1N0YXRlcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlLXN3aXRjaGluZyBvcHRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBzdGF0ZWxlc3MgbGV4ZXJzIChmb3IgdG9rZW4gJ1wiICsgb3B0aW9ucy5kZWZhdWx0VHlwZSArIFwiJylcIilcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlLXN3aXRjaGluZyBvcHRpb25zIGFyZSBub3QgYWxsb3dlZCBvbiBmYWxsYmFjayB0b2tlbnMgKGZvciB0b2tlbiAnXCIgKyBvcHRpb25zLmRlZmF1bHRUeXBlICsgXCInKVwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgcnVsZXMgd2l0aCBhIC5tYXRjaCBhcmUgaW5jbHVkZWQgaW4gdGhlIFJlZ0V4cFxuICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZmFzdEFsbG93ZWQgPSBmYWxzZVxuXG4gICAgICBncm91cHMucHVzaChvcHRpb25zKVxuXG4gICAgICAvLyBDaGVjayB1bmljb2RlIGZsYWcgaXMgdXNlZCBldmVyeXdoZXJlIG9yIG5vd2hlcmVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2gubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IG1hdGNoW2pdXG4gICAgICAgIGlmICghaXNSZWdFeHAob2JqKSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5pY29kZUZsYWcgPT09IG51bGwpIHtcbiAgICAgICAgICB1bmljb2RlRmxhZyA9IG9iai51bmljb2RlXG4gICAgICAgIH0gZWxzZSBpZiAodW5pY29kZUZsYWcgIT09IG9iai51bmljb2RlICYmIG9wdGlvbnMuZmFsbGJhY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiBvbmUgcnVsZSBpcyAvdSB0aGVuIGFsbCBtdXN0IGJlJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IHRvIFJlZ0V4cFxuICAgICAgdmFyIHBhdCA9IHJlVW5pb24obWF0Y2gubWFwKHJlZ2V4cE9yTGl0ZXJhbCkpXG5cbiAgICAgIC8vIHZhbGlkYXRlXG4gICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXQpXG4gICAgICBpZiAocmVnZXhwLnRlc3QoXCJcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnRXhwIG1hdGNoZXMgZW1wdHkgc3RyaW5nOiBcIiArIHJlZ2V4cClcbiAgICAgIH1cbiAgICAgIHZhciBncm91cENvdW50ID0gcmVHcm91cHMocGF0KVxuICAgICAgaWYgKGdyb3VwQ291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ0V4cCBoYXMgY2FwdHVyZSBncm91cHM6IFwiICsgcmVnZXhwICsgXCJcXG5Vc2UgKD86IOKApiApIGluc3RlYWRcIilcbiAgICAgIH1cblxuICAgICAgLy8gdHJ5IGFuZCBkZXRlY3QgcnVsZXMgbWF0Y2hpbmcgbmV3bGluZXNcbiAgICAgIGlmICghb3B0aW9ucy5saW5lQnJlYWtzICYmIHJlZ2V4cC50ZXN0KCdcXG4nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGUgc2hvdWxkIGRlY2xhcmUgbGluZUJyZWFrczogJyArIHJlZ2V4cClcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgcmVnZXhcbiAgICAgIHBhcnRzLnB1c2gocmVDYXB0dXJlKHBhdCkpXG4gICAgfVxuXG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGZhbGxiYWNrIHJ1bGUsIHVzZSB0aGUgc3RpY2t5IGZsYWcgc28gd2Ugb25seSBsb29rIGZvclxuICAgIC8vIG1hdGNoZXMgYXQgdGhlIGN1cnJlbnQgaW5kZXguXG4gICAgLy9cbiAgICAvLyBJZiB3ZSBkb24ndCBzdXBwb3J0IHRoZSBzdGlja3kgZmxhZywgdGhlbiBmYWtlIGl0IHVzaW5nIGFuIGlycmVmdXRhYmxlXG4gICAgLy8gbWF0Y2ggKGkuZS4gYW4gZW1wdHkgcGF0dGVybikuXG4gICAgdmFyIGZhbGxiYWNrUnVsZSA9IGVycm9yUnVsZSAmJiBlcnJvclJ1bGUuZmFsbGJhY2tcbiAgICB2YXIgZmxhZ3MgPSBoYXNTdGlja3kgJiYgIWZhbGxiYWNrUnVsZSA/ICd5bScgOiAnZ20nXG4gICAgdmFyIHN1ZmZpeCA9IGhhc1N0aWNreSB8fCBmYWxsYmFja1J1bGUgPyAnJyA6ICd8J1xuXG4gICAgaWYgKHVuaWNvZGVGbGFnID09PSB0cnVlKSBmbGFncyArPSBcInVcIlxuICAgIHZhciBjb21iaW5lZCA9IG5ldyBSZWdFeHAocmVVbmlvbihwYXJ0cykgKyBzdWZmaXgsIGZsYWdzKVxuICAgIHJldHVybiB7cmVnZXhwOiBjb21iaW5lZCwgZ3JvdXBzOiBncm91cHMsIGZhc3Q6IGZhc3QsIGVycm9yOiBlcnJvclJ1bGUgfHwgZGVmYXVsdEVycm9yUnVsZX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUocnVsZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGlsZVJ1bGVzKHRvUnVsZXMocnVsZXMpKVxuICAgIHJldHVybiBuZXcgTGV4ZXIoe3N0YXJ0OiByZXN1bHR9LCAnc3RhcnQnKVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tTdGF0ZUdyb3VwKGcsIG5hbWUsIG1hcCkge1xuICAgIHZhciBzdGF0ZSA9IGcgJiYgKGcucHVzaCB8fCBnLm5leHQpXG4gICAgaWYgKHN0YXRlICYmICFtYXBbc3RhdGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0YXRlICdcIiArIHN0YXRlICsgXCInIChpbiB0b2tlbiAnXCIgKyBnLmRlZmF1bHRUeXBlICsgXCInIG9mIHN0YXRlICdcIiArIG5hbWUgKyBcIicpXCIpXG4gICAgfVxuICAgIGlmIChnICYmIGcucG9wICYmICtnLnBvcCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9wIG11c3QgYmUgMSAoaW4gdG9rZW4gJ1wiICsgZy5kZWZhdWx0VHlwZSArIFwiJyBvZiBzdGF0ZSAnXCIgKyBuYW1lICsgXCInKVwiKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjb21waWxlU3RhdGVzKHN0YXRlcywgc3RhcnQpIHtcbiAgICB2YXIgYWxsID0gc3RhdGVzLiRhbGwgPyB0b1J1bGVzKHN0YXRlcy4kYWxsKSA6IFtdXG4gICAgZGVsZXRlIHN0YXRlcy4kYWxsXG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlcylcbiAgICBpZiAoIXN0YXJ0KSBzdGFydCA9IGtleXNbMF1cblxuICAgIHZhciBydWxlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIHJ1bGVNYXBba2V5XSA9IHRvUnVsZXMoc3RhdGVzW2tleV0pLmNvbmNhdChhbGwpXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIHZhciBydWxlcyA9IHJ1bGVNYXBba2V5XVxuICAgICAgdmFyIGluY2x1ZGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2pdXG4gICAgICAgIGlmICghcnVsZS5pbmNsdWRlKSBjb250aW51ZVxuICAgICAgICB2YXIgc3BsaWNlID0gW2osIDFdXG4gICAgICAgIGlmIChydWxlLmluY2x1ZGUgIT09IGtleSAmJiAhaW5jbHVkZWRbcnVsZS5pbmNsdWRlXSkge1xuICAgICAgICAgIGluY2x1ZGVkW3J1bGUuaW5jbHVkZV0gPSB0cnVlXG4gICAgICAgICAgdmFyIG5ld1J1bGVzID0gcnVsZU1hcFtydWxlLmluY2x1ZGVdXG4gICAgICAgICAgaWYgKCFuZXdSdWxlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluY2x1ZGUgbm9uZXhpc3RlbnQgc3RhdGUgJ1wiICsgcnVsZS5pbmNsdWRlICsgXCInIChpbiBzdGF0ZSAnXCIgKyBrZXkgKyBcIicpXCIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmV3UnVsZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdSdWxlID0gbmV3UnVsZXNba11cbiAgICAgICAgICAgIGlmIChydWxlcy5pbmRleE9mKG5ld1J1bGUpICE9PSAtMSkgY29udGludWVcbiAgICAgICAgICAgIHNwbGljZS5wdXNoKG5ld1J1bGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1bGVzLnNwbGljZS5hcHBseShydWxlcywgc3BsaWNlKVxuICAgICAgICBqLS1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIG1hcFtrZXldID0gY29tcGlsZVJ1bGVzKHJ1bGVNYXBba2V5XSwgdHJ1ZSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0ga2V5c1tpXVxuICAgICAgdmFyIHN0YXRlID0gbWFwW25hbWVdXG4gICAgICB2YXIgZ3JvdXBzID0gc3RhdGUuZ3JvdXBzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGVja1N0YXRlR3JvdXAoZ3JvdXBzW2pdLCBuYW1lLCBtYXApXG4gICAgICB9XG4gICAgICB2YXIgZmFzdEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdGF0ZS5mYXN0KVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmYXN0S2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGVja1N0YXRlR3JvdXAoc3RhdGUuZmFzdFtmYXN0S2V5c1tqXV0sIG5hbWUsIG1hcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExleGVyKG1hcCwgc3RhcnQpXG4gIH1cblxuICBmdW5jdGlvbiBrZXl3b3JkVHJhbnNmb3JtKG1hcCkge1xuICAgIHZhciByZXZlcnNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHZhciBieUxlbmd0aCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB2YXIgdHlwZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXApXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuVHlwZSA9IHR5cGVzW2ldXG4gICAgICB2YXIgaXRlbSA9IG1hcFt0b2tlblR5cGVdXG4gICAgICB2YXIga2V5d29yZExpc3QgPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXVxuICAgICAga2V5d29yZExpc3QuZm9yRWFjaChmdW5jdGlvbihrZXl3b3JkKSB7XG4gICAgICAgIChieUxlbmd0aFtrZXl3b3JkLmxlbmd0aF0gPSBieUxlbmd0aFtrZXl3b3JkLmxlbmd0aF0gfHwgW10pLnB1c2goa2V5d29yZClcbiAgICAgICAgaWYgKHR5cGVvZiBrZXl3b3JkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXdvcmQgbXVzdCBiZSBzdHJpbmcgKGluIGtleXdvcmQgJ1wiICsgdG9rZW5UeXBlICsgXCInKVwiKVxuICAgICAgICB9XG4gICAgICAgIHJldmVyc2VNYXBba2V5d29yZF0gPSB0b2tlblR5cGVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gZmFzdCBzdHJpbmcgbG9va3VwXG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3N0cmluZy1sb29rdXBzXG4gICAgZnVuY3Rpb24gc3RyKHgpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpIH1cbiAgICB2YXIgc291cmNlID0gJydcbiAgICBzb3VyY2UgKz0gJ3N3aXRjaCAodmFsdWUubGVuZ3RoKSB7XFxuJ1xuICAgIGZvciAodmFyIGxlbmd0aCBpbiBieUxlbmd0aCkge1xuICAgICAgdmFyIGtleXdvcmRzID0gYnlMZW5ndGhbbGVuZ3RoXVxuICAgICAgc291cmNlICs9ICdjYXNlICcgKyBsZW5ndGggKyAnOlxcbidcbiAgICAgIHNvdXJjZSArPSAnc3dpdGNoICh2YWx1ZSkge1xcbidcbiAgICAgIGtleXdvcmRzLmZvckVhY2goZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW5UeXBlID0gcmV2ZXJzZU1hcFtrZXl3b3JkXVxuICAgICAgICBzb3VyY2UgKz0gJ2Nhc2UgJyArIHN0cihrZXl3b3JkKSArICc6IHJldHVybiAnICsgc3RyKHRva2VuVHlwZSkgKyAnXFxuJ1xuICAgICAgfSlcbiAgICAgIHNvdXJjZSArPSAnfVxcbidcbiAgICB9XG4gICAgc291cmNlICs9ICd9XFxuJ1xuICAgIHJldHVybiBGdW5jdGlvbigndmFsdWUnLCBzb3VyY2UpIC8vIHR5cGVcbiAgfVxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgdmFyIExleGVyID0gZnVuY3Rpb24oc3RhdGVzLCBzdGF0ZSkge1xuICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXRlXG4gICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXNcbiAgICB0aGlzLmJ1ZmZlciA9ICcnXG4gICAgdGhpcy5zdGFjayA9IFtdXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkYXRhLCBpbmZvKSB7XG4gICAgdGhpcy5idWZmZXIgPSBkYXRhIHx8ICcnXG4gICAgdGhpcy5pbmRleCA9IDBcbiAgICB0aGlzLmxpbmUgPSBpbmZvID8gaW5mby5saW5lIDogMVxuICAgIHRoaXMuY29sID0gaW5mbyA/IGluZm8uY29sIDogMVxuICAgIHRoaXMucXVldWVkVG9rZW4gPSBpbmZvID8gaW5mby5xdWV1ZWRUb2tlbiA6IG51bGxcbiAgICB0aGlzLnF1ZXVlZFRocm93ID0gaW5mbyA/IGluZm8ucXVldWVkVGhyb3cgOiBudWxsXG4gICAgdGhpcy5zZXRTdGF0ZShpbmZvID8gaW5mby5zdGF0ZSA6IHRoaXMuc3RhcnRTdGF0ZSlcbiAgICB0aGlzLnN0YWNrID0gaW5mbyAmJiBpbmZvLnN0YWNrID8gaW5mby5zdGFjay5zbGljZSgpIDogW11cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgY29sOiB0aGlzLmNvbCxcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2suc2xpY2UoKSxcbiAgICAgIHF1ZXVlZFRva2VuOiB0aGlzLnF1ZXVlZFRva2VuLFxuICAgICAgcXVldWVkVGhyb3c6IHRoaXMucXVldWVkVGhyb3csXG4gICAgfVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlIHx8IHRoaXMuc3RhdGUgPT09IHN0YXRlKSByZXR1cm5cbiAgICB0aGlzLnN0YXRlID0gc3RhdGVcbiAgICB2YXIgaW5mbyA9IHRoaXMuc3RhdGVzW3N0YXRlXVxuICAgIHRoaXMuZ3JvdXBzID0gaW5mby5ncm91cHNcbiAgICB0aGlzLmVycm9yID0gaW5mby5lcnJvclxuICAgIHRoaXMucmUgPSBpbmZvLnJlZ2V4cFxuICAgIHRoaXMuZmFzdCA9IGluZm8uZmFzdFxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLnBvcFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnN0YWNrLnBvcCgpKVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUpXG4gICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIHZhciBlYXQgPSBoYXNTdGlja3kgPyBmdW5jdGlvbihyZSwgYnVmZmVyKSB7IC8vIGFzc3VtZSByZSBpcyAveVxuICAgIHJldHVybiByZS5leGVjKGJ1ZmZlcilcbiAgfSA6IGZ1bmN0aW9uKHJlLCBidWZmZXIpIHsgLy8gYXNzdW1lIHJlIGlzIC9nXG4gICAgdmFyIG1hdGNoID0gcmUuZXhlYyhidWZmZXIpXG4gICAgLy8gd2lsbCBhbHdheXMgbWF0Y2gsIHNpbmNlIHdlIHVzZWQgdGhlIHwoPzopIHRyaWNrXG4gICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUuX2dldEdyb3VwID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICB2YXIgZ3JvdXBDb3VudCA9IHRoaXMuZ3JvdXBzLmxlbmd0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSsrKSB7XG4gICAgICBpZiAobWF0Y2hbaSArIDFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzW2ldXG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgdG9rZW4gdHlwZSBmb3IgbWF0Y2hlZCB0ZXh0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuVG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleFxuXG4gICAgLy8gSWYgYSBmYWxsYmFjayB0b2tlbiBtYXRjaGVkLCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJ1biB0aGUgUmVnRXhwXG4gICAgaWYgKHRoaXMucXVldWVkR3JvdXApIHtcbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuX3Rva2VuKHRoaXMucXVldWVkR3JvdXAsIHRoaXMucXVldWVkVGV4dCwgaW5kZXgpXG4gICAgICB0aGlzLnF1ZXVlZEdyb3VwID0gbnVsbFxuICAgICAgdGhpcy5xdWV1ZWRUZXh0ID0gXCJcIlxuICAgICAgcmV0dXJuIHRva2VuXG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyXG4gICAgaWYgKGluZGV4ID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLy8gRU9GXG4gICAgfVxuXG4gICAgLy8gRmFzdCBtYXRjaGluZyBmb3Igc2luZ2xlIGNoYXJhY3RlcnNcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmZhc3RbYnVmZmVyLmNoYXJDb2RlQXQoaW5kZXgpXVxuICAgIGlmIChncm91cCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuKGdyb3VwLCBidWZmZXIuY2hhckF0KGluZGV4KSwgaW5kZXgpXG4gICAgfVxuXG4gICAgLy8gRXhlY3V0ZSBSZWdFeHBcbiAgICB2YXIgcmUgPSB0aGlzLnJlXG4gICAgcmUubGFzdEluZGV4ID0gaW5kZXhcbiAgICB2YXIgbWF0Y2ggPSBlYXQocmUsIGJ1ZmZlcilcblxuICAgIC8vIEVycm9yIHRva2VucyBtYXRjaCB0aGUgcmVtYWluaW5nIGJ1ZmZlclxuICAgIHZhciBlcnJvciA9IHRoaXMuZXJyb3JcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuKGVycm9yLCBidWZmZXIuc2xpY2UoaW5kZXgsIGJ1ZmZlci5sZW5ndGgpLCBpbmRleClcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl9nZXRHcm91cChtYXRjaClcbiAgICB2YXIgdGV4dCA9IG1hdGNoWzBdXG5cbiAgICBpZiAoZXJyb3IuZmFsbGJhY2sgJiYgbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICB0aGlzLnF1ZXVlZEdyb3VwID0gZ3JvdXBcbiAgICAgIHRoaXMucXVldWVkVGV4dCA9IHRleHRcblxuICAgICAgLy8gRmFsbGJhY2sgdG9rZW5zIGNvbnRhaW4gdGhlIHVubWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBidWZmZXJcbiAgICAgIHJldHVybiB0aGlzLl90b2tlbihlcnJvciwgYnVmZmVyLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCksIGluZGV4KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90b2tlbihncm91cCwgdGV4dCwgaW5kZXgpXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUuX3Rva2VuID0gZnVuY3Rpb24oZ3JvdXAsIHRleHQsIG9mZnNldCkge1xuICAgIC8vIGNvdW50IGxpbmUgYnJlYWtzXG4gICAgdmFyIGxpbmVCcmVha3MgPSAwXG4gICAgaWYgKGdyb3VwLmxpbmVCcmVha3MpIHtcbiAgICAgIHZhciBtYXRjaE5MID0gL1xcbi9nXG4gICAgICB2YXIgbmwgPSAxXG4gICAgICBpZiAodGV4dCA9PT0gJ1xcbicpIHtcbiAgICAgICAgbGluZUJyZWFrcyA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChtYXRjaE5MLmV4ZWModGV4dCkpIHsgbGluZUJyZWFrcysrOyBubCA9IG1hdGNoTkwubGFzdEluZGV4IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICB0eXBlOiAodHlwZW9mIGdyb3VwLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgZ3JvdXAudHlwZSh0ZXh0KSkgfHwgZ3JvdXAuZGVmYXVsdFR5cGUsXG4gICAgICB2YWx1ZTogdHlwZW9mIGdyb3VwLnZhbHVlID09PSAnZnVuY3Rpb24nID8gZ3JvdXAudmFsdWUodGV4dCkgOiB0ZXh0LFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHRvU3RyaW5nOiB0b2tlblRvU3RyaW5nLFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBsaW5lQnJlYWtzOiBsaW5lQnJlYWtzLFxuICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgY29sOiB0aGlzLmNvbCxcbiAgICB9XG4gICAgLy8gbmIuIGFkZGluZyBtb3JlIHByb3BzIHRvIHRva2VuIG9iamVjdCB3aWxsIG1ha2UgVjggc2FkIVxuXG4gICAgdmFyIHNpemUgPSB0ZXh0Lmxlbmd0aFxuICAgIHRoaXMuaW5kZXggKz0gc2l6ZVxuICAgIHRoaXMubGluZSArPSBsaW5lQnJlYWtzXG4gICAgaWYgKGxpbmVCcmVha3MgIT09IDApIHtcbiAgICAgIHRoaXMuY29sID0gc2l6ZSAtIG5sICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbCArPSBzaXplXG4gICAgfVxuXG4gICAgLy8gdGhyb3csIGlmIG5vIHJ1bGUgd2l0aCB7ZXJyb3I6IHRydWV9XG4gICAgaWYgKGdyb3VwLnNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvcih0b2tlbiwgXCJpbnZhbGlkIHN5bnRheFwiKSlcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAucG9wKSB0aGlzLnBvcFN0YXRlKClcbiAgICBlbHNlIGlmIChncm91cC5wdXNoKSB0aGlzLnB1c2hTdGF0ZShncm91cC5wdXNoKVxuICAgIGVsc2UgaWYgKGdyb3VwLm5leHQpIHRoaXMuc2V0U3RhdGUoZ3JvdXAubmV4dClcblxuICAgIHJldHVybiB0b2tlblxuICB9XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgIHZhciBMZXhlckl0ZXJhdG9yID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICAgIHRoaXMubGV4ZXIgPSBsZXhlclxuICAgIH1cblxuICAgIExleGVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbiA9IHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICByZXR1cm4ge3ZhbHVlOiB0b2tlbiwgZG9uZTogIXRva2VufVxuICAgIH1cblxuICAgIExleGVySXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgTGV4ZXIucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgTGV4ZXJJdGVyYXRvcih0aGlzKVxuICAgIH1cbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgIC8vIEFuIHVuZGVmaW5lZCB0b2tlbiBpbmRpY2F0ZXMgRU9GXG4gICAgICB2YXIgdGV4dCA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMuaW5kZXgpXG4gICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIG9mZnNldDogdGhpcy5pbmRleCxcbiAgICAgICAgbGluZUJyZWFrczogdGV4dC5pbmRleE9mKCdcXG4nKSA9PT0gLTEgPyAwIDogMSxcbiAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICBjb2w6IHRoaXMuY29sLFxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCB0b2tlbi5vZmZzZXQgLSB0b2tlbi5jb2wgKyAxKVxuICAgIHZhciBlb2wgPSB0b2tlbi5saW5lQnJlYWtzID8gdG9rZW4udGV4dC5pbmRleE9mKCdcXG4nKSA6IHRva2VuLnRleHQubGVuZ3RoXG4gICAgdmFyIGZpcnN0TGluZSA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZyhzdGFydCwgdG9rZW4ub2Zmc2V0ICsgZW9sKVxuICAgIG1lc3NhZ2UgKz0gXCIgYXQgbGluZSBcIiArIHRva2VuLmxpbmUgKyBcIiBjb2wgXCIgKyB0b2tlbi5jb2wgKyBcIjpcXG5cXG5cIlxuICAgIG1lc3NhZ2UgKz0gXCIgIFwiICsgZmlyc3RMaW5lICsgXCJcXG5cIlxuICAgIG1lc3NhZ2UgKz0gXCIgIFwiICsgQXJyYXkodG9rZW4uY29sKS5qb2luKFwiIFwiKSArIFwiXlwiXG4gICAgcmV0dXJuIG1lc3NhZ2VcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTGV4ZXIodGhpcy5zdGF0ZXMsIHRoaXMuc3RhdGUpXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG5cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlOiBjb21waWxlLFxuICAgIHN0YXRlczogY29tcGlsZVN0YXRlcyxcbiAgICBlcnJvcjogT2JqZWN0LmZyZWV6ZSh7ZXJyb3I6IHRydWV9KSxcbiAgICBmYWxsYmFjazogT2JqZWN0LmZyZWV6ZSh7ZmFsbGJhY2s6IHRydWV9KSxcbiAgICBrZXl3b3Jkczoga2V5d29yZFRyYW5zZm9ybSxcbiAgfVxuXG59KSk7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290Lm5lYXJsZXkgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIFJ1bGUobmFtZSwgc3ltYm9scywgcG9zdHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy5pZCA9ICsrUnVsZS5oaWdoZXN0SWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3ltYm9scyA9IHN5bWJvbHM7ICAgICAgICAvLyBhIGxpc3Qgb2YgbGl0ZXJhbCB8IHJlZ2V4IGNsYXNzIHwgbm9udGVybWluYWxcbiAgICAgICAgdGhpcy5wb3N0cHJvY2VzcyA9IHBvc3Rwcm9jZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgUnVsZS5oaWdoZXN0SWQgPSAwO1xuXG4gICAgUnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbih3aXRoQ3Vyc29yQXQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5U3ltYm9sU2VxdWVuY2UgKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmxpdGVyYWwgPyBKU09OLnN0cmluZ2lmeShlLmxpdGVyYWwpIDpcbiAgICAgICAgICAgICAgICAgICBlLnR5cGUgPyAnJScgKyBlLnR5cGUgOiBlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bWJvbFNlcXVlbmNlID0gKHR5cGVvZiB3aXRoQ3Vyc29yQXQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5zeW1ib2xzLm1hcChzdHJpbmdpZnlTeW1ib2xTZXF1ZW5jZSkuam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKCAgIHRoaXMuc3ltYm9scy5zbGljZSgwLCB3aXRoQ3Vyc29yQXQpLm1hcChzdHJpbmdpZnlTeW1ib2xTZXF1ZW5jZSkuam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIOKXjyBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB0aGlzLnN5bWJvbHMuc2xpY2Uod2l0aEN1cnNvckF0KS5tYXAoc3RyaW5naWZ5U3ltYm9sU2VxdWVuY2UpLmpvaW4oJyAnKSAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiIOKGkiBcIiArIHN5bWJvbFNlcXVlbmNlO1xuICAgIH1cblxuXG4gICAgLy8gYSBTdGF0ZSBpcyBhIHJ1bGUgYXQgYSBwb3NpdGlvbiBmcm9tIGEgZ2l2ZW4gc3RhcnRpbmcgcG9pbnQgaW4gdGhlIGlucHV0IHN0cmVhbSAocmVmZXJlbmNlKVxuICAgIGZ1bmN0aW9uIFN0YXRlKHJ1bGUsIGRvdCwgcmVmZXJlbmNlLCB3YW50ZWRCeSkge1xuICAgICAgICB0aGlzLnJ1bGUgPSBydWxlO1xuICAgICAgICB0aGlzLmRvdCA9IGRvdDtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLndhbnRlZEJ5ID0gd2FudGVkQnk7XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRoaXMuZG90ID09PSBydWxlLnN5bWJvbHMubGVuZ3RoO1xuICAgIH1cblxuICAgIFN0YXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyB0aGlzLnJ1bGUudG9TdHJpbmcodGhpcy5kb3QpICsgXCJ9LCBmcm9tOiBcIiArICh0aGlzLnJlZmVyZW5jZSB8fCAwKTtcbiAgICB9O1xuXG4gICAgU3RhdGUucHJvdG90eXBlLm5leHRTdGF0ZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSh0aGlzLnJ1bGUsIHRoaXMuZG90ICsgMSwgdGhpcy5yZWZlcmVuY2UsIHRoaXMud2FudGVkQnkpO1xuICAgICAgICBzdGF0ZS5sZWZ0ID0gdGhpcztcbiAgICAgICAgc3RhdGUucmlnaHQgPSBjaGlsZDtcbiAgICAgICAgaWYgKHN0YXRlLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHN0YXRlLmRhdGEgPSBzdGF0ZS5idWlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuXG4gICAgU3RhdGUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZS5yaWdodC5kYXRhKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIH0gd2hpbGUgKG5vZGUubGVmdCk7XG4gICAgICAgIGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGUucG9zdHByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMucnVsZS5wb3N0cHJvY2Vzcyh0aGlzLmRhdGEsIHRoaXMucmVmZXJlbmNlLCBQYXJzZXIuZmFpbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBDb2x1bW4oZ3JhbW1hciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLndhbnRzID0ge307IC8vIHN0YXRlcyBpbmRleGVkIGJ5IHRoZSBub24tdGVybWluYWwgdGhleSBleHBlY3RcbiAgICAgICAgdGhpcy5zY2FubmFibGUgPSBbXTsgLy8gbGlzdCBvZiBzdGF0ZXMgdGhhdCBleHBlY3QgYSB0b2tlblxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHt9OyAvLyBzdGF0ZXMgdGhhdCBhcmUgbnVsbGFibGVcbiAgICB9XG5cblxuICAgIENvbHVtbi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKG5leHRDb2x1bW4pIHtcbiAgICAgICAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICAgICAgICB2YXIgd2FudHMgPSB0aGlzLndhbnRzO1xuICAgICAgICB2YXIgY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBzdGF0ZXMubGVuZ3RoOyB3KyspIHsgLy8gbmIuIHdlIHB1c2goKSBkdXJpbmcgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbd107XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRhdGEgIT09IFBhcnNlci5mYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YW50ZWRCeSA9IHN0YXRlLndhbnRlZEJ5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gd2FudGVkQnkubGVuZ3RoOyBpLS07ICkgeyAvLyB0aGlzIGxpbmUgaXMgaG90XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHdhbnRlZEJ5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShsZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgbnVsbGFibGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZWZlcmVuY2UgPT09IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBmdXR1cmUgcHJlZGljdG9ycyBvZiB0aGlzIHJ1bGUgZ2V0IGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHAgPSBzdGF0ZS5ydWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jb21wbGV0ZWRbZXhwXSA9IHRoaXMuY29tcGxldGVkW2V4cF0gfHwgW10pLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHNjYW5uYWJsZSBzdGF0ZXNcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5hYmxlLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwcmVkaWN0XG4gICAgICAgICAgICAgICAgaWYgKHdhbnRzW2V4cF0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FudHNbZXhwXS5wdXNoKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkLmhhc093blByb3BlcnR5KGV4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudWxscyA9IGNvbXBsZXRlZFtleHBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IG51bGxzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoc3RhdGUsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbnRzW2V4cF0gPSBbc3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZWRpY3QoZXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb2x1bW4ucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbihleHApIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ncmFtbWFyLmJ5TmFtZVtleHBdIHx8IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcnVsZXNbaV07XG4gICAgICAgICAgICB2YXIgd2FudGVkQnkgPSB0aGlzLndhbnRzW2V4cF07XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBTdGF0ZShyLCAwLCB0aGlzLmluZGV4LCB3YW50ZWRCeSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29sdW1uLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBjb3B5ID0gbGVmdC5uZXh0U3RhdGUocmlnaHQpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKGNvcHkpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gR3JhbW1hcihydWxlcywgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfHwgdGhpcy5ydWxlc1swXS5uYW1lO1xuICAgICAgICB2YXIgYnlOYW1lID0gdGhpcy5ieU5hbWUgPSB7fTtcbiAgICAgICAgdGhpcy5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIGlmICghYnlOYW1lLmhhc093blByb3BlcnR5KHJ1bGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBieU5hbWVbcnVsZS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnlOYW1lW3J1bGUubmFtZV0ucHVzaChydWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU28gd2UgY2FuIGFsbG93IHBhc3NpbmcgKHJ1bGVzLCBzdGFydCkgZGlyZWN0bHkgdG8gUGFyc2VyIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIEdyYW1tYXIuZnJvbUNvbXBpbGVkID0gZnVuY3Rpb24ocnVsZXMsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBsZXhlciA9IHJ1bGVzLkxleGVyO1xuICAgICAgICBpZiAocnVsZXMuUGFyc2VyU3RhcnQpIHtcbiAgICAgICAgICBzdGFydCA9IHJ1bGVzLlBhcnNlclN0YXJ0O1xuICAgICAgICAgIHJ1bGVzID0gcnVsZXMuUGFyc2VyUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gcnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiAobmV3IFJ1bGUoci5uYW1lLCByLnN5bWJvbHMsIHIucG9zdHByb2Nlc3MpKTsgfSk7XG4gICAgICAgIHZhciBnID0gbmV3IEdyYW1tYXIocnVsZXMsIHN0YXJ0KTtcbiAgICAgICAgZy5sZXhlciA9IGxleGVyOyAvLyBuYi4gc3RvcmluZyBsZXhlciBvbiBHcmFtbWFyIGlzIGlmZnksIGJ1dCB1bmF2b2lkYWJsZVxuICAgICAgICByZXR1cm4gZztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIFN0cmVhbUxleGVyKCkge1xuICAgICAgdGhpcy5yZXNldChcIlwiKTtcbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkYXRhLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGRhdGE7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGF0ZSA/IHN0YXRlLmxpbmUgOiAxO1xuICAgICAgICB0aGlzLmxhc3RMaW5lQnJlYWsgPSBzdGF0ZSA/IC1zdGF0ZS5jb2wgOiAwO1xuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgICB0aGlzLmxpbmUgKz0gMTtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUJyZWFrID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IGNofTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgIGNvbDogdGhpcy5pbmRleCAtIHRoaXMubGFzdExpbmVCcmVhayxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbih0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICAvLyBuYi4gdGhpcyBnZXRzIGNhbGxlZCBhZnRlciBjb25zdW1pbmcgdGhlIG9mZmVuZGluZyB0b2tlbixcbiAgICAgICAgLy8gc28gdGhlIGN1bHByaXQgaXMgaW5kZXgtMVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIG5leHRMaW5lQnJlYWsgPSBidWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpZiAobmV4dExpbmVCcmVhayA9PT0gLTEpIG5leHRMaW5lQnJlYWsgPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBidWZmZXIuc3Vic3RyaW5nKHRoaXMubGFzdExpbmVCcmVhaywgbmV4dExpbmVCcmVhaylcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzLmluZGV4IC0gdGhpcy5sYXN0TGluZUJyZWFrO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBhdCBsaW5lIFwiICsgdGhpcy5saW5lICsgXCIgY29sIFwiICsgY29sICsgXCI6XFxuXFxuXCI7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiICBcIiArIGxpbmUgKyBcIlxcblwiXG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiICBcIiArIEFycmF5KGNvbCkuam9pbihcIiBcIikgKyBcIl5cIlxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZSArIFwiIGF0IGluZGV4IFwiICsgKHRoaXMuaW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gUGFyc2VyKHJ1bGVzLCBzdGFydCwgb3B0aW9ucykge1xuICAgICAgICBpZiAocnVsZXMgaW5zdGFuY2VvZiBHcmFtbWFyKSB7XG4gICAgICAgICAgICB2YXIgZ3JhbW1hciA9IHJ1bGVzO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBncmFtbWFyID0gR3JhbW1hci5mcm9tQ29tcGlsZWQocnVsZXMsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuXG4gICAgICAgIC8vIFJlYWQgb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBrZWVwSGlzdG9yeTogZmFsc2UsXG4gICAgICAgICAgICBsZXhlcjogZ3JhbW1hci5sZXhlciB8fCBuZXcgU3RyZWFtTGV4ZXIsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAob3B0aW9ucyB8fCB7fSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dXAgbGV4ZXJcbiAgICAgICAgdGhpcy5sZXhlciA9IHRoaXMub3B0aW9ucy5sZXhlcjtcbiAgICAgICAgdGhpcy5sZXhlclN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFNldHVwIGEgdGFibGVcbiAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBDb2x1bW4oZ3JhbW1hciwgMCk7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGUgPSBbY29sdW1uXTtcblxuICAgICAgICAvLyBJIGNvdWxkIGJlIGV4cGVjdGluZyBhbnl0aGluZy5cbiAgICAgICAgY29sdW1uLndhbnRzW2dyYW1tYXIuc3RhcnRdID0gW107XG4gICAgICAgIGNvbHVtbi5wcmVkaWN0KGdyYW1tYXIuc3RhcnQpO1xuICAgICAgICAvLyBUT0RPIHdoYXQgaWYgc3RhcnQgcnVsZSBpcyBudWxsYWJsZT9cbiAgICAgICAgY29sdW1uLnByb2Nlc3MoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMDsgLy8gdG9rZW4gaW5kZXhcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSByZXNlcnZlZCB0b2tlbiBmb3IgaW5kaWNhdGluZyBhIHBhcnNlIGZhaWxcbiAgICBQYXJzZXIuZmFpbCA9IHt9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5mZWVkID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgdmFyIGxleGVyID0gdGhpcy5sZXhlcjtcbiAgICAgICAgbGV4ZXIucmVzZXQoY2h1bmssIHRoaXMubGV4ZXJTdGF0ZSk7XG5cbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSAodG9rZW4gPSBsZXhlci5uZXh0KCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFkZCBuZXcgc3RhdGVzIHRvIHRhYmxlW2N1cnJlbnQrMV1cbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRhYmxlW3RoaXMuY3VycmVudF07XG5cbiAgICAgICAgICAgIC8vIEdDIHVudXNlZCBzdGF0ZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFibGVbdGhpcy5jdXJyZW50IC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5jdXJyZW50ICsgMTtcbiAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uID0gbmV3IENvbHVtbih0aGlzLmdyYW1tYXIsIG4pO1xuICAgICAgICAgICAgdGhpcy50YWJsZS5wdXNoKG5leHRDb2x1bW4pO1xuXG4gICAgICAgICAgICAvLyBBZHZhbmNlIGFsbCB0b2tlbnMgdGhhdCBleHBlY3QgdGhlIHN5bWJvbFxuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0b2tlbi50ZXh0ICE9PSB1bmRlZmluZWQgPyB0b2tlbi50ZXh0IDogdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsZXhlci5jb25zdHJ1Y3RvciA9PT0gU3RyZWFtTGV4ZXIgPyB0b2tlbi52YWx1ZSA6IHRva2VuO1xuICAgICAgICAgICAgdmFyIHNjYW5uYWJsZSA9IGNvbHVtbi5zY2FubmFibGU7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gc2Nhbm5hYmxlLmxlbmd0aDsgdy0tOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzY2FubmFibGVbd107XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjb25zdW1lIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIC8vIGVpdGhlciByZWdleCBvciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdC50ZXN0ID8gZXhwZWN0LnRlc3QodmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LnR5cGUgPyBleHBlY3QudHlwZSA9PT0gdG9rZW4udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4cGVjdC5saXRlcmFsID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0YXRlLm5leHRTdGF0ZSh7ZGF0YTogdmFsdWUsIHRva2VuOiB0b2tlbiwgaXNUb2tlbjogdHJ1ZSwgcmVmZXJlbmNlOiBuIC0gMX0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29sdW1uLnN0YXRlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV4dCwgZm9yIGVhY2ggb2YgdGhlIHJ1bGVzLCB3ZSBlaXRoZXJcbiAgICAgICAgICAgIC8vIChhKSBjb21wbGV0ZSBpdCwgYW5kIHRyeSB0byBzZWUgaWYgdGhlIHJlZmVyZW5jZSByb3cgZXhwZWN0ZWQgdGhhdFxuICAgICAgICAgICAgLy8gICAgIHJ1bGVcbiAgICAgICAgICAgIC8vIChiKSBwcmVkaWN0IHRoZSBuZXh0IG5vbnRlcm1pbmFsIGl0IGV4cGVjdHMgYnkgYWRkaW5nIHRoYXRcbiAgICAgICAgICAgIC8vICAgICBub250ZXJtaW5hbCdzIHN0YXJ0IHN0YXRlXG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0aW9uLCB3ZSBhbHNvIGtlZXAgdHJhY2sgb2YgcnVsZXMgd2UgaGF2ZSBhbHJlYWR5XG4gICAgICAgICAgICAvLyBhZGRlZFxuXG4gICAgICAgICAgICBuZXh0Q29sdW1uLnByb2Nlc3MoKTtcblxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkLCB0aHJvdyBhbiBlcnJvcjpcbiAgICAgICAgICAgIGlmIChuZXh0Q29sdW1uLnN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzdGF0ZXMgYXQgYWxsISBUaGlzIGlzIG5vdCBnb29kLlxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IodGhpcy5yZXBvcnRFcnJvcih0b2tlbikpO1xuICAgICAgICAgICAgICAgIGVyci5vZmZzZXQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgZXJyLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYXliZSBzYXZlIGxleGVyIHN0YXRlXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICAgIGNvbHVtbi5sZXhlclN0YXRlID0gbGV4ZXIuc2F2ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSBsZXhlci5zYXZlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudGFsbHkga2VlcCB0cmFjayBvZiByZXN1bHRzXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuZmluaXNoKCk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcsIGZvciB3aGF0ZXZlciBpdCdzIHdvcnRoXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHZhciB0b2tlbkRpc3BsYXkgPSAodG9rZW4udHlwZSA/IHRva2VuLnR5cGUgKyBcIiB0b2tlbjogXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRva2VuLnZhbHVlICE9PSB1bmRlZmluZWQgPyB0b2tlbi52YWx1ZSA6IHRva2VuKTtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmxleGVyLmZvcm1hdEVycm9yKHRva2VuLCBcIlN5bnRheCBlcnJvclwiKSk7XG4gICAgICAgIGxpbmVzLnB1c2goJ1VuZXhwZWN0ZWQgJyArIHRva2VuRGlzcGxheSArICcuIEluc3RlYWQsIEkgd2FzIGV4cGVjdGluZyB0byBzZWUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuJyk7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uSW5kZXggPSB0aGlzLnRhYmxlLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uID0gdGhpcy50YWJsZVtsYXN0Q29sdW1uSW5kZXhdO1xuICAgICAgICB2YXIgZXhwZWN0YW50U3RhdGVzID0gbGFzdENvbHVtbi5zdGF0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFN5bWJvbCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U3ltYm9sICYmIHR5cGVvZiBuZXh0U3ltYm9sICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlzcGxheSBhIFwic3RhdGUgc3RhY2tcIiBmb3IgZWFjaCBleHBlY3RhbnQgc3RhdGVcbiAgICAgICAgLy8gLSB3aGljaCBzaG93cyB5b3UgaG93IHRoaXMgc3RhdGUgY2FtZSB0byBiZSwgc3RlcCBieSBzdGVwLlxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGRlcml2YXRpb24sIHdlIG9ubHkgZGlzcGxheSB0aGUgZmlyc3Qgb25lLlxuICAgICAgICB2YXIgc3RhdGVTdGFja3MgPSBleHBlY3RhbnRTdGF0ZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZpcnN0U3RhdGVTdGFjayhzdGF0ZSwgW10pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIC8vIERpc3BsYXkgZWFjaCBzdGF0ZSB0aGF0IGlzIGV4cGVjdGluZyBhIHRlcm1pbmFsIHN5bWJvbCBuZXh0LlxuICAgICAgICBzdGF0ZVN0YWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlU3RhY2spIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlU3RhY2tbMF07XG4gICAgICAgICAgICB2YXIgbmV4dFN5bWJvbCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgdmFyIHN5bWJvbERpc3BsYXkgPSB0aGlzLmdldFN5bWJvbERpc3BsYXkobmV4dFN5bWJvbCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKCdBICcgKyBzeW1ib2xEaXNwbGF5ICsgJyBiYXNlZCBvbjonKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVN0YXRlU3RhY2soc3RhdGVTdGFjaywgbGluZXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5kaXNwbGF5U3RhdGVTdGFjayA9IGZ1bmN0aW9uKHN0YXRlU3RhY2ssIGxpbmVzKSB7XG4gICAgICAgIHZhciBsYXN0RGlzcGxheTtcbiAgICAgICAgdmFyIHNhbWVEaXNwbGF5Q291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0YXRlU3RhY2subGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlU3RhY2tbal07XG4gICAgICAgICAgICB2YXIgZGlzcGxheSA9IHN0YXRlLnJ1bGUudG9TdHJpbmcoc3RhdGUuZG90KTtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5ID09PSBsYXN0RGlzcGxheSkge1xuICAgICAgICAgICAgICAgIHNhbWVEaXNwbGF5Q291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVEaXNwbGF5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJyAgICDirIYg77iOJyArIHNhbWVEaXNwbGF5Q291bnQgKyAnIG1vcmUgbGluZXMgaWRlbnRpY2FsIHRvIHRoaXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FtZURpc3BsYXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnICAgICcgKyBkaXNwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3REaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmdldFN5bWJvbERpc3BsYXkgPSBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ltYm9sO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHN5bWJvbC5saXRlcmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3ltYm9sLmxpdGVyYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgc3ltYm9sIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NoYXJhY3RlciBtYXRjaGluZyAnICsgc3ltYm9sO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgc3ltYm9sLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2wudHlwZSArICcgdG9rZW4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN5bWJvbCB0eXBlOiAnICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEJ1aWxkcyBhIHRoZSBmaXJzdCBzdGF0ZSBzdGFjay4gWW91IGNhbiB0aGluayBvZiBhIHN0YXRlIHN0YWNrIGFzIHRoZSBjYWxsIHN0YWNrXG4gICAgb2YgdGhlIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlciB3aGljaCB0aGUgTmVhcmxleSBwYXJzZSBhbGdvcml0aG0gc2ltdWxhdGVzLlxuICAgIEEgc3RhdGUgc3RhY2sgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGUgb2JqZWN0cy4gV2l0aGluIGFcbiAgICBzdGF0ZSBzdGFjaywgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIGFycmF5IHdpbGwgYmUgdGhlIHN0YXJ0aW5nXG4gICAgc3RhdGUsIHdpdGggZWFjaCBzdWNjZXNzaXZlIGl0ZW0gaW4gdGhlIGFycmF5IGdvaW5nIGZ1cnRoZXIgYmFjayBpbnRvIGhpc3RvcnkuXG5cbiAgICBUaGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGdpdmVuIGEgc3RhcnRpbmcgc3RhdGUgYW5kIGFuIGVtcHR5IGFycmF5IHJlcHJlc2VudGluZ1xuICAgIHRoZSB2aXNpdGVkIHN0YXRlcywgYW5kIGl0IHJldHVybnMgYW4gc2luZ2xlIHN0YXRlIHN0YWNrLlxuXG4gICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLmJ1aWxkRmlyc3RTdGF0ZVN0YWNrID0gZnVuY3Rpb24oc3RhdGUsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaW5kZXhPZihzdGF0ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBjeWNsZSwgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIC8vIHRvIGVsaW1pbmF0ZSB0aGlzIHBhdGggZnJvbSB0aGUgcmVzdWx0cywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBob3cgdG8gZGlzcGxheSBpdCBtZWFuaW5nZnVsbHlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS53YW50ZWRCeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbc3RhdGVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSBzdGF0ZS53YW50ZWRCeVswXTtcbiAgICAgICAgdmFyIGNoaWxkVmlzaXRlZCA9IFtzdGF0ZV0uY29uY2F0KHZpc2l0ZWQpO1xuICAgICAgICB2YXIgY2hpbGRSZXN1bHQgPSB0aGlzLmJ1aWxkRmlyc3RTdGF0ZVN0YWNrKHByZXZTdGF0ZSwgY2hpbGRWaXNpdGVkKTtcbiAgICAgICAgaWYgKGNoaWxkUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXRlXS5jb25jYXQoY2hpbGRSZXN1bHQpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMudGFibGVbdGhpcy5jdXJyZW50XTtcbiAgICAgICAgY29sdW1uLmxleGVyU3RhdGUgPSB0aGlzLmxleGVyU3RhdGU7XG4gICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICB2YXIgaW5kZXggPSBjb2x1bW4uaW5kZXg7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGluZGV4O1xuICAgICAgICB0aGlzLnRhYmxlW2luZGV4XSA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy50YWJsZS5zcGxpY2UoaW5kZXggKyAxKTtcbiAgICAgICAgdGhpcy5sZXhlclN0YXRlID0gY29sdW1uLmxleGVyU3RhdGU7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50YWxseSBrZWVwIHRyYWNrIG9mIHJlc3VsdHNcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5maW5pc2goKTtcbiAgICB9O1xuXG4gICAgLy8gbmIuIGRlcHJlY2F0ZWQ6IHVzZSBzYXZlL3Jlc3RvcmUgaW5zdGVhZCFcbiAgICBQYXJzZXIucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmtlZXBIaXN0b3J5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldCBvcHRpb24gYGtlZXBIaXN0b3J5YCB0byBlbmFibGUgcmV3aW5kaW5nJylcbiAgICAgICAgfVxuICAgICAgICAvLyBuYi4gcmVjYWxsIGNvbHVtbiAodGFibGUpIGluZGljaWVzIGZhbGwgYmV0d2VlbiB0b2tlbiBpbmRpY2llcy5cbiAgICAgICAgLy8gICAgICAgIGNvbCAwICAgLS0gICB0b2tlbiAwICAgLS0gICBjb2wgMVxuICAgICAgICB0aGlzLnJlc3RvcmUodGhpcy50YWJsZVtpbmRleF0pO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHBvc3NpYmxlIHBhcnNpbmdzXG4gICAgICAgIHZhciBjb25zaWRlcmF0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdyYW1tYXIuc3RhcnQ7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRhYmxlW3RoaXMudGFibGUubGVuZ3RoIC0gMV1cbiAgICAgICAgY29sdW1uLnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAodC5ydWxlLm5hbWUgPT09IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICYmIHQuZG90ID09PSB0LnJ1bGUuc3ltYm9scy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgJiYgdC5yZWZlcmVuY2UgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgJiYgdC5kYXRhICE9PSBQYXJzZXIuZmFpbCkge1xuICAgICAgICAgICAgICAgIGNvbnNpZGVyYXRpb25zLnB1c2godCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29uc2lkZXJhdGlvbnMubWFwKGZ1bmN0aW9uKGMpIHtyZXR1cm4gYy5kYXRhOyB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgUGFyc2VyOiBQYXJzZXIsXG4gICAgICAgIEdyYW1tYXI6IEdyYW1tYXIsXG4gICAgICAgIFJ1bGU6IFJ1bGUsXG4gICAgfTtcblxufSkpO1xuIiwiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xNi4xXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciB0aW1lb3V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59KCk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBub2RlIG9mIHRoZSByZWZlcmVuY2Ugb2JqZWN0LCBvciB0aGUgcmVmZXJlbmNlIG9iamVjdCBpdHNlbGYuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlID8gcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgOiByZWZlcmVuY2U7XG59XG5cbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5mdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10pICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuaGVpZ2h0O1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChwYXJlbnROb2RlKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMocG9wcGVyLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDtcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0IHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQgfHwgMCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBwb3BwZXIuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICB2YXIgcG9wcGVyV2lkdGggPSByb3VuZChwb3BwZXIud2lkdGgpO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICB2YXIgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIHZhciBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuXG4gIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5ID8gcm91bmQgOiBmbG9vcjtcbiAgdmFyIHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IHJvdW5kO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kID8gcG9wcGVyLmxlZnQgLSAxIDogcG9wcGVyLmxlZnQpLFxuICAgIHRvcDogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpXG4gIH07XG59XG5cbnZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgLy8gd2hlbiBvZmZzZXRQYXJlbnQgaXMgPGh0bWw+IHRoZSBwb3NpdGlvbmluZyBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gKGV4Y2x1ZGluZyB0aGUgc2Nyb2xsYmFyKVxuICAgIC8vIGFuZCBub3QgdGhlIGJvdHRvbSBvZiB0aGUgaHRtbCBlbGVtZW50XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudC5jbGllbnRXaWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVuY3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiByZWZlcmVuY2UgZWxlbWVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NCb3R0b20gfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NUb3ApO1xuXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgfHwgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudDtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc2V0cyB0aGUgcG9wcGVyJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgZG9jdW1lbnQgc2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBleGNsdWRpbmdcbiAgLy8gdGhlIHNpemUgb2YgdGhlIHBvcHBlciBlbGVtZW50IGl0c2VsZlxuICB2YXIgdHJhbnNmb3JtUHJvcCA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gIHZhciBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICB2YXIgdG9wID0gcG9wcGVyU3R5bGVzLnRvcCxcbiAgICAgIGxlZnQgPSBwb3BwZXJTdHlsZXMubGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXTtcblxuICBwb3BwZXJTdHlsZXMudG9wID0gJyc7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gJyc7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9ICcnO1xuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuXG4gIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QocG9wcGVyKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNb2RpZmllciBmdW5jdGlvbiwgZWFjaCBtb2RpZmllciBjYW4gaGF2ZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSBhc3NpZ25lZFxuICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gKiBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCB1cGRhdGUsIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdFxuICogbWFrZSBzdXJlIHRoZXkgYXJlIHBlcmZvcm1hbnQgZW5vdWdoIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLlxuICpcbiAqIEBmdW5jdGlvbiBNb2RpZmllckZuXG4gKiBAYXJndW1lbnQge2RhdGFPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge2RhdGFPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVycyBhcmUgcGx1Z2lucyB1c2VkIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB5b3VyIHBvcHBlcnMuPGJyIC8+XG4gKiBQb3BwZXIuanMgdXNlcyBhIHNldCBvZiA5IG1vZGlmaWVycyB0byBwcm92aWRlIGFsbCB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzXG4gKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogVXN1YWxseSB5b3UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0aGUgYG9yZGVyYCwgYGZuYCBhbmQgYG9uTG9hZGAgcHJvcHMuXG4gKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAqIEBuYW1lc3BhY2UgbW9kaWZpZXJzXG4gKi9cbnZhciBtb2RpZmllcnMgPSB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgYGhlaWdodGAuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBZb3UgY2FuIHJlYWQgbW9yZSBvbiB0aGlzIGF0IHRoaXMgW2lzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQSBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyLiBUaGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBhbHdheXMgaGFzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIuIENhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlclxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdW5jdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24uXG4gICAgICogVGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zPWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSBwb3BwZXIgZWxlbWVudCBvdmVybGFwcyBpdHMgcmVmZXJlbmNlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2VcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9uIHVzZWQgYnkgUG9wcGVyLmpzLlxuICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIGBvcHRpb25zYCBvYmplY3QsIGFzIHRoZSAzcmQgYXJndW1lbnQuIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudC5cbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWQuXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qcy5cbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIi8qKiFcbiogdGlwcHkuanMgdjUuMi4xXG4qIChjKSAyMDE3LTIwMjAgYXRvbWlrc1xuKiBNSVQgTGljZW5zZVxuKi9cbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjUuMi4xXCI7XG5cbi8qKlxuICogVHJpZ2dlcnMgcmVmbG93XG4gKi9cbmZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gIHZvaWQgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG59XG4vKipcbiAqIFNldHMgdGhlIGlubmVySFRNTCBvZiBhbiBlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0SW5uZXJIVE1MKGVsZW1lbnQsIGh0bWwpIHtcbiAgZWxlbWVudFtpbm5lckhUTUwoKV0gPSBodG1sO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBhIHJlZmVyZW5jZSBlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gaXNSZWZlcmVuY2VFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fdGlwcHkgJiYgdmFsdWUuX3RpcHB5LnJlZmVyZW5jZSA9PT0gdmFsdWUpO1xufVxuLyoqXG4gKiBTYWZlIC5oYXNPd25Qcm9wZXJ0eSBjaGVjaywgZm9yIHByb3RvdHlwZS1sZXNzIG9iamVjdHNcbiAqL1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZWxlbWVudHMgYmFzZWQgb24gdGhlIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gZ2V0QXJyYXlPZkVsZW1lbnRzKHZhbHVlKSB7XG4gIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIFt2YWx1ZV07XG4gIH1cblxuICBpZiAoaXNOb2RlTGlzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgYXQgYSBnaXZlbiBpbmRleCBkZXBlbmRpbmcgb24gaWYgaXQncyBhbiBhcnJheSBvciBudW1iZXJcbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUF0SW5kZXhPclJldHVybih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgdiA9IHZhbHVlW2luZGV4XTtcbiAgICByZXR1cm4gdiA9PSBudWxsID8gQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlW2luZGV4XSA6IGRlZmF1bHRWYWx1ZSA6IHY7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFByZXZlbnRzIGVycm9ycyBmcm9tIGJlaW5nIHRocm93biB3aGlsZSBhY2Nlc3NpbmcgbmVzdGVkIG1vZGlmaWVyIG9iamVjdHNcbiAqIGluIGBwb3BwZXJPcHRpb25zYFxuICovXG5cbmZ1bmN0aW9uIGdldE1vZGlmaWVyKG9iaiwga2V5KSB7XG4gIHJldHVybiBvYmogJiYgb2JqLm1vZGlmaWVycyAmJiBvYmoubW9kaWZpZXJzW2tleV07XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIG9mIHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBpc1R5cGUodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICByZXR1cm4gc3RyLmluZGV4T2YoJ1tvYmplY3QnKSA9PT0gMCAmJiBzdHIuaW5kZXhPZih0eXBlICsgXCJdXCIpID4gLTE7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIG9mIHR5cGUgRWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnRWxlbWVudCcpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBvZiB0eXBlIE5vZGVMaXN0XG4gKi9cblxuZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnTm9kZUxpc3QnKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgb2YgdHlwZSBNb3VzZUV2ZW50XG4gKi9cblxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdNb3VzZUV2ZW50Jyk7XG59XG4vKipcbiAqIEZpcmVmb3ggZXh0ZW5zaW9ucyBkb24ndCBhbGxvdyBzZXR0aW5nIC5pbm5lckhUTUwgZGlyZWN0bHksIHRoaXMgd2lsbCB0cmlja1xuICogaXRcbiAqL1xuXG5mdW5jdGlvbiBpbm5lckhUTUwoKSB7XG4gIHJldHVybiAnaW5uZXJIVE1MJztcbn1cbi8qKlxuICogRXZhbHVhdGVzIGEgZnVuY3Rpb24gaWYgb25lLCBvciByZXR1cm5zIHRoZSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGludm9rZVdpdGhBcmdzT3JSZXR1cm4odmFsdWUsIGFyZ3MpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncykgOiB2YWx1ZTtcbn1cbi8qKlxuICogU2V0cyBhIHBvcHBlckluc3RhbmNlIG1vZGlmaWVyJ3MgcHJvcGVydHkgdG8gYSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHNldE1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBuYW1lLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgbW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBtLm5hbWUgPT09IG5hbWU7XG4gIH0pWzBdW3Byb3BlcnR5XSA9IHZhbHVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBkaXZgIGVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBkaXYoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zaXRpb24gZHVyYXRpb24gdG8gYSBsaXN0IG9mIGVsZW1lbnRzXG4gKi9cblxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkR1cmF0aW9uKGVscywgdmFsdWUpIHtcbiAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB2YWx1ZSArIFwibXNcIjtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBTZXRzIHRoZSB2aXNpYmlsaXR5IHN0YXRlIHRvIGVsZW1lbnRzIHNvIHRoZXkgY2FuIGJlZ2luIHRvIHRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBzZXRWaXNpYmlsaXR5U3RhdGUoZWxzLCBzdGF0ZSkge1xuICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBEZWJvdW5jZSB1dGlsaXR5LiBUbyBhdm9pZCBibG9hdGluZyBidW5kbGUgc2l6ZSwgd2UncmUgb25seSBwYXNzaW5nIDFcbiAqIGFyZ3VtZW50IGhlcmUsIGEgbW9yZSBnZW5lcmljIGZ1bmN0aW9uIHdvdWxkIHBhc3MgYWxsIGFyZ3VtZW50cy4gT25seVxuICogYG9uTW91c2VNb3ZlYCB1c2VzIHRoaXMgd2hpY2ggdGFrZXMgdGhlIGV2ZW50IG9iamVjdCBmb3Igbm93LlxuICovXG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBtcykge1xuICAvLyBBdm9pZCB3cmFwcGluZyBpbiBgc2V0VGltZW91dGAgaWYgbXMgaXMgMCBhbnl3YXlcbiAgaWYgKG1zID09PSAwKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKGFyZyk7XG4gICAgfSwgbXMpO1xuICB9O1xufVxuLyoqXG4gKiBQcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGludm9jYXRpb24gd2hlbiBhbm90aGVyIGZ1bmN0aW9uIHJlcGxhY2VzIGl0XG4gKi9cblxuZnVuY3Rpb24gcHJlc2VydmVJbnZvY2F0aW9uKG9yaWdpbmFsRm4sIGN1cnJlbnRGbiwgYXJncykge1xuICBpZiAob3JpZ2luYWxGbiAmJiBvcmlnaW5hbEZuICE9PSBjdXJyZW50Rm4pIHtcbiAgICBvcmlnaW5hbEZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gIH1cbn1cbi8qKlxuICogRGVsZXRlcyBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0IChwdXJlKVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXMob2JqLCBrZXlzKSB7XG4gIHZhciBjbG9uZSA9IF9leHRlbmRzKHt9LCBvYmopO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIGNsb25lW2tleV07XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIFBvbnlmaWxsIGZvciBBcnJheS5mcm9tIC0gY29udmVydHMgaXRlcmFibGUgdmFsdWVzIHRvIGFuIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gYXJyYXlGcm9tKHZhbHVlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cbi8qKlxuICogV29ya3MgbGlrZSBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0LCBidXQgdXNlcyBhIGNhbGxiYWNrIGluc3RlYWRcbiAqL1xuXG5mdW5jdGlvbiBjbG9zZXN0Q2FsbGJhY2soZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoY2FsbGJhY2soZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBhcnJheSBvciBzdHJpbmcgaW5jbHVkZXMgYSBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBpbmNsdWRlcyhhLCBiKSB7XG4gIHJldHVybiBhLmluZGV4T2YoYikgPiAtMTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHN0cmluZyBvZiB2YWx1ZXMgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2VcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdEJ5U3BhY2VzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgYG5leHRWYWx1ZWAgaWYgYG5leHRWYWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLCBvdGhlcndpc2UgcmV0dXJuc1xuICogYGN1cnJlbnRWYWx1ZWBcbiAqL1xuXG5mdW5jdGlvbiB1c2VJZkRlZmluZWQobmV4dFZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgcmV0dXJuIG5leHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gbmV4dFZhbHVlIDogY3VycmVudFZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHZhbHVlIHRoYXQncyBhbiBhcnJheSBvciBzaW5nbGUgdmFsdWUgdG8gYW4gYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBbXS5jb25jYXQodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvd25lckRvY3VtZW50IG9mIHRoZSBmaXJzdCBhdmFpbGFibGUgZWxlbWVudCwgb3RoZXJ3aXNlIGdsb2JhbFxuICogZG9jdW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KGVsZW1lbnRPckVsZW1lbnRzKSB7XG4gIHZhciBfbm9ybWFsaXplVG9BcnJheSA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudE9yRWxlbWVudHMpLFxuICAgICAgZWxlbWVudCA9IF9ub3JtYWxpemVUb0FycmF5WzBdO1xuXG4gIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50IDogZG9jdW1lbnQ7XG59XG4vKipcbiAqIEFkZHMgaXRlbSB0byBhcnJheSBpZiBhcnJheSBkb2VzIG5vdCBjb250YWluIGl0XG4gKi9cblxuZnVuY3Rpb24gcHVzaElmVW5pcXVlKGFyciwgdmFsdWUpIHtcbiAgaWYgKGFyci5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogQWRkcyBgcHhgIGlmIHZhbHVlIGlzIGEgbnVtYmVyLCBvciByZXR1cm5zIGl0IGRpcmVjdGx5XG4gKi9cblxuZnVuY3Rpb24gYXBwZW5kUHhJZk51bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlICsgXCJweFwiIDogdmFsdWU7XG59XG4vKipcbiAqIEZpbHRlcnMgb3V0IGR1cGxpY2F0ZSBlbGVtZW50cyBpbiBhbiBhcnJheVxuICovXG5cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbiAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgbnVtYmVyIGZyb20gbnVtYmVyIG9yIENTUyB1bml0cyBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBnZXROdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHBhcnNlRmxvYXQodmFsdWUpO1xufVxuLyoqXG4gKiBHZXRzIG51bWJlciBvciBDU1Mgc3RyaW5nIHVuaXRzIGluIHBpeGVscyAoZS5nLiBgMXJlbWAgLT4gMTYpXG4gKi9cblxuZnVuY3Rpb24gZ2V0VW5pdHNJblB4KGRvYywgdmFsdWUpIHtcbiAgdmFyIGlzUmVtID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBpbmNsdWRlcyh2YWx1ZSwgJ3JlbScpO1xuICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByb290Rm9udFNpemUgPSAxNjtcblxuICBpZiAoaHRtbCAmJiBpc1JlbSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoaHRtbCkuZm9udFNpemUgfHwgU3RyaW5nKHJvb3RGb250U2l6ZSkpICogZ2V0TnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBnZXROdW1iZXIodmFsdWUpO1xufVxuLyoqXG4gKiBBZGRzIHRoZSBgZGlzdGFuY2VQeGAgdmFsdWUgdG8gdGhlIHBsYWNlbWVudCBvZiBhIFBvcHBlci5QYWRkaW5nIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkUGFkZGluZyhiYXNlUGxhY2VtZW50LCBwYWRkaW5nLCBkaXN0YW5jZVB4KSB7XG4gIGlmIChwYWRkaW5nID09PSB2b2lkIDApIHtcbiAgICBwYWRkaW5nID0gNTtcbiAgfVxuXG4gIHZhciBmcmVzaFBhZGRpbmdPYmplY3QgPSB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJlc2hQYWRkaW5nT2JqZWN0KTtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIG9ialtrZXldID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInID8gcGFkZGluZyA6IHBhZGRpbmdba2V5XTtcblxuICAgIGlmIChiYXNlUGxhY2VtZW50ID09PSBrZXkpIHtcbiAgICAgIG9ialtrZXldID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInID8gcGFkZGluZyArIGRpc3RhbmNlUHggOiBwYWRkaW5nW2Jhc2VQbGFjZW1lbnRdICsgZGlzdGFuY2VQeDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LCBmcmVzaFBhZGRpbmdPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlMZWFrV2FybmluZyhtZXRob2QpIHtcbiAgdmFyIHR4dCA9IG1ldGhvZCA9PT0gJ2Rlc3Ryb3knID8gJ24gYWxyZWFkeS0nIDogJyAnO1xuICByZXR1cm4gXCJcXG4gICAgXCIgKyBtZXRob2QgKyBcIigpIHdhcyBjYWxsZWQgb24gYVwiICsgdHh0ICsgXCJkZXN0cm95ZWQgaW5zdGFuY2UuIFRoaXMgaXMgYSBuby1vcCBidXRcXG4gICAgaW5kaWNhdGVzIGEgcG90ZW50aWFsIG1lbW9yeSBsZWFrLlxcbiAgXCI7XG59XG5mdW5jdGlvbiBjbGVhbih2YWx1ZSkge1xuICB2YXIgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG4gIHZhciBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShzcGFjZXNBbmRUYWJzLCAnICcpLnJlcGxhY2UobGluZVN0YXJ0V2l0aFNwYWNlcywgJycpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBjbGVhbihcIlxcbiAgJWN0aXBweS5qc1xcblxcbiAgJWNcIiArIGNsZWFuKG1lc3NhZ2UpICsgXCJcXG5cXG4gICVjXFx1RDgzRFxcdURDNzdcXHUyMDBEIFRoaXMgaXMgYSBkZXZlbG9wbWVudC1vbmx5IG1lc3NhZ2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uLlxcbiAgXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAvLyB0aXRsZVxuICAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4zZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsIC8vIG1lc3NhZ2VcbiAgJ2xpbmUtaGVpZ2h0OiAxLjUnLCAvLyBmb290ZXJcbiAgJ2NvbG9yOiAjYTZhMDk1OyddO1xufVxuLyoqXG4gKiBIZWxwZnVsIHdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLndhcm4oKWAuXG4gKiBUT0RPOiBTaG91bGQgd2UgdXNlIGEgY2FjaGUgc28gaXQgb25seSB3YXJucyBhIHNpbmdsZSB0aW1lIGFuZCBub3Qgc3BhbSB0aGVcbiAqIGNvbnNvbGU/IChOZWVkIHRvIGNvbnNpZGVyIGhvdCByZWxvYWRpbmcgYW5kIGludmFsaWRhdGlvbiB0aG91Z2gpLiBDaHJvbWVcbiAqIGFscmVhZHkgYmF0Y2hlcyB3YXJuaW5ncyBhcyB3ZWxsLlxuICovXG5cbmZ1bmN0aW9uIHdhcm5XaGVuKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSkud2Fybi5hcHBseShfY29uc29sZSwgZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cbi8qKlxuICogSGVscGZ1bCB3cmFwcGVyIGFyb3VuZCBgY29uc29sZS5lcnJvcigpYFxuICovXG5cbmZ1bmN0aW9uIGVycm9yV2hlbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHZhciBfY29uc29sZTI7XG5cbiAgICAoX2NvbnNvbGUyID0gY29uc29sZSkuZXJyb3IuYXBwbHkoX2NvbnNvbGUyLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGB0YXJnZXRzYCB2YWx1ZSBwYXNzZWQgdG8gYHRpcHB5KClgXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIGRpZFBhc3NGYWxzeVZhbHVlID0gIXRhcmdldHM7XG4gIHZhciBkaWRQYXNzUGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0cykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICF0YXJnZXRzLmFkZEV2ZW50TGlzdGVuZXI7XG4gIGVycm9yV2hlbihkaWRQYXNzRmFsc3lWYWx1ZSwgWyd0aXBweSgpIHdhcyBwYXNzZWQnLCAnYCcgKyBTdHJpbmcodGFyZ2V0cykgKyAnYCcsICdhcyBpdHMgdGFyZ2V0cyAoZmlyc3QpIGFyZ3VtZW50LiBWYWxpZCB0eXBlcyBhcmU6IFN0cmluZywgRWxlbWVudCwgRWxlbWVudFtdLCcsICdvciBOb2RlTGlzdC4nXS5qb2luKCcgJykpO1xuICBlcnJvcldoZW4oZGlkUGFzc1BsYWluT2JqZWN0LCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCBhIHBsYWluIG9iamVjdCB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFzIGFuIGFyZ3VtZW50LicsICdTZWU6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy9taXNjLyNjdXN0b20tcG9zaXRpb24nXS5qb2luKCcgJykpO1xufVxuXG52YXIgcGx1Z2luUHJvcHMgPSB7XG4gIGFuaW1hdGVGaWxsOiBmYWxzZSxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaW5saW5lUG9zaXRpb25pbmc6IGZhbHNlLFxuICBzdGlja3k6IGZhbHNlXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IF9leHRlbmRzKHtcbiAgYWxsb3dIVE1MOiB0cnVlLFxuICBhbmltYXRpb246ICdmYWRlJyxcbiAgYXBwZW5kVG86IGZ1bmN0aW9uIGFwcGVuZFRvKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9LFxuICBhcmlhOiAnZGVzY3JpYmVkYnknLFxuICBhcnJvdzogdHJ1ZSxcbiAgYm91bmRhcnk6ICdzY3JvbGxQYXJlbnQnLFxuICBjb250ZW50OiAnJyxcbiAgZGVsYXk6IDAsXG4gIGRpc3RhbmNlOiAxMCxcbiAgZHVyYXRpb246IFszMDAsIDI1MF0sXG4gIGZsaXA6IHRydWUsXG4gIGZsaXBCZWhhdmlvcjogJ2ZsaXAnLFxuICBmbGlwT25VcGRhdGU6IGZhbHNlLFxuICBoaWRlT25DbGljazogdHJ1ZSxcbiAgaWdub3JlQXR0cmlidXRlczogZmFsc2UsXG4gIGluZXJ0aWE6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gIGludGVyYWN0aXZlQm9yZGVyOiAyLFxuICBpbnRlcmFjdGl2ZURlYm91bmNlOiAwLFxuICBsYXp5OiB0cnVlLFxuICBtYXhXaWR0aDogMzUwLFxuICBtdWx0aXBsZTogZmFsc2UsXG4gIG9mZnNldDogMCxcbiAgb25BZnRlclVwZGF0ZTogZnVuY3Rpb24gb25BZnRlclVwZGF0ZSgpIHt9LFxuICBvbkJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gb25CZWZvcmVVcGRhdGUoKSB7fSxcbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG4gIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KCkge30sXG4gIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHt9LFxuICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHt9LFxuICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge30sXG4gIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge30sXG4gIG9uU2hvd246IGZ1bmN0aW9uIG9uU2hvd24oKSB7fSxcbiAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoKSB7fSxcbiAgb25VbnRyaWdnZXI6IGZ1bmN0aW9uIG9uVW50cmlnZ2VyKCkge30sXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIHBsdWdpbnM6IFtdLFxuICBwb3BwZXJPcHRpb25zOiB7fSxcbiAgcm9sZTogJ3Rvb2x0aXAnLFxuICBzaG93T25DcmVhdGU6IGZhbHNlLFxuICB0aGVtZTogJycsXG4gIHRvdWNoOiB0cnVlLFxuICB0cmlnZ2VyOiAnbW91c2VlbnRlciBmb2N1cycsXG4gIHRyaWdnZXJUYXJnZXQ6IG51bGwsXG4gIHVwZGF0ZUR1cmF0aW9uOiAwLFxuICB6SW5kZXg6IDk5OTlcbn0sIHBsdWdpblByb3BzKTtcbnZhciBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRQcm9wcyk7XG4vKipcbiAqIElmIHRoZSBzZXRQcm9wcygpIG1ldGhvZCBlbmNvdW50ZXJzIG9uZSBvZiB0aGVzZSwgdGhlIHBvcHBlckluc3RhbmNlIG11c3QgYmVcbiAqIHJlY3JlYXRlZFxuICovXG5cbnZhciBQT1BQRVJfSU5TVEFOQ0VfREVQRU5ERU5DSUVTID0gWydhcnJvdycsICdib3VuZGFyeScsICdkaXN0YW5jZScsICdmbGlwJywgJ2ZsaXBCZWhhdmlvcicsICdmbGlwT25VcGRhdGUnLCAnb2Zmc2V0JywgJ3BsYWNlbWVudCcsICdwb3BwZXJPcHRpb25zJ107XG4vKipcbiAqIE11dGF0ZXMgdGhlIGRlZmF1bHRQcm9wcyBvYmplY3QgYnkgc2V0dGluZyB0aGUgcHJvcHMgc3BlY2lmaWVkXG4gKi9cblxudmFyIHNldERlZmF1bHRQcm9wcyA9IGZ1bmN0aW9uIHNldERlZmF1bHRQcm9wcyhwYXJ0aWFsUHJvcHMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBbXSk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcyk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVmYXVsdFByb3BzW2tleV0gPSBwYXJ0aWFsUHJvcHNba2V5XTtcbiAgfSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGV4dGVuZGVkIHByb3BzIG9iamVjdCBpbmNsdWRpbmcgcGx1Z2luIHByb3BzXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhwYXNzZWRQcm9wcykge1xuICB2YXIgcGx1Z2lucyA9IHBhc3NlZFByb3BzLnBsdWdpbnMgfHwgW107XG4gIHZhciBwbHVnaW5Qcm9wcyA9IHBsdWdpbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsdWdpbikge1xuICAgIHZhciBuYW1lID0gcGx1Z2luLm5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHBsdWdpbi5kZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgYWNjW25hbWVdID0gcGFzc2VkUHJvcHNbbmFtZV0gIT09IHVuZGVmaW5lZCA/IHBhc3NlZFByb3BzW25hbWVdIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBwYXNzZWRQcm9wcywge30sIHBsdWdpblByb3BzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Ygb3B0aW9uYWwgcHJvcHMgZnJvbSBkYXRhLXRpcHB5LSogYXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHBsdWdpbnMpIHtcbiAgdmFyIHByb3BLZXlzID0gcGx1Z2lucyA/IE9iamVjdC5rZXlzKGdldEV4dGVuZGVkUGFzc2VkUHJvcHMoX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywge1xuICAgIHBsdWdpbnM6IHBsdWdpbnNcbiAgfSkpKSA6IGRlZmF1bHRLZXlzO1xuICB2YXIgcHJvcHMgPSBwcm9wS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHZhbHVlQXNTdHJpbmcgPSAocmVmZXJlbmNlLmdldEF0dHJpYnV0ZShcImRhdGEtdGlwcHktXCIgKyBrZXkpIHx8ICcnKS50cmltKCk7XG5cbiAgICBpZiAoIXZhbHVlQXNTdHJpbmcpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjY1trZXldID0gSlNPTi5wYXJzZSh2YWx1ZUFzU3RyaW5nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHByb3BzO1xufVxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIHByb3BzIG9iamVjdCBieSBtZXJnaW5nIGRhdGEgYXR0cmlidXRlcyBhbmQgZGlzYWJsaW5nXG4gKiBjb25mbGljdGluZyBwcm9wcyB3aGVyZSBuZWNlc3NhcnlcbiAqL1xuXG5mdW5jdGlvbiBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMpIHtcbiAgdmFyIG91dCA9IF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNvbnRlbnQ6IGludm9rZVdpdGhBcmdzT3JSZXR1cm4ocHJvcHMuY29udGVudCwgW3JlZmVyZW5jZV0pXG4gIH0sIHByb3BzLmlnbm9yZUF0dHJpYnV0ZXMgPyB7fSA6IGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHByb3BzLnBsdWdpbnMpKTtcblxuICBpZiAob3V0LmludGVyYWN0aXZlKSB7XG4gICAgb3V0LmFyaWEgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHByb3BzIHdpdGggdGhlIHZhbGlkIGBkZWZhdWx0UHJvcHNgIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBwbHVnaW5zKSB7XG4gIGlmIChwYXJ0aWFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHBhcnRpYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gcGFydGlhbFByb3BzW3Byb3BdO1xuICAgIHZhciBkaWRTcGVjaWZ5UGxhY2VtZW50SW5Qb3BwZXJPcHRpb25zID0gcHJvcCA9PT0gJ3BvcHBlck9wdGlvbnMnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgaGFzT3duUHJvcGVydHkodmFsdWUsICdwbGFjZW1lbnQnKTtcbiAgICB2YXIgbm9uUGx1Z2luUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKGRlZmF1bHRQcm9wcywgWydhbmltYXRlRmlsbCcsICdmb2xsb3dDdXJzb3InLCAnaW5saW5lUG9zaXRpb25pbmcnLCAnc3RpY2t5J10pOyAvLyBUaGVzZSBwcm9wcyBoYXZlIGN1c3RvbSB3YXJuaW5nc1xuXG4gICAgdmFyIGN1c3RvbVdhcm5pbmdQcm9wcyA9IFsnYTExeScsICdhcnJvd1R5cGUnLCAnc2hvd09uSW5pdCcsICdzaXplJywgJ3RhcmdldCcsICd0b3VjaEhvbGQnXTtcbiAgICB2YXIgZGlkUGFzc1Vua25vd25Qcm9wID0gIWhhc093blByb3BlcnR5KG5vblBsdWdpblByb3BzLCBwcm9wKSAmJiAhaW5jbHVkZXMoY3VzdG9tV2FybmluZ1Byb3BzLCBwcm9wKTsgLy8gQ2hlY2sgaWYgdGhlIHByb3AgZXhpc3RzIGluIGBwbHVnaW5zYFxuXG4gICAgaWYgKGRpZFBhc3NVbmtub3duUHJvcCkge1xuICAgICAgZGlkUGFzc1Vua25vd25Qcm9wID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLm5hbWUgPT09IHByb3A7XG4gICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgd2FybldoZW4ocHJvcCA9PT0gJ3RhcmdldCcsIFsnVGhlIGB0YXJnZXRgIHByb3Agd2FzIHJlbW92ZWQgaW4gdjUgYW5kIHJlcGxhY2VkIHdpdGggdGhlIGRlbGVnYXRlKCkgYWRkb24nLCAnaW4gb3JkZXIgdG8gY29uc2VydmUgYnVuZGxlIHNpemUuJywgJ1NlZTogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL2FkZG9ucy8jZXZlbnQtZGVsZWdhdGlvbiddLmpvaW4oJyAnKSk7XG4gICAgd2FybldoZW4ocHJvcCA9PT0gJ2ExMXknLCBbJ1RoZSBgYTExeWAgcHJvcCB3YXMgcmVtb3ZlZCBpbiB2NS4gTWFrZSBzdXJlIHRoZSBlbGVtZW50IHlvdSBhcmUgZ2l2aW5nIGEnLCAndGlwcHkgdG8gaXMgbmF0aXZlbHkgZm9jdXNhYmxlLCBzdWNoIGFzIDxidXR0b24+IG9yIDxpbnB1dD4sIG5vdCA8ZGl2PicsICdvciA8c3Bhbj4uJ10uam9pbignICcpKTtcbiAgICB3YXJuV2hlbihwcm9wID09PSAnc2hvd09uSW5pdCcsICdUaGUgYHNob3dPbkluaXRgIHByb3Agd2FzIHJlbmFtZWQgdG8gYHNob3dPbkNyZWF0ZWAgaW4gdjUuJyk7XG4gICAgd2FybldoZW4ocHJvcCA9PT0gJ2Fycm93VHlwZScsIFsnVGhlIGBhcnJvd1R5cGVgIHByb3Agd2FzIHJlbW92ZWQgaW4gdjUgaW4gZmF2b3Igb2Ygb3ZlcmxvYWRpbmcgdGhlIGBhcnJvd2AnLCAncHJvcC4nLCAnXFxuXFxuJywgJ1wicm91bmRcIiBzdHJpbmcgd2FzIHJlcGxhY2VkIHdpdGggaW1wb3J0aW5nIHRoZSBzdHJpbmcgZnJvbSB0aGUgcGFja2FnZS4nLCAnXFxuXFxuJywgXCIqIGltcG9ydCB7cm91bmRBcnJvd30gZnJvbSAndGlwcHkuanMnOyAoRVNNIHZlcnNpb24pXFxuXCIsICcqIGNvbnN0IHtyb3VuZEFycm93fSA9IHRpcHB5OyAoSUlGRSBDRE4gdmVyc2lvbiknLCAnXFxuXFxuJywgJ0JlZm9yZToge2Fycm93OiB0cnVlLCBhcnJvd1R5cGU6IFwicm91bmRcIn1cXG4nLCAnQWZ0ZXI6IHthcnJvdzogcm91bmRBcnJvd31gJ10uam9pbignICcpKTtcbiAgICB3YXJuV2hlbihwcm9wID09PSAndG91Y2hIb2xkJywgWydUaGUgYHRvdWNoSG9sZGAgcHJvcCB3YXMgcmVtb3ZlZCBpbiB2NSBpbiBmYXZvciBvZiBvdmVybG9hZGluZyB0aGUgYHRvdWNoYCcsICdwcm9wLicsICdcXG5cXG4nLCAnQmVmb3JlOiB7dG91Y2hIb2xkOiB0cnVlfVxcbicsICdBZnRlcjoge3RvdWNoOiBcImhvbGRcIn0nXS5qb2luKCcgJykpO1xuICAgIHdhcm5XaGVuKHByb3AgPT09ICdzaXplJywgWydUaGUgYHNpemVgIHByb3Agd2FzIHJlbW92ZWQgaW4gdjUuIEluc3RlYWQsIHVzZSBhIHRoZW1lIHRoYXQgc3BlY2lmaWVzJywgJ0NTUyBwYWRkaW5nIGFuZCBmb250LXNpemUgcHJvcGVydGllcy4nXS5qb2luKCcgJykpO1xuICAgIHdhcm5XaGVuKHByb3AgPT09ICd0aGVtZScgJiYgdmFsdWUgPT09ICdnb29nbGUnLCAnVGhlIGluY2x1ZGVkIHRoZW1lIFwiZ29vZ2xlXCIgd2FzIHJlbmFtZWQgdG8gXCJtYXRlcmlhbFwiIGluIHY1LicpO1xuICAgIHdhcm5XaGVuKGRpZFNwZWNpZnlQbGFjZW1lbnRJblBvcHBlck9wdGlvbnMsIFsnU3BlY2lmeWluZyBwbGFjZW1lbnQgaW4gYHBvcHBlck9wdGlvbnNgIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSB0aGUgYmFzZS1sZXZlbCcsICdgcGxhY2VtZW50YCBwcm9wIGluc3RlYWQuJywgJ1xcblxcbicsICdCZWZvcmU6IHtwb3BwZXJPcHRpb25zOiB7cGxhY2VtZW50OiBcImJvdHRvbVwifX1cXG4nLCAnQWZ0ZXI6IHtwbGFjZW1lbnQ6IFwiYm90dG9tXCJ9J10uam9pbignICcpKTtcbiAgICB3YXJuV2hlbihkaWRQYXNzVW5rbm93blByb3AsIFtcImBcIiArIHByb3AgKyBcImBcIiwgXCJpcyBub3QgYSB2YWxpZCBwcm9wLiBZb3UgbWF5IGhhdmUgc3BlbGxlZCBpdCBpbmNvcnJlY3RseSwgb3IgaWYgaXQncyBhXCIsICdwbHVnaW4sIGZvcmdvdCB0byBwYXNzIGl0IGluIGFuIGFycmF5IGFzIHByb3BzLnBsdWdpbnMuJywgJ1xcblxcbicsICdJbiB2NSwgdGhlIGZvbGxvd2luZyBwcm9wcyB3ZXJlIHR1cm5lZCBpbnRvIHBsdWdpbnM6JywgJ1xcblxcbicsICcqIGFuaW1hdGVGaWxsXFxuJywgJyogZm9sbG93Q3Vyc29yXFxuJywgJyogc3RpY2t5JywgJ1xcblxcbicsICdBbGwgcHJvcHM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy9hbGwtcHJvcHMvXFxuJywgJ1BsdWdpbnM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy9wbHVnaW5zLyddLmpvaW4oJyAnKSk7XG4gIH0pO1xufVxuXG52YXIgUEFTU0lWRSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBST1VORF9BUlJPVyA9ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMTggN1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgN3MyLjAyMS0uMDE1IDUuMjUzLTQuMjE4QzYuNTg0IDEuMDUxIDcuNzk3LjAwNyA5IDBjMS4yMDMtLjAwNyAyLjQxNiAxLjAzNSAzLjc2MSAyLjc4MkMxNi4wMTIgNy4wMDUgMTggNyAxOCA3SDB6XCIvPjwvc3ZnPic7XG52YXIgSU9TX0NMQVNTID0gXCJ0aXBweS1pT1NcIjtcbnZhciBQT1BQRVJfQ0xBU1MgPSBcInRpcHB5LXBvcHBlclwiO1xudmFyIFRPT0xUSVBfQ0xBU1MgPSBcInRpcHB5LXRvb2x0aXBcIjtcbnZhciBDT05URU5UX0NMQVNTID0gXCJ0aXBweS1jb250ZW50XCI7XG52YXIgQkFDS0RST1BfQ0xBU1MgPSBcInRpcHB5LWJhY2tkcm9wXCI7XG52YXIgQVJST1dfQ0xBU1MgPSBcInRpcHB5LWFycm93XCI7XG52YXIgU1ZHX0FSUk9XX0NMQVNTID0gXCJ0aXBweS1zdmctYXJyb3dcIjtcbnZhciBQT1BQRVJfU0VMRUNUT1IgPSBcIi5cIiArIFBPUFBFUl9DTEFTUztcbnZhciBUT09MVElQX1NFTEVDVE9SID0gXCIuXCIgKyBUT09MVElQX0NMQVNTO1xudmFyIENPTlRFTlRfU0VMRUNUT1IgPSBcIi5cIiArIENPTlRFTlRfQ0xBU1M7XG52YXIgQVJST1dfU0VMRUNUT1IgPSBcIi5cIiArIEFSUk9XX0NMQVNTO1xudmFyIFNWR19BUlJPV19TRUxFQ1RPUiA9IFwiLlwiICsgU1ZHX0FSUk9XX0NMQVNTO1xuXG52YXIgY3VycmVudElucHV0ID0ge1xuICBpc1RvdWNoOiBmYWxzZVxufTtcbnZhciBsYXN0TW91c2VNb3ZlVGltZSA9IDA7XG4vKipcbiAqIFdoZW4gYSBgdG91Y2hzdGFydGAgZXZlbnQgaXMgZmlyZWQsIGl0J3MgYXNzdW1lZCB0aGUgdXNlciBpcyB1c2luZyB0b3VjaFxuICogaW5wdXQuIFdlJ2xsIGJpbmQgYSBgbW91c2Vtb3ZlYCBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIG1vdXNlIGlucHV0IGluXG4gKiB0aGUgZnV0dXJlLiBUaGlzIHdheSwgdGhlIGBpc1RvdWNoYCBwcm9wZXJ0eSBpcyBmdWxseSBkeW5hbWljIGFuZCB3aWxsIGhhbmRsZVxuICogaHlicmlkIGRldmljZXMgdGhhdCB1c2UgYSBtaXggb2YgdG91Y2ggKyBtb3VzZSBpbnB1dC5cbiAqL1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hTdGFydCgpIHtcbiAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3VycmVudElucHV0LmlzVG91Y2ggPSB0cnVlO1xuXG4gIGlmICh3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxufVxuLyoqXG4gKiBXaGVuIHR3byBgbW91c2Vtb3ZlYCBldmVudCBhcmUgZmlyZWQgY29uc2VjdXRpdmVseSB3aXRoaW4gMjBtcywgaXQncyBhc3N1bWVkXG4gKiB0aGUgdXNlciBpcyB1c2luZyBtb3VzZSBpbnB1dCBhZ2Fpbi4gYG1vdXNlbW92ZWAgY2FuIGZpcmUgb24gdG91Y2ggZGV2aWNlcyBhc1xuICogd2VsbCwgYnV0IHZlcnkgcmFyZWx5IHRoYXQgcXVpY2tseS5cbiAqL1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKCkge1xuICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgaWYgKG5vdyAtIGxhc3RNb3VzZU1vdmVUaW1lIDwgMjApIHtcbiAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG5cbiAgbGFzdE1vdXNlTW92ZVRpbWUgPSBub3c7XG59XG4vKipcbiAqIFdoZW4gYW4gZWxlbWVudCBpcyBpbiBmb2N1cyBhbmQgaGFzIGEgdGlwcHksIGxlYXZpbmcgdGhlIHRhYi93aW5kb3cgYW5kXG4gKiByZXR1cm5pbmcgY2F1c2VzIGl0IHRvIHNob3cgYWdhaW4uIEZvciBtb3VzZSB1c2VycyB0aGlzIGlzIHVuZXhwZWN0ZWQsIGJ1dFxuICogZm9yIGtleWJvYXJkIHVzZSBpdCBtYWtlcyBzZW5zZS5cbiAqIFRPRE86IGZpbmQgYSBiZXR0ZXIgdGVjaG5pcXVlIHRvIHNvbHZlIHRoaXMgcHJvYmxlbVxuICovXG5cbmZ1bmN0aW9uIG9uV2luZG93Qmx1cigpIHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIGlmIChpc1JlZmVyZW5jZUVsZW1lbnQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBhY3RpdmVFbGVtZW50Ll90aXBweTtcblxuICAgIGlmIChhY3RpdmVFbGVtZW50LmJsdXIgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEFkZHMgdGhlIG5lZWRlZCBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzXG4gKi9cblxuZnVuY3Rpb24gYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb2N1bWVudFRvdWNoU3RhcnQsIF9leHRlbmRzKHt9LCBQQVNTSVZFLCB7XG4gICAgY2FwdHVyZTogdHJ1ZVxuICB9KSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25XaW5kb3dCbHVyKTtcbn1cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgdWEgPSBpc0Jyb3dzZXIgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJyc7XG52YXIgaXNJRSA9IC9NU0lFIHxUcmlkZW50XFwvLy50ZXN0KHVhKTtcbnZhciBpc0lPUyA9IGlzQnJvd3NlciAmJiAvaVBob25lfGlQYWR8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuZnVuY3Rpb24gdXBkYXRlSU9TQ2xhc3MoaXNBZGQpIHtcbiAgdmFyIHNob3VsZEFkZCA9IGlzQWRkICYmIGlzSU9TICYmIGN1cnJlbnRJbnB1dC5pc1RvdWNoO1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdFtzaG91bGRBZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShJT1NfQ0xBU1MpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvcHBlcidzIHBsYWNlbWVudCwgaWdub3Jpbmcgc2hpZnRpbmcgKHRvcC1zdGFydCwgZXRjKVxuICovXG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cbi8qKlxuICogQWRkcyBgZGF0YS1pbmVydGlhYCBhdHRyaWJ1dGVcbiAqL1xuXG5mdW5jdGlvbiBhZGRJbmVydGlhKHRvb2x0aXApIHtcbiAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScsICcnKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBgZGF0YS1pbmVydGlhYCBhdHRyaWJ1dGVcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVJbmVydGlhKHRvb2x0aXApIHtcbiAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScpO1xufVxuLyoqXG4gKiBBZGRzIGludGVyYWN0aXZlLXJlbGF0ZWQgYXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIGFkZEludGVyYWN0aXZlKHRvb2x0aXApIHtcbiAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJhY3RpdmUnLCAnJyk7XG59XG4vKipcbiAqIFJlbW92ZXMgaW50ZXJhY3RpdmUtcmVsYXRlZCBhdHRyaWJ1dGVzXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3RpdmUodG9vbHRpcCkge1xuICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbnRlcmFjdGl2ZScpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50IG9mIGEgdG9vbHRpcFxuICovXG5cbmZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudEVsLCBwcm9wcykge1xuICBpZiAoaXNFbGVtZW50KHByb3BzLmNvbnRlbnQpKSB7XG4gICAgc2V0SW5uZXJIVE1MKGNvbnRlbnRFbCwgJycpO1xuICAgIGNvbnRlbnRFbC5hcHBlbmRDaGlsZChwcm9wcy5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuY29udGVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBrZXkgPSBwcm9wcy5hbGxvd0hUTUwgPyAnaW5uZXJIVE1MJyA6ICd0ZXh0Q29udGVudCc7XG4gICAgY29udGVudEVsW2tleV0gPSBwcm9wcy5jb250ZW50O1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIGEgcG9wcGVyIGVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihwb3BwZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0b29sdGlwOiBwb3BwZXIucXVlcnlTZWxlY3RvcihUT09MVElQX1NFTEVDVE9SKSxcbiAgICBjb250ZW50OiBwb3BwZXIucXVlcnlTZWxlY3RvcihDT05URU5UX1NFTEVDVE9SKSxcbiAgICBhcnJvdzogcG9wcGVyLnF1ZXJ5U2VsZWN0b3IoQVJST1dfU0VMRUNUT1IpIHx8IHBvcHBlci5xdWVyeVNlbGVjdG9yKFNWR19BUlJPV19TRUxFQ1RPUilcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJvdyBlbGVtZW50IGFuZCByZXR1cm5zIGl0XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQXJyb3dFbGVtZW50KGFycm93KSB7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBkaXYoKTtcblxuICBpZiAoYXJyb3cgPT09IHRydWUpIHtcbiAgICBhcnJvd0VsZW1lbnQuY2xhc3NOYW1lID0gQVJST1dfQ0xBU1M7XG4gIH0gZWxzZSB7XG4gICAgYXJyb3dFbGVtZW50LmNsYXNzTmFtZSA9IFNWR19BUlJPV19DTEFTUztcblxuICAgIGlmIChpc0VsZW1lbnQoYXJyb3cpKSB7XG4gICAgICBhcnJvd0VsZW1lbnQuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoYXJyb3dFbGVtZW50LCBhcnJvdyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycm93RWxlbWVudDtcbn1cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgcG9wcGVyIGVsZW1lbnQgYW5kIHJldHVybnMgaXRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVQb3BwZXJFbGVtZW50KGlkLCBwcm9wcykge1xuICB2YXIgcG9wcGVyID0gZGl2KCk7XG4gIHBvcHBlci5jbGFzc05hbWUgPSBQT1BQRVJfQ0xBU1M7XG4gIHBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHBvcHBlci5zdHlsZS50b3AgPSAnMCc7XG4gIHBvcHBlci5zdHlsZS5sZWZ0ID0gJzAnO1xuICB2YXIgdG9vbHRpcCA9IGRpdigpO1xuICB0b29sdGlwLmNsYXNzTmFtZSA9IFRPT0xUSVBfQ0xBU1M7XG4gIHRvb2x0aXAuaWQgPSBcInRpcHB5LVwiICsgaWQ7XG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2hpZGRlbicpO1xuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgdXBkYXRlVGhlbWUodG9vbHRpcCwgJ2FkZCcsIHByb3BzLnRoZW1lKTtcbiAgdmFyIGNvbnRlbnQgPSBkaXYoKTtcbiAgY29udGVudC5jbGFzc05hbWUgPSBDT05URU5UX0NMQVNTO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcblxuICBpZiAocHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICBhZGRJbnRlcmFjdGl2ZSh0b29sdGlwKTtcbiAgfVxuXG4gIGlmIChwcm9wcy5hcnJvdykge1xuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFycm93JywgJycpO1xuICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KHByb3BzLmFycm93KSk7XG4gIH1cblxuICBpZiAocHJvcHMuaW5lcnRpYSkge1xuICAgIGFkZEluZXJ0aWEodG9vbHRpcCk7XG4gIH1cblxuICBzZXRDb250ZW50KGNvbnRlbnQsIHByb3BzKTtcbiAgdG9vbHRpcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgcG9wcGVyLmFwcGVuZENoaWxkKHRvb2x0aXApO1xuICB1cGRhdGVQb3BwZXJFbGVtZW50KHBvcHBlciwgcHJvcHMsIHByb3BzKTtcbiAgcmV0dXJuIHBvcHBlcjtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9wcGVyIGVsZW1lbnQgYmFzZWQgb24gdGhlIG5ldyBwcm9wc1xuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcHBlckVsZW1lbnQocG9wcGVyLCBwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgX2dldENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKSxcbiAgICAgIHRvb2x0aXAgPSBfZ2V0Q2hpbGRyZW4udG9vbHRpcCxcbiAgICAgIGNvbnRlbnQgPSBfZ2V0Q2hpbGRyZW4uY29udGVudCxcbiAgICAgIGFycm93ID0gX2dldENoaWxkcmVuLmFycm93O1xuXG4gIHBvcHBlci5zdHlsZS56SW5kZXggPSAnJyArIG5leHRQcm9wcy56SW5kZXg7XG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsIG5leHRQcm9wcy5hbmltYXRpb24pO1xuICB0b29sdGlwLnN0eWxlLm1heFdpZHRoID0gYXBwZW5kUHhJZk51bWJlcihuZXh0UHJvcHMubWF4V2lkdGgpO1xuXG4gIGlmIChuZXh0UHJvcHMucm9sZSkge1xuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdyb2xlJywgbmV4dFByb3BzLnJvbGUpO1xuICB9IGVsc2Uge1xuICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gIH1cblxuICBpZiAocHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50KSB7XG4gICAgc2V0Q29udGVudChjb250ZW50LCBuZXh0UHJvcHMpO1xuICB9IC8vIGFycm93XG5cblxuICBpZiAoIXByZXZQcm9wcy5hcnJvdyAmJiBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAvLyBmYWxzZSB0byB0cnVlXG4gICAgdG9vbHRpcC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYXJyb3cnLCAnJyk7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzLmFycm93ICYmICFuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAvLyB0cnVlIHRvIGZhbHNlXG4gICAgdG9vbHRpcC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYXJyb3cnKTtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMuYXJyb3cgIT09IG5leHRQcm9wcy5hcnJvdykge1xuICAgIC8vIHRydWUgdG8gJ3JvdW5kJyBvciB2aWNlLXZlcnNhXG4gICAgdG9vbHRpcC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgdG9vbHRpcC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gIH0gLy8gaW50ZXJhY3RpdmVcblxuXG4gIGlmICghcHJldlByb3BzLmludGVyYWN0aXZlICYmIG5leHRQcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgIGFkZEludGVyYWN0aXZlKHRvb2x0aXApO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcy5pbnRlcmFjdGl2ZSAmJiAhbmV4dFByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgcmVtb3ZlSW50ZXJhY3RpdmUodG9vbHRpcCk7XG4gIH0gLy8gaW5lcnRpYVxuXG5cbiAgaWYgKCFwcmV2UHJvcHMuaW5lcnRpYSAmJiBuZXh0UHJvcHMuaW5lcnRpYSkge1xuICAgIGFkZEluZXJ0aWEodG9vbHRpcCk7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzLmluZXJ0aWEgJiYgIW5leHRQcm9wcy5pbmVydGlhKSB7XG4gICAgcmVtb3ZlSW5lcnRpYSh0b29sdGlwKTtcbiAgfSAvLyB0aGVtZVxuXG5cbiAgaWYgKHByZXZQcm9wcy50aGVtZSAhPT0gbmV4dFByb3BzLnRoZW1lKSB7XG4gICAgdXBkYXRlVGhlbWUodG9vbHRpcCwgJ3JlbW92ZScsIHByZXZQcm9wcy50aGVtZSk7XG4gICAgdXBkYXRlVGhlbWUodG9vbHRpcCwgJ2FkZCcsIG5leHRQcm9wcy50aGVtZSk7XG4gIH1cbn1cbi8qKlxuICogQWRkL3JlbW92ZSB0cmFuc2l0aW9uZW5kIGxpc3RlbmVyIGZyb20gdG9vbHRpcFxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcih0b29sdGlwLCBhY3Rpb24sIGxpc3RlbmVyKSB7XG4gIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0b29sdGlwW2FjdGlvbiArICdFdmVudExpc3RlbmVyJ10oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfSk7XG59XG4vKipcbiAqIEFkZHMvcmVtb3ZlcyB0aGVtZSBmcm9tIHRvb2x0aXAncyBjbGFzc0xpc3RcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVUaGVtZSh0b29sdGlwLCBhY3Rpb24sIHRoZW1lKSB7XG4gIHNwbGl0QnlTcGFjZXModGhlbWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0b29sdGlwLmNsYXNzTGlzdFthY3Rpb25dKG5hbWUgKyBcIi10aGVtZVwiKTtcbiAgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIG1vdXNlIGN1cnNvciBpcyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIncyBpbnRlcmFjdGl2ZSBib3JkZXJcbiAqIHJlZ2lvblxuICovXG5cbmZ1bmN0aW9uIGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyKHBvcHBlclRyZWVEYXRhLCBldmVudCkge1xuICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgcmV0dXJuIHBvcHBlclRyZWVEYXRhLmV2ZXJ5KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHBvcHBlclJlY3QgPSBfcmVmLnBvcHBlclJlY3QsXG4gICAgICAgIHRvb2x0aXBSZWN0ID0gX3JlZi50b29sdGlwUmVjdCxcbiAgICAgICAgaW50ZXJhY3RpdmVCb3JkZXIgPSBfcmVmLmludGVyYWN0aXZlQm9yZGVyO1xuICAgIC8vIEdldCBtaW4vbWF4IGJvdW5kcyBvZiBib3RoIHRoZSBwb3BwZXIgYW5kIHRvb2x0aXAgcmVjdHMgZHVlIHRvXG4gICAgLy8gYGRpc3RhbmNlYCBvZmZzZXRcbiAgICB2YXIgbWVyZ2VkUmVjdCA9IHtcbiAgICAgIHRvcDogTWF0aC5taW4ocG9wcGVyUmVjdC50b3AsIHRvb2x0aXBSZWN0LnRvcCksXG4gICAgICByaWdodDogTWF0aC5tYXgocG9wcGVyUmVjdC5yaWdodCwgdG9vbHRpcFJlY3QucmlnaHQpLFxuICAgICAgYm90dG9tOiBNYXRoLm1heChwb3BwZXJSZWN0LmJvdHRvbSwgdG9vbHRpcFJlY3QuYm90dG9tKSxcbiAgICAgIGxlZnQ6IE1hdGgubWluKHBvcHBlclJlY3QubGVmdCwgdG9vbHRpcFJlY3QubGVmdClcbiAgICB9O1xuICAgIHZhciBleGNlZWRzVG9wID0gbWVyZ2VkUmVjdC50b3AgLSBjbGllbnRZID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNCb3R0b20gPSBjbGllbnRZIC0gbWVyZ2VkUmVjdC5ib3R0b20gPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc0xlZnQgPSBtZXJnZWRSZWN0LmxlZnQgLSBjbGllbnRYID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNSaWdodCA9IGNsaWVudFggLSBtZXJnZWRSZWN0LnJpZ2h0ID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgcmV0dXJuIGV4Y2VlZHNUb3AgfHwgZXhjZWVkc0JvdHRvbSB8fCBleGNlZWRzTGVmdCB8fCBleGNlZWRzUmlnaHQ7XG4gIH0pO1xufVxuXG52YXIgaWRDb3VudGVyID0gMTtcbnZhciBtb3VzZU1vdmVMaXN0ZW5lcnMgPSBbXTtcbi8qKlxuICogVXNlZCBieSBgaGlkZUFsbCgpYFxuICovXG5cbnZhciBtb3VudGVkSW5zdGFuY2VzID0gW107XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBUaXBweSBvYmplY3QuIFdlJ3JlIHVzaW5nIGEgY2xvc3VyZSBwYXR0ZXJuIGluc3RlYWQgb2ZcbiAqIGEgY2xhc3Mgc28gdGhhdCB0aGUgZXhwb3NlZCBvYmplY3QgQVBJIGlzIGNsZWFuIHdpdGhvdXQgcHJpdmF0ZSBtZW1iZXJzXG4gKiBwcmVmaXhlZCB3aXRoIGBfYC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKSB7XG4gIHZhciBwcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCB7fSwgZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhwYXNzZWRQcm9wcykpKTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBzaG91bGRuJ3QgaGF2ZSBtdWx0aXBsZSB0aXBweXMsIHJldHVybiBudWxsIGVhcmx5XG5cbiAgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiByZWZlcmVuY2UuX3RpcHB5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyogPT09PT09PT09PT09PT09PT09PT09PT0g8J+UkiBQcml2YXRlIG1lbWJlcnMg8J+UkiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgdmFyIHNob3dUaW1lb3V0O1xuICB2YXIgaGlkZVRpbWVvdXQ7XG4gIHZhciBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZTtcbiAgdmFyIGlzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdmFyIGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuICB2YXIgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgdmFyIHBvcHBlclVwZGF0ZXMgPSAwO1xuICB2YXIgbGFzdFRyaWdnZXJFdmVudDtcbiAgdmFyIGN1cnJlbnRNb3VudENhbGxiYWNrO1xuICB2YXIgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcjtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgcHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gIHZhciBjdXJyZW50VGFyZ2V0OyAvLyBTdXBwb3J0IGlmcmFtZSBjb250ZXh0c1xuICAvLyBTdGF0aWMgY2hlY2sgdGhhdCBhc3N1bWVzIGFueSBvZiB0aGUgYHRyaWdnZXJUYXJnZXRgIG9yIGByZWZlcmVuY2VgXG4gIC8vIG5vZGVzIHdpbGwgbmV2ZXIgY2hhbmdlIGRvY3VtZW50cywgZXZlbiB3aGVuIHRoZXkgYXJlIHVwZGF0ZWRcblxuICB2YXIgZG9jID0gZ2V0T3duZXJEb2N1bWVudChwcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09IPCflJEgUHVibGljIG1lbWJlcnMg8J+UkSA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIHZhciBpZCA9IGlkQ291bnRlcisrO1xuICB2YXIgcG9wcGVyID0gY3JlYXRlUG9wcGVyRWxlbWVudChpZCwgcHJvcHMpO1xuICB2YXIgcG9wcGVyQ2hpbGRyZW4gPSBnZXRDaGlsZHJlbihwb3BwZXIpO1xuICB2YXIgcG9wcGVySW5zdGFuY2UgPSBudWxsO1xuICB2YXIgcGx1Z2lucyA9IHVuaXF1ZShwcm9wcy5wbHVnaW5zKTsgLy8gVGhlc2UgdHdvIGVsZW1lbnRzIGFyZSBzdGF0aWNcblxuICB2YXIgdG9vbHRpcCA9IHBvcHBlckNoaWxkcmVuLnRvb2x0aXAsXG4gICAgICBjb250ZW50ID0gcG9wcGVyQ2hpbGRyZW4uY29udGVudDtcbiAgdmFyIHRyYW5zaXRpb25hYmxlRWxlbWVudHMgPSBbdG9vbHRpcCwgY29udGVudF07XG4gIHZhciBzdGF0ZSA9IHtcbiAgICAvLyBUaGUgY3VycmVudCByZWFsIHBsYWNlbWVudCAoYGRhdGEtcGxhY2VtZW50YCBhdHRyaWJ1dGUpXG4gICAgY3VycmVudFBsYWNlbWVudDogbnVsbCxcbiAgICAvLyBJcyB0aGUgaW5zdGFuY2UgY3VycmVudGx5IGVuYWJsZWQ/XG4gICAgaXNFbmFibGVkOiB0cnVlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgc2hvd2luZyBhbmQgbm90IHRyYW5zaXRpb25pbmcgb3V0P1xuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSBpbnN0YW5jZSBiZWVuIGRlc3Ryb3llZD9cbiAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBtb3VudGVkIHRvIHRoZSBET00/XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIHRpcHB5IGZpbmlzaGVkIHRyYW5zaXRpb25pbmcgaW4/XG4gICAgaXNTaG93bjogZmFsc2VcbiAgfTtcbiAgdmFyIGluc3RhbmNlID0ge1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBpZDogaWQsXG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgcG9wcGVyOiBwb3BwZXIsXG4gICAgcG9wcGVyQ2hpbGRyZW46IHBvcHBlckNoaWxkcmVuLFxuICAgIHBvcHBlckluc3RhbmNlOiBwb3BwZXJJbnN0YW5jZSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIHBsdWdpbnM6IHBsdWdpbnMsXG4gICAgLy8gbWV0aG9kc1xuICAgIGNsZWFyRGVsYXlUaW1lb3V0czogY2xlYXJEZWxheVRpbWVvdXRzLFxuICAgIHNldFByb3BzOiBzZXRQcm9wcyxcbiAgICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICAgIHNob3c6IHNob3csXG4gICAgaGlkZTogaGlkZSxcbiAgICBlbmFibGU6IGVuYWJsZSxcbiAgICBkaXNhYmxlOiBkaXNhYmxlLFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3lcbiAgfTtcbiAgLyogPT09PT09PT09PT09PT09PT09PT0gSW5pdGlhbCBpbnN0YW5jZSBtdXRhdGlvbnMgPT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIHJlZmVyZW5jZS5fdGlwcHkgPSBpbnN0YW5jZTtcbiAgcG9wcGVyLl90aXBweSA9IGluc3RhbmNlO1xuICB2YXIgcGx1Z2luc0hvb2tzID0gcGx1Z2lucy5tYXAoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHJldHVybiBwbHVnaW4uZm4oaW5zdGFuY2UpO1xuICB9KTtcbiAgdmFyIGhhZEFyaWFFeHBhbmRlZEF0dHJpYnV0ZU9uQ3JlYXRlID0gcmVmZXJlbmNlLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICBhZGRMaXN0ZW5lcnNUb1RyaWdnZXJUYXJnZXQoKTtcbiAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgaWYgKCFwcm9wcy5sYXp5KSB7XG4gICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgfVxuXG4gIGludm9rZUhvb2soJ29uQ3JlYXRlJywgW2luc3RhbmNlXSk7XG5cbiAgaWYgKHByb3BzLnNob3dPbkNyZWF0ZSkge1xuICAgIHNjaGVkdWxlU2hvdygpO1xuICB9IC8vIFByZXZlbnQgYSB0aXBweSB3aXRoIGEgZGVsYXkgZnJvbSBoaWRpbmcgaWYgdGhlIGN1cnNvciBsZWZ0IHRoZW4gcmV0dXJuZWRcbiAgLy8gYmVmb3JlIGl0IHN0YXJ0ZWQgaGlkaW5nXG5cblxuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICB9XG4gIH0pO1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBpbmNsdWRlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLCAnbW91c2VlbnRlcicpKSB7XG4gICAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZShldmVudCk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbiAgLyogPT09PT09PT09PT09PT09PT09PT09PT0g8J+UkiBQcml2YXRlIG1ldGhvZHMg8J+UkiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCkge1xuICAgIHZhciB0b3VjaCA9IGluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRvdWNoKSA/IHRvdWNoIDogW3RvdWNoLCAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpIHtcbiAgICByZXR1cm4gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKVswXSA9PT0gJ2hvbGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFRhcmdldCgpIHtcbiAgICByZXR1cm4gY3VycmVudFRhcmdldCB8fCByZWZlcmVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWxheShpc1Nob3cpIHtcbiAgICAvLyBGb3IgdG91Y2ggb3Iga2V5Ym9hcmQgaW5wdXQsIGZvcmNlIGAwYCBkZWxheSBmb3IgVVggcmVhc29uc1xuICAgIC8vIEFsc28gaWYgdGhlIGluc3RhbmNlIGlzIG1vdW50ZWQgYnV0IG5vdCB2aXNpYmxlICh0cmFuc2l0aW9uaW5nIG91dCksXG4gICAgLy8gaWdub3JlIGRlbGF5XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlIHx8IGN1cnJlbnRJbnB1dC5pc1RvdWNoIHx8IGxhc3RUcmlnZ2VyRXZlbnQgJiYgbGFzdFRyaWdnZXJFdmVudC50eXBlID09PSAnZm9jdXMnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZGVsYXksIGlzU2hvdyA/IDAgOiAxLCBkZWZhdWx0UHJvcHMuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSG9vayhob29rLCBhcmdzLCBzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICBpZiAoc2hvdWxkSW52b2tlUHJvcHNIb29rID09PSB2b2lkIDApIHtcbiAgICAgIHNob3VsZEludm9rZVByb3BzSG9vayA9IHRydWU7XG4gICAgfVxuXG4gICAgcGx1Z2luc0hvb2tzLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbkhvb2tzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkocGx1Z2luSG9va3MsIGhvb2spKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGx1Z2luSG9va3NbaG9va10uYXBwbHkocGx1Z2luSG9va3MsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwcm9wcztcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgKF9pbnN0YW5jZSRwcm9wcyA9IGluc3RhbmNlLnByb3BzKVtob29rXS5hcHBseShfaW5zdGFuY2UkcHJvcHMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFEZXNjcmliZWRCeUF0dHJpYnV0ZSgpIHtcbiAgICB2YXIgYXJpYSA9IGluc3RhbmNlLnByb3BzLmFyaWE7XG5cbiAgICBpZiAoIWFyaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXR0ciA9IFwiYXJpYS1cIiArIGFyaWE7XG4gICAgdmFyIGlkID0gdG9vbHRpcC5pZDtcbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgY3VycmVudFZhbHVlID8gY3VycmVudFZhbHVlICsgXCIgXCIgKyBpZCA6IGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLnJlcGxhY2UoaWQsICcnKS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIG5leHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIGBhcmlhLWV4cGFuZGVkYCBvbiB0aGVpciByZWZlcmVuY2Ugd2hlbiB0aGVcbiAgICAvLyBpbnN0YW5jZSB3YXMgY3JlYXRlZCwgd2UgaGF2ZSB0byBhc3N1bWUgdGhleSdyZSBjb250cm9sbGluZyBpdCBleHRlcm5hbGx5XG4gICAgLy8gdGhlbXNlbHZlc1xuICAgIGlmIChoYWRBcmlhRXhwYW5kZWRBdHRyaWJ1dGVPbkNyZWF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBub2RlID09PSBnZXRDdXJyZW50VGFyZ2V0KCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpIHtcbiAgICBkb2MuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgc2NoZWR1bGVIaWRlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIG1vdXNlTW92ZUxpc3RlbmVycyA9IG1vdXNlTW92ZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIgIT09IGRlYm91bmNlZE9uTW91c2VNb3ZlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Eb2N1bWVudE1vdXNlRG93bihldmVudCkge1xuICAgIC8vIENsaWNrZWQgb24gaW50ZXJhY3RpdmUgcG9wcGVyXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIHBvcHBlci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGlja2VkIG9uIHRoZSBldmVudCBsaXN0ZW5lcnMgdGFyZ2V0XG5cblxuICAgIGlmIChnZXRDdXJyZW50VGFyZ2V0KCkuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpbmNsdWRlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLCAnY2xpY2snKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSBmYWxzZTtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpOyAvLyBgbW91c2Vkb3duYCBldmVudCBpcyBmaXJlZCByaWdodCBiZWZvcmUgYGZvY3VzYCBpZiBwcmVzc2luZyB0aGVcbiAgICAgIC8vIGN1cnJlbnRUYXJnZXQuIFRoaXMgbGV0cyBhIHRpcHB5IHdpdGggYGZvY3VzYCB0cmlnZ2VyIGtub3cgdGhhdCBpdFxuICAgICAgLy8gc2hvdWxkIG5vdCBzaG93XG5cbiAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfSk7IC8vIFRoZSBsaXN0ZW5lciBnZXRzIGFkZGVkIGluIGBzY2hlZHVsZVNob3coKWAsIGJ1dCB0aGlzIG1heSBiZSBoaWRpbmcgaXRcbiAgICAgIC8vIGJlZm9yZSBpdCBzaG93cywgYW5kIGhpZGUoKSdzIGVhcmx5IGJhaWwtb3V0IGJlaGF2aW9yIGNhbiBwcmV2ZW50IGl0XG4gICAgICAvLyBmcm9tIGJlaW5nIGNsZWFuZWQgdXBcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVtb3ZlRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIoKSB7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRNb3VzZURvd24sIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudE1vdXNlRG93biwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIHBvcHBlci5wYXJlbnROb2RlICYmIHBvcHBlci5wYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRvb2x0aXApIHtcbiAgICAgICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKHRvb2x0aXAsICdyZW1vdmUnLCBsaXN0ZW5lcik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBNYWtlIGNhbGxiYWNrIHN5bmNocm9ub3VzIGlmIGR1cmF0aW9uIGlzIDBcbiAgICAvLyBgdHJhbnNpdGlvbmVuZGAgd29uJ3QgZmlyZSBvdGhlcndpc2VcblxuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIodG9vbHRpcCwgJ3JlbW92ZScsIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIpO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcih0b29sdGlwLCAnYWRkJywgbGlzdGVuZXIpO1xuICAgIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzVG9UcmlnZ2VyVGFyZ2V0KCkge1xuICAgIGlmIChnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSkge1xuICAgICAgb24oJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIFBBU1NJVkUpO1xuICAgICAgb24oJ3RvdWNoZW5kJywgb25Nb3VzZUxlYXZlLCBQQVNTSVZFKTtcbiAgICB9XG5cbiAgICBzcGxpdEJ5U3BhY2VzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvbihldmVudFR5cGUsIG9uVHJpZ2dlcik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgIG9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgb24oaXNJRSA/ICdmb2N1c291dCcgOiAnYmx1cicsIG9uQmx1ck9yRm9jdXNPdXQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgICAgIG9uKCdmb2N1c291dCcsIG9uQmx1ck9yRm9jdXNPdXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzRnJvbVRyaWdnZXJUYXJnZXQoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gZmFsc2U7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCB8fCBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fCBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxhc3RUcmlnZ2VyRXZlbnQgPSBldmVudDtcbiAgICBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHNjcm9sbGluZywgYG1vdXNlZW50ZXJgIGV2ZW50cyBjYW4gYmUgZmlyZWQgaWYgdGhlIGN1cnNvciBsYW5kc1xuICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAvLyBjYXVzZXMgaW50ZXJhY3RpdmUgdG9vbHRpcHMgdG8gZ2V0IHN0dWNrIG9wZW4gdW50aWwgdGhlIGN1cnNvciBpc1xuICAgICAgLy8gbW92ZWRcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSAvLyBUb2dnbGUgc2hvdy9oaWRlIHdoZW4gY2xpY2tpbmcgY2xpY2stdHJpZ2dlcmVkIHRvb2x0aXBzXG5cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snICYmICghaW5jbHVkZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlciwgJ21vdXNlZW50ZXInKSB8fCBpc1Zpc2libGVGcm9tQ2xpY2spICYmIGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrICE9PSBmYWxzZSAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9nZXROb3JtYWxpemVkVG91Y2hTZSA9IGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCksXG4gICAgICAgICAgdmFsdWUgPSBfZ2V0Tm9ybWFsaXplZFRvdWNoU2VbMF0sXG4gICAgICAgICAgZHVyYXRpb24gPSBfZ2V0Tm9ybWFsaXplZFRvdWNoU2VbMV07XG5cbiAgICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiB2YWx1ZSA9PT0gJ2hvbGQnICYmIGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIFdlIGNhbiBoaWphY2sgdGhlIHNob3cgdGltZW91dCBoZXJlLCBpdCB3aWxsIGJlIGNsZWFyZWQgYnlcbiAgICAgICAgLy8gYHNjaGVkdWxlSGlkZSgpYCB3aGVuIG5lY2Vzc2FyeVxuICAgICAgICBzaG93VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGlzVmlzaWJsZUZyb21DbGljayA9ICFzaG91bGRTY2hlZHVsZUNsaWNrSGlkZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUpIHtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIgPSBjbG9zZXN0Q2FsbGJhY2soZXZlbnQudGFyZ2V0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbCA9PT0gcmVmZXJlbmNlIHx8IGVsID09PSBwb3BwZXI7XG4gICAgfSk7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9wcGVyVHJlZURhdGEgPSBhcnJheUZyb20ocG9wcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoUE9QUEVSX1NFTEVDVE9SKSkuY29uY2F0KHBvcHBlcikubWFwKGZ1bmN0aW9uIChwb3BwZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHBvcHBlci5fdGlwcHk7XG4gICAgICB2YXIgdG9vbHRpcCA9IGluc3RhbmNlLnBvcHBlckNoaWxkcmVuLnRvb2x0aXA7XG4gICAgICB2YXIgaW50ZXJhY3RpdmVCb3JkZXIgPSBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvcHBlclJlY3Q6IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgdG9vbHRpcFJlY3Q6IHRvb2x0aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGludGVyYWN0aXZlQm9yZGVyOiBpbnRlcmFjdGl2ZUJvcmRlclxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGlmIChpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihwb3BwZXJUcmVlRGF0YSwgZXZlbnQpKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICBpZiAoaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlciwgJ2NsaWNrJykgJiYgaXNWaXNpYmxlRnJvbUNsaWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBkb2MuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgc2NoZWR1bGVIaWRlKTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgICBwdXNoSWZVbmlxdWUobW91c2VNb3ZlTGlzdGVuZXJzLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmx1ck9yRm9jdXNPdXQoZXZlbnQpIHtcbiAgICBpZiAoIWluY2x1ZGVzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIsICdmb2N1c2luJykgJiYgZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIGZvY3VzIHdhcyBtb3ZlZCB0byB3aXRoaW4gdGhlIHBvcHBlclxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgZXZlbnQucmVsYXRlZFRhcmdldCAmJiBwb3BwZXIuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkge1xuICAgIHZhciBzdXBwb3J0c1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIHZhciBpc1RvdWNoRXZlbnQgPSBpbmNsdWRlcyhldmVudC50eXBlLCAndG91Y2gnKTtcbiAgICB2YXIgaXNDdXN0b21Ub3VjaCA9IGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpO1xuICAgIHJldHVybiBzdXBwb3J0c1RvdWNoICYmIGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmIGlzQ3VzdG9tVG91Y2ggJiYgIWlzVG91Y2hFdmVudCB8fCBjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiAhaXNDdXN0b21Ub3VjaCAmJiBpc1RvdWNoRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpIHtcbiAgICB2YXIgcG9wcGVyT3B0aW9ucyA9IGluc3RhbmNlLnByb3BzLnBvcHBlck9wdGlvbnM7XG4gICAgdmFyIGFycm93ID0gaW5zdGFuY2UucG9wcGVyQ2hpbGRyZW4uYXJyb3c7XG4gICAgdmFyIGZsaXBNb2RpZmllciA9IGdldE1vZGlmaWVyKHBvcHBlck9wdGlvbnMsICdmbGlwJyk7XG4gICAgdmFyIHByZXZlbnRPdmVyZmxvd01vZGlmaWVyID0gZ2V0TW9kaWZpZXIocG9wcGVyT3B0aW9ucywgJ3ByZXZlbnRPdmVyZmxvdycpO1xuICAgIHZhciBkaXN0YW5jZVB4O1xuXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoZGF0YSkge1xuICAgICAgdmFyIHByZXZQbGFjZW1lbnQgPSBpbnN0YW5jZS5zdGF0ZS5jdXJyZW50UGxhY2VtZW50O1xuICAgICAgaW5zdGFuY2Uuc3RhdGUuY3VycmVudFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZmxpcCAmJiAhaW5zdGFuY2UucHJvcHMuZmxpcE9uVXBkYXRlKSB7XG4gICAgICAgIGlmIChkYXRhLmZsaXBwZWQpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLnBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0TW9kaWZpZXJWYWx1ZShpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5tb2RpZmllcnMsICdmbGlwJywgJ2VuYWJsZWQnLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcsIGRhdGEucGxhY2VtZW50KTtcblxuICAgICAgaWYgKGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddICE9PSBmYWxzZSkge1xuICAgICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1vdXQtb2YtYm91bmRhcmllcycsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW91dC1vZi1ib3VuZGFyaWVzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChkYXRhLnBsYWNlbWVudCk7XG4gICAgICB2YXIgaXNWZXJ0aWNhbFBsYWNlbWVudCA9IGluY2x1ZGVzKFsndG9wJywgJ2JvdHRvbSddLCBiYXNlUGxhY2VtZW50KTtcbiAgICAgIHZhciBpc1NlY29uZGFyeVBsYWNlbWVudCA9IGluY2x1ZGVzKFsnYm90dG9tJywgJ3JpZ2h0J10sIGJhc2VQbGFjZW1lbnQpOyAvLyBBcHBseSBgZGlzdGFuY2VgIHByb3BcblxuICAgICAgdG9vbHRpcC5zdHlsZS50b3AgPSAnMCc7XG4gICAgICB0b29sdGlwLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICB0b29sdGlwLnN0eWxlW2lzVmVydGljYWxQbGFjZW1lbnQgPyAndG9wJyA6ICdsZWZ0J10gPSAoaXNTZWNvbmRhcnlQbGFjZW1lbnQgPyAxIDogLTEpICogZGlzdGFuY2VQeCArICdweCc7IC8vIENhcmVmdWwgbm90IHRvIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgaGVyZVxuICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzc4NFxuXG4gICAgICBpZiAocHJldlBsYWNlbWVudCAmJiBwcmV2UGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gX2V4dGVuZHMoe1xuICAgICAgZXZlbnRzRW5hYmxlZDogZmFsc2UsXG4gICAgICBwbGFjZW1lbnQ6IGluc3RhbmNlLnByb3BzLnBsYWNlbWVudFxuICAgIH0sIHBvcHBlck9wdGlvbnMsIHtcbiAgICAgIG1vZGlmaWVyczogX2V4dGVuZHMoe30sIHBvcHBlck9wdGlvbnMgJiYgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMsIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIGBwYWRkaW5nYCBvbiB0aGUgcG9wcGVyIGVsIGJlY2F1c2Ugb2YgdGhlc2UgYnVncyB3aGVuXG4gICAgICAgIC8vIGZsaXBwaW5nIGZyb20gYSB2ZXJ0aWNhbCB0byBob3Jpem9udGFsIHBsYWNlbWVudCBvciB2aWNlLXZlcnNhLFxuICAgICAgICAvLyB0aGVyZSBpcyBzZXZlcmUgZmxpY2tlcmluZy5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzcyMFxuICAgICAgICAvLyBUaGlzIHdvcmthcm91bmQgaW5jcmVhc2VzIGJ1bmRsZSBzaXplIGJ5IDI1MEIgbWluemlwIHVuZm9ydHVuYXRlbHksXG4gICAgICAgIC8vIGR1ZSB0byBuZWVkIHRvIGN1c3RvbSBjb21wdXRlIHRoZSBkaXN0YW5jZSAoc2luY2UgUG9wcGVyIHJlY3QgZG9lc1xuICAgICAgICAvLyBub3QgZ2V0IGFmZmVjdGVkIGJ5IHRoZSBpbm5lciB0b29sdGlwJ3MgZGlzdGFuY2Ugb2Zmc2V0KVxuICAgICAgICB0aXBweURpc3RhbmNlOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBvcmRlcjogMCxcbiAgICAgICAgICBmbjogZnVuY3Rpb24gZm4oZGF0YSkge1xuICAgICAgICAgICAgLy8gYGh0bWxgIGZvbnRTaXplIG1heSBjaGFuZ2Ugd2hpbGUgYHBvcHBlckluc3RhbmNlYCBpcyBhbGl2ZVxuICAgICAgICAgICAgLy8gZS5nLiBvbiByZXNpemUgaW4gbWVkaWEgcXVlcmllc1xuICAgICAgICAgICAgZGlzdGFuY2VQeCA9IGdldFVuaXRzSW5QeChkb2MsIGluc3RhbmNlLnByb3BzLmRpc3RhbmNlKTtcbiAgICAgICAgICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChkYXRhLnBsYWNlbWVudCk7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRQcmV2ZW50T3ZlcmZsb3dQYWRkaW5nID0gZ2V0Q29tcHV0ZWRQYWRkaW5nKGJhc2VQbGFjZW1lbnQsIHByZXZlbnRPdmVyZmxvd01vZGlmaWVyICYmIHByZXZlbnRPdmVyZmxvd01vZGlmaWVyLnBhZGRpbmcsIGRpc3RhbmNlUHgpO1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkRmxpcFBhZGRpbmcgPSBnZXRDb21wdXRlZFBhZGRpbmcoYmFzZVBsYWNlbWVudCwgZmxpcE1vZGlmaWVyICYmIGZsaXBNb2RpZmllci5wYWRkaW5nLCBkaXN0YW5jZVB4KTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZU1vZGlmaWVycyA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLm1vZGlmaWVycztcbiAgICAgICAgICAgIHNldE1vZGlmaWVyVmFsdWUoaW5zdGFuY2VNb2RpZmllcnMsICdwcmV2ZW50T3ZlcmZsb3cnLCAncGFkZGluZycsIGNvbXB1dGVkUHJldmVudE92ZXJmbG93UGFkZGluZyk7XG4gICAgICAgICAgICBzZXRNb2RpZmllclZhbHVlKGluc3RhbmNlTW9kaWZpZXJzLCAnZmxpcCcsICdwYWRkaW5nJywgY29tcHV0ZWRGbGlwUGFkZGluZyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzogX2V4dGVuZHMoe1xuICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiBpbnN0YW5jZS5wcm9wcy5ib3VuZGFyeVxuICAgICAgICB9LCBwcmV2ZW50T3ZlcmZsb3dNb2RpZmllciksXG4gICAgICAgIGZsaXA6IF9leHRlbmRzKHtcbiAgICAgICAgICBlbmFibGVkOiBpbnN0YW5jZS5wcm9wcy5mbGlwLFxuICAgICAgICAgIGJlaGF2aW9yOiBpbnN0YW5jZS5wcm9wcy5mbGlwQmVoYXZpb3JcbiAgICAgICAgfSwgZmxpcE1vZGlmaWVyKSxcbiAgICAgICAgYXJyb3c6IF9leHRlbmRzKHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBlbmFibGVkOiAhIWFycm93XG4gICAgICAgIH0sIGdldE1vZGlmaWVyKHBvcHBlck9wdGlvbnMsICdhcnJvdycpKSxcbiAgICAgICAgb2Zmc2V0OiBfZXh0ZW5kcyh7XG4gICAgICAgICAgb2Zmc2V0OiBpbnN0YW5jZS5wcm9wcy5vZmZzZXRcbiAgICAgICAgfSwgZ2V0TW9kaWZpZXIocG9wcGVyT3B0aW9ucywgJ29mZnNldCcpKVxuICAgICAgfSksXG4gICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoZGF0YSkge1xuICAgICAgICBhcHBseU11dGF0aW9ucyhkYXRhKTtcbiAgICAgICAgcHJlc2VydmVJbnZvY2F0aW9uKHBvcHBlck9wdGlvbnMgJiYgcG9wcGVyT3B0aW9ucy5vbkNyZWF0ZSwgY29uZmlnLm9uQ3JlYXRlLCBbZGF0YV0pO1xuICAgICAgICBydW5Nb3VudENhbGxiYWNrKCk7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYXBwbHlNdXRhdGlvbnMoZGF0YSk7XG4gICAgICAgIHByZXNlcnZlSW52b2NhdGlvbihwb3BwZXJPcHRpb25zICYmIHBvcHBlck9wdGlvbnMub25VcGRhdGUsIGNvbmZpZy5vblVwZGF0ZSwgW2RhdGFdKTtcbiAgICAgICAgcnVuTW91bnRDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBuZXcgUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBjb25maWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuTW91bnRDYWxsYmFjaygpIHtcbiAgICAvLyBPbmx5IGludm9rZSBjdXJyZW50TW91bnRDYWxsYmFjayBhZnRlciAyIHVwZGF0ZXNcbiAgICAvLyBUaGlzIGZpeGVzIHNvbWUgYnVncyBpbiBQb3BwZXIuanMgKFRPRE86IGFpbSBmb3Igb25seSAxIHVwZGF0ZSlcbiAgICBpZiAocG9wcGVyVXBkYXRlcyA9PT0gMCkge1xuICAgICAgcG9wcGVyVXBkYXRlcysrOyAvLyAxXG5cbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudE1vdW50Q2FsbGJhY2sgJiYgcG9wcGVyVXBkYXRlcyA9PT0gMSkge1xuICAgICAgcG9wcGVyVXBkYXRlcysrOyAvLyAyXG5cbiAgICAgIHJlZmxvdyhwb3BwZXIpO1xuICAgICAgY3VycmVudE1vdW50Q2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAvLyBUaGUgbW91bnRpbmcgY2FsbGJhY2sgKGBjdXJyZW50TW91bnRDYWxsYmFja2ApIGlzIG9ubHkgcnVuIGR1ZSB0byBhXG4gICAgLy8gcG9wcGVySW5zdGFuY2UgdXBkYXRlL2NyZWF0ZVxuICAgIHBvcHBlclVwZGF0ZXMgPSAwO1xuICAgIHZhciBhcHBlbmRUbyA9IGluc3RhbmNlLnByb3BzLmFwcGVuZFRvO1xuICAgIHZhciBwYXJlbnROb2RlOyAvLyBCeSBkZWZhdWx0LCB3ZSdsbCBhcHBlbmQgdGhlIHBvcHBlciB0byB0aGUgdHJpZ2dlclRhcmdldHMncyBwYXJlbnROb2RlIHNvXG4gICAgLy8gaXQncyBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgc28gdGhlIGVsZW1lbnRzIGluc2lkZSB0aGVcbiAgICAvLyB0aXBweSBjYW4gYmUgdGFiYmVkIHRvXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNsaXBwaW5nIGlzc3VlcywgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYXBwZW5kVG9cbiAgICAvLyBhbmQgZW5zdXJlIGZvY3VzIG1hbmFnZW1lbnQgaXMgaGFuZGxlZCBjb3JyZWN0bHkgbWFudWFsbHlcblxuICAgIHZhciBub2RlID0gZ2V0Q3VycmVudFRhcmdldCgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdwYXJlbnQnKSB7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlID0gaW52b2tlV2l0aEFyZ3NPclJldHVybihhcHBlbmRUbywgW25vZGVdKTtcbiAgICB9IC8vIFRoZSBwb3BwZXIgZWxlbWVudCBuZWVkcyB0byBleGlzdCBvbiB0aGUgRE9NIGJlZm9yZSBpdHMgcG9zaXRpb24gY2FuIGJlXG4gICAgLy8gdXBkYXRlZCBhcyBQb3BwZXIuanMgbmVlZHMgdG8gcmVhZCBpdHMgZGltZW5zaW9uc1xuXG5cbiAgICBpZiAoIXBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIEFjY2Vzc2liaWxpdHkgY2hlY2tcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IHBvcHBlciwgWydJbnRlcmFjdGl2ZSB0aXBweSBlbGVtZW50IG1heSBub3QgYmUgYWNjZXNzaWJsZSB2aWEga2V5Ym9hcmQgbmF2aWdhdGlvbicsICdiZWNhdXNlIGl0IGlzIG5vdCBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaW4gdGhlIERPTSBzb3VyY2UnLCAnb3JkZXIuJywgJ1xcblxcbicsICdVc2luZyBhIHdyYXBwZXIgPGRpdj4gb3IgPHNwYW4+IHRhZyBhcm91bmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50IHNvbHZlcycsICd0aGlzIGJ5IGNyZWF0aW5nIGEgbmV3IHBhcmVudE5vZGUgY29udGV4dC4nLCAnXFxuXFxuJywgJ1NwZWNpZnlpbmcgYGFwcGVuZFRvOiBkb2N1bWVudC5ib2R5YCBzaWxlbmNlcyB0aGlzIHdhcm5pbmcsIGJ1dCBpdCcsICdhc3N1bWVzIHlvdSBhcmUgdXNpbmcgYSBmb2N1cyBtYW5hZ2VtZW50IHNvbHV0aW9uIHRvIGhhbmRsZSBrZXlib2FyZCcsICduYXZpZ2F0aW9uLicsICdcXG5cXG4nLCAnU2VlOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvYWNjZXNzaWJpbGl0eS8jaW50ZXJhY3Rpdml0eSddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgc2V0TW9kaWZpZXJWYWx1ZShpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5tb2RpZmllcnMsICdmbGlwJywgJ2VuYWJsZWQnLCBpbnN0YW5jZS5wcm9wcy5mbGlwKTtcbiAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5lbmFibGVFdmVudExpc3RlbmVycygpOyAvLyBNb3VudGluZyBjYWxsYmFjayBpbnZva2VkIGluIGBvblVwZGF0ZWBcblxuICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVTaG93KGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgaW52b2tlSG9vaygnb25UcmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGFkZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIoKTtcbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheSh0cnVlKTtcblxuICAgIGlmIChkZWxheSkge1xuICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgaW52b2tlSG9vaygnb25VbnRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIHNjaGVkdWxlSGlkZSBpcyBhZGRlZCB0byBhIGRvY3VtZW50LmJvZHkgaGFuZGxlclxuICAgIC8vIGZyb20gb25Nb3VzZUxlYXZlIHNvIG11c3QgaW50ZXJjZXB0IHNjaGVkdWxlZCBoaWRlcyBmcm9tIG1vdXNlbW92ZS9sZWF2ZVxuICAgIC8vIGV2ZW50cyB3aGVuIHRyaWdnZXIgY29udGFpbnMgbW91c2VlbnRlciBhbmQgY2xpY2ssIGFuZCB0aGUgdGlwIGlzXG4gICAgLy8gY3VycmVudGx5IHNob3duIGFzIGEgcmVzdWx0IG9mIGEgY2xpY2suXG5cblxuICAgIGlmIChpbmNsdWRlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLCAnbW91c2VlbnRlcicpICYmIGluY2x1ZGVzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIsICdjbGljaycpICYmIGluY2x1ZGVzKFsnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnXSwgZXZlbnQudHlwZSkgJiYgaXNWaXNpYmxlRnJvbUNsaWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXkoZmFsc2UpO1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpeGVzIGEgYHRyYW5zaXRpb25lbmRgIHByb2JsZW0gd2hlbiBpdCBmaXJlcyAxIGZyYW1lIHRvb1xuICAgICAgLy8gbGF0ZSBzb21ldGltZXMsIHdlIGRvbid0IHdhbnQgaGlkZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09IPCflJEgUHVibGljIG1ldGhvZHMg8J+UkSA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIC8vIERpc2FibGluZyB0aGUgaW5zdGFuY2Ugc2hvdWxkIGFsc28gaGlkZSBpdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5LmpzLXJlYWN0L2lzc3Vlcy8xMDZcbiAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRlbGF5VGltZW91dHMoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNob3dUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQoaGlkZVRpbWVvdXQpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2V0UHJvcHMnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIHBsdWdpbnMpO1xuICAgICAgd2FybldoZW4ocGFydGlhbFByb3BzLnBsdWdpbnMgPyBwYXJ0aWFsUHJvcHMucGx1Z2lucy5sZW5ndGggIT09IHBsdWdpbnMubGVuZ3RoIHx8IHBsdWdpbnMuc29tZShmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICBpZiAocGFydGlhbFByb3BzLnBsdWdpbnMgJiYgcGFydGlhbFByb3BzLnBsdWdpbnNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gcCAhPT0gcGFydGlhbFByb3BzLnBsdWdpbnNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pIDogZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSBwbHVnaW5zXCIpO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQmVmb3JlVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgICByZW1vdmVMaXN0ZW5lcnNGcm9tVHJpZ2dlclRhcmdldCgpO1xuICAgIHZhciBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIF9leHRlbmRzKHt9LCBpbnN0YW5jZS5wcm9wcywge30sIHBhcnRpYWxQcm9wcywge1xuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pKTtcbiAgICBuZXh0UHJvcHMuaWdub3JlQXR0cmlidXRlcyA9IHVzZUlmRGVmaW5lZChwYXJ0aWFsUHJvcHMuaWdub3JlQXR0cmlidXRlcywgcHJldlByb3BzLmlnbm9yZUF0dHJpYnV0ZXMpO1xuICAgIGluc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuICAgIGFkZExpc3RlbmVyc1RvVHJpZ2dlclRhcmdldCgpO1xuXG4gICAgaWYgKHByZXZQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlICE9PSBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVQb3BwZXJFbGVtZW50KHBvcHBlciwgcHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKTsgLy8gRW5zdXJlIHN0YWxlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlcyBhcmUgcmVtb3ZlZFxuXG4gICAgaWYgKHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0ICYmICFuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgbm9ybWFsaXplVG9BcnJheShwcmV2UHJvcHMudHJpZ2dlclRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgcmVmZXJlbmNlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgIH1cblxuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpZiAoUE9QUEVSX0lOU1RBTkNFX0RFUEVOREVOQ0lFUy5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShwYXJ0aWFsUHJvcHMsIHByb3ApICYmIHBhcnRpYWxQcm9wc1twcm9wXSAhPT0gcHJldlByb3BzW3Byb3BdO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSZWZlcmVuY2UgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0gY3VycmVudFJlZmVyZW5jZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25BZnRlclVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDAsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzaG93JykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeVZpc2libGUgPSBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIHZhciBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCA9IGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmICFpbnN0YW5jZS5wcm9wcy50b3VjaDtcblxuICAgIGlmIChpc0FscmVhZHlWaXNpYmxlIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQgfHwgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE5vcm1hbGl6ZSBgZGlzYWJsZWRgIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAvLyBGaXJlZm94IGFsbG93cyBldmVudHMgb24gZGlzYWJsZWQgZWxlbWVudHMsIGJ1dCBDaHJvbWUgZG9lc24ndC5cbiAgICAvLyBVc2luZyBhIHdyYXBwZXIgZWxlbWVudCAoaS5lLiA8c3Bhbj4pIGlzIHJlY29tbWVuZGVkLlxuXG5cbiAgICBpZiAoZ2V0Q3VycmVudFRhcmdldCgpLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25TaG93JywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IHRydWU7IC8vIFByZXZlbnQgYSB0cmFuc2l0aW9uIG9mIHRoZSBwb3BwZXIgZnJvbSBpdHMgcHJldmlvdXMgcG9zaXRpb24gYW5kIG9mIHRoZVxuICAgIC8vIGVsZW1lbnRzIGF0IGEgZGlmZmVyZW50IHBsYWNlbWVudFxuICAgIC8vIENoZWNrIGlmIHRoZSB0aXBweSB3YXMgZnVsbHkgdW5tb3VudGVkIGJlZm9yZSBgc2hvdygpYCB3YXMgY2FsbGVkLCB0b1xuICAgIC8vIGFsbG93IGZvciBzbW9vdGggdHJhbnNpdGlvbiBmb3IgYGNyZWF0ZVNpbmdsZXRvbigpYFxuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLmNvbmNhdChwb3BwZXIpLCAwKTtcbiAgICB9XG5cbiAgICBjdXJyZW50TW91bnRDYWxsYmFjayA9IGZ1bmN0aW9uIGN1cnJlbnRNb3VudENhbGxiYWNrKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW3BvcHBlcl0sIGluc3RhbmNlLnByb3BzLnVwZGF0ZUR1cmF0aW9uKTtcbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLCBkdXJhdGlvbik7XG4gICAgICBzZXRWaXNpYmlsaXR5U3RhdGUodHJhbnNpdGlvbmFibGVFbGVtZW50cywgJ3Zpc2libGUnKTtcbiAgICAgIGhhbmRsZUFyaWFEZXNjcmliZWRCeUF0dHJpYnV0ZSgpO1xuICAgICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgICBwdXNoSWZVbmlxdWUobW91bnRlZEluc3RhbmNlcywgaW5zdGFuY2UpO1xuICAgICAgdXBkYXRlSU9TQ2xhc3ModHJ1ZSk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgaW52b2tlSG9vaygnb25Nb3VudCcsIFtpbnN0YW5jZV0pO1xuICAgICAgb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgaW52b2tlSG9vaygnb25TaG93bicsIFtpbnN0YW5jZV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIG1vdW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDEsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlJykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeUhpZGRlbiA9ICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgIWlzQmVpbmdEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkICYmICFpc0JlaW5nRGVzdHJveWVkO1xuXG4gICAgaWYgKGlzQWxyZWFkeUhpZGRlbiB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25IaWRlJywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uSGlkZShpbnN0YW5jZSkgPT09IGZhbHNlICYmICFpc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVtb3ZlRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lcigpO1xuICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IGZhbHNlO1xuICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLCBkdXJhdGlvbik7XG4gICAgc2V0VmlzaWJpbGl0eVN0YXRlKHRyYW5zaXRpb25hYmxlRWxlbWVudHMsICdoaWRkZW4nKTtcbiAgICBoYW5kbGVBcmlhRGVzY3JpYmVkQnlBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLnBsYWNlbWVudCA9IGluc3RhbmNlLnByb3BzLnBsYWNlbWVudDtcbiAgICAgIHBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHBlcik7XG4gICAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkgIT09IGluc3RhbmNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtb3VudGVkSW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB1cGRhdGVJT1NDbGFzcyhmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgaW52b2tlSG9vaygnb25IaWRkZW4nLCBbaW5zdGFuY2VdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdkZXN0cm95JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGluc3RhbmNlLmhpZGUoMCk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzRnJvbVRyaWdnZXJUYXJnZXQoKTtcbiAgICBkZWxldGUgcmVmZXJlbmNlLl90aXBweTtcblxuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgaW52b2tlSG9vaygnb25EZXN0cm95JywgW2luc3RhbmNlXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGlwcHkodGFyZ2V0cywgb3B0aW9uYWxQcm9wcyxcbi8qKiBAZGVwcmVjYXRlZCB1c2UgUHJvcHMucGx1Z2lucyAqL1xucGx1Z2lucykge1xuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIHBsdWdpbnMgPSBkZWZhdWx0UHJvcHMucGx1Z2lucy5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IHBsdWdpbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cyk7XG4gICAgdmFsaWRhdGVQcm9wcyhvcHRpb25hbFByb3BzLCBwbHVnaW5zKTtcbiAgfVxuXG4gIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpO1xuXG4gIHZhciBwYXNzZWRQcm9wcyA9IF9leHRlbmRzKHt9LCBvcHRpb25hbFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KTtcblxuICB2YXIgZWxlbWVudHMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ID0gaXNFbGVtZW50KHBhc3NlZFByb3BzLmNvbnRlbnQpO1xuICAgIHZhciBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oaXNTaW5nbGVDb250ZW50RWxlbWVudCAmJiBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYW4gRWxlbWVudCBhcyB0aGUgYGNvbnRlbnRgIHByb3AsIGJ1dCBtb3JlIHRoYW4gb25lIHRpcHB5JywgJ2luc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHRoaXMgaW52b2NhdGlvbi4gVGhpcyBtZWFucyB0aGUgY29udGVudCBlbGVtZW50IHdpbGwnLCAnb25seSBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCB0aXBweSBpbnN0YW5jZS4nLCAnXFxuXFxuJywgJ0luc3RlYWQsIHBhc3MgdGhlIC5pbm5lckhUTUwgb2YgdGhlIGVsZW1lbnQsIG9yIHVzZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhJywgJ2Nsb25lZCB2ZXJzaW9uIG9mIHRoZSBlbGVtZW50IGluc3RlYWQuJywgJ1xcblxcbicsICcxKSBjb250ZW50OiBlbGVtZW50LmlubmVySFRNTFxcbicsICcyKSBjb250ZW50OiAoKSA9PiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKSddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZmVyZW5jZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHJlZmVyZW5jZSAmJiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgYWNjLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXRzKSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbn1cblxudGlwcHkudmVyc2lvbiA9IHZlcnNpb247XG50aXBweS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG50aXBweS5zZXREZWZhdWx0UHJvcHMgPSBzZXREZWZhdWx0UHJvcHM7XG50aXBweS5jdXJyZW50SW5wdXQgPSBjdXJyZW50SW5wdXQ7XG4vKipcbiAqIEhpZGVzIGFsbCB2aXNpYmxlIHBvcHBlcnMgb24gdGhlIGRvY3VtZW50XG4gKi9cblxudmFyIGhpZGVBbGwgPSBmdW5jdGlvbiBoaWRlQWxsKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgPSBfcmVmLmV4Y2x1ZGUsXG4gICAgICBkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb247XG5cbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA6IGluc3RhbmNlLnBvcHBlciA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLnBvcHBlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoZHVyYXRpb24pO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgcHJveHkgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHBhc3NlcyB0aGUgcGx1Z2luc1xuICogQGRlcHJlY2F0ZWQgdXNlIHRpcHB5LnNldERlZmF1bHRQcm9wcyh7cGx1Z2luczogWy4uLl19KTtcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUaXBweVdpdGhQbHVnaW5zKG91dGVyUGx1Z2lucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgd2FybldoZW4odHJ1ZSwgWydjcmVhdGVUaXBweVdpdGhQbHVnaW5zKFsuLi5dKSBoYXMgYmVlbiBkZXByZWNhdGVkLicsICdcXG5cXG4nLCAnVXNlIHRpcHB5LnNldERlZmF1bHRQcm9wcyh7cGx1Z2luczogWy4uLl19KSBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgdGlwcHlQbHVnaW5zV3JhcHBlciA9IGZ1bmN0aW9uIHRpcHB5UGx1Z2luc1dyYXBwZXIodGFyZ2V0cywgb3B0aW9uYWxQcm9wcywgaW5uZXJQbHVnaW5zKSB7XG4gICAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChpbm5lclBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgICAgaW5uZXJQbHVnaW5zID0gW107XG4gICAgfVxuXG4gICAgaW5uZXJQbHVnaW5zID0gb3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IGlubmVyUGx1Z2lucztcbiAgICByZXR1cm4gdGlwcHkodGFyZ2V0cywgX2V4dGVuZHMoe30sIG9wdGlvbmFsUHJvcHMsIHtcbiAgICAgIHBsdWdpbnM6IFtdLmNvbmNhdChvdXRlclBsdWdpbnMsIGlubmVyUGx1Z2lucylcbiAgICB9KSk7XG4gIH07XG5cbiAgdGlwcHlQbHVnaW5zV3JhcHBlci52ZXJzaW9uID0gdmVyc2lvbjtcbiAgdGlwcHlQbHVnaW5zV3JhcHBlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gIHRpcHB5UGx1Z2luc1dyYXBwZXIuc2V0RGVmYXVsdFByb3BzID0gc2V0RGVmYXVsdFByb3BzO1xuICB0aXBweVBsdWdpbnNXcmFwcGVyLmN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnB1dDsgLy8gQHRzLWlnbm9yZVxuXG4gIHJldHVybiB0aXBweVBsdWdpbnNXcmFwcGVyO1xufVxuXG5leHBvcnQgeyBCQUNLRFJPUF9DTEFTUyBhcyBCLCBST1VORF9BUlJPVyBhcyBSLCBfZXh0ZW5kcyBhcyBfLCBkaXYgYXMgYSwgaXNNb3VzZUV2ZW50IGFzIGIsIGN1cnJlbnRJbnB1dCBhcyBjLCBkZWZhdWx0UHJvcHMgYXMgZCwgZXJyb3JXaGVuIGFzIGUsIGNsb3Nlc3RDYWxsYmFjayBhcyBmLCBnZXRPd25lckRvY3VtZW50IGFzIGcsIGdldEJhc2VQbGFjZW1lbnQgYXMgaCwgaW5jbHVkZXMgYXMgaSwgYXJyYXlGcm9tIGFzIGosIGhpZGVBbGwgYXMgaywgY3JlYXRlVGlwcHlXaXRoUGx1Z2lucyBhcyBsLCBpc0Jyb3dzZXIgYXMgbSwgbm9ybWFsaXplVG9BcnJheSBhcyBuLCByZW1vdmVQcm9wZXJ0aWVzIGFzIHIsIHNldFZpc2liaWxpdHlTdGF0ZSBhcyBzLCB0aXBweSBhcyB0LCB1c2VJZkRlZmluZWQgYXMgdSwgd2FybldoZW4gYXMgdyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlwcHkuY2h1bmsuZXNtLmpzLm1hcFxuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi90aXBweS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7IiwiLyoqIVxuKiB0aXBweS5qcyB2NS4yLjFcbiogKGMpIDIwMTctMjAyMCBhdG9taWtzXG4qIE1JVCBMaWNlbnNlXG4qL1xuaW1wb3J0IHsgZSBhcyBlcnJvcldoZW4sIF8gYXMgX2V4dGVuZHMsIGQgYXMgZGVmYXVsdFByb3BzLCB0IGFzIHRpcHB5LCBhIGFzIGRpdiwgciBhcyByZW1vdmVQcm9wZXJ0aWVzLCBuIGFzIG5vcm1hbGl6ZVRvQXJyYXksIGkgYXMgaW5jbHVkZXMsIHMgYXMgc2V0VmlzaWJpbGl0eVN0YXRlLCB3IGFzIHdhcm5XaGVuLCBCIGFzIEJBQ0tEUk9QX0NMQVNTLCBnIGFzIGdldE93bmVyRG9jdW1lbnQsIGIgYXMgaXNNb3VzZUV2ZW50LCB1IGFzIHVzZUlmRGVmaW5lZCwgYyBhcyBjdXJyZW50SW5wdXQsIGYgYXMgY2xvc2VzdENhbGxiYWNrLCBoIGFzIGdldEJhc2VQbGFjZW1lbnQsIGogYXMgYXJyYXlGcm9tIH0gZnJvbSAnLi90aXBweS5jaHVuay5lc20uanMnO1xuZXhwb3J0IHsgbCBhcyBjcmVhdGVUaXBweVdpdGhQbHVnaW5zLCB0IGFzIGRlZmF1bHQsIGsgYXMgaGlkZUFsbCwgUiBhcyByb3VuZEFycm93IH0gZnJvbSAnLi90aXBweS5jaHVuay5lc20uanMnO1xuaW1wb3J0ICdwb3BwZXIuanMnO1xuXG4vKipcbiAqIFJlLXVzZXMgYSBzaW5nbGUgdGlwcHkgZWxlbWVudCBmb3IgbWFueSBkaWZmZXJlbnQgdGlwcHkgaW5zdGFuY2VzLlxuICogUmVwbGFjZXMgdjQncyBgdGlwcHkuZ3JvdXAoKWAuXG4gKi9cblxudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbih0aXBweUluc3RhbmNlcywgb3B0aW9uYWxQcm9wcyxcbi8qKiBAZGVwcmVjYXRlZCB1c2UgUHJvcHMucGx1Z2lucyAqL1xucGx1Z2lucykge1xuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcldoZW4oIUFycmF5LmlzQXJyYXkodGlwcHlJbnN0YW5jZXMpLCBbJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU2luZ2xldG9uKCkgbXVzdCBiZSBhbiBhcnJheSBvZiB0aXBweScsICdpbnN0YW5jZXMuIFRoZSBwYXNzZWQgdmFsdWUgd2FzJywgU3RyaW5nKHRpcHB5SW5zdGFuY2VzKV0uam9pbignICcpKTtcbiAgfVxuXG4gIHBsdWdpbnMgPSBvcHRpb25hbFByb3BzLnBsdWdpbnMgfHwgcGx1Z2lucztcbiAgdGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gIH0pO1xuXG4gIHZhciB1c2VyQXJpYSA9IF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHt9LCBvcHRpb25hbFByb3BzKS5hcmlhO1xuXG4gIHZhciBjdXJyZW50QXJpYTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7XG4gIHZhciBzaG91bGRTa2lwVXBkYXRlID0gZmFsc2U7XG4gIHZhciByZWZlcmVuY2VzID0gdGlwcHlJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gIH0pO1xuICB2YXIgc2luZ2xldG9uID0ge1xuICAgIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlQXJpYURlc2NyaWJlZEJ5QXR0cmlidXRlKGlzU2hvdykge1xuICAgICAgICBpZiAoIWN1cnJlbnRBcmlhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHIgPSBcImFyaWEtXCIgKyBjdXJyZW50QXJpYTtcblxuICAgICAgICBpZiAoaXNTaG93ICYmICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQuc2V0QXR0cmlidXRlKGF0dHIsIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuLnRvb2x0aXAuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoXywgX3JlZikge1xuICAgICAgICAgIHZhciBhcmlhID0gX3JlZi5hcmlhO1xuXG4gICAgICAgICAgLy8gRW5zdXJlIGBhcmlhYCBmb3IgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBzdGF5cyBgbnVsbGAsIHdoaWxlXG4gICAgICAgICAgLy8gY2hhbmdpbmcgdGhlIGB1c2VyQXJpYWAgdmFsdWVcbiAgICAgICAgICBpZiAoYXJpYSAhPT0gdW5kZWZpbmVkICYmIGFyaWEgIT09IHVzZXJBcmlhKSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXNlckFyaWEgPSBhcmlhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2hvdWxkU2tpcFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBhcmlhOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzaG91bGRTa2lwVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgICAgICB0aXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZW5hYmxlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgICAgaGFuZGxlQXJpYURlc2NyaWJlZEJ5QXR0cmlidXRlKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7XG4gICAgICAgICAgaGFuZGxlQXJpYURlc2NyaWJlZEJ5QXR0cmlidXRlKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICB2YXIgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YodGFyZ2V0KTsgLy8gYmFpbC1vdXRcblxuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIGN1cnJlbnRBcmlhID0gdXNlckFyaWE7XG5cbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBoYW5kbGVBcmlhRGVzY3JpYmVkQnlBdHRyaWJ1dGUodHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0gdGFyZ2V0O1xuICAgICAgICAgIGluc3RhbmNlLnNldENvbnRlbnQodGlwcHlJbnN0YW5jZXNbaW5kZXhdLnByb3BzLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRpcHB5KGRpdigpLCBfZXh0ZW5kcyh7fSwgb3B0aW9uYWxQcm9wcywge1xuICAgIHBsdWdpbnM6IFtzaW5nbGV0b25dLmNvbmNhdChwbHVnaW5zKSxcbiAgICBhcmlhOiBudWxsLFxuICAgIHRyaWdnZXJUYXJnZXQ6IHJlZmVyZW5jZXNcbiAgfSkpO1xufTtcblxudmFyIEJVQkJMSU5HX0VWRU5UU19NQVAgPSB7XG4gIG1vdXNlb3ZlcjogJ21vdXNlZW50ZXInLFxuICBmb2N1c2luOiAnZm9jdXMnLFxuICBjbGljazogJ2NsaWNrJ1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGRlbGVnYXRlIGluc3RhbmNlIHRoYXQgY29udHJvbHMgdGhlIGNyZWF0aW9uIG9mIHRpcHB5IGluc3RhbmNlc1xuICogZm9yIGNoaWxkIGVsZW1lbnRzIChgdGFyZ2V0YCBDU1Mgc2VsZWN0b3IpLlxuICovXG5cbmZ1bmN0aW9uIGRlbGVnYXRlKHRhcmdldHMsIHByb3BzLFxuLyoqIEBkZXByZWNhdGVkIHVzZSBQcm9wcy5wbHVnaW5zICovXG5wbHVnaW5zKSB7XG4gIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHtcbiAgICBwbHVnaW5zID0gW107XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JXaGVuKCEocHJvcHMgJiYgcHJvcHMudGFyZ2V0KSwgWydZb3UgbXVzdCBzcGVjaXR5IGEgYHRhcmdldGAgcHJvcCBpbmRpY2F0aW5nIGEgQ1NTIHNlbGVjdG9yIHN0cmluZyBtYXRjaGluZycsICd0aGUgdGFyZ2V0IGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlY2VpdmUgYSB0aXBweS4nXS5qb2luKCcgJykpO1xuICB9XG5cbiAgcGx1Z2lucyA9IHByb3BzLnBsdWdpbnMgfHwgcGx1Z2lucztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICB2YXIgbmF0aXZlUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKHByb3BzLCBbJ3RhcmdldCddKTtcblxuICB2YXIgcGFyZW50UHJvcHMgPSBfZXh0ZW5kcyh7fSwgbmF0aXZlUHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zLFxuICAgIHRyaWdnZXI6ICdtYW51YWwnXG4gIH0pO1xuXG4gIHZhciBjaGlsZFByb3BzID0gX2V4dGVuZHMoe30sIG5hdGl2ZVByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICBzaG93T25DcmVhdGU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gdGlwcHkodGFyZ2V0cywgcGFyZW50UHJvcHMpO1xuICB2YXIgbm9ybWFsaXplZFJldHVyblZhbHVlID0gbm9ybWFsaXplVG9BcnJheShyZXR1cm5WYWx1ZSk7XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KHRhcmdldCk7XG5cbiAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCByZWxldmFudCB0cmlnZ2VyIHdpdGggZmFsbGJhY2tzOlxuICAgIC8vIDEuIENoZWNrIGBkYXRhLXRpcHB5LXRyaWdnZXJgIGF0dHJpYnV0ZSBvbiB0YXJnZXQgbm9kZVxuICAgIC8vIDIuIEZhbGxiYWNrIHRvIGB0cmlnZ2VyYCBwYXNzZWQgdG8gYGRlbGVnYXRlKClgXG4gICAgLy8gMy4gRmFsbGJhY2sgdG8gYGRlZmF1bHRQcm9wcy50cmlnZ2VyYFxuXG5cbiAgICB2YXIgdHJpZ2dlciA9IHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXRyaWdnZXInKSB8fCBwcm9wcy50cmlnZ2VyIHx8IGRlZmF1bHRQcm9wcy50cmlnZ2VyOyAvLyBPbmx5IGNyZWF0ZSB0aGUgaW5zdGFuY2UgaWYgdGhlIGJ1YmJsaW5nIGV2ZW50IG1hdGNoZXMgdGhlIHRyaWdnZXIgdHlwZVxuXG4gICAgaWYgKCFpbmNsdWRlcyh0cmlnZ2VyLCBCVUJCTElOR19FVkVOVFNfTUFQW2V2ZW50LnR5cGVdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKG5vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIG9uKHJlZmVyZW5jZSwgJ21vdXNlb3ZlcicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnZm9jdXNpbicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnY2xpY2snLCBvblRyaWdnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcblxuICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICBub3JtYWxpemVkUmV0dXJuVmFsdWUuZm9yRWFjaChhcHBseU11dGF0aW9ucyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxudmFyIGFuaW1hdGVGaWxsID0ge1xuICBuYW1lOiAnYW5pbWF0ZUZpbGwnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlJHBvcHBlckNoaWxkID0gaW5zdGFuY2UucG9wcGVyQ2hpbGRyZW4sXG4gICAgICAgIHRvb2x0aXAgPSBfaW5zdGFuY2UkcG9wcGVyQ2hpbGQudG9vbHRpcCxcbiAgICAgICAgY29udGVudCA9IF9pbnN0YW5jZSRwb3BwZXJDaGlsZC5jb250ZW50O1xuICAgIHZhciBiYWNrZHJvcCA9IGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsID8gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCkgOiBudWxsO1xuXG4gICAgZnVuY3Rpb24gYWRkQmFja2Ryb3BUb1BvcHBlckNoaWxkcmVuKCkge1xuICAgICAgaW5zdGFuY2UucG9wcGVyQ2hpbGRyZW4uYmFja2Ryb3AgPSBiYWNrZHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBhZGRCYWNrZHJvcFRvUG9wcGVyQ2hpbGRyZW4oKTtcbiAgICAgICAgICB0b29sdGlwLmluc2VydEJlZm9yZShiYWNrZHJvcCwgdG9vbHRpcC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0ZWZpbGwnLCAnJyk7XG4gICAgICAgICAgdG9vbHRpcC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogJ3NoaWZ0LWF3YXknLFxuICAgICAgICAgICAgYXJyb3c6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gdG9vbHRpcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gTnVtYmVyKHRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKCdtcycsICcnKSk7IC8vIFRoZSBjb250ZW50IHNob3VsZCBmYWRlIGluIGFmdGVyIHRoZSBiYWNrZHJvcCBoYXMgbW9zdGx5IGZpbGxlZCB0aGVcbiAgICAgICAgICAvLyB0b29sdGlwIGVsZW1lbnQuIGBjbGlwLXBhdGhgIGlzIHRoZSBvdGhlciBhbHRlcm5hdGl2ZSBidXQgaXMgbm90XG4gICAgICAgICAgLy8gd2VsbC1zdXBwb3J0ZWQgYW5kIGlzIGJ1Z2d5IG9uIHNvbWUgZGV2aWNlcy5cblxuICAgICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIDEwKSArIFwibXNcIjtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICd2aXNpYmxlJyk7IC8vIFdhcm4gaWYgdGhlIHN0eWxlc2hlZXRzIGFyZSBub3QgbG9hZGVkXG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB3YXJuV2hlbihnZXRDb21wdXRlZFN0eWxlKGJhY2tkcm9wKS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJywgXCJUaGUgYHRpcHB5LmpzL2Rpc3QvYmFja2Ryb3AuY3NzYCBzdHlsZXNoZWV0IGhhcyBub3QgYmVlblxcbiAgICAgICAgICAgICAgaW1wb3J0ZWQhXFxuICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgIFRoZSBgYW5pbWF0ZUZpbGxgIHBsdWdpbiByZXF1aXJlcyB0aGlzIHN0eWxlc2hlZXQgdG8gd29yay5cIik7XG4gICAgICAgICAgICB3YXJuV2hlbihnZXRDb21wdXRlZFN0eWxlKHRvb2x0aXApLnRyYW5zZm9ybSA9PT0gJ25vbmUnLCBcIlRoZSBgdGlwcHkuanMvYW5pbWF0aW9ucy9zaGlmdC1hd2F5LmNzc2Agc3R5bGVzaGVldCBoYXMgbm90XFxuICAgICAgICAgICAgICBiZWVuIGltcG9ydGVkIVxcbiAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICBUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhpcyBzdHlsZXNoZWV0IHRvIHdvcmsuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMG1zJztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25BZnRlclVwZGF0ZTogZnVuY3Rpb24gb25BZnRlclVwZGF0ZSgpIHtcbiAgICAgICAgLy8gV2l0aCB0aGlzIHR5cGUgb2YgcHJvcCwgaXQncyBoaWdobHkgdW5saWtlbHkgaXQgd2lsbCBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIGR5bmFtaWNhbGx5LiBXZSdsbCBsZWF2ZSBvdXQgdGhlIGRpZmYvdXBkYXRlIGxvZ2ljIGl0IHRvIHNhdmUgYnl0ZXMuXG4gICAgICAgIC8vIGBwb3BwZXJDaGlsZHJlbmAgaXMgYXNzaWduZWQgYSBuZXcgb2JqZWN0IG9uQWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkQmFja2Ryb3BUb1BvcHBlckNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCkge1xuICB2YXIgYmFja2Ryb3AgPSBkaXYoKTtcbiAgYmFja2Ryb3AuY2xhc3NOYW1lID0gQkFDS0RST1BfQ0xBU1M7XG4gIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gIHJldHVybiBiYWNrZHJvcDtcbn1cblxudmFyIGZvbGxvd0N1cnNvciA9IHtcbiAgbmFtZTogJ2ZvbGxvd0N1cnNvcicsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IGluc3RhbmNlLnBvcHBlcjtcbiAgICB2YXIgb3JpZ2luYWxSZWZlcmVuY2UgPSBudWxsOyAvLyBTdXBwb3J0IGlmcmFtZSBjb250ZXh0c1xuICAgIC8vIFN0YXRpYyBjaGVjayB0aGF0IGFzc3VtZXMgYW55IG9mIHRoZSBgdHJpZ2dlclRhcmdldGAgb3IgYHJlZmVyZW5jZWBcbiAgICAvLyBub2RlcyB3aWxsIG5ldmVyIGNoYW5nZSBkb2N1bWVudHMsIGV2ZW4gd2hlbiB0aGV5IGFyZSB1cGRhdGVkXG5cbiAgICB2YXIgZG9jID0gZ2V0T3duZXJEb2N1bWVudChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7IC8vIEludGVybmFsIHN0YXRlXG5cbiAgICB2YXIgbGFzdE1vdXNlTW92ZUV2ZW50O1xuICAgIHZhciBtb3VzZUNvb3JkcyA9IG51bGw7XG4gICAgdmFyIGlzSW50ZXJuYWxseVNldHRpbmdDb250cm9sbGVkUHJvcCA9IGZhbHNlOyAvLyBUaGVzZSBhcmUgY29udHJvbGxlZCBieSB0aGlzIHBsdWdpbiwgc28gd2UgbmVlZCB0byBzdG9yZSB0aGUgdXNlcidzXG4gICAgLy8gb3JpZ2luYWwgcHJvcCB2YWx1ZVxuXG4gICAgdmFyIHVzZXJQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgZnVuY3Rpb24gc2V0VXNlclByb3BzKHByb3BzKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB1c2VyUHJvcHNbcHJvcF0gPSB1c2VJZkRlZmluZWQocHJvcHNbcHJvcF0sIHVzZXJQcm9wc1twcm9wXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJc01hbnVhbCgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLnRyaW0oKSA9PT0gJ21hbnVhbCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SXNFbmFibGVkKCkge1xuICAgICAgLy8gIzU5N1xuICAgICAgdmFyIGlzVmFsaWRNb3VzZUV2ZW50ID0gZ2V0SXNNYW51YWwoKSA/IHRydWUgOiAvLyBDaGVjayBpZiBhIGtleWJvYXJkIFwiY2xpY2tcIlxuICAgICAgbW91c2VDb29yZHMgIT09IG51bGwgJiYgIShtb3VzZUNvb3Jkcy5jbGllbnRYID09PSAwICYmIG1vdXNlQ29vcmRzLmNsaWVudFkgPT09IDApO1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciAmJiBpc1ZhbGlkTW91c2VFdmVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJc0luaXRpYWxCZWhhdmlvcigpIHtcbiAgICAgIHJldHVybiBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fCBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgPT09ICdpbml0aWFsJyAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRSZWZlcmVuY2UoKSB7XG4gICAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgJiYgb3JpZ2luYWxSZWZlcmVuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0gb3JpZ2luYWxSZWZlcmVuY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUGxhY2VtZW50KCkge1xuICAgICAgLy8gRHVlIHRvIGBnZXRWaXJ0dWFsT2Zmc2V0cygpYCwgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBwbGFjZW1lbnQgaWYgaXQnc1xuICAgICAgLy8gc2hpZnRlZCAoc3RhcnQgLT4gZW5kLCBhbmQgdmljZS12ZXJzYSlcbiAgICAgIC8vIEVhcmx5IGJhaWwtb3V0XG4gICAgICBpZiAoIWdldElzRW5hYmxlZCgpICYmIGluc3RhbmNlLnByb3BzLnBsYWNlbWVudCA9PT0gdXNlclByb3BzLnBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwbGFjZW1lbnQgPSB1c2VyUHJvcHMucGxhY2VtZW50O1xuICAgICAgdmFyIHNoaWZ0ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG4gICAgICBpc0ludGVybmFsbHlTZXR0aW5nQ29udHJvbGxlZFByb3AgPSB0cnVlO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICBwbGFjZW1lbnQ6IGdldElzRW5hYmxlZCgpICYmIHNoaWZ0ID8gcGxhY2VtZW50LnJlcGxhY2Uoc2hpZnQsIHNoaWZ0ID09PSAnc3RhcnQnID8gJ2VuZCcgOiAnc3RhcnQnKSA6IHBsYWNlbWVudFxuICAgICAgfSk7XG4gICAgICBpc0ludGVybmFsbHlTZXR0aW5nQ29udHJvbGxlZFByb3AgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb3BwZXJMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAoIWluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUG9wcGVyJ3Mgc2Nyb2xsIGxpc3RlbmVycyBtYWtlIHNlbnNlIGZvciBgdHJ1ZWAgb25seS4gVE9ETzogd29yayBvdXRcbiAgICAgIC8vIGhvdyB0byBvbmx5IGxpc3RlbiBob3Jpem9udGFsIHNjcm9sbCBmb3IgXCJob3Jpem9udGFsXCIgYW5kIHZlcnRpY2FsXG4gICAgICAvLyBzY3JvbGwgZm9yIFwidmVydGljYWxcIlxuXG5cbiAgICAgIGlmIChnZXRJc0VuYWJsZWQoKSAmJiBnZXRJc0luaXRpYWxCZWhhdmlvcigpKSB7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZUxpc3RlbmVyKCkge1xuICAgICAgaWYgKGdldElzRW5hYmxlZCgpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldFJlZmVyZW5jZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXJMYXN0TW91c2VNb3ZlKCkge1xuICAgICAgaWYgKGdldElzRW5hYmxlZCgpKSB7XG4gICAgICAgIG9uTW91c2VNb3ZlKGxhc3RNb3VzZU1vdmVFdmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoKSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgdmFyIF9sYXN0TW91c2VNb3ZlRXZlbnQgPSBsYXN0TW91c2VNb3ZlRXZlbnQgPSBldmVudCxcbiAgICAgICAgICBjbGllbnRYID0gX2xhc3RNb3VzZU1vdmVFdmVudC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfbGFzdE1vdXNlTW92ZUV2ZW50LmNsaWVudFk7XG5cbiAgICAgIGlmICghaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgfHwgIWluc3RhbmNlLnN0YXRlLmN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGUgaW5zdGFuY2UgaXMgaW50ZXJhY3RpdmUsIGF2b2lkIHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB1bmxlc3MgaXQnc1xuICAgICAgLy8gb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcblxuXG4gICAgICB2YXIgaXNDdXJzb3JPdmVyUmVmZXJlbmNlID0gY2xvc2VzdENhbGxiYWNrKGV2ZW50LnRhcmdldCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gcmVmZXJlbmNlO1xuICAgICAgfSk7XG4gICAgICB2YXIgZm9sbG93Q3Vyc29yID0gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yO1xuICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgdmFyIGlzVmVydGljYWwgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCc7XG4gICAgICB2YXIgaXNWZXJ0aWNhbFBsYWNlbWVudCA9IGluY2x1ZGVzKFsndG9wJywgJ2JvdHRvbSddLCBnZXRCYXNlUGxhY2VtZW50KGluc3RhbmNlLnN0YXRlLmN1cnJlbnRQbGFjZW1lbnQpKTsgLy8gVGhlIHZpcnR1YWwgcmVmZXJlbmNlIG5lZWRzIHNvbWUgc2l6ZSB0byBwcmV2ZW50IGl0c2VsZiBmcm9tIG92ZXJmbG93aW5nXG5cbiAgICAgIHZhciBfZ2V0VmlydHVhbE9mZnNldHMgPSBnZXRWaXJ0dWFsT2Zmc2V0cyhwb3BwZXIsIGlzVmVydGljYWxQbGFjZW1lbnQpLFxuICAgICAgICAgIHNpemUgPSBfZ2V0VmlydHVhbE9mZnNldHMuc2l6ZSxcbiAgICAgICAgICB4ID0gX2dldFZpcnR1YWxPZmZzZXRzLngsXG4gICAgICAgICAgeSA9IF9nZXRWaXJ0dWFsT2Zmc2V0cy55O1xuXG4gICAgICBpZiAoaXNDdXJzb3JPdmVyUmVmZXJlbmNlIHx8ICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBQcmVzZXJ2ZSBjdXN0b20gcG9zaXRpb24gUmVmZXJlbmNlT2JqZWN0cywgd2hpY2ggbWF5IG5vdCBiZSB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgdGFyZ2V0cyByZWZlcmVuY2UgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG4gICAgICAgIGlmIChvcmlnaW5hbFJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG9yaWdpbmFsUmVmZXJlbmNlID0gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0ge1xuICAgICAgICAgIHJlZmVyZW5jZU5vZGU6IHJlZmVyZW5jZSxcbiAgICAgICAgICAvLyBUaGVzZSBgY2xpZW50YCB2YWx1ZXMgZG9uJ3QgZ2V0IHVzZWQgYnkgUG9wcGVyLmpzIGlmIHRoZXkgYXJlIDBcbiAgICAgICAgICBjbGllbnRXaWR0aDogMCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQ6IDAsXG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBpc1ZlcnRpY2FsUGxhY2VtZW50ID8gc2l6ZSA6IDAsXG4gICAgICAgICAgICAgIGhlaWdodDogaXNWZXJ0aWNhbFBsYWNlbWVudCA/IDAgOiBzaXplLFxuICAgICAgICAgICAgICB0b3A6IChpc0hvcml6b250YWwgPyByZWN0LnRvcCA6IGNsaWVudFkpIC0geSxcbiAgICAgICAgICAgICAgYm90dG9tOiAoaXNIb3Jpem9udGFsID8gcmVjdC5ib3R0b20gOiBjbGllbnRZKSArIHksXG4gICAgICAgICAgICAgIGxlZnQ6IChpc1ZlcnRpY2FsID8gcmVjdC5sZWZ0IDogY2xpZW50WCkgLSB4LFxuICAgICAgICAgICAgICByaWdodDogKGlzVmVydGljYWwgPyByZWN0LnJpZ2h0IDogY2xpZW50WCkgKyB4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0luaXRpYWxCZWhhdmlvcigpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoXywgcGFydGlhbFByb3BzKSB7XG4gICAgICAgIGlmICghaXNJbnRlcm5hbGx5U2V0dGluZ0NvbnRyb2xsZWRQcm9wKSB7XG4gICAgICAgICAgc2V0VXNlclByb3BzKHBhcnRpYWxQcm9wcyk7XG5cbiAgICAgICAgICBpZiAocGFydGlhbFByb3BzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgaGFuZGxlUGxhY2VtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEEgbmV3IHBsYWNlbWVudCBjYXVzZXMgdGhlIHBvcHBlckluc3RhbmNlIHRvIGJlIHJlY3JlYXRlZFxuXG5cbiAgICAgICAgaWYgKHBhcnRpYWxQcm9wcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBoYW5kbGVQb3BwZXJMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSAvLyBXYWl0IGZvciBgLnVwZGF0ZSgpYCB0byBzZXQgYGluc3RhbmNlLnN0YXRlLmN1cnJlbnRQbGFjZW1lbnRgIHRvXG4gICAgICAgIC8vIHRoZSBuZXcgcGxhY2VtZW50XG5cblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodHJpZ2dlckxhc3RNb3VzZU1vdmUpO1xuICAgICAgfSxcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIHRyaWdnZXJMYXN0TW91c2VNb3ZlKCk7XG4gICAgICAgIGhhbmRsZVBvcHBlckxpc3RlbmVycygpO1xuICAgICAgfSxcbiAgICAgIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge1xuICAgICAgICBpZiAoZ2V0SXNNYW51YWwoKSkge1xuICAgICAgICAgIC8vIFNpbmNlIHRoZXJlJ3Mgbm8gdHJpZ2dlciBldmVudCB0byB1c2UsIHdlIGhhdmUgdG8gdXNlIHRoZXNlIGFzXG4gICAgICAgICAgLy8gYmFzZWxpbmUgY29vcmRzXG4gICAgICAgICAgbW91c2VDb29yZHMgPSB7XG4gICAgICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICAgICAgY2xpZW50WTogMFxuICAgICAgICAgIH07IC8vIEVuc3VyZSBgbGFzdE1vdXNlTW92ZUV2ZW50YCBkb2Vzbid0IGFjY2VzcyBhbnkgb3RoZXIgcHJvcGVydGllc1xuICAgICAgICAgIC8vIG9mIGEgTW91c2VFdmVudCBoZXJlXG5cbiAgICAgICAgICBsYXN0TW91c2VNb3ZlRXZlbnQgPSBtb3VzZUNvb3JkcztcbiAgICAgICAgICBoYW5kbGVQbGFjZW1lbnQoKTtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgLy8gVGFwcGluZyBvbiB0b3VjaCBkZXZpY2VzIGNhbiB0cmlnZ2VyIGBtb3VzZWVudGVyYCB0aGVuIGBmb2N1c2BcbiAgICAgICAgaWYgKG1vdXNlQ29vcmRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICBtb3VzZUNvb3JkcyA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsYXN0TW91c2VNb3ZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZVBsYWNlbWVudCgpO1xuICAgICAgICBoYW5kbGVNb3VzZU1vdmVMaXN0ZW5lcigpO1xuICAgICAgfSxcbiAgICAgIG9uVW50cmlnZ2VyOiBmdW5jdGlvbiBvblVudHJpZ2dlcigpIHtcbiAgICAgICAgLy8gSWYgdW50cmlnZ2VyZWQgYmVmb3JlIHNob3dpbmcgKGBvbkhpZGRlbmAgd2lsbCBuZXZlciBiZSBpbnZva2VkKVxuICAgICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgbW91c2VDb29yZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICByZXNldFJlZmVyZW5jZSgpO1xuICAgICAgICBtb3VzZUNvb3JkcyA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFZpcnR1YWxPZmZzZXRzKHBvcHBlciwgaXNWZXJ0aWNhbFBsYWNlbWVudCkge1xuICB2YXIgc2l6ZSA9IGlzVmVydGljYWxQbGFjZW1lbnQgPyBwb3BwZXIub2Zmc2V0V2lkdGggOiBwb3BwZXIub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHNpemU6IHNpemUsXG4gICAgeDogaXNWZXJ0aWNhbFBsYWNlbWVudCA/IHNpemUgOiAwLFxuICAgIHk6IGlzVmVydGljYWxQbGFjZW1lbnQgPyAwIDogc2l6ZVxuICB9O1xufVxuXG4vLyBwb3NpdGlvbi4gVGhpcyB3aWxsIHJlcXVpcmUgdGhlIGBmb2xsb3dDdXJzb3JgIHBsdWdpbidzIGZpeGVzIGZvciBvdmVyZmxvd1xuLy8gZHVlIHRvIHVzaW5nIGV2ZW50LmNsaWVudFgvWSB2YWx1ZXMuIChub3JtYWxpemVkUGxhY2VtZW50LCBnZXRWaXJ0dWFsT2Zmc2V0cylcblxudmFyIGlubGluZVBvc2l0aW9uaW5nID0ge1xuICBuYW1lOiAnaW5saW5lUG9zaXRpb25pbmcnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuICEhaW5zdGFuY2UucHJvcHMuaW5saW5lUG9zaXRpb25pbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgICAgICAgaWYgKGdldElzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7XG4gICAgICAgIGlmICghZ2V0SXNFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5yZWZlcmVuY2UgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlTm9kZTogcmVmZXJlbmNlLFxuICAgICAgICAgIC8vIFRoZXNlIGBjbGllbnRgIHZhbHVlcyBkb24ndCBnZXQgdXNlZCBieSBQb3BwZXIuanMgaWYgdGhleSBhcmUgMFxuICAgICAgICAgIGNsaWVudFdpZHRoOiAwLFxuICAgICAgICAgIGNsaWVudEhlaWdodDogMCxcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoaW5zdGFuY2Uuc3RhdGUuY3VycmVudFBsYWNlbWVudCAmJiBnZXRCYXNlUGxhY2VtZW50KGluc3RhbmNlLnN0YXRlLmN1cnJlbnRQbGFjZW1lbnQpLCByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFycmF5RnJvbShyZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KGN1cnJlbnRCYXNlUGxhY2VtZW50LCBib3VuZGluZ1JlY3QsIGNsaWVudFJlY3RzKSB7XG4gIC8vIE5vdCBhbiBpbmxpbmUgZWxlbWVudCwgb3IgcGxhY2VtZW50IGlzIG5vdCB5ZXQga25vd25cbiAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA8IDIgfHwgY3VycmVudEJhc2VQbGFjZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICB9XG5cbiAgc3dpdGNoIChjdXJyZW50QmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICB2YXIgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzVG9wID0gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICd0b3AnO1xuICAgICAgICB2YXIgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgdmFyIGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAge1xuICAgICAgICB2YXIgbWluTGVmdCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGNsaWVudFJlY3RzLm1hcChmdW5jdGlvbiAocmVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdHMubGVmdDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbWF4UmlnaHQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBjbGllbnRSZWN0cy5tYXAoZnVuY3Rpb24gKHJlY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RzLnJpZ2h0O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0JyA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF90b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICB2YXIgX2JvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICB2YXIgX2xlZnQgPSBtaW5MZWZ0O1xuICAgICAgICB2YXIgX3JpZ2h0ID0gbWF4UmlnaHQ7XG5cbiAgICAgICAgdmFyIF93aWR0aCA9IF9yaWdodCAtIF9sZWZ0O1xuXG4gICAgICAgIHZhciBfaGVpZ2h0ID0gX2JvdHRvbSAtIF90b3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IF90b3AsXG4gICAgICAgICAgYm90dG9tOiBfYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IF9sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBfcmlnaHQsXG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIHN0aWNreSA9IHtcbiAgbmFtZTogJ3N0aWNreScsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IGluc3RhbmNlLnBvcHBlcjtcblxuICAgIGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA/IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnJlZmVyZW5jZSA6IHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDaGVjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdHJ1ZSB8fCBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UmVmUmVjdCA9IG51bGw7XG4gICAgdmFyIHByZXZQb3BSZWN0ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgdmFyIGN1cnJlbnRSZWZSZWN0ID0gc2hvdWxkQ2hlY2soJ3JlZmVyZW5jZScpID8gZ2V0UmVmZXJlbmNlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuICAgICAgdmFyIGN1cnJlbnRQb3BSZWN0ID0gc2hvdWxkQ2hlY2soJ3BvcHBlcicpID8gcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcblxuICAgICAgaWYgKGN1cnJlbnRSZWZSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZSZWZSZWN0LCBjdXJyZW50UmVmUmVjdCkgfHwgY3VycmVudFBvcFJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlBvcFJlY3QsIGN1cnJlbnRQb3BSZWN0KSkge1xuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcHJldlJlZlJlY3QgPSBjdXJyZW50UmVmUmVjdDtcbiAgICAgIHByZXZQb3BSZWN0ID0gY3VycmVudFBvcFJlY3Q7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnN0aWNreSkge1xuICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVSZWN0c0RpZmZlcmVudChyZWN0QSwgcmVjdEIpIHtcbiAgaWYgKHJlY3RBICYmIHJlY3RCKSB7XG4gICAgcmV0dXJuIHJlY3RBLnRvcCAhPT0gcmVjdEIudG9wIHx8IHJlY3RBLnJpZ2h0ICE9PSByZWN0Qi5yaWdodCB8fCByZWN0QS5ib3R0b20gIT09IHJlY3RCLmJvdHRvbSB8fCByZWN0QS5sZWZ0ICE9PSByZWN0Qi5sZWZ0O1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7IGFuaW1hdGVGaWxsLCBjcmVhdGVTaW5nbGV0b24sIGRlbGVnYXRlLCBmb2xsb3dDdXJzb3IsIGlubGluZVBvc2l0aW9uaW5nLCBzdGlja3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpcHB5LmVzbS5qcy5tYXBcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGlnaHQtYm9yZGVyLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxudmFyIGV4cG9ydGVkID0gY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHt9O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlZDsiLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJpbXBvcnQgeyBfX25vbk51bGwsIGFic3VyZCB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBBbm5vdGF0aW9uLCBib29sXyB9IGZyb20gXCIuL3V0aWwvTGF0dGljZVwiXG5pbXBvcnQgeyBpbnRlcnNlY3Rpb24sIHVuaW9uIH0gZnJvbSBcIi4vdXRpbC9TZXRcIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgX19kZWx0YXMgfSBmcm9tIFwiLi9EZWx0YVwiXG5pbXBvcnQgeyBFeHBsIH0gZnJvbSBcIi4vRXhwbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4vRXhwclwiXG5pbXBvcnQgeyBWYWx1ZSwgXyB9IGZyb20gXCIuL1ZhbHVlXCJcblxuZXhwb3J0IHR5cGUgQW5ub3RhdGVkID0gRXhwci5TeW50YXhOb2RlIHwgRXhwbFZhbHVlXG5leHBvcnQgdHlwZSBTbGljZSA9IFNldDxBbm5vdGF0ZWQ+XG5cbmV4cG9ydCBmdW5jdGlvbiBhbm5vdGF0ZWQgKHY6IFZhbHVlKTogdiBpcyBBbm5vdGF0ZWQge1xuICAgcmV0dXJuIHYgaW5zdGFuY2VvZiBFeHByLlN5bnRheE5vZGUgfHwgdiBpbnN0YW5jZW9mIEV4cGxWYWx1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXPOsSAodjogQW5ub3RhdGVkKTogQW5ub3RhdGlvbiB7XG4gICByZXR1cm4gX19zbGljZS5pcyh2KVxufVxuXG4vLyBDdXJyZW50bHkgbm8gZGVsdGFzIGFyZSBhc3NvY2lhdGVkIHdpdGggYW5ub3RhdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gc2V0zrE8VCBleHRlbmRzIEFubm90YXRlZD4gKM6xOiBBbm5vdGF0aW9uLCB2OiBUKTogdm9pZCB7XG4gICBfX3NsaWNlLnNldCh2LCDOsSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldGpvaW7OsSAozrE6IEFubm90YXRpb24sIHY6IEFubm90YXRlZCk6IHZvaWQge1xuICAgc2V0zrEoYm9vbF8uam9pbijOsSwgaXPOsSh2KSksIHYpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRtZWV0zrEgKM6xOiBBbm5vdGF0aW9uLCB2OiBBbm5vdGF0ZWQpOiB2b2lkIHtcbiAgIHNldM6xKGJvb2xfLm1lZXQozrEsIGlzzrEodikpLCB2KVxufVxuXG5leHBvcnQgZW51bSBEaXJlY3Rpb24geyBGd2QsIEJ3ZCB9XG5cbmV4cG9ydCBjbGFzcyBBbm5vdGF0aW9ucyB7XG4gICBhbm46IFNsaWNlID0gbmV3IFNldCgpIC8vIHVuYXZhaWxhYmxlIG5vZGVzIChmd2QpIG9yIG5lZWRlZCBub2RlcyAoYndkKVxuICAgZGlyZWN0aW9uOiBEaXJlY3Rpb24gPSBEaXJlY3Rpb24uRndkXG5cbiAgIC8vIFdoZXRoZXIgdiBpcyBuZWVkZWQgKGdvaW5nIGJhY2t3YXJkKSBvciBhdmFpbGFibGUgKGdvaW5nIGZvcndhcmQpLlxuICAgaXMgKHY6IEFubm90YXRlZCk6IEFubm90YXRpb24ge1xuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uRndkKSB7XG4gICAgICAgICByZXR1cm4gYm9vbF8ubmVnYXRlKHRoaXMuYW5uLmhhcyh2KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5hbm4uaGFzKHYpXG4gICAgICB9XG4gICB9XG4gICBcbiAgIC8vIEdvaW5nIGZvcndhcmQsIGFubm90YXRpb24gdXBkYXRlcyBtdXN0IGJlIGRlY3JlYXNpbmc7IGdvaW5nIGJhY2t3YXJkLCBpbmNyZWFzaW5nLiBUaGlzIGlzIGJlY2F1c2UgXG4gICAvLyBmb3J3YXJkIHNsaWNpbmcgcHJvcGFnYXRlcyBub24tYXZhaWxhYmlsaXR5LCB3aGVyZWFzIGJhY2t3YXJkIHNsaWNpbmcgcHJvcGFnYXRlcyBkZW1hbmQuXG4gICBzZXQgKHY6IEFubm90YXRlZCwgzrE6IEFubm90YXRpb24pOiB2b2lkIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQ6IEFubm90YXRpb24gPSB0aGlzLmlzKHYpXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Gd2QgJiYgzrEgPCBjdXJyZW50IHx8XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Cd2QgJiYgzrEgPiBjdXJyZW50KSB7XG4gICAgICAgICB0aGlzLmFubi5hZGQodilcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uRndkICYmIM6xID4gY3VycmVudCB8fFxuICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Cd2QgJiYgzrEgPCBjdXJyZW50KSB7XG4gICAgICAgICBhYnN1cmQoYEluY29tcGF0aWJsZSB1cGRhdGUgb2YgYW5ub3RhdGlvbiBmcm9tICR7Y3VycmVudH0gdG8gJHvOsX0uYCwgY3VycmVudCwgzrEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gaWRlbXBvdGVudFxuICAgICAgfVxuICAgfVxuXG4gICByZXNldCAoZGlyZWN0aW9uOiBEaXJlY3Rpb24pOiB2b2lkIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uXG4gICAgICB0aGlzLmFubiA9IG5ldyBTZXQoKVxuICAgfVxuXG4gICByZXN0cmljdFRvICh0dnM6IEV4cGxWYWx1ZVtdKTogU2xpY2Uge1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbih0aGlzLmFubiwgdW5pb24oLi4udHZzLm1hcCh0diA9PiBleHBsRGVzY2VuZGFudHModHYpKSkpXG4gICB9XG59XG5cbmZ1bmN0aW9uIGV4cGxEZXNjZW5kYW50cyAodHY6IEV4cGxWYWx1ZSk6IFNldDxFeHBsVmFsdWU+IHtcbiAgIGNvbnN0IGRlc2M6IFNldDxFeHBsVmFsdWU+ID0gbmV3IFNldCgpXG4gICBleHBsRGVzY2VuZGFudHNfYXV4KHR2LCBkZXNjKVxuICAgcmV0dXJuIGRlc2Ncbn1cblxuZnVuY3Rpb24gZXhwbERlc2NlbmRhbnRzX2F1eCAodHY6IEV4cGxWYWx1ZSwgZGVzYzogU2V0PEV4cGxWYWx1ZT4pOiB2b2lkIHtcbiAgIGRlc2MuYWRkKHR2KVxuICAgaWYgKHR2LnYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgIGNvbnN0IHt0LCB2fTogRXhwbFZhbHVlPERhdGFWYWx1ZT4gPSB0diBhcyBFeHBsVmFsdWU8RGF0YVZhbHVlPlxuICAgICAgRXhwbC5leHBsQ2hpbGRyZW4odCx2KS5mb3JFYWNoKCh0djogRXhwbFZhbHVlKTogdm9pZCA9PiB7IFxuICAgICAgICAgZXhwbERlc2NlbmRhbnRzX2F1eCh0diwgZGVzYylcbiAgICAgIH0pXG4gICB9XG59XG5cbmV4cG9ydCBjb25zdCBfX3NsaWNlOiBBbm5vdGF0aW9ucyA9IG5ldyBBbm5vdGF0aW9ucygpXG4iLCJpbXBvcnQgeyBhYnN1cmQgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgaW5pdERhdGFUeXBlIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRGF0YVZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IElkLCBQZXJzaXN0ZW50LCBWYWx1ZSwgXywgbWFrZSB9IGZyb20gXCIuL1ZhbHVlXCJcbmltcG9ydCB7IGF0IH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuLy8gU2VlIEVudiBmb3IgY29udmVudGlvbiByZWdhcmRpbmcgaW5zdGFuY2UgbWVtYmVycyBvbiByZWZsZWN0ZWQgZGF0YXR5cGVzLlxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQm9vbCBleHRlbmRzIERhdGFWYWx1ZTxcIkJvb2xcIj4ge1xufVxuXG5leHBvcnQgY2xhc3MgVHJ1ZSBleHRlbmRzIEJvb2wge1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ1ZV8gKCk6IChrOiBJZCkgPT4gQm9vbCB7XG4gICByZXR1cm4gYXQoVHJ1ZSlcbn1cblxuZXhwb3J0IGNsYXNzIEZhbHNlIGV4dGVuZHMgQm9vbCB7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWxzZV8gKCk6IChrOiBJZCkgPT4gQm9vbCB7XG4gICByZXR1cm4gYXQoRmFsc2UpXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMaXN0PFQgPSBWYWx1ZT4gZXh0ZW5kcyBEYXRhVmFsdWU8XCJMaXN0XCI+IHtcbiAgIHN0YXRpYyBmcm9tQXJyYXk8VCBleHRlbmRzIFBlcnNpc3RlbnQ+ICh4zIU6IFRbXSk6IExpc3Q8VD4ge1xuICAgICAgbGV0IHjMhcq5OiBMaXN0PFQ+ID0gbmlsKClcbiAgICAgIGZvciAobGV0IG46IG51bWJlciA9IHjMhS5sZW5ndGggLSAxOyBuID49IDA7IC0tbikge1xuICAgICAgICAgeMyFyrkgPSBjb25zKHjMhVtuXSwgeMyFyrkpXG4gICAgICB9XG4gICAgICByZXR1cm4geMyFyrlcbiAgIH1cblxuICAgdG9BcnJheSAoKTogVFtdIHtcbiAgICAgIGNvbnN0IHjMhTogVFtdID0gW11cbiAgICAgIHRoaXMudG9BcnJheV8oeMyFKVxuICAgICAgcmV0dXJuIHjMhVxuICAgfVxuXG4gICB0b0FycmF5XyAoeMyFOiBUW10pOiB2b2lkIHtcbiAgICAgIGlmIChDb25zLmlzKHRoaXMpKSB7XG4gICAgICAgICB4zIUucHVzaCh0aGlzLmhlYWQpXG4gICAgICAgICB0aGlzLnRhaWwudG9BcnJheV8oeMyFKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoTmlsLmlzKHRoaXMpKSB7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOaWw8VCA9IFZhbHVlPiBleHRlbmRzIExpc3Q8VD4ge1xuICAgc3RhdGljIGlzPFQ+ICh4czogTGlzdDxUPik6IHhzIGlzIE5pbDxUPiB7XG4gICAgICByZXR1cm4geHMgaW5zdGFuY2VvZiBOaWxcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5pbDxUPiAoKTogTGlzdDxUPiB7XG4gICByZXR1cm4gbWFrZShOaWwpIGFzIE5pbDxUPlxufVxuXG5leHBvcnQgY2xhc3MgQ29uczxUID0gVmFsdWU+IGV4dGVuZHMgTGlzdDxUPiB7XG4gICBoZWFkOiBUID0gX1xuICAgdGFpbDogTGlzdDxUPiA9IF9cblxuICAgc3RhdGljIGlzPFQ+ICh4czogTGlzdDxUPik6IHhzIGlzIENvbnM8VD4ge1xuICAgICAgcmV0dXJuIHhzIGluc3RhbmNlb2YgQ29uc1xuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uczxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKGhlYWQ6IFQsIHRhaWw6IExpc3Q8VD4pOiBDb25zPFQ+IHtcbiAgIHJldHVybiBtYWtlKENvbnMsIGhlYWQsIHRhaWwpIGFzIENvbnM8VD5cbn1cblxuZXhwb3J0IGNsYXNzIFBhaXI8VCA9IFZhbHVlLCBVID0gVmFsdWU+IGV4dGVuZHMgRGF0YVZhbHVlPFwiUGFpclwiPiB7XG4gICBmc3Q6IFQgPSBfXG4gICBzbmQ6IFUgPSBfXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWlyPFQgZXh0ZW5kcyBQZXJzaXN0ZW50LCBVIGV4dGVuZHMgUGVyc2lzdGVudD4gKGZzdDogVCwgc25kOiBVKTogUGFpcjxULCBVPiB7XG4gICByZXR1cm4gbWFrZShQYWlyLCBmc3QsIHNuZCkgYXMgUGFpcjxULCBVPlxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJlZTxUIGV4dGVuZHMgUGVyc2lzdGVudD4gZXh0ZW5kcyBEYXRhVmFsdWU8XCJUcmVlXCI+IHtcbiAgIHRvQXJyYXkgKCk6IFRbXSB7XG4gICAgICBjb25zdCB4zIU6IFRbXSA9IFtdXG4gICAgICB0aGlzLnRvQXJyYXlfKHjMhSlcbiAgICAgIHJldHVybiB4zIVcbiAgIH1cblxuICAgdG9BcnJheV8gKHjMhTogVFtdKTogdm9pZCB7XG4gICAgICBpZiAoTm9uRW1wdHkuaXModGhpcykpIHtcbiAgICAgICAgIHRoaXMubGVmdC50b0FycmF5Xyh4zIUpXG4gICAgICAgICB4zIUucHVzaCh0aGlzLnQpXG4gICAgICAgICB0aGlzLnJpZ2h0LnRvQXJyYXlfKHjMhSlcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKEVtcHR5LmlzKHRoaXMpKSB7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbXB0eTxUIGV4dGVuZHMgUGVyc2lzdGVudD4gZXh0ZW5kcyBUcmVlPFQ+IHtcbiAgIHN0YXRpYyBpczxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKHQ6IFRyZWU8VD4pOiB0IGlzIEVtcHR5PFQ+IHtcbiAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgRW1wdHlcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5PFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAoKTogRW1wdHk8VD4ge1xuICAgcmV0dXJuIG1ha2UoRW1wdHkpIGFzIEVtcHR5PFQ+XG59XG5cbmV4cG9ydCBjbGFzcyBOb25FbXB0eTxUIGV4dGVuZHMgUGVyc2lzdGVudD4gZXh0ZW5kcyBUcmVlPFQ+IHtcbiAgIGxlZnQ6IFRyZWU8VD4gPSBfXG4gICB0OiBUID0gX1xuICAgcmlnaHQ6IFRyZWU8VD4gPSBfXG5cbiAgIHN0YXRpYyBpczxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKHQ6IFRyZWU8VD4pOiB0IGlzIE5vbkVtcHR5PFQ+IHtcbiAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgTm9uRW1wdHlcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vbkVtcHR5IDxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKGxlZnQ6IFRyZWU8VD4sIHQ6IFQsIHJpZ2h0OiBUcmVlPFQ+KTogTm9uRW1wdHk8VD4ge1xuICAgcmV0dXJuIG1ha2UoTm9uRW1wdHksIGxlZnQsIHQsIHJpZ2h0KSBhcyBOb25FbXB0eTxUPlxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT3B0aW9uPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiBleHRlbmRzIERhdGFWYWx1ZTxcIk9wdGlvblwiPiB7XG59XG5cbmV4cG9ydCBjbGFzcyBOb25lPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiBleHRlbmRzIE9wdGlvbjxUPiB7XG4gICBzdGF0aWMgaXM8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IChvOiBPcHRpb248VD4pOiBvIGlzIE5vbmU8VD4ge1xuICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBOb25lXG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTb21lPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiBleHRlbmRzIE9wdGlvbjxUPiB7XG4gICB0OiBUID0gX1xuXG4gICBzdGF0aWMgaXM8VCBleHRlbmRzIFBlcnNpc3RlbnQ+IChvOiBPcHRpb248VD4pOiBvIGlzIFNvbWU8VD4ge1xuICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBTb21lXG4gICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPcmRlcmluZyBleHRlbmRzIERhdGFWYWx1ZTxcIk9yZGVyaW5nXCI+IHtcbn1cblxuZXhwb3J0IGNsYXNzIExUIGV4dGVuZHMgT3JkZXJpbmcge1xufVxuXG5leHBvcnQgY2xhc3MgR1QgZXh0ZW5kcyBPcmRlcmluZyB7XG59XG5cbmV4cG9ydCBjbGFzcyBFUSBleHRlbmRzIE9yZGVyaW5nIHtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBCYXNlVHlwZXMge1xuICAgZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpc2UgKCk6IHZvaWQge1xuICAgICAgaW5pdERhdGFUeXBlKEJvb2wsIFtUcnVlLCBGYWxzZV0pXG4gICAgICBpbml0RGF0YVR5cGUoTGlzdCwgW05pbCwgQ29uc10pXG4gICAgICBpbml0RGF0YVR5cGUoT3B0aW9uLCBbU29tZSwgTm9uZV0pXG4gICAgICBpbml0RGF0YVR5cGUoT3JkZXJpbmcsIFtMVCwgR1QsIEVRXSlcbiAgICAgIGluaXREYXRhVHlwZShQYWlyLCBbUGFpcl0pXG4gICAgICBpbml0RGF0YVR5cGUoVHJlZSwgW0VtcHR5LCBOb25FbXB0eV0pXG4gICB9XG59XG4iLCJpbXBvcnQgeyBBQ2xhc3MsIENsYXNzLCBfX25vbk51bGwgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgRGF0YVZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi9FeHBsXCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi9FeHByXCJcbmltcG9ydCB7IERhdGFFbGltIH0gZnJvbSBcIi4vTWF0Y2hcIlxuaW1wb3J0IHsgTnVtLCBQcmltVmFsdWUsIFN0ciwgXywgZmllbGRzIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgzr0sIHN0ciB9IGZyb20gXCIuL1ZlcnNpb25lZFwiXG5cbmV4cG9ydCBjbGFzcyBQcmltVHlwZSB7XG4gICBuYW1lOiBTdHJcbiAgIEM6IENsYXNzPFByaW1WYWx1ZT5cblxuICAgY29uc3RydWN0b3IgKG5hbWU6IFN0ciwgQzogQ2xhc3M8UHJpbVZhbHVlPikge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZVxuICAgICAgdGhpcy5DID0gQ1xuICAgfVxufVxuXG4vLyBOZWl0aGVyIG9mIHRoZXNlIGlzIGN1cnJlbnRseSByZWZsZWN0aXZlIGJlY2F1c2Ugb2Ygbm9uLXN0YW5kYXJkIGZpZWxkcy5cbmV4cG9ydCBjbGFzcyBEYXRhVHlwZSB7XG4gICBuYW1lOiBTdHJcbiAgIGVsaW1DOiBDbGFzczxEYXRhRWxpbT4gICAgICAgICAgICBcbiAgIGN0cnM6IE1hcDxzdHJpbmcsIEN0cj4gICAgICAgICAgICAgICAgICAgIC8vIGZpZWxkcyBvZiBteSBjb25zdHJ1Y3RvcnNcbiAgIGV4cHJDzIU6IE1hcDxzdHJpbmcsIENsYXNzPEV4cHIuRGF0YUV4cHI+PiAgLy8gXCJleHByZXNzaW9uXCIgY2xhc3MgcGVyIGNvbnN0cnVjdG9yXG4gICBleHBsQ8yFOiBNYXA8c3RyaW5nLCBDbGFzczxFeHBsLkRhdGFFeHBsPj4gIC8vIFwiZXhwbGFuYXRpb25cIiBjbGFzcyBwZXIgY29uc3RydWN0b3JcblxuICAgY29uc3RydWN0b3IgKFxuICAgICAgbmFtZTogU3RyLFxuICAgICAgZWxpbUM6IENsYXNzPERhdGFFbGltPiwgXG4gICAgICBjdHJzOiBNYXA8c3RyaW5nLCBDdHI+LCBcbiAgICAgIGV4cHJDzIU6IE1hcDxzdHJpbmcsIENsYXNzPEV4cHIuRGF0YUV4cHI+PixcbiAgICAgIGV4cGxDzIU6IE1hcDxzdHJpbmcsIENsYXNzPEV4cGwuRGF0YUV4cGw+PlxuICAgKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgICB0aGlzLmVsaW1DID0gZWxpbUNcbiAgICAgIHRoaXMuY3RycyA9IGN0cnNcbiAgICAgIHRoaXMuZXhwckPMhSA9IGV4cHJDzIVcbiAgICAgIHRoaXMuZXhwbEPMhSA9IGV4cGxDzIVcbiAgIH1cbn1cblxuLy8gQ29uc3RydWN0b3Igb2YgYSBkYXRhdHlwZSwgbm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggYW4gaW5zdGFuY2Ugb2Ygc3VjaCBhIHRoaW5nIChEYXRhVmFsdWUpIG9yIG5hbWUgb2Ygc3VjaCBhIHRoaW5nXG4vLyAoTGV4LkN0cikuIEZpZWxkcyBoYXZlIGEgdG90YWwgb3JkZXJpbmcgZ2l2ZW4gYnkgdGhlIG9yZGVyIG9mIGRlZmluaXRpb24gaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2xhc3MuXG5leHBvcnQgY2xhc3MgQ3RyIHtcbiAgIEM6IENsYXNzPERhdGFWYWx1ZT5cbiAgIGbMhTogc3RyaW5nW11cblxuICAgY29uc3RydWN0b3IgKEM6IENsYXNzPERhdGFWYWx1ZT4sIGbMhTogc3RyaW5nW10pIHtcbiAgICAgIHRoaXMuQyA9IENcbiAgICAgIHRoaXMuZsyFID0gZsyFXG4gICB9XG5cbiAgIGdldCBhcml0eSAoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmbMhS5sZW5ndGhcbiAgIH1cblxuICAgZ2V0IGMgKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gdGhpcy5DLm5hbWVcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN0ckZvciAoYzogc3RyaW5nKTogQ3RyIHtcbiAgIHJldHVybiBfX25vbk51bGwoY3RyVG9EYXRhVHlwZS5nZXQoYyksIGBVbmtub3duIGNvbnN0cnVjdG9yICR7Y30uYCkuY3Rycy5nZXQoYykhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsQ2xhc3MgKEM6IENsYXNzPERhdGFWYWx1ZT4pOiBDbGFzczxFeHBsLkRhdGFFeHBsPiB7XG4gICByZXR1cm4gX19ub25OdWxsKGN0clRvRGF0YVR5cGUuZ2V0KEMubmFtZSkpLmV4cGxDzIUuZ2V0KEMubmFtZSkhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByQ2xhc3MgKEM6IENsYXNzPERhdGFWYWx1ZT4pOiBDbGFzczxFeHByLkRhdGFFeHByPiB7XG4gICByZXR1cm4gX19ub25OdWxsKGN0clRvRGF0YVR5cGUuZ2V0KEMubmFtZSkpLmV4cHJDzIUuZ2V0KEMubmFtZSkhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZUNsYXNzIChDOiBDbGFzczxFeHByLkRhdGFFeHByPik6IENsYXNzPERhdGFWYWx1ZT4ge1xuICAgcmV0dXJuIGN0ckZvcihDLm5hbWUpLkNcbn1cblxuLy8gUG9wdWxhdGVkIGJ5IGluaXREYXRhVHlwZXMoKS4gQ29uc3RydWN0b3JzIGFyZSBub3QgeWV0IGZpcnN0LWNsYXNzLlxuZXhwb3J0IGNvbnN0IHR5cGVzOiBNYXA8c3RyaW5nLCBEYXRhVHlwZSB8IFByaW1UeXBlPiA9IG5ldyBNYXBcbmV4cG9ydCBjb25zdCBjdHJUb0RhdGFUeXBlOiBNYXA8c3RyaW5nLCBEYXRhVHlwZT4gPSBuZXcgTWFwXG5leHBvcnQgY29uc3QgZWxpbVRvRGF0YVR5cGU6IE1hcDxzdHJpbmcsIERhdGFUeXBlPiA9IG5ldyBNYXBcblxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMzNjA1Nzc1IGZvciB0aGUgZHluYW1pYyBjbGFzcy1uYW1pbmcgaWRpb20uXG5leHBvcnQgZnVuY3Rpb24gaW5pdERhdGFUeXBlPFQgZXh0ZW5kcyBEYXRhVmFsdWU+IChEOiBBQ2xhc3M8VD4sIEPMhTogQ2xhc3M8VD5bXSkge1xuICAgQ8yFLnNvcnQoKEMsIEPKuSk6IG51bWJlciA9PiBDLm5hbWUubG9jYWxlQ29tcGFyZShDyrkubmFtZSkpIC8vIGNvbnNpc3RlbnQgd2l0aCBTdHIubGVxXG4gICBjb25zdCBjdHJzOiBbc3RyaW5nLCBDdHJdW10gPSBDzIUubWFwKFxuICAgICAgICAgICAgKEM6IENsYXNzPFQ+KTogW3N0cmluZywgQ3RyXSA9PiBbQy5uYW1lLCBuZXcgQ3RyKEMsIGZpZWxkcyhuZXcgQykgYXMgc3RyaW5nW10pXVxuICAgICAgICAgKSxcbiAgICAgICAgIGVsaW1DOiBDbGFzczxEYXRhRWxpbT4gPSB7XG4gICAgICAgICAgICBbRC5uYW1lXTogY2xhc3MgZXh0ZW5kcyBEYXRhRWxpbSB7XG4gICAgICAgICAgICAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICAgICAgICAvLyBsZXhpY29ncmFwaGljYWwgb3JkZXIgaG9wZWZ1bGx5IHByZXNlcnZlZCBieSBnZXRPd25Qcm9wZXJ0eU5hbWVzKClcbiAgICAgICAgICAgICAgICAgIEPMhS5mb3JFYWNoKChDOiBDbGFzczxUPik6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgKHRoaXMgYXMgYW55KVtDLm5hbWVdID0gX1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1bRC5uYW1lXSxcbiAgICAgICAgIGV4cHJDzIU6IFtzdHJpbmcsIENsYXNzPEV4cHIuRGF0YUV4cHI+XVtdID0gY3Rycy5tYXAoKFtjX3N0ciwgY106IFtzdHJpbmcsIEN0cl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbY19zdHIsIHtcbiAgICAgICAgICAgICAgIFtjX3N0cl06IGNsYXNzIGV4dGVuZHMgRXhwci5EYXRhRXhwciB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgICAgICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICAgICAgICAgICBjLmbMhS5mb3JFYWNoKChmOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzIGFzIGFueSlbZl0gPSBfXG4gICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVtjX3N0cl1dXG4gICAgICAgICB9KSxcbiAgICAgICAgIGV4cGxDzIU6IFtzdHJpbmcsIENsYXNzPEV4cGwuRGF0YUV4cGw+XVtdID0gY3Rycy5tYXAoKFtjX3N0ciwgY106IFtzdHJpbmcsIEN0cl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbY19zdHIsIHtcbiAgICAgICAgICAgICAgIFtjX3N0cl06IGNsYXNzIGV4dGVuZHMgRXhwbC5EYXRhRXhwbCB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgICAgICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICAgICAgICAgICBjLmbMhS5mb3JFYWNoKChmOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzIGFzIGFueSlbZl0gPSBfXG4gICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVtjX3N0cl1dXG4gICAgICAgICB9KSxcbiAgICAgICAgIGQ6IERhdGFUeXBlID0gbmV3IERhdGFUeXBlKHN0cihELm5hbWUpKM69KCkpLCBlbGltQywgbmV3IE1hcChjdHJzKSwgbmV3IE1hcChleHByQ8yFKSwgbmV3IE1hcChleHBsQ8yFKSlcbiAgIEPMhS5mb3JFYWNoKChDOiBDbGFzczxUPik6IHZvaWQgPT4ge1xuICAgICAgY3RyVG9EYXRhVHlwZS5zZXQoQy5uYW1lLCBkKVxuICAgfSlcbiAgIGVsaW1Ub0RhdGFUeXBlLnNldChELm5hbWUsIGQpXG4gICB0eXBlcy5zZXQoZC5uYW1lLnZhbCwgZClcbn1cblxudHlwZXMuc2V0KE51bS5uYW1lLCBuZXcgUHJpbVR5cGUoc3RyKE51bS5uYW1lKSjOvSgpKSwgTnVtKSlcbnR5cGVzLnNldChTdHIubmFtZSwgbmV3IFByaW1UeXBlKHN0cihTdHIubmFtZSkozr0oKSksIFN0cikpXG4iLCJpbXBvcnQgeyBfX25vbk51bGwsIGNsYXNzTmFtZSB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBFeHBsIH0gZnJvbSBcIi4vRXhwbFwiXG5pbXBvcnQgeyBEYXRhVmFsdWVUYWcsIFZhbHVlLCBfLCBtYWtlIH0gZnJvbSBcIi4vVmFsdWVcIlxuXG4vLyBWYWx1ZSBvZiBhIGRhdGF0eXBlIGNvbnN0cnVjdG9yOyBjaGlsZHJlbiBhcmUgYWx3YXlzIHVzZXItbGV2ZWwgdmFsdWVzIChpLmUuIG5vdCBFUzYgcHJpbWl0aXZlcykuXG5leHBvcnQgY2xhc3MgRGF0YVZhbHVlPFRhZyBleHRlbmRzIERhdGFWYWx1ZVRhZyA9IERhdGFWYWx1ZVRhZz4gZXh0ZW5kcyBWYWx1ZTxUYWc+IHtcbiAgIGdldCBjdHIgKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lKHRoaXMpXG4gICB9XG5cbiAgIF9fY2hpbGQgKGs6IGtleW9mIHRoaXMpOiBWYWx1ZSB7XG4gICAgICByZXR1cm4gc3VwZXIuX19jaGlsZChrKSBhcyBWYWx1ZVxuICAgfVxuXG4gICBnZXQgX19jaGlsZHJlbiAoKTogVmFsdWVbXSB7XG4gICAgICByZXR1cm4gc3VwZXIuX19jaGlsZHJlbiBhcyBWYWx1ZVtdXG4gICB9XG59XG5cbi8vIEhlcmUgdG8gYnJlYWsgY3ljbGljIGRlcGVuZGVuY3kuXG5leHBvcnQgY2xhc3MgRXhwbFZhbHVlPFQgZXh0ZW5kcyBWYWx1ZSA9IFZhbHVlPiBleHRlbmRzIERhdGFWYWx1ZTxcIkV4cGxWYWx1ZVwiPiB7XG4gICB0OiBFeHBsID0gX1xuICAgdjogVCA9IF9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxWYWx1ZTxUIGV4dGVuZHMgVmFsdWUgPSBWYWx1ZT4gKHQ6IEV4cGwsIHY6IFQpOiBFeHBsVmFsdWU8VD4ge1xuICAgcmV0dXJuIG1ha2UoRXhwbFZhbHVlLCB0LCB2KSBhcyBFeHBsVmFsdWU8VD5cbn1cbiIsImltcG9ydCB7IGFic3VyZCwgYXNzZXJ0IH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IE9yZCB9IGZyb20gXCIuL3V0aWwvT3JkXCJcbmltcG9ydCB7IFBlcnNpc3RlbnQsIFZhbHVlLCBmaWVsZHMsIG1lcmdlSW50byB9IGZyb20gXCIuL1ZhbHVlXCJcblxuLy8gRGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBzdGF0ZXMgKG9mIHRoZSBzYW1lIHZhbHVlIGNsYXNzKS4gU2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIGxpa2UgVmFsdWUsIGFuZFxuLy8gcGFyYW1ldGVyaXNlZCBvbiB0eXBlIG9mIHZhbHVlcyBiZWluZyBjb21wYXJlZC5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsdWVEZWx0YSB7XG4gICBbcHJvcDogc3RyaW5nXTogeyBiZWZvcmU6IFBlcnNpc3RlbnQsIGFmdGVyOiBQZXJzaXN0ZW50IH0gLy8gW2JlZm9yZSwgYWZ0ZXJdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXEgKHMxOiBWYWx1ZURlbHRhLCBzMjogVmFsdWVEZWx0YSk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIE9iamVjdC5rZXlzKHMxKS5ldmVyeSgocHJvcDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICByZXR1cm4gczIuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgczFbcHJvcF0uYmVmb3JlID09PSBzMltwcm9wXS5iZWZvcmUgJiYgczFbcHJvcF0uYWZ0ZXIgPT09IHMyW3Byb3BdLmFmdGVyXG4gICB9KVxufVxuXG5mdW5jdGlvbiBlbXB0eSAo4bqfOiBWYWx1ZURlbHRhKTogYm9vbGVhbiB7XG4gICByZXR1cm4gZmllbGRzKOG6nykubGVuZ3RoID09PSAwXG59XG5cbmV4cG9ydCBjbGFzcyBEZWx0YXMge1xuICAg4bqfzIU6IE1hcDxWYWx1ZSwgRGVsdGE+ID0gbmV3IE1hcCgpXG5cbiAgIGdldCBzaXplICgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMu4bqfzIUuc2l6ZVxuICAgfVxuXG4gICAvLyBDaGFuZ2Ugc2V0cyBtdXN0IGJlIGRpc2pvaW50IGF0IGEgZ2l2ZW4gcmV2aXNpb24uIEJlY2F1c2Ugb2Ygc2hhcmluZyB3aXRoaW4gYSByZXZpc2lvbiwgXG4gICAvLyBhIG5vZGUgbWF5IGZpcnN0IGFwcGVhciBuZXcgKG9yIHJlY2xhc3NpZmllZCkgYW5kIHRoZW4gbGF0ZXIgYXBwZWFyIGNoYW5nZWQsIGJ1dCB0aGUgXG4gICAvLyBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIG11c3QgYmUgZW1wdHkuXG4gICBjaGFuZ2VkICh2OiBWYWx1ZSwgc1/hup86IFZhbHVlRGVsdGEpOiB2b2lkIHtcbiAgICAgIGxldCB2X+G6nzogRGVsdGEgfCB1bmRlZmluZWQgPSB0aGlzLuG6n8yFLmdldCh2KVxuICAgICAgaWYgKHZf4bqfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMu4bqfzIUuc2V0KHYsIG5ldyBDaGFuZ2Uoc1/hup8pKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodl/hup8gaW5zdGFuY2VvZiBDaGFuZ2UpIHtcbiAgICAgICAgIG1lcmdlSW50byh2X+G6ny5jaGFuZ2VkLCBzX+G6nylcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHZf4bqfIGluc3RhbmNlb2YgTmV3IHx8IHZf4bqfIGluc3RhbmNlb2YgUmVjbGFzc2lmeSkge1xuICAgICAgICAgYXNzZXJ0KGVtcHR5KHNf4bqfKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICAvLyBBIHZhbHVlIGNhbm5vdCBiZSByZWNsYXNzaWZpZWQgdHdpY2UgYXQgdGhlIHNhbWUgcmV2aXNpb24uXG4gICByZWNsYXNzaWZpZWQgKHY6IFZhbHVlKTogdm9pZCB7XG4gICAgICBsZXQgdl/hup86IERlbHRhIHwgdW5kZWZpbmVkID0gdGhpcy7hup/MhS5nZXQodilcbiAgICAgIGlmICh2X+G6nyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aGlzLuG6n8yFLnNldCh2LCBuZXcgUmVjbGFzc2lmeSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIC8vIEEgdmFsdWUgY2Fubm90IGJlIGNyZWF0ZWQgdHdpY2UgYXQgdGhlIHNhbWUgcmV2aXNpb24uXG4gICBjcmVhdGVkICh2OiBWYWx1ZSk6IHZvaWQge1xuICAgICAgbGV0IHZf4bqfOiBEZWx0YSB8IHVuZGVmaW5lZCA9IHRoaXMu4bqfzIUuZ2V0KHYpXG4gICAgICBpZiAodl/hup8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy7hup/MhS5zZXQodiwgbmV3IE5ldygpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGNsZWFyICgpOiB2b2lkIHtcbiAgICAgIHRoaXMu4bqfzIUuY2xlYXIoKVxuICAgfVxufVxuXG5leHBvcnQgY29uc3QgX19kZWx0YXM6IERlbHRhcyA9IG5ldyBEZWx0YXMoKVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGVsdGEgaW1wbGVtZW50cyBPcmQ8RGVsdGE+IHtcbiAgIGFic3RyYWN0IGxlcSAo4bqfOiBEZWx0YSk6IGJvb2xlYW5cblxuICAgZXEgKOG6nzogRGVsdGEpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzLmxlcSjhup8pICYmIOG6ny5sZXEodGhpcylcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5ldyBleHRlbmRzIERlbHRhIHtcbiAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcbiAgIH1cblxuICAgbGVxICjhup86IERlbHRhKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4g4bqfIGluc3RhbmNlb2YgTmV3XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDaGFuZ2UgZXh0ZW5kcyBEZWx0YSB7XG4gICBjaGFuZ2VkOiBWYWx1ZURlbHRhXG5cbiAgIGNvbnN0cnVjdG9yIChjaGFuZ2VkOiBWYWx1ZURlbHRhKSB7XG4gICAgICBzdXBlcigpXG4gICAgICB0aGlzLmNoYW5nZWQgPSBjaGFuZ2VkXG4gICB9XG5cbiAgIGxlcSAo4bqfOiBEZWx0YSk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIOG6nyBpbnN0YW5jZW9mIENoYW5nZSAmJiBsZXEodGhpcy5jaGFuZ2VkLCDhup8uY2hhbmdlZClcbiAgIH1cblxuICAgaGFzQ2hhbmdlZCAocHJvcDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gZmllbGRzKHRoaXMuY2hhbmdlZCkuaW5jbHVkZXMocHJvcClcbiAgIH1cbn1cblxuLy8gQ29uc3RydWN0b3IgaGFzIGNoYW5nZWQsIGFuZCB0aGVyZWZvcmUgZmllbGRzIG1heSBub3QgYWxpZ24uIE1vcmUgc29waGlzdGljYXRlZCByZWNsYXNzaWZpY2F0aW9uXG4vLyBkZWx0YSBjb3VsZCBhbGxvdyBmb3IgZmllbGRzIHRvIGJlIHNoYXJlZCB3aGVuIGFuIG9iamVjdCBjaGFuZ2VzIGNsYXNzLlxuZXhwb3J0IGNsYXNzIFJlY2xhc3NpZnkgZXh0ZW5kcyBEZWx0YSB7XG4gICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG4gICB9XG5cbiAgIGxlcSAo4bqfOiBEZWx0YSk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIOG6nyBpbnN0YW5jZW9mIFJlY2xhc3NpZnlcbiAgIH1cbn1cbiIsImltcG9ydCB7IGFic3VyZCB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBEYXRhVmFsdWUsIEV4cGxWYWx1ZSB9IGZyb20gXCIuL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBTdHIsIF8sIG1ha2UgfSBmcm9tIFwiLi9WYWx1ZVwiXG5cbi8vIEVudmlyb25tZW50cyBhcmUgc25vYyBsaXN0czsgdGhlIHZhbHVlcyBhcmUgXCJleHBsYWluZWRcIiBiZWNhdXNlIHVzYWdlIGluZm9ybWF0aW9uIGlzIHJlY29yZGVkIG9uIHRyYWNlcy5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFbnYgZXh0ZW5kcyBEYXRhVmFsdWU8XCJFbnZcIj4ge1xuICAgZ2V0IChrOiBTdHIpOiBFeHBsVmFsdWUgfCB1bmRlZmluZWQge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFbXB0eUVudikge1xuICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV4dGVuZEVudikge1xuICAgICAgICAgaWYgKHRoaXMuay52YWwgPT09IGsudmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50dlxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLs+BLmdldChrKVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuICAgXG4gICBoYXMgKGs6IFN0cik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGspICE9PSB1bmRlZmluZWRcbiAgIH1cblxuICAgc3RhdGljIHNpbmdsZXRvbiAoazogU3RyLCB0djogRXhwbFZhbHVlKTogRXh0ZW5kRW52IHtcbiAgICAgIHJldHVybiBleHRlbmRFbnYoZW1wdHlFbnYoKSwgaywgdHYpXG4gICB9XG4gICBcbiAgIGNvbmNhdCAoz4E6IEVudik6IEVudiB7XG4gICAgICBpZiAoz4EgaW5zdGFuY2VvZiBFbXB0eUVudikge1xuICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKM+BIGluc3RhbmNlb2YgRXh0ZW5kRW52KSB7XG4gICAgICAgICByZXR1cm4gZXh0ZW5kRW52KHRoaXMuY29uY2F0KM+BLs+BKSwgz4Euaywgz4EudHYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIHZhbHVlcyAoKTogRXhwbFZhbHVlW10ge1xuICAgICAgY29uc3QgdHZzOiBFeHBsVmFsdWVbXSA9IFtdXG4gICAgICBmb3IgKGxldCDPgTogRW52ID0gdGhpczsgz4EgaW5zdGFuY2VvZiBFeHRlbmRFbnY7IM+BID0gz4Euz4EpIHtcbiAgICAgICAgIHR2cy5wdXNoKM+BLnR2KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHR2c1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRW1wdHlFbnYgZXh0ZW5kcyBFbnYge1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHlFbnYgKCk6IEVtcHR5RW52IHtcbiAgIHJldHVybiBtYWtlKEVtcHR5RW52KVxufVxuXG5leHBvcnQgY2xhc3MgRXh0ZW5kRW52IGV4dGVuZHMgRW52IHtcbiAgIM+BOiBFbnYgPSBfXG4gICBrOiBTdHIgPSBfXG4gICB0djogRXhwbFZhbHVlID0gX1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRW52ICjPgTogRW52LCBrOiBTdHIsIHR2OiBFeHBsVmFsdWUpOiBFeHRlbmRFbnYge1xuICAgcmV0dXJuIG1ha2UoRXh0ZW5kRW52LCDPgSwgaywgdHYpXG59XG4iLCJpbXBvcnQgeyB6aXAgfSBmcm9tIFwiLi91dGlsL0FycmF5XCJcbmltcG9ydCB7IENsYXNzLCBfX25vbk51bGwsIGFic3VyZCwgYXMsIGFzc2VydCwgY2xhc3NOYW1lLCBjbGFzc09mLCB1c2VyRXJyb3IgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgYm9vbF8gfSBmcm9tIFwiLi91dGlsL0xhdHRpY2VcIlxuaW1wb3J0IHsgRGlyZWN0aW9uLCBpc86xLCBzZXRqb2luzrEsIHNldG1lZXTOsSwgc2V0zrEgfSBmcm9tIFwiLi9Bbm5vdGF0aW9uXCJcbmltcG9ydCB7IENvbnMsIExpc3QsIE5pbCwgY29ucywgbmlsIH0gZnJvbSBcIi4vQmFzZVR5cGVzXCJcbmltcG9ydCB7IERhdGFUeXBlLCBQcmltVHlwZSwgY3RyVG9EYXRhVHlwZSwgZXhwbENsYXNzLCBpbml0RGF0YVR5cGUsIHR5cGVzLCB2YWx1ZUNsYXNzIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUsIGV4cGxWYWx1ZSB9IGZyb20gXCIuL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBFbnYsIGVtcHR5RW52LCBleHRlbmRFbnYgfSBmcm9tIFwiLi9FbnZcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuL0V4cGxcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IHsgZ2V0IH0gZnJvbSBcIi4vRmluaXRlTWFwXCJcbmltcG9ydCB7IEVsaW0sIE1hdGNoLCBhcHBseV9id2QsIGFwcGx5X2Z3ZCB9IGZyb20gXCIuL01hdGNoXCJcbmltcG9ydCB7IFVuYXJ5T3AsIEJpbmFyeU9wLCBiaW5hcnlPcHMsIHVuYXJ5T3BzIH0gZnJvbSBcIi4vUHJpbWl0aXZlXCJcbmltcG9ydCB7IElkLCBNZW1vSWQsIFByaW1WYWx1ZSwgTnVtLCBTdHIsIFRhZ2dlZElkLCBWYWx1ZSwgXywgbWVtb0lkIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgYXQsIG51bSwgc3RyIH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxudHlwZSBEZWYgPSBFeHByLkRlZlxudHlwZSBSZWNEZWYgPSBFeHByLlJlY0RlZlxuXG5leHBvcnQgdHlwZSBFeHBsSWQgPSBUYWdnZWRJZDxcInRcIj5cbmV4cG9ydCB0eXBlIFZhbElkID0gVGFnZ2VkSWQ8XCJ2XCI+XG5cbmV4cG9ydCBtb2R1bGUgRXZhbCB7XG5cbi8vIM+BIHBsdXMgYmluZGluZ3MgaW4gzrQgYXJlIGNsb3NpbmcgZm9yIGYuXG5leHBvcnQgY2xhc3MgQ2xvc3VyZSBleHRlbmRzIERhdGFWYWx1ZTxcIkNsb3N1cmVcIj4ge1xuICAgz4E6IEVudiA9IF9cbiAgIM60OiBMaXN0PFJlY0RlZj4gPSBfXG4gICBmOiBFbGltPEV4cHI+ID0gX1xufVxuXG5mdW5jdGlvbiBjbG9zdXJlICjPgTogRW52LCDOtDogTGlzdDxSZWNEZWY+LCBmOiBFbGltPEV4cHI+KTogKGs6IElkKSA9PiBDbG9zdXJlIHtcbiAgIHJldHVybiBhdChDbG9zdXJlLCDPgSwgzrQsIGYpXG59XG5cbi8vIEVudmlyb25tZW50cyBhcmUgc25vYy1saXN0cywgc28gdGhpcyAoaW5jb25zZXF1ZW50aWFsbHkpIHJldmVyc2VzIGRlY2xhcmF0aW9uIG9yZGVyLlxuZnVuY3Rpb24gcmVjRGVmcyAozrRfMDogTGlzdDxSZWNEZWY+LCDPgTogRW52LCDOtDogTGlzdDxSZWNEZWY+KTogW0xpc3Q8RXhwbC5SZWNEZWY+LCBFbnZdIHtcbiAgIGlmIChDb25zLmlzKM60KSkge1xuICAgICAgY29uc3QgZGVmOiBSZWNEZWYgPSDOtC5oZWFkLFxuICAgICAgICAgICAgW8604oKcLCDPgV9leHRdOiBbTGlzdDxFeHBsLlJlY0RlZj4sIEVudl0gPSByZWNEZWZzKM60XzAsIM+BLCDOtC50YWlsKSxcbiAgICAgICAgICAgIGs6IE1lbW9JZCA9IG1lbW9JZChyZWNEZWZzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgdGY6IEV4cGxWYWx1ZTxDbG9zdXJlPiA9IGV4cGxWYWx1ZShFeHBsLmZ1bihkZWYuz4MpKGsudGFnKFwidFwiKSksIGNsb3N1cmUoz4EsIM60XzAsIGRlZi7Pgykoay50YWcoXCJ2XCIpKSlcbiAgICAgIHJldHVybiBbY29ucyhFeHBsLnJlY0RlZihkZWYueCwgdGYpKGspLCDOtOKCnCksIGV4dGVuZEVudijPgV9leHQsIGRlZi54LCB0ZildXG4gICB9IGVsc2VcbiAgIGlmIChOaWwuaXMozrQpKSB7XG4gICAgICByZXR1cm4gW25pbCgpLCBlbXB0eUVudigpXVxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgfVxufVxuXG5mdW5jdGlvbiByZWNEZWZzXyAoZGlyOiBEaXJlY3Rpb24sIM60OiBMaXN0PEV4cGwuUmVjRGVmPik6IHZvaWQge1xuICAgaWYgKENvbnMuaXMozrQpKSB7XG4gICAgICB6aXAozrQuaGVhZC50Zi52Ls60LnRvQXJyYXkoKSwgzrQudG9BcnJheSgpKS5tYXAoKFtkZWYsIGRlZuKCnF06IFtSZWNEZWYsIEV4cGwuUmVjRGVmXSk6IHZvaWQgPT4ge1xuICAgICAgICAgYXNzZXJ0KGRlZi54LmVxKGRlZuKCnC54KSlcbiAgICAgICAgIGlmIChkaXIgPT09IERpcmVjdGlvbi5Gd2QpIHtcbiAgICAgICAgICAgIHNldM6xKGlzzrEoZGVmKSwgZGVm4oKcLnRmKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldGpvaW7OsShpc86xKGRlZuKCnC50ZiksIGRlZilcbiAgICAgICAgIH1cbiAgICAgIH0pXG4gICB9IGVsc2VcbiAgIGlmIChOaWwuaXMozrQpKSB7XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICB9XG59XG5cbi8vIEhlcmUgd2UgbXVzdG4ndCBpbnZlcnQgZGVmaW5pdGlvbiBvcmRlci5cbmV4cG9ydCBmdW5jdGlvbiBkZWZzICjPgTogRW52LCBkZWbMhTogTGlzdDxEZWY+LCDPgV9leHQ6IEVudik6IFtMaXN0PEV4cGwuRGVmPiwgRW52XSB7XG4gICBjb25zdCBrOiBNZW1vSWQgPSBtZW1vSWQoZGVmcywgYXJndW1lbnRzKVxuICAgaWYgKENvbnMuaXMoZGVmzIUpKSB7XG4gICAgICBjb25zdCBkZWY6IERlZiA9IGRlZsyFLmhlYWRcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCkge1xuICAgICAgICAgY29uc3QgdHY6IEV4cGxWYWx1ZSA9IGV2YWxfKM+BLmNvbmNhdCjPgV9leHQpLCBkZWYuZSksXG4gICAgICAgICAgICAgICBbZGVmzIXigpwsIM+BX2V4dMq5XTogW0xpc3Q8RXhwbC5EZWY+LCBFbnZdID0gZGVmcyjPgSwgZGVmzIUudGFpbCwgZXh0ZW5kRW52KM+BX2V4dCwgZGVmLngsIHR2KSlcbiAgICAgICAgIHJldHVybiBbY29ucyhFeHBsLmxldF8oZGVmLngsIHR2KShrKSwgZGVmzIXigpwpLCDPgV9leHTKuV1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuUHJpbSkge1xuICAgICAgICAgLy8gZmlyc3QtY2xhc3MgcHJpbWl0aXZlcyBjdXJyZW50bHkgaGFwcGVuIHRvIGJlIHVuYXJ5XG4gICAgICAgICBpZiAodW5hcnlPcHMuaGFzKGRlZi54LnZhbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRfb3A6IEV4cGxWYWx1ZTxVbmFyeU9wPiA9IHVuYXJ5T3BzLmdldChkZWYueC52YWwpISxcbiAgICAgICAgICAgICAgICAgIFtkZWbMheKCnCwgz4FfZXh0yrldOiBbTGlzdDxFeHBsLkRlZj4sIEVudl0gPSBkZWZzKM+BLCBkZWbMhS50YWlsLCBleHRlbmRFbnYoz4FfZXh0LCBkZWYueCwgdF9vcCkpXG4gICAgICAgICAgICByZXR1cm4gW2NvbnMoRXhwbC5wcmltKGRlZi54LCB0X29wKShrKSwgZGVmzIXigpwpLCDPgV9leHTKuV1cbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckVycm9yKGBObyBpbXBsZW1lbnRhdGlvbiBmb3VuZCBmb3IgcHJpbWl0aXZlIFwiJHtkZWYueC52YWx9XCIuYClcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuTGV0UmVjKSB7XG4gICAgICAgICBjb25zdCBbzrQsIM+B4bWfXTogW0xpc3Q8RXhwbC5SZWNEZWY+LCBFbnZdID0gcmVjRGVmcyhkZWYuzrQsIM+BLmNvbmNhdCjPgV9leHQpLCBkZWYuzrQpLFxuICAgICAgICAgICAgICAgW2RlZsyF4oKcLCDPgV9leHTKuV06IFtMaXN0PEV4cGwuRGVmPiwgRW52XSA9IGRlZnMoz4EsIGRlZsyFLnRhaWwsIM+BX2V4dC5jb25jYXQoz4HhtZ8pKVxuICAgICAgICAgcmV0dXJuIFtjb25zKEV4cGwubGV0UmVjKM60KShrKSwgZGVmzIXigpwpLCDPgV9leHTKuV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKE5pbC5pcyhkZWbMhSkpIHtcbiAgICAgIHJldHVybiBbbmlsKCksIM+BX2V4dF1cbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cblxuZnVuY3Rpb24gZGVmc19md2QgKGRlZsyFOiBMaXN0PERlZj4sIGRlZsyF4oKcOiBMaXN0PEV4cGwuRGVmPik6IHZvaWQge1xuICAgemlwKGRlZsyFLnRvQXJyYXkoKSwgZGVmzIXigpwudG9BcnJheSgpKS5mb3JFYWNoKChbZGVmLCBkZWbigpxdOiBbRGVmLCBFeHBsLkRlZl0pID0+IHtcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLkxldCkge1xuICAgICAgICAgZXZhbF9md2QoZGVmLmUsIGRlZuKCnC50dilcbiAgICAgICAgIHNldG1lZXTOsShpc86xKGRlZiksIGRlZuKCnC50dilcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuUHJpbSAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLlByaW0pIHtcbiAgICAgICAgIHNldM6xKGlzzrEoZGVmKSwgZGVm4oKcLnRfb3ApXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldFJlYyAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLkxldFJlYykge1xuICAgICAgICAgcmVjRGVmc18oRGlyZWN0aW9uLkZ3ZCwgZGVm4oKcLs60KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZCgpXG4gICAgICB9XG4gICB9KVxufVxuXG5mdW5jdGlvbiBkZWZzX2J3ZCAoZGVmzIU6IExpc3Q8RGVmPiwgZGVmzIXigpw6IExpc3Q8RXhwbC5EZWY+KTogdm9pZCB7XG4gICB6aXAoZGVmzIUudG9BcnJheSgpLCBkZWbMheKCnC50b0FycmF5KCkpLnJldmVyc2UoKS5mb3JFYWNoKChbZGVmLCBkZWbigpxdOiBbRGVmLCBFeHBsLkRlZl0pID0+IHtcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLkxldCkge1xuICAgICAgICAgc2V0am9pbs6xKGlzzrEoZGVm4oKcLnR2KSwgZGVmKVxuICAgICAgICAgZXZhbF9id2QoZGVmLmUsIGRlZuKCnC50dilcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIEV4cHIuUHJpbSAmJiBkZWbigpwgaW5zdGFuY2VvZiBFeHBsLlByaW0pIHtcbiAgICAgICAgIHNldGpvaW7OsShpc86xKGRlZuKCnC50X29wKSwgZGVmKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwci5MZXRSZWMgJiYgZGVm4oKcIGluc3RhbmNlb2YgRXhwbC5MZXRSZWMpIHtcbiAgICAgICAgIHJlY0RlZnNfKERpcmVjdGlvbi5Cd2QsIGRlZuKCnC7OtClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhYnN1cmQoKVxuICAgICAgfVxuICAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWxfICjPgTogRW52LCBlOiBFeHByKTogRXhwbFZhbHVlIHtcbiAgIGNvbnN0IGs6IE1lbW9JZCA9IG1lbW9JZChldmFsXywgYXJndW1lbnRzKSxcbiAgICAgICAgIFtr4oKcLCBr4bWlXTogW0V4cGxJZCwgVmFsSWRdID0gW2sudGFnKFwidFwiKSwgay50YWcoXCJ2XCIpXVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkNvbnN0TnVtKSB7XG4gICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuY29uc3RfKCkoa+KCnCksIG51bShlLnZhbC52YWwpKGvhtaUpKVxuICAgfSBlbHNlXG4gICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuQ29uc3RTdHIpIHtcbiAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5jb25zdF8oKShr4oKcKSwgc3RyKGUudmFsLnZhbCkoa+G1pSkpXG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5GdW4pIHtcbiAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5mdW4oZS7Pgykoa+KCnCksIGNsb3N1cmUoz4EsIG5pbCgpLCBlLs+DKShr4bWlKSlcbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkRhdGFFeHByKSB7XG4gICAgICBjb25zdCB0dsyFOiBFeHBsVmFsdWVbXSA9IGUuX19jaGlsZHJlbi5tYXAoKGU6IEV4cHIpID0+IGV2YWxfKM+BLCBlKSksXG4gICAgICAgICAgICBDOiBDbGFzczxEYXRhVmFsdWU+ID0gdmFsdWVDbGFzcyhjbGFzc09mKGUpKSxcbiAgICAgICAgICAgIHQ6IEV4cGwgPSBhdChleHBsQ2xhc3MoQyksIC4uLnR2zIUubWFwKCh7dH0pID0+IHQpKShr4oKcKSxcbiAgICAgICAgICAgIHY6IFZhbHVlID0gYXQoQywgLi4udHbMhS5tYXAoKHt2fSkgPT4gdikpKGvhtaUpXG4gICAgICByZXR1cm4gZXhwbFZhbHVlKHQsIHYpXG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5RdW90ZSkge1xuICAgICAgcmV0dXJuIGV4cGxWYWx1ZShFeHBsLnF1b3RlKCkoa+KCnCksIGUuZSlcbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLlZhcikge1xuICAgICAgaWYgKM+BLmhhcyhlLngpKSB7XG4gICAgICAgICBjb25zdCB7dCwgdn06IEV4cGxWYWx1ZSA9IM+BLmdldChlLngpIVxuICAgICAgICAgcmV0dXJuIGV4cGxWYWx1ZShFeHBsLnZhcl8oZS54LCB0KShr4oKcKSwgdilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdXNlckVycm9yKGBWYXJpYWJsZSBcIiR7ZS54LnZhbH1cIiBub3QgZm91bmQuYClcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLkFwcCkge1xuICAgICAgY29uc3QgW3RmLCB0dV06IFtFeHBsVmFsdWUsIEV4cGxWYWx1ZV0gPSBbZXZhbF8oz4EsIGUuZiksIGV2YWxfKM+BLCBlLmUpXSxcbiAgICAgICAgICAgIFt2LCB1XTogW1ZhbHVlLCBWYWx1ZV0gPSBbdGYudiwgdHUudl1cbiAgICAgIGlmICh2IGluc3RhbmNlb2YgQ2xvc3VyZSkge1xuICAgICAgICAgY29uc3QgW860LCDPgeG1n106IFtMaXN0PEV4cGwuUmVjRGVmPiwgRW52XSA9IHJlY0RlZnModi7OtCwgdi7PgSwgdi7OtCksXG4gICAgICAgICAgICAgICBbz4HKuSwgzr7Oul06IFtFbnYsIE1hdGNoPEV4cHI+XSA9IHYuZi5hcHBseSh0dSksXG4gICAgICAgICAgICAgICB7dCwgdjogdsq5fTogRXhwbFZhbHVlID0gZXZhbF8odi7PgS5jb25jYXQoz4HhtZ8uY29uY2F0KM+ByrkpKSwgzr7Oui7OuilcbiAgICAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5hcHAodGYgYXMgRXhwbFZhbHVlPENsb3N1cmU+LCB0dSwgzrQsIM6+zrosIHQpKGvigpwpLCB2yrkpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgVW5hcnlPcCkge1xuICAgICAgICAgaWYgKHUgaW5zdGFuY2VvZiBOdW0gfHwgdSBpbnN0YW5jZW9mIFN0cikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGxWYWx1ZShFeHBsLnVuYXJ5QXBwKHRmIGFzIEV4cGxWYWx1ZTxVbmFyeU9wPiwgdHUgYXMgRXhwbFZhbHVlPFByaW1WYWx1ZT4pKGvigpwpLCB2Lm9wKHUpKGvhtaUpKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoYEFwcGx5aW5nIFwiJHt2Lm5hbWV9XCIgdG8gbm9uLXByaW1pdGl2ZSB2YWx1ZS5gLCB1KVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoYENhbm5vdCBhcHBseSAke2NsYXNzTmFtZSh2KX1gKVxuICAgICAgfVxuICAgfSBlbHNlXG4gICAvLyBCaW5hcnkgb3BlcmF0b3JzIGFyZSAoY3VycmVudGx5KSBcInN5bnRheFwiLCByYXRoZXIgdGhhbiBmaXJzdC1jbGFzcy5cbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5CaW5hcnlBcHApIHtcbiAgICAgIGlmIChiaW5hcnlPcHMuaGFzKGUub3BOYW1lLnZhbCkpIHtcbiAgICAgICAgIGNvbnN0IG9wOiBCaW5hcnlPcCA9IGJpbmFyeU9wcy5nZXQoZS5vcE5hbWUudmFsKSEudixcbiAgICAgICAgICAgICAgIFt0djEsIHR2Ml06IFtFeHBsVmFsdWUsIEV4cGxWYWx1ZV0gPSBbZXZhbF8oz4EsIGUuZTEpLCBldmFsXyjPgSwgZS5lMildLFxuICAgICAgICAgICAgICAgW3YxLCB2Ml06IFtWYWx1ZSwgVmFsdWVdID0gW3R2MS52LCB0djIudl1cbiAgICAgICAgIGlmICgodjEgaW5zdGFuY2VvZiBOdW0gfHwgdjEgaW5zdGFuY2VvZiBTdHIpICYmICh2MiBpbnN0YW5jZW9mIE51bSB8fCB2MiBpbnN0YW5jZW9mIFN0cikpIHtcbiAgICAgICAgICAgIGNvbnN0IGs6IE1lbW9JZCA9IG1lbW9JZChvcC5vcCwgW3YxLCB2Ml0pXG4gICAgICAgICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuYmluYXJ5QXBwKHR2MSBhcyBFeHBsVmFsdWU8UHJpbVZhbHVlPiwgZS5vcE5hbWUsIHR2MiBhcyBFeHBsVmFsdWU8UHJpbVZhbHVlPikoa+KCnCksIG9wLm9wKHYxLCB2MikoaykpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgQXBwbHlpbmcgXCIke2Uub3BOYW1lLnZhbH1cIiB0byBub24tcHJpbWl0aXZlIHZhbHVlLmAsIHYxLCB2MilcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdXNlckVycm9yKGBCaW5hcnkgcHJpbWl0aXZlIFwiJHtlLm9wTmFtZS52YWx9XCIgbm90IGZvdW5kLmApXG4gICAgICB9XG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5EZWZzKSB7XG4gICAgICBjb25zdCBbZGVmzIXigpwsIM+ByrldOiBbTGlzdDxFeHBsLkRlZj4sIEVudl0gPSBkZWZzKM+BLCBlLmRlZsyFLCBlbXB0eUVudigpKSxcbiAgICAgICAgICAgIHt0LCB2fTogRXhwbFZhbHVlID0gZXZhbF8oz4EuY29uY2F0KM+ByrkpLCBlLmUpXG4gICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuZGVmcyhkZWbMheKCnCwgdCkoa+KCnCksIHYpXG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5NYXRjaEFzKSB7XG4gICAgICBjb25zdCB0dTogRXhwbFZhbHVlID0gZXZhbF8oz4EsIGUuZSksXG4gICAgICAgICAgICBbz4HKuSwgzr7Oul06IFtFbnYsIE1hdGNoPEV4cHI+XSA9IGUuz4MuYXBwbHkodHUpLFxuICAgICAgICAgICAge3QsIHZ9OiBFeHBsVmFsdWUgPSBldmFsXyjPgS5jb25jYXQoz4HKuSksIM6+zrouzropXG4gICAgICByZXR1cm4gZXhwbFZhbHVlKEV4cGwubWF0Y2hBcyh0dSwgzr7OuiwgdCkoa+KCnCksIHYpXG4gICB9IGVsc2VcbiAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5UeXBlbWF0Y2gpIHtcbiAgICAgIGNvbnN0IHR1OiBFeHBsVmFsdWUgPSBldmFsXyjPgSwgZS5lKSxcbiAgICAgICAgICAgIGQ6IERhdGFUeXBlIHwgUHJpbVR5cGUgPSBjdHJUb0RhdGFUeXBlLmdldChjbGFzc05hbWUodHUudikpIHx8IHR5cGVzLmdldChjbGFzc05hbWUodHUudikpISxcbiAgICAgICAgICAgIGXKuTogRXhwciB8IHVuZGVmaW5lZCA9IGdldChlLmNhc2VzLCBkLm5hbWUpXG4gICAgICBpZiAoZcq5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoYFR5cGVjYXNlIG1pc21hdGNoOiBubyBjbGF1c2UgZm9yICR7Y2xhc3NOYW1lKHR1LnYpfS5gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGNvbnN0IHt0LCB2fTogRXhwbFZhbHVlID0gZXZhbF8oz4EsIGXKuSlcbiAgICAgICAgIHJldHVybiBleHBsVmFsdWUoRXhwbC50eXBlbWF0Y2godHUsIGQubmFtZSwgdCkoa+KCnCksIHYpXG4gICAgICB9XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZChgVW5pbXBsZW1lbnRlZCBleHByZXNzaW9uIGZvcm06ICR7Y2xhc3NOYW1lKGUpfS5gKVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbF9md2QgKGU6IEV4cHIsIHR2OiBFeHBsVmFsdWUpOiB2b2lkIHtcbiAgIGNvbnN0IHt0LCB2fTogRXhwbFZhbHVlID0gdHZcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5Db25zdCAmJiAodiBpbnN0YW5jZW9mIE51bSB8fCB2IGluc3RhbmNlb2YgU3RyKSkge1xuICAgICAgc2V0zrEoaXPOsShlKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5GdW4gJiYgdiBpbnN0YW5jZW9mIENsb3N1cmUpIHtcbiAgICAgIHNldM6xKGlzzrEoZSksIHR2KVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuUXVvdGUpIHtcbiAgICAgIHNldM6xKGlzzrEoZSksIHR2KVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuVmFyKSB7XG4gICAgICBzZXTOsShib29sXy5tZWV0KGlzzrEoZSksIGlzzrEoZXhwbFZhbHVlKHQudCwgdikpKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5EYXRhRXhwbCkge1xuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgICAgIGNvbnN0IGXKuTogRXhwci5EYXRhRXhwciA9IGFzKGUsIEV4cHIuRGF0YUV4cHIpXG4gICAgICAgICB6aXAoRXhwbC5leHBsQ2hpbGRyZW4odCwgdiksIGXKuS5fX2NoaWxkcmVuKS5tYXAoKFt0diwgZV0pID0+IGV2YWxfZndkKGUsIHR2KSlcbiAgICAgICAgIHNldM6xKGlzzrEoZSksIHR2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZCgpXG4gICAgICB9XG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5BcHApIHtcbiAgICAgIGNvbnN0IGXKuTogRXhwci5BcHAgPSBhcyhlLCBFeHByLkFwcClcbiAgICAgIGV2YWxfZndkKGXKuS5mLCB0LnRmKVxuICAgICAgZXZhbF9md2QoZcq5LmUsIHQudHUpXG4gICAgICByZWNEZWZzXyhEaXJlY3Rpb24uRndkLCB0Ls60KVxuICAgICAgZXZhbF9md2QodC7Ovi7OuiwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBzZXTOsShib29sXy5tZWV0KGlzzrEodC50ZiksIGFwcGx5X2Z3ZCh0Ls6+KSwgaXPOsShlKSwgaXPOsShleHBsVmFsdWUodC50LCB2KSkpLCB0dilcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlVuYXJ5QXBwKSB7XG4gICAgICBjb25zdCBlyrk6IEV4cHIuQXBwID0gYXMoZSwgRXhwci5BcHApXG4gICAgICBldmFsX2Z3ZChlyrkuZiwgdC50ZilcbiAgICAgIGV2YWxfZndkKGXKuS5lLCB0LnR2KVxuICAgICAgc2V0zrEoYm9vbF8ubWVldChpc86xKHQudGYpLCBpc86xKHQudHYpLCBpc86xKGUpKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5CaW5hcnlBcHApIHtcbiAgICAgIGNvbnN0IGXKuTogRXhwci5CaW5hcnlBcHAgPSBhcyhlLCBFeHByLkJpbmFyeUFwcClcbiAgICAgIGV2YWxfZndkKGXKuS5lMSwgdC50djEpXG4gICAgICBldmFsX2Z3ZChlyrkuZTIsIHQudHYyKVxuICAgICAgc2V0zrEoYm9vbF8ubWVldChpc86xKHQudHYxKSwgaXPOsSh0LnR2MiksIGlzzrEoZSkpLCB0dilcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkRlZnMpIHtcbiAgICAgIGNvbnN0IGXKuTogRXhwci5EZWZzID0gYXMoZSwgRXhwci5EZWZzKVxuICAgICAgZGVmc19md2QoZcq5LmRlZsyFLCB0LmRlZsyFKVxuICAgICAgZXZhbF9md2QoZcq5LmUsIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgc2V0zrEoYm9vbF8ubWVldChpc86xKGUpLCBpc86xKGV4cGxWYWx1ZSh0LnQsIHYpKSksIHR2KVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuTWF0Y2hBcykge1xuICAgICAgY29uc3QgZcq5OiBFeHByLk1hdGNoQXMgPSBhcyhlLCBFeHByLk1hdGNoQXMpXG4gICAgICBldmFsX2Z3ZChlyrkuZSwgdC50dSlcbiAgICAgIGV2YWxfZndkKHQuzr4uzrosIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgc2V0zrEoYm9vbF8ubWVldChhcHBseV9md2QodC7OviksIGlzzrEoZSksIGlzzrEoZXhwbFZhbHVlKHQudCwgdikpKSwgdHYpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5UeXBlbWF0Y2gpIHtcbiAgICAgIGNvbnN0IGXKuTogRXhwci5UeXBlbWF0Y2ggPSBhcyhlLCBFeHByLlR5cGVtYXRjaClcbiAgICAgIGV2YWxfZndkKGXKuS5lLCB0LnR1KVxuICAgICAgZXZhbF9md2QoZ2V0KGXKuS5jYXNlcywgdC5kKSEsIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgc2V0zrEoYm9vbF8ubWVldChpc86xKGUpLCBpc86xKGV4cGxWYWx1ZSh0LnQsIHYpKSksIHR2KVxuICAgfSBlbHNlIHtcbiAgICAgIGFic3VyZCgpXG4gICB9XG59XG5cbi8vIEF2b2lkIGV4Y2Vzc2l2ZSBqb2lucyB2aWEgYSBtZXJnaW5nIGltcGxlbWVudGF0aW9uOyByZXF1aXJlcyBhbGwgYW5ub3RhdGlvbnMgdG8gaGF2ZSBiZWVuIGNsZWFyZWQgZmlyc3QuXG5leHBvcnQgZnVuY3Rpb24gZXZhbF9id2QgKGU6IEV4cHIsIHR2OiBFeHBsVmFsdWUpOiB2b2lkIHtcbiAgIGNvbnN0IHt0LCB2fTogRXhwbFZhbHVlID0gdHZcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5Db25zdCAmJiAodiBpbnN0YW5jZW9mIE51bSB8fCB2IGluc3RhbmNlb2YgU3RyKSkge1xuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCBlKVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuRnVuICYmIHYgaW5zdGFuY2VvZiBDbG9zdXJlKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5EYXRhRXhwbCkge1xuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgICAgIGNvbnN0IGXKuTogRXhwci5EYXRhRXhwciA9IGFzKGUsIEV4cHIuRGF0YUV4cHIpXG4gICAgICAgICAvLyByZXZlcnNlIG9yZGVyIGJ1dCBzaG91bGRuJ3QgbWF0dGVyIGluIGFic2VuY2Ugb2Ygc2lkZS1lZmZlY3RzOlxuICAgICAgICAgemlwKEV4cGwuZXhwbENoaWxkcmVuKHQsIHYpLCBlyrkuX19jaGlsZHJlbikubWFwKChbdHYsIGVdKSA9PiBldmFsX2J3ZChlLCB0dikpXG4gICAgICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgYWJzdXJkKClcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlF1b3RlKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5WYXIpIHtcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5BcHApIHtcbiAgICAgIGFzc2VydCh0LnRmLnYgaW5zdGFuY2VvZiBDbG9zdXJlKVxuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCBleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIGV2YWxfYndkKHQuzr4uzrosIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgYXBwbHlfYndkKHQuzr4sIGlzzrEodHYpKVxuICAgICAgcmVjRGVmc18oRGlyZWN0aW9uLkJ3ZCwgdC7OtClcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgdC50ZilcbiAgICAgIGNvbnN0IGXKuTogRXhwci5BcHAgPSBhcyhlLCBFeHByLkFwcClcbiAgICAgIGV2YWxfYndkKGXKuS5mLCB0LnRmKVxuICAgICAgZXZhbF9id2QoZcq5LmUsIHQudHUpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5VbmFyeUFwcCkge1xuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCB0LnRmKVxuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCB0LnR2KVxuICAgICAgY29uc3QgZcq5OiBFeHByLkFwcCA9IGFzKGUsIEV4cHIuQXBwKVxuICAgICAgZXZhbF9id2QoZcq5LmYsIHQudGYpXG4gICAgICBldmFsX2J3ZChlyrkuZSwgdC50dilcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgZSlcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkJpbmFyeUFwcCkge1xuICAgICAgYXNzZXJ0KGJpbmFyeU9wcy5oYXModC5vcE5hbWUudmFsKSlcbiAgICAgIHNldGpvaW7OsShpc86xKHR2KSwgdC50djEpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIHQudHYyKVxuICAgICAgY29uc3QgZcq5OiBFeHByLkJpbmFyeUFwcCA9IGFzKGUsIEV4cHIuQmluYXJ5QXBwKVxuICAgICAgZXZhbF9id2QoZcq5LmUxLCB0LnR2MSlcbiAgICAgIGV2YWxfYndkKGXKuS5lMiwgdC50djIpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5EZWZzKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgY29uc3QgZcq5OiBFeHByLkRlZnMgPSBhcyhlLCBFeHByLkRlZnMpXG4gICAgICBldmFsX2J3ZChlyrkuZSwgZXhwbFZhbHVlKHQudCwgdikpXG4gICAgICBkZWZzX2J3ZChlyrkuZGVmzIUsIHQuZGVmzIUpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2VcbiAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5NYXRjaEFzKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgY29uc3QgZcq5OiBFeHByLk1hdGNoQXMgPSBhcyhlLCBFeHByLk1hdGNoQXMpXG4gICAgICBldmFsX2J3ZCh0Ls6+Ls66LCBleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIGFwcGx5X2J3ZCh0Ls6+LCBpc86xKHR2KSlcbiAgICAgIGV2YWxfYndkKGXKuS5lLCB0LnR1KVxuICAgICAgc2V0am9pbs6xKGlzzrEodHYpLCBlKVxuICAgfSBlbHNlXG4gICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuVHlwZW1hdGNoKSB7XG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgY29uc3QgZcq5OiBFeHByLlR5cGVtYXRjaCA9IGFzKGUsIEV4cHIuVHlwZW1hdGNoKVxuICAgICAgZXZhbF9id2QoZ2V0KGXKuS5jYXNlcywgdC5kKSEsIGV4cGxWYWx1ZSh0LnQsIHYpKVxuICAgICAgZXZhbF9id2QoZcq5LmUsIHQudHUpXG4gICAgICBzZXRqb2luzrEoaXPOsSh0diksIGUpXG4gICB9IGVsc2Uge1xuICAgICAgYWJzdXJkKClcbiAgIH1cbn1cblxufVxuXG5pbml0RGF0YVR5cGUoXG4gICBFeHByLkV4cHIsXG4gICBbRXhwci5BcHAsIEV4cHIuQmluYXJ5QXBwLCBFeHByLkNvbnN0TnVtLCBFeHByLkNvbnN0U3RyLCBFeHByLkRhdGFFeHByLCBFeHByLkRlZnMsIEV4cHIuRnVuLCBFeHByLk1hdGNoQXMsIEV4cHIuUXVvdGUsIEV4cHIuVmFyXVxuKVxuIiwiaW1wb3J0IHsgX19ub25OdWxsLCBhYnN1cmQsIGFzc2VydCwgY2xhc3NOYW1lIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUsIGV4cGxWYWx1ZSB9IGZyb20gXCIuL0RhdGFWYWx1ZVwiXG5pbXBvcnQgeyBFdmFsIH0gZnJvbSBcIi4vRXZhbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4vRXhwclwiXG5pbXBvcnQgeyBFbGltLCBNYXRjaCB9IGZyb20gXCIuL01hdGNoXCJcbmltcG9ydCB7IFVuYXJ5T3AgfSBmcm9tIFwiLi9QcmltaXRpdmVcIlxuaW1wb3J0IHsgSWQsIFByaW1WYWx1ZSwgU3RyLCBfLCBmaWVsZHMgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyBhdCB9IGZyb20gXCIuL1ZlcnNpb25lZFwiXG5cbmV4cG9ydCB0eXBlIENsb3N1cmUgPSBFdmFsLkNsb3N1cmVcbmV4cG9ydCB0eXBlIEV4cGwgPSBFeHBsLkV4cGxcblxuZXhwb3J0IG5hbWVzcGFjZSBFeHBsIHtcbiAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFeHBsIGV4dGVuZHMgRGF0YVZhbHVlPFwiRXhwbFwiPiB7XG4gICB9XG5cbiAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBOb25UZXJtaW5hbCBleHRlbmRzIEV4cGwge1xuICAgICAgYWJzdHJhY3QgdDogRXhwbFxuICAgfVxuXG4gICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGVybWluYWwgZXh0ZW5kcyBFeHBsIHtcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIE5vblRlcm1pbmFsIHtcbiAgICAgIHRmOiBFeHBsVmFsdWU8Q2xvc3VyZT4gPSBfXG4gICAgICB0dTogRXhwbFZhbHVlID0gX1xuICAgICAgzrQ6IExpc3Q8UmVjRGVmPiA9IF8gLy8gYWRkaXRpb25hbCByZWN1cnNpdmUgZnVuY3Rpb25zIGJvdW5kIGF0IHRoaXMgc3RlcFxuICAgICAgzr46IE1hdGNoPEV4cHI+ID0gX1xuICAgICAgdDogRXhwbCA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIGFwcCAodGY6IEV4cGxWYWx1ZTxDbG9zdXJlPiwgdHU6IEV4cGxWYWx1ZSwgzrQ6IExpc3Q8UmVjRGVmPiwgzr46IE1hdGNoPEV4cHI+LCB0OiBFeHBsKTogKGs6IElkKSA9PiBBcHAge1xuICAgICAgcmV0dXJuIGF0KEFwcCwgdGYsIHR1LCDOtCwgzr4sIHQpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBVbmFyeUFwcCBleHRlbmRzIFRlcm1pbmFsIHtcbiAgICAgIHRmOiBFeHBsVmFsdWU8VW5hcnlPcD4gPSBfXG4gICAgICB0djogRXhwbFZhbHVlPFByaW1WYWx1ZT4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiB1bmFyeUFwcCAodGY6IEV4cGxWYWx1ZTxVbmFyeU9wPiwgdHY6IEV4cGxWYWx1ZTxQcmltVmFsdWU+KTogKGs6IElkKSA9PiBVbmFyeUFwcCB7XG4gICAgICByZXR1cm4gYXQoVW5hcnlBcHAsIHRmLCB0dilcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIEJpbmFyeUFwcCBleHRlbmRzIFRlcm1pbmFsIHtcbiAgICAgIHR2MTogRXhwbFZhbHVlPFByaW1WYWx1ZT4gPSBfXG4gICAgICBvcE5hbWU6IFN0ciA9IF9cbiAgICAgIHR2MjogRXhwbFZhbHVlPFByaW1WYWx1ZT4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBiaW5hcnlBcHAgKHR2MTogRXhwbFZhbHVlPFByaW1WYWx1ZT4sIG9wTmFtZTogU3RyLCB0djI6IEV4cGxWYWx1ZTxQcmltVmFsdWU+KTogKGs6IElkKSA9PiBCaW5hcnlBcHAge1xuICAgICAgcmV0dXJuIGF0KEJpbmFyeUFwcCwgdHYxLCBvcE5hbWUsIHR2MilcbiAgIH1cblxuICAgLy8gSGFzIGEgY29uY3JldGUgc3ViY2xhc3MgZm9yIGVhY2ggZGF0YXR5cGUuXG4gICBleHBvcnQgY2xhc3MgRGF0YUV4cGwgZXh0ZW5kcyBUZXJtaW5hbCB7XG4gICAgICBnZXQgY3RyICgpOiBzdHJpbmcge1xuICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBnZXQgX19jaGlsZHJlbiAoKTogRXhwbFtdIHtcbiAgICAgICAgIHJldHVybiBzdXBlci5fX2NoaWxkcmVuIGFzIEV4cGxbXVxuICAgICAgfVxuICAgfVxuXG4gICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRGVmIGV4dGVuZHMgRGF0YVZhbHVlPFwiRXhwbC5EZWZcIj4ge1xuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgTGV0IGV4dGVuZHMgRGVmIHtcbiAgICAgIHg6IFN0ciA9IF9cbiAgICAgIHR2OiBFeHBsVmFsdWUgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBsZXRfICh4OiBTdHIsIHR2OiBFeHBsVmFsdWUpOiAoazogSWQpID0+IExldCB7XG4gICAgICByZXR1cm4gYXQoTGV0LCB4LCB0dilcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFByaW0gZXh0ZW5kcyBEZWYge1xuICAgICAgeDogU3RyID0gX1xuICAgICAgdF9vcDogRXhwbFZhbHVlPFVuYXJ5T3A+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gcHJpbSAoeDogU3RyLCB0X29wOiBFeHBsVmFsdWU8VW5hcnlPcD4pOiAoazogSWQpID0+IFByaW0ge1xuICAgICAgcmV0dXJuIGF0KFByaW0sIHgsIHRfb3ApXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBSZWNEZWYgZXh0ZW5kcyBEYXRhVmFsdWU8XCJFeHBsLlJlY0RlZlwiPiB7XG4gICAgICB4OiBTdHIgPSBfXG4gICAgICB0ZjogRXhwbFZhbHVlPENsb3N1cmU+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gcmVjRGVmICh4OiBTdHIsIHRmOiBFeHBsVmFsdWU8Q2xvc3VyZT4pOiAoazogSWQpID0+IFJlY0RlZiB7XG4gICAgICByZXR1cm4gYXQoUmVjRGVmLCB4LCB0ZilcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIExldFJlYyBleHRlbmRzIERlZiB7XG4gICAgICDOtDogTGlzdDxSZWNEZWY+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gbGV0UmVjICjOtDogTGlzdDxSZWNEZWY+KTogKGs6IElkKSA9PiBMZXRSZWMge1xuICAgICAgcmV0dXJuIGF0KExldFJlYywgzrQpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBEZWZzIGV4dGVuZHMgTm9uVGVybWluYWwge1xuICAgICAgZGVmzIU6IExpc3Q8RGVmPiA9IF9cbiAgICAgIHQ6IEV4cGwgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBkZWZzIChkZWbMhTogTGlzdDxEZWY+LCB0OiBFeHBsKTogKGs6IElkKSA9PiBEZWZzIHtcbiAgICAgIHJldHVybiBhdChEZWZzLCBkZWbMhSwgdClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIENvbnN0IGV4dGVuZHMgVGVybWluYWwge1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gY29uc3RfICgpOiAoazogSWQpID0+IENvbnN0IHtcbiAgICAgIHJldHVybiBhdChDb25zdClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIEZ1biBleHRlbmRzIFRlcm1pbmFsIHtcbiAgICAgIM+DOiBFbGltPEV4cHI+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gZnVuICjPgzogRWxpbTxFeHByPik6IChrOiBJZCkgPT4gRnVuIHtcbiAgICAgIHJldHVybiBhdChGdW4sIM+DKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgTWF0Y2hBcyBleHRlbmRzIE5vblRlcm1pbmFsIHtcbiAgICAgIHR1OiBFeHBsVmFsdWUgPSBfXG4gICAgICDOvjogTWF0Y2g8RXhwcj4gPSBfXG4gICAgICB0OiBFeHBsID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gbWF0Y2hBcyAodHU6IEV4cGxWYWx1ZSwgzr46IE1hdGNoPEV4cHI+LCB0OiBFeHBsKTogKGs6IElkKSA9PiBNYXRjaEFzIHtcbiAgICAgIHJldHVybiBhdChNYXRjaEFzLCB0dSwgzr4sIHQpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBRdW90ZSBleHRlbmRzIFRlcm1pbmFsIHtcbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHF1b3RlICgpOiAoazogSWQpID0+IFF1b3RlIHtcbiAgICAgIHJldHVybiBhdChRdW90ZSlcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFR5cGVtYXRjaCBleHRlbmRzIE5vblRlcm1pbmFsIHtcbiAgICAgIHR1OiBFeHBsVmFsdWUgPSBfXG4gICAgICBkOiBTdHIgPSBfXG4gICAgICB0OiBFeHBsID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gdHlwZW1hdGNoICh0dTogRXhwbFZhbHVlLCBkOiBTdHIsIHQ6IEV4cGwpOiAoazogSWQpID0+IFR5cGVtYXRjaCB7XG4gICAgICByZXR1cm4gYXQoVHlwZW1hdGNoLCB0dSwgZCwgdClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFZhciBleHRlbmRzIE5vblRlcm1pbmFsIHtcbiAgICAgIHg6IFN0ciA9IF9cbiAgICAgIHQ6IEV4cGwgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiB2YXJfICh4OiBTdHIsIHQ6IEV4cGwpOiAoazogSWQpID0+IFZhciB7XG4gICAgICByZXR1cm4gYXQoVmFyLCB4LCB0KVxuICAgfVxuXG4gICAvLyBTaG91bGQgcHJvYmFibHkgZG8gYSBiZXR0ZXIgam9iIG9mIHJlc3RyaWN0aW5nIGsgdG8gYmUgYSBib25hIGZpZGUgZmllbGQgbmFtZS5cbiAgIGV4cG9ydCBmdW5jdGlvbiBleHBsQ2hpbGQ8VCBleHRlbmRzIERhdGFWYWx1ZT4gKHQ6IEV4cGwsIHY6IFQsIHByb3A6IGtleW9mIFQpOiBFeHBsVmFsdWUge1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgYXNzZXJ0KHQgaW5zdGFuY2VvZiBEYXRhRXhwbClcbiAgICAgICAgIHJldHVybiBleHBsVmFsdWUodC5fX2NoaWxkKHByb3AgYXMga2V5b2YgRXhwbCkgYXMgRXhwbCwgdi5fX2NoaWxkKHByb3ApKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICByZXR1cm4gZXhwbENoaWxkKHQudCwgdiwgcHJvcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAvLyBQcmltaXRpdmUgYXBwbGljYXRpb25zIGFyZSBjdXJyZW50bHkgXCJ0ZXJtaW5hbFwiIGZvcm1zLCB3aGljaCBpcyB0ZWNobmljYWxseSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZmFjdCBcbiAgICAgICAgIC8vIHRoYXQgdGhleSBjYW4gcmV0dXJuIHN0cnVjdHVyZWQgZGF0YS4gSW4gcHJhY3RpY2UgdGhpcyBkb2Vzbid0IG1hdHRlciBiZWNhdXNlIHRoZXkgb25seSByZXR1cm4gdmFsdWVzIFxuICAgICAgICAgLy8gbGlrZSBUcnVlIGFuZCBGYWxzZSwgd2hpY2ggaGF2ZSBubyBjaGlsZHJlbi4gUHJvYmFibHkgcHJpbWl0aXZlcyBzaG91bGQgYmUgbm9uLXRlcm1pbmFsLlxuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBleHBsQ2hpbGRyZW4gKHQ6IEV4cGwsIHY6IERhdGFWYWx1ZSk6IEV4cGxWYWx1ZVtdIHtcbiAgICAgIHJldHVybiBmaWVsZHModikubWFwKGsgPT4gZXhwbENoaWxkKHQsIHYsIGsgYXMgYW55KSlcbiAgIH1cbn1cbiIsImltcG9ydCB7IF9fbm9uTnVsbCwgYWJzdXJkLCBjbGFzc05hbWUgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgZGlmZiwgdW5pb24gfSBmcm9tIFwiLi91dGlsL1NldFwiXG5pbXBvcnQgeyBDb25zLCBMaXN0LCBOaWwgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRGF0YVZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IEZpbml0ZU1hcCB9IGZyb20gXCIuL0Zpbml0ZU1hcFwiXG5pbXBvcnQgeyBFbGltLCBEYXRhRWxpbSwgVmFyRWxpbSB9IGZyb20gXCIuL01hdGNoXCJcbmltcG9ydCB7IElkLCBOdW0sIFN0ciwgXyB9IGZyb20gXCIuL1ZhbHVlXCJcbmltcG9ydCB7IGF0IH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuLy8gQ29uc3RhbnRzIHVzZWQgZm9yIHBhcnNpbmcsIGFuZCBhbHNvIGZvciB0b1N0cmluZygpIGltcGxlbWVudGF0aW9ucy5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICAgYXJyb3c6IFwi4oaSXCIsXG4gICBhczogXCJhc1wiLFxuICAgYnJhY2tldEw6IFwiW1wiLFxuICAgYnJhY2tldFI6IFwiXVwiLFxuICAgY29tbWE6IFwiLFwiLFxuICAgY3VybHlMOiBcIntcIixcbiAgIGN1cmx5UjogXCJ9XCIsXG4gICBlbGxpcHNpczogXCIuLi5cIixcbiAgIGVxdWFsczogXCI9XCIsXG4gICBmdW46IFwiZnVuXCIsXG4gICBpbl86IFwiaW5cIixcbiAgIGxldF86IFwibGV0XCIsXG4gICBsZXRSZWM6IFwibGV0cmVjXCIsXG4gICBtYXRjaDogXCJtYXRjaFwiLFxuICAgcHJpbWl0aXZlOiBcInByaW1pdGl2ZVwiLFxuICAgcGFyZW5MOiBcIihcIixcbiAgIHBhcmVuUjogXCIpXCIsXG4gICBxdW90ZXM6ICdcIicsXG4gICBzZW1pY29sb246IFwiO1wiLFxuICAgdHlwZW1hdGNoOiBcInR5cGVtYXRjaFwiXG59XG5cbmV4cG9ydCB0eXBlIEV4cHIgPSBFeHByLkV4cHJcbmV4cG9ydCB0eXBlIENvbnQgPSBFeHByLkNvbnRcblxuZXhwb3J0IG5hbWVzcGFjZSBFeHByIHtcbiAgIC8vIFVzZSB0byBiZSBhIHBhcmFtZXRlcmlzZWQgY2xhc3MgYnV0IHdlIGNhbiBzaW1wbGlmeSB1c2luZyBvdXIgbm9taW5hbCB0eXBlIGlkaW9tLlxuICAgZXhwb3J0IHR5cGUgQ29udCA9IEV4cHIgfCBEYXRhVmFsdWU8XCJFbGltXCI+XG5cbiAgIHR5cGUgU3ludGF4Tm9kZVRhZyA9IFwiRXhwclwiIHwgXCJFeHByLkRlZlwiIHwgXCJFeHByLlJlY0RlZlwiXG5cbiAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTeW50YXhOb2RlPFRhZyBleHRlbmRzIFN5bnRheE5vZGVUYWcgPSBTeW50YXhOb2RlVGFnPiBleHRlbmRzIERhdGFWYWx1ZTxUYWc+IHtcbiAgIH1cblxuICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEV4cHIgZXh0ZW5kcyBTeW50YXhOb2RlPFwiRXhwclwiPiB7XG4gICB9XG4gICBcbiAgIGV4cG9ydCBjbGFzcyBBcHAgZXh0ZW5kcyBFeHByIHtcbiAgICAgIGY6IEV4cHIgPSBfXG4gICAgICBlOiBFeHByID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gYXBwIChmOiBFeHByLCBlOiBFeHByKTogKGs6IElkKSA9PiBBcHAge1xuICAgICAgcmV0dXJuIGF0KEFwcCwgZiwgZSlcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIEJpbmFyeUFwcCBleHRlbmRzIEV4cHIge1xuICAgICAgZTE6IEV4cHIgPSBfXG4gICAgICBvcE5hbWU6IFN0ciA9IF9cbiAgICAgIGUyOiBFeHByID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gYmluYXJ5QXBwIChlMTogRXhwciwgb3BOYW1lOiBTdHIsIGUyOiBFeHByKTogKGs6IElkKSA9PiBCaW5hcnlBcHAge1xuICAgICAgcmV0dXJuIGF0KEJpbmFyeUFwcCwgZTEsIG9wTmFtZSwgZTIpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBDb25zdE51bSBleHRlbmRzIEV4cHIge1xuICAgICAgdmFsOiBOdW0gPSBfXG4gICB9XG4gICBcbiAgIGV4cG9ydCBmdW5jdGlvbiBjb25zdE51bSAodmFsOiBOdW0pOiAoazogSWQpID0+IENvbnN0TnVtIHtcbiAgICAgIHJldHVybiBhdChDb25zdE51bSwgdmFsKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgQ29uc3RTdHIgZXh0ZW5kcyBFeHByIHtcbiAgICAgIHZhbDogU3RyID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gY29uc3RTdHIgKHZhbDogU3RyKTogKGs6IElkKSA9PiBDb25zdFN0ciB7XG4gICAgICByZXR1cm4gYXQoQ29uc3RTdHIsIHZhbClcbiAgIH1cblxuICAgLy8gSGFzIGEgY29uY3JldGUgc3ViY2xhc3MgZm9yIGVhY2ggZGF0YXR5cGUuIFNob3VsZCB0aGlzIGJlIHBhcmFtZXRlcmlzZWQgYnkgVCBleHRlbmRzIERhdGFWYWx1ZT9cbiAgIGV4cG9ydCBjbGFzcyBEYXRhRXhwciBleHRlbmRzIEV4cHIge1xuICAgICAgZ2V0IGN0ciAoKTogc3RyaW5nIHtcbiAgICAgICAgIHJldHVybiBjbGFzc05hbWUodGhpcylcbiAgICAgIH1cblxuICAgICAgX19jaGlsZCAocHJvcDoga2V5b2YgdGhpcyk6IEV4cHIge1xuICAgICAgICAgcmV0dXJuIHN1cGVyLl9fY2hpbGQocHJvcCkgYXMgRXhwclxuICAgICAgfVxuXG4gICAgICBnZXQgX19jaGlsZHJlbiAoKTogRXhwcltdIHtcbiAgICAgICAgIHJldHVybiBzdXBlci5fX2NoaWxkcmVuIGFzIEV4cHJbXVxuICAgICAgfVxuICAgfVxuICAgXG4gICBleHBvcnQgY2xhc3MgRGVmIGV4dGVuZHMgU3ludGF4Tm9kZTxcIkV4cHIuRGVmXCI+IHtcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIExldCBleHRlbmRzIERlZiB7XG4gICAgICB4OiBTdHIgPSBfXG4gICAgICBlOiBFeHByID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gbGV0XyAoeDogU3RyLCBlOiBFeHByKTogKGs6IElkKSA9PiBMZXQge1xuICAgICAgcmV0dXJuIGF0KExldCwgeCwgZSlcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIFByaW0gZXh0ZW5kcyBEZWYge1xuICAgICAgeDogU3RyID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gcHJpbSAoeDogU3RyKTogKGs6IElkKSA9PiBQcmltIHtcbiAgICAgIHJldHVybiBhdChQcmltLCB4KVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgUmVjRGVmIGV4dGVuZHMgU3ludGF4Tm9kZTxcIkV4cHIuUmVjRGVmXCI+IHtcbiAgICAgIHg6IFN0ciA9IF9cbiAgICAgIM+DOiBFbGltPEV4cHI+ID0gX1xuICAgfVxuIFxuICAgZXhwb3J0IGZ1bmN0aW9uIHJlY0RlZiAoeDogU3RyLCDPgzogRWxpbTxFeHByPik6IChrOiBJZCkgPT4gUmVjRGVmIHtcbiAgICAgIHJldHVybiBhdChSZWNEZWYsIHgsIM+DKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgTGV0UmVjIGV4dGVuZHMgRGVmIHtcbiAgICAgIM60OiBMaXN0PFJlY0RlZj4gPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBsZXRSZWMgKM60OiBMaXN0PFJlY0RlZj4pOiAoazogSWQpID0+IExldFJlYyB7XG4gICAgICByZXR1cm4gYXQoTGV0UmVjLCDOtClcbiAgIH1cblxuICAgZXhwb3J0IGNsYXNzIERlZnMgZXh0ZW5kcyBFeHByIHtcbiAgICAgIGRlZsyFOiBMaXN0PERlZj4gPSBfXG4gICAgICBlOiBFeHByID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gZGVmcyAoZGVmzIU6IExpc3Q8RGVmPiwgZTogRXhwcik6IChrOiBJZCkgPT4gRGVmcyB7XG4gICAgICByZXR1cm4gYXQoRGVmcywgZGVmzIUsIGUpXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBGdW4gZXh0ZW5kcyBFeHByIHtcbiAgICAgIM+DOiBFbGltPEV4cHI+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gZnVuICjPgzogRWxpbTxFeHByPik6IChrOiBJZCkgPT4gRnVuIHtcbiAgICAgIHJldHVybiBhdChGdW4sIM+DKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgTWF0Y2hBcyBleHRlbmRzIEV4cHIge1xuICAgICAgZTogRXhwciA9IF9cbiAgICAgIM+DOiBFbGltPEV4cHI+ID0gX1xuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gbWF0Y2hBcyAoZTogRXhwciwgz4M6IEVsaW08RXhwcj4pOiAoazogSWQpID0+IE1hdGNoQXMge1xuICAgICAgcmV0dXJuIGF0KE1hdGNoQXMsIGUsIM+DKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgUXVvdGUgZXh0ZW5kcyBFeHByIHtcbiAgICAgIGU6IEV4cHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBxdW90ZSAoZTogRXhwcik6IChrOiBJZCkgPT4gUXVvdGUge1xuICAgICAgcmV0dXJuIGF0KFF1b3RlLCBlKVxuICAgfVxuXG4gICAvLyBCcmluZyBpbiBsaW5lIHdpdGggdGhlIGN1cnJlbnQgZWxpbWluYXRvciBkZXNpZ24sIGkuZS4gb3B0aW1pc2UgaW50byBhbiBvYmplY3Q/XG4gICBleHBvcnQgY2xhc3MgVHlwZW1hdGNoIGV4dGVuZHMgRXhwciB7XG4gICAgICBlOiBFeHByID0gX1xuICAgICAgY2FzZXM6IEZpbml0ZU1hcDxFeHByPiA9IF9cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHR5cGVtYXRjaCAoZTogRXhwciwgY2FzZXM6IEZpbml0ZU1hcDxFeHByPik6IChrOiBJZCkgPT4gVHlwZW1hdGNoIHtcbiAgICAgIHJldHVybiBhdChUeXBlbWF0Y2gsIGUsIGNhc2VzKVxuICAgfVxuXG4gICBleHBvcnQgY2xhc3MgVmFyIGV4dGVuZHMgRXhwciB7XG4gICAgICB4OiBTdHIgPSBfXG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiB2YXJfICh4OiBTdHIpOiAoazogSWQpID0+IFZhciB7XG4gICAgICByZXR1cm4gYXQoVmFyLCB4KVxuICAgfVxuXG4gICAvLyB1c2VkIGJ5IFdyYXR0bGVyXG4gICBleHBvcnQgZnVuY3Rpb24gZnJlZVZhcnMgKGU6IEV4cHIpOiBTZXQ8c3RyaW5nPiB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbnN0TnVtKSB7XG4gICAgICAgICByZXR1cm4gbmV3IFNldCgpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29uc3RTdHIpIHtcbiAgICAgICAgIHJldHVybiBuZXcgU2V0KClcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGdW4pIHtcbiAgICAgICAgIHJldHVybiBmcmVlVmFyc0VsaW0oZS7PgylcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBEYXRhRXhwcikge1xuICAgICAgICAgcmV0dXJuIHVuaW9uKC4uLmUuX19jaGlsZHJlbi5tYXAoZnJlZVZhcnMpKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFF1b3RlKSB7XG4gICAgICAgICByZXR1cm4gZnJlZVZhcnMoZS5lKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFZhcikge1xuICAgICAgICAgcmV0dXJuIG5ldyBTZXQoW2UueC52YWxdKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFwcCkge1xuICAgICAgICAgcmV0dXJuIHVuaW9uKGZyZWVWYXJzKGUuZiksIGZyZWVWYXJzKGUuZSkpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQmluYXJ5QXBwKSB7XG4gICAgICAgICByZXR1cm4gdW5pb24oZnJlZVZhcnMoZS5lMSksIGZyZWVWYXJzKGUuZTIpKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIERlZnMpIHtcbiAgICAgICAgIGNvbnN0IFtib3VuZCwgZnJlZV06IFtTZXQ8c3RyaW5nPiwgU2V0PHN0cmluZz5dID0gZnJlZVZhcnNEZWZzKGUuZGVmzIUsIG5ldyBTZXQoKSlcbiAgICAgICAgIHJldHVybiB1bmlvbihkaWZmKGZyZWVWYXJzKGUuZSksIGJvdW5kKSwgZnJlZSlcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNYXRjaEFzKSB7XG4gICAgICAgICByZXR1cm4gdW5pb24oZnJlZVZhcnMoZS5lKSwgZnJlZVZhcnNFbGltKGUuz4MpKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFR5cGVtYXRjaCkge1xuICAgICAgICAgcmV0dXJuIHVuaW9uKGZyZWVWYXJzKGUuZSksIC4uLmUuY2FzZXMudG9BcnJheSgpLm1hcCgoeyBzbmQgfSkgPT4gZnJlZVZhcnMoc25kKSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGZyZWVWYXJzQ29udCAozro6IENvbnQpOiBTZXQ8c3RyaW5nPiB7XG4gICAgICBpZiAozrogaW5zdGFuY2VvZiBFeHByKSB7XG4gICAgICAgICByZXR1cm4gZnJlZVZhcnMozropXG4gICAgICB9IGVsc2UgXG4gICAgICBpZiAozrogaW5zdGFuY2VvZiBFbGltKSB7XG4gICAgICAgICByZXR1cm4gZnJlZVZhcnNFbGltKM66KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBmcmVlVmFyc0VsaW08SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPik6IFNldDxzdHJpbmc+IHtcbiAgICAgIGlmIChWYXJFbGltLmlzKM+DKSkge1xuICAgICAgICAgcmV0dXJuIGRpZmYoZnJlZVZhcnNDb250KM+DLs66KSwgbmV3IFNldChbz4MueC52YWxdKSlcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKERhdGFFbGltLmlzKM+DKSkge1xuICAgICAgICAgcmV0dXJuIHVuaW9uKC4uLijPgy5fX2NoaWxkcmVuIGFzIEtbXSkubWFwKGZyZWVWYXJzQ29udCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIC8vIChib3VuZCwgZnJlZSkgdmFycyAtIG5vdCBuZWNlc3NhcmlseSBkaXNqb2ludCwgYmVjYXVzZSB0aGUgZGVmcyBuZXN0XG4gICBmdW5jdGlvbiBmcmVlVmFyc0RlZnMgKGRlZsyFOiBMaXN0PERlZj4sIGJvdW5kOiBTZXQ8c3RyaW5nPik6IFtTZXQ8c3RyaW5nPiwgU2V0PHN0cmluZz5dIHtcbiAgICAgIGlmIChDb25zLmlzKGRlZsyFKSkge1xuICAgICAgICAgY29uc3QgZGVmOiBEZWYgPSBkZWbMhS5oZWFkXG4gICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgUHJpbSkge1xuICAgICAgICAgICAgY29uc3QgeMyFOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoW2RlZi54LnZhbF0pLFxuICAgICAgICAgICAgICAgICAgW2JvdW5kyrksIGZyZWVdID0gZnJlZVZhcnNEZWZzKGRlZsyFLnRhaWwsIGJvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIFtib3VuZMq5LCBkaWZmKGZyZWUsIHjMhSldXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBMZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHjMhTogU2V0PHN0cmluZz4gPSBuZXcgU2V0KFtkZWYueC52YWxdKSxcbiAgICAgICAgICAgICAgICAgIFtib3VuZMq5LCBmcmVlXSA9IGZyZWVWYXJzRGVmcyhkZWbMhS50YWlsLCB1bmlvbihib3VuZCwgeMyFKSlcbiAgICAgICAgICAgIHJldHVybiBbYm91bmTKuSwgdW5pb24oZGlmZihmcmVlLCB4zIUpLCBmcmVlVmFycyhkZWYuZSkpXVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgTGV0UmVjKSB7XG4gICAgICAgICAgICBjb25zdCBmzIU6IFJlY0RlZltdID0gZGVmLs60LnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgIHjMhTogU2V0PHN0cmluZz4gPSBuZXcgU2V0KGbMhS5tYXAoZiA9PiBmLngudmFsKSksXG4gICAgICAgICAgICAgICAgICBbYm91bmTKuSwgZnJlZV0gPSBmcmVlVmFyc0RlZnMoZGVmzIUudGFpbCwgdW5pb24oYm91bmQsIHjMhSkpXG4gICAgICAgICAgICByZXR1cm4gW2JvdW5kyrksIGRpZmYodW5pb24oZnJlZSwgLi4uZsyFLm1hcChmID0+IGZyZWVWYXJzRWxpbShmLs+DKSkpLCB4zIUpXVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoTmlsLmlzKGRlZsyFKSkge1xuICAgICAgICAgcmV0dXJuIFtib3VuZCwgbmV3IFNldCgpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxufVxuIiwiaW1wb3J0IHsgYWJzdXJkIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IEVtcHR5LCBOb25FbXB0eSwgUGFpciwgVHJlZSwgZW1wdHksIG5vbkVtcHR5LCBwYWlyIH0gZnJvbSBcIi4vQmFzZVR5cGVzXCJcbmltcG9ydCB7IFBlcnNpc3RlbnQsIFN0ciB9IGZyb20gXCIuL1ZhbHVlXCJcblxuLy8gU2ltcGxpZnkgdG8ga2V5cyBvZiB0eXBlIFN0ciB1bnRpbCB3ZSBoYXZlIHNvbWV0aGluZyBsaWtlIHR5cGUgY2xhc3Nlcy5cbmV4cG9ydCB0eXBlIEZpbml0ZU1hcDxWPiA9IFRyZWU8UGFpcjxTdHIsIFY+PlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0IDxWIGV4dGVuZHMgUGVyc2lzdGVudD4gKG06IEZpbml0ZU1hcDxWPiwgazogU3RyKTogViB8IHVuZGVmaW5lZCB7XG4gICBpZiAoTm9uRW1wdHkuaXMobSkpIHtcbiAgICAgIGlmIChrLmxlcShtLnQuZnN0KSkge1xuICAgICAgICAgaWYgKG0udC5mc3QubGVxKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gbS50LnNuZFxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQobS5sZWZ0LCBrKVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBnZXQobS5yaWdodCwgaylcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKEVtcHR5LmlzKG0pKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnQgPFYgZXh0ZW5kcyBQZXJzaXN0ZW50PiAobTogRmluaXRlTWFwPFY+LCBrOiBTdHIsIHY6IFYpOiBGaW5pdGVNYXA8Vj4ge1xuICAgaWYgKE5vbkVtcHR5LmlzKG0pKSB7XG4gICAgICBpZiAoay5sZXEobS50LmZzdCkpIHtcbiAgICAgICAgIGlmIChtLnQuZnN0LmxlcShrKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vbkVtcHR5KG0ubGVmdCwgcGFpcihrLCB2KSwgbS5yaWdodClcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9uRW1wdHkoaW5zZXJ0KG0ubGVmdCwgaywgdiksIG0udCwgbS5yaWdodClcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gbm9uRW1wdHkobS5sZWZ0LCBtLnQsIGluc2VydChtLnJpZ2h0LCBrLCB2KSlcbiAgICAgIH1cbiAgIH0gZWxzZVxuICAgaWYgKEVtcHR5LmlzKG0pKSB7XG4gICAgICByZXR1cm4gbm9uRW1wdHkobSwgcGFpcihrLCB2KSwgbSlcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZXRvbiA8ViBleHRlbmRzIFBlcnNpc3RlbnQ+IChrOiBTdHIsIHY6IFYpOiBGaW5pdGVNYXA8Vj4ge1xuICAgcmV0dXJuIGluc2VydChlbXB0eSgpLCBrLCB2KVxufVxuXG4vLyBVbmlvbiB3aXRoIGEgY29tYmluaW5nIGZ1bmN0aW9uLiBJZiBrZXlzIGFyZSBlcXVhbCwgcmlnaHQtaGFuZCBrZXkgd2lsbCBiZSB1c2VkIGluIHRoZSBvdXRwdXQuXG4vLyBBdm9pZCBwcmltZXMgaW4gc2lnbmF0dXJlOyBzZWVtcyB0byBiZSBpbmNvbXBhdGlibGUgd2l0aCB2ZXJzaW9uIG9mIHRzLWxvYWRlciB1c2VkIGJ5IFdyYXR0bGVyLlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uV2l0aCA8ViBleHRlbmRzIFBlcnNpc3RlbnQsIFQgZXh0ZW5kcyBGaW5pdGVNYXA8Vj4+IChtMTogVCwgbTI6IFQsIGY6ICh2MTogViwgdjI6IFYpID0+IFYpOiBUIHtcbiAgIGlmIChOb25FbXB0eS5pcyhtMikpIHtcbiAgICAgIGNvbnN0IGs6IFN0ciA9IG0yLnQuZnN0LFxuICAgICAgICAgICAgdjogViA9IG0yLnQuc25kLFxuICAgICAgICAgICAgdsq5OiBWIHwgdW5kZWZpbmVkID0gZ2V0KG0xLCBrKSxcbiAgICAgICAgICAgIHU6IFYgPSB2yrkgPT09IHVuZGVmaW5lZCA/IHYgOiBmKHYsIHbKuSlcbiAgICAgIHJldHVybiB1bmlvbldpdGgoaW5zZXJ0KHVuaW9uV2l0aChtMSwgbTIubGVmdCwgZiksIGssIHUpLCBtMi5yaWdodCwgZikgYXMgVFxuICAgfSBlbHNlXG4gICBpZiAoRW1wdHkuaXMobTIpKSB7XG4gICAgICByZXR1cm4gbTFcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cbiIsImltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgaW5pdERhdGFUeXBlIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRGF0YVZhbHVlIH0gZnJvbSBcIi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IE51bSwgU3RyLCBfIH0gZnJvbSBcIi4vVmFsdWVcIlxuXG5leHBvcnQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBEYXRhVmFsdWU8XCJQb2ludFwiPiB7XG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG59XG5cbi8vIElzb21vcnBoaWMgdG8gQm9vbFxuZXhwb3J0IGNsYXNzIE9yaWVudCBleHRlbmRzIERhdGFWYWx1ZTxcIk9yaWVudFwiPiB7XG59XG5cbmV4cG9ydCBjbGFzcyBIb3JpeiBleHRlbmRzIE9yaWVudCB7XG59XG5cbmV4cG9ydCBjbGFzcyBWZXJ0IGV4dGVuZHMgT3JpZW50IHtcbn1cblxuZXhwb3J0IHR5cGUgR3JhcGhpY3NFbGVtZW50VGFnID0gXCJDaXJjbGVcIiB8IFwiR3JvdXBcIiB8IFwiTGluZVwiIHwgXCJQb2x5bGluZVwiIHwgXCJQb2x5bWFya2Vyc1wiIHwgXCJSZWN0XCIgfCBcIlRleHRcIiB8IFwiVmlld3BvcnRcIlxuXG5leHBvcnQgY2xhc3MgR3JhcGhpY3NFbGVtZW50PFRhZyBleHRlbmRzIEdyYXBoaWNzRWxlbWVudFRhZyA9IEdyYXBoaWNzRWxlbWVudFRhZz4gZXh0ZW5kcyBEYXRhVmFsdWU8VGFnPiB7XG59XG5cbmV4cG9ydCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBHcmFwaGljc0VsZW1lbnQ8XCJDaXJjbGVcIj4geyAgIFxuICAgeDogTnVtID0gX1xuICAgeTogTnVtID0gX1xuICAgcmFkaXVzOiBOdW0gPSBfXG4gICBmaWxsOiBTdHIgPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBHcm91cCBleHRlbmRzIEdyYXBoaWNzRWxlbWVudDxcIkdyb3VwXCI+IHtcbiAgIGdzOiBMaXN0PEdyYXBoaWNzRWxlbWVudD4gPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBMaW5lIGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50PFwiTGluZVwiPiB7XG4gICBwMTogUG9pbnQgPSBfXG4gICBwMjogUG9pbnQgPSBfXG4gICBzdHJva2U6IFN0ciA9IF9cbiAgIHN0cm9rZVdpZHRoOiBOdW0gPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBQb2x5bGluZSBleHRlbmRzIEdyYXBoaWNzRWxlbWVudDxcIlBvbHlsaW5lXCI+IHtcbiAgIHBvaW50czogTGlzdDxQb2ludD4gPSBfXG4gICBzdHJva2U6IFN0ciA9IF9cbiAgIHN0cm9rZVdpZHRoOiBOdW0gPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBQb2x5bWFya2VycyBleHRlbmRzIEdyYXBoaWNzRWxlbWVudDxcIlBvbHltYXJrZXJzXCI+IHtcbiAgIHBvaW50czogTGlzdDxQb2ludD4gPSBfXG4gICBtYXJrZXJzOiBMaXN0PEdyYXBoaWNzRWxlbWVudD4gPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBSZWN0IGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50PFwiUmVjdFwiPiB7XG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG4gICB3aWR0aDogTnVtID0gX1xuICAgaGVpZ2h0OiBOdW0gPSBfXG4gICBmaWxsOiBTdHIgPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBUZXh0IGV4dGVuZHMgR3JhcGhpY3NFbGVtZW50PFwiVGV4dFwiPiB7XG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG4gICBzdHI6IFN0ciA9IF9cbiAgIGFuY2hvcjogU3RyID0gXyAgIC8vIFNWRyB0ZXh0LWFuY2hvclxuICAgYmFzZWxpbmU6IFN0ciA9IF8gLy8gU1ZHIGFsaWdubWVudC1iYXNlbGluZVxufVxuXG5leHBvcnQgY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBHcmFwaGljc0VsZW1lbnQ8XCJWaWV3cG9ydFwiPiB7XG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG4gICB3aWR0aDogTnVtID0gX1xuICAgaGVpZ2h0OiBOdW0gPSBfXG4gICBmaWxsOiBTdHIgPSBfXG4gICBtYXJnaW46IE51bSA9IF8gLy8gaW4gKnBhcmVudCogcmVmZXJlbmNlIGZyYW1lXG4gICBzY2FsZTogVHJhbnNmb3JtID0gX1xuICAgdHJhbnNsYXRlOiBUcmFuc2Zvcm0gPSBfIC8vIHNjYWxpbmcgYXBwbGllcyB0byB0cmFuc2xhdGVkIGNvb3JkaW5hdGVzXG4gICBnOiBHcmFwaGljc0VsZW1lbnQgPSBfXG59XG5cbmV4cG9ydCB0eXBlIFRyYW5zZm9ybVRhZyA9IFwiU2NhbGVcIiB8IFwiVHJhbnNsYXRlXCJcblxuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybTxUYWcgZXh0ZW5kcyBUcmFuc2Zvcm1UYWcgPSBUcmFuc2Zvcm1UYWc+IGV4dGVuZHMgRGF0YVZhbHVlPFRhZz4ge1xufVxuXG5leHBvcnQgY2xhc3MgU2NhbGUgZXh0ZW5kcyBUcmFuc2Zvcm08XCJTY2FsZVwiPiB7XG4gICB4OiBOdW0gPSBfXG4gICB5OiBOdW0gPSBfXG59XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGUgZXh0ZW5kcyBUcmFuc2Zvcm08XCJUcmFuc2xhdGVcIj4ge1xuICAgeDogTnVtID0gX1xuICAgeTogTnVtID0gX1xufVxuXG5leHBvcnQgdHlwZSBNYXJrZXJUYWcgPSBcIkFycm93aGVhZFwiXG5cbmV4cG9ydCBjbGFzcyBNYXJrZXI8VGFnIGV4dGVuZHMgTWFya2VyVGFnID0gTWFya2VyVGFnPiBleHRlbmRzIERhdGFWYWx1ZTxUYWc+IHtcbn1cblxuZXhwb3J0IGNsYXNzIEFycm93aGVhZCBleHRlbmRzIE1hcmtlcjxcIkFycm93aGVhZFwiPiB7ICAgXG59XG5cbmluaXREYXRhVHlwZShQb2ludCwgW1BvaW50XSlcbmluaXREYXRhVHlwZShPcmllbnQsIFtIb3JpeiwgVmVydF0pXG5pbml0RGF0YVR5cGUoR3JhcGhpY3NFbGVtZW50LCBbQ2lyY2xlLCBHcm91cCwgTGluZSwgUG9seWxpbmUsIFBvbHltYXJrZXJzLCBSZWN0LCBUZXh0LCBWaWV3cG9ydF0pXG5pbml0RGF0YVR5cGUoVHJhbnNmb3JtLCBbU2NhbGUsIFRyYW5zbGF0ZV0pXG5pbml0RGF0YVR5cGUoTWFya2VyLCBbQXJyb3doZWFkXSlcbiIsIi8vIFwidHlwaW5nc1wiIHByb3BlcnR5IG9mIHBhY2thZ2UuanNvbiByZXF1aXJlcyBhIHNpbmdsZSBUeXBlU2NyaXB0IGludGVyZmFjZS5cbmltcG9ydCBcIi4vQmFzZVR5cGVzXCIgLy8gbmVlZCB0aGVzZSBlYXJseSBiZWNhdXNlIG9mIGEgV2VicGFjayBkZXBlbmRlbmN5IHByb2JsZW1cbmltcG9ydCB7IFBhbmUgfSBmcm9tIFwiLi9hcHAvUGFuZVwiXG5pbXBvcnQgeyBQYW5lQ29vcmRpbmF0b3IgfSBmcm9tIFwiLi9hcHAvUGFuZUNvb3JkaW5hdG9yXCJcbmltcG9ydCB7IEVudiwgZW1wdHlFbnYgfSBmcm9tIFwiLi9FbnZcIlxuaW1wb3J0IHsgRXZhbCB9IGZyb20gXCIuL0V2YWxcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IHsgYmluZERhdGFzZXQsIG9wZW5EYXRhc2V0QXMsIHBhcnNlV2l0aEltcG9ydHMgfSBmcm9tIFwiLi9Nb2R1bGVcIlxuXG5leHBvcnQgeyBQYW5lLCBQYW5lQ29vcmRpbmF0b3IsIEVudiwgRXZhbCwgRXhwciwgYmluZERhdGFzZXQsIGVtcHR5RW52LCBvcGVuRGF0YXNldEFzLCBwYXJzZVdpdGhJbXBvcnRzIH1cbiIsImltcG9ydCB7IHppcCwgemlwV2l0aCB9IGZyb20gXCIuL3V0aWwvQXJyYXlcIlxuaW1wb3J0IHsgQ2xhc3MsIF9fbm9uTnVsbCwgYWJzdXJkLCBhc3NlcnQsIGNsYXNzTmFtZSwgdXNlckVycm9yIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IGVxIH0gZnJvbSBcIi4vdXRpbC9PcmRcIlxuaW1wb3J0IHsgQW5ub3RhdGlvbiwgYm9vbF8gfSBmcm9tIFwiLi91dGlsL0xhdHRpY2VcIlxuaW1wb3J0IHsgaXPOsSwgc2V0am9pbs6xIH0gZnJvbSBcIi4vQW5ub3RhdGlvblwiXG5pbXBvcnQgeyBMaXN0LCBjb25zLCBuaWwgfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgRGF0YVR5cGUsIGN0clRvRGF0YVR5cGUsIGVsaW1Ub0RhdGFUeXBlIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRW52LCBlbXB0eUVudiB9IGZyb20gXCIuL0VudlwiXG5pbXBvcnQgeyBFeHBsIH0gZnJvbSBcIi4vRXhwbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4vRXhwclwiXG5pbXBvcnQgeyBJZCwgTWVtb0lkLCBTdHIsIFZhbHVlLCBfLCBmaWVsZHMsIG1ha2UsIG1lbW9JZCB9IGZyb20gXCIuL1ZhbHVlXCJcbmltcG9ydCB7IGF0IH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuaW1wb3J0IENvbnQgPSBFeHByLkNvbnRcblxuLy8gVW5yZWxhdGVkIHRvIHRoZSBhbm5vdGF0aW9uIGxhdHRpY2UuIEV4cHIgY2FzZSBpbnRlbnRpb25hbGx5IG9ubHkgZGVmaW5lZCBmb3IgaGlnaGVyLW9yZGVyIChmdW5jdGlvbikgY2FzZS5cbmZ1bmN0aW9uIGpvaW48SyBleHRlbmRzIENvbnQ+ICjOujogSywgzrrKuTogSyk6IEsge1xuICAgY29uc3QgazogTWVtb0lkID0gbWVtb0lkKGpvaW4sIGFyZ3VtZW50cylcbiAgIGlmICjOuiBpbnN0YW5jZW9mIEVsaW0gJiYgzrrKuSBpbnN0YW5jZW9mIEVsaW0pIHtcbiAgICAgIHJldHVybiBEYXRhRWxpbS5qb2luPEs+KM66LCDOusq5KSBhcyBDb250IGFzIEtcbiAgIH0gZWxzZVxuICAgaWYgKM66IGluc3RhbmNlb2YgRXhwci5GdW4gJiYgzrrKuSBpbnN0YW5jZW9mIEV4cHIuRnVuKSB7XG4gICAgICByZXR1cm4gRXhwci5mdW4oam9pbijOui7PgywgzrrKuS7PgykpKGspIGFzIEV4cHIgYXMgS1xuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhYnN1cmQoXCJVbmRlZmluZWQgam9pbi5cIiwgzrosIM66yrkpXG4gICB9XG59XG5cbi8vIFByZW9yZGVyIHRyYXZlcnNhbCBvZiBhbGwgbm9kZXMgaW4gdGhlIG1hdGNoZWQgcHJlZml4LlxudHlwZSBNYXRjaFByZWZpeCA9IExpc3Q8RXhwbFZhbHVlPERhdGFWYWx1ZT4+XG5cbmV4cG9ydCBjbGFzcyBNYXRjaDxLPiBleHRlbmRzIERhdGFWYWx1ZTxcIk1hdGNoXCI+IHtcbiAgIHR2zIU6IE1hdGNoUHJlZml4ID0gX1xuICAgzro6IEsgPSBfXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxLIGV4dGVuZHMgQ29udD4gKM6+OiBNYXRjaFByZWZpeCwgzro6IEspOiBNYXRjaDxLPiB7XG4gICByZXR1cm4gbWFrZShNYXRjaCwgzr4sIM66KSBhcyBNYXRjaDxLPlxufVxuXG4vLyBTZWUgR2l0SHViIGlzc3VlICMxMjguXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRWxpbTxLIGV4dGVuZHMgQ29udCA9IENvbnQ+IGV4dGVuZHMgRGF0YVZhbHVlPFwiRWxpbVwiPiB7XG4gICAvLyBjb3VsZCBoYXZlIGNhbGxlZCB0aGlzIFwibWF0Y2hcIiwgYnV0IGNvbmZsaWN0cyB3aXRoIGZhY3RvcnkgbWV0aG9kIG9mIHNhbWUgbmFtZVxuICAgYXBwbHkgKHR2OiBFeHBsVmFsdWUpOiBbRW52LCBNYXRjaDxLPl0ge1xuICAgICAgcmV0dXJuIGFwcGx5Xyh0aGlzLCB0diwgbmlsKCkpXG4gICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5XzxLIGV4dGVuZHMgQ29udD4gKM+DOiBFbGltPEs+LCB0djogRXhwbFZhbHVlLCB1zIU6IE1hdGNoUHJlZml4KTogW0VudiwgTWF0Y2g8Sz5dIHtcbiAgIGlmIChWYXJFbGltLmlzKM+DKSkge1xuICAgICAgY29uc3Qgz4E6IEVudiA9IM+DLngudmFsID09PSBcIl9cIiA/IGVtcHR5RW52KCkgOiBFbnYuc2luZ2xldG9uKM+DLngsIHR2KVxuICAgICAgcmV0dXJuIFvPgSwgbWF0Y2godcyFLCDPgy7OuildXG4gICB9IGVsc2VcbiAgIGlmIChEYXRhRWxpbS5pcyjPgykpIHtcbiAgICAgIGNvbnN0IHY6IFZhbHVlID0gdHYudixcbiAgICAgICAgICAgIGM6IHN0cmluZyA9IGNsYXNzTmFtZSh2KVxuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgICAgIGNvbnN0IM66OiBLID0gKM+DIGFzIGFueSlbY10gYXMgS1xuICAgICAgICAgaWYgKM66ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHR2zIU6IEV4cGxWYWx1ZVtdID0gRXhwbC5leHBsQ2hpbGRyZW4odHYudCwgdiksXG4gICAgICAgICAgICBbz4EsIM6+XTogW0VudiwgTWF0Y2g8Sz5dID0gbWF0Y2hBcmdzKM66LCB0dsyFLCB1zIUpXG4gICAgICAgICAgICByZXR1cm4gW8+BLCBtYXRjaChjb25zKHR2IGFzIEV4cGxWYWx1ZTxEYXRhVmFsdWU+LCDOvi50dsyFKSwgzr4uzropXVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGQ6IERhdGFUeXBlID0gZWxpbVRvRGF0YVR5cGUuZ2V0KGNsYXNzTmFtZSjPgykpIVxuICAgICAgICAgICAgaWYgKGQuY3Rycy5oYXMoYykpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoYFBhdHRlcm4gbWlzbWF0Y2g6IFwiJHtjfVwiIGNhc2UgdW5kZWZpbmVkIGZvciAke2QubmFtZS52YWx9LmApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJFcnJvcihgUGF0dGVybiBtaXNtYXRjaDogZm91bmQgJHtjfSwgZXhwZWN0ZWQgJHtkLm5hbWUudmFsfS5gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoYFBhdHRlcm4gbWlzbWF0Y2g6ICR7Y30gaXMgbm90IGEgZGF0YXR5cGUuYCwgdiwgz4MpXG4gICAgICB9XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICB9XG59XG5cbi8vIFBhcnNlciBlbnN1cmVzIGNvbnN0cnVjdG9yIGNhbGxzIGFyZSBzYXR1cmF0ZWQuXG5mdW5jdGlvbiBtYXRjaEFyZ3M8SyBleHRlbmRzIENvbnQ+ICjOujogSywgdHbMhTogRXhwbFZhbHVlW10sIHXMhTogTWF0Y2hQcmVmaXgpOiBbRW52LCBNYXRjaDxLPl0ge1xuICAgaWYgKHR2zIUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW2VtcHR5RW52KCksIG1hdGNoKHXMhSwgzropXVxuICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFt0diwgLi4udHbMhcq5XSA9IHR2zIVcbiAgICAgIGlmICjOuiBpbnN0YW5jZW9mIEVsaW0pIHtcbiAgICAgICAgIGNvbnN0IM+DOiBFbGltPEs+ID0gzrosIC8vIFwidW5mb2xkXCIgSyBpbnRvIEVsaW08Sz5cbiAgICAgICAgICAgICAgIFvPgSwgzr5dOiBbRW52LCBNYXRjaDxLPl0gPSBhcHBseV8oz4MsIHR2LCB1zIUpLFxuICAgICAgICAgICAgICAgW8+ByrksIM6+yrldOiBbRW52LCBNYXRjaDxLPl0gPSBtYXRjaEFyZ3Mozr4uzrosIHR2zIXKuSwgzr4udHbMhSlcbiAgICAgICAgIHJldHVybiBbz4EuY29uY2F0KM+ByrkpLCDOvsq5XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoXCJUb28gbWFueSBhcmd1bWVudHMgdG8gY29uc3RydWN0b3IuXCIpXG4gICAgICB9XG4gICB9XG59XG5cbi8vIENvbmNyZXRlIGluc3RhbmNlcyBoYXZlIGEgZmllbGQgcGVyIGNvbnN0cnVjdG9yLCBpbiAqbGV4aWNvZ3JhcGhpY2FsKiBvcmRlci5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhRWxpbTxLIGV4dGVuZHMgQ29udCA9IENvbnQ+IGV4dGVuZHMgRWxpbTxLPiB7XG4gICBzdGF0aWMgaXM8SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPik6IM+DIGlzIERhdGFFbGltPEs+IHtcbiAgICAgIHJldHVybiDPgyBpbnN0YW5jZW9mIERhdGFFbGltXG4gICB9XG5cbiAgIHN0YXRpYyBqb2luPEsgZXh0ZW5kcyBDb250PiAoz4M6IEVsaW08Sz4sIM+EOiBFbGltPEs+KTogRWxpbTxLPiB7XG4gICAgICBjb25zdCBrOiBNZW1vSWQgPSBtZW1vSWQoRGF0YUVsaW0uam9pbiwgYXJndW1lbnRzKVxuICAgICAgaWYgKFZhckVsaW0uaXMoz4MpICYmIFZhckVsaW0uaXMoz4QpICYmIGVxKM+DLngsIM+ELngpKSB7XG4gICAgICAgICByZXR1cm4gdmFyRWxpbSjPgy54LCBqb2luKM+DLs66LCDPhC7OuikpKGspXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChEYXRhRWxpbS5pcyjPgykgJiYgRGF0YUVsaW0uaXMoz4QpKSB7XG4gICAgICAgICAvLyBCb3RoIG1hcHMgKHdoaWNoIGFyZSBub24tZW1wdHkpIGNhbiAoaW5kdWN0aXZlbHkpIGJlIGFzc3VtZWQgdG8gaGF2ZSBrZXlzIHRha2VuIGZyb20gdGhlIFxuICAgICAgICAgLy8gc2FtZSBkYXRhdHlwZS4gRW5zdXJlIHRoYXQgaW52YXJpYW50IGlzIHByZXNlcnZlZDpcbiAgICAgICAgIGNvbnN0IGNfz4M6IHN0cmluZyA9IGZpZWxkcyjPgylbMF0sXG4gICAgICAgICAgICAgICBjX8+EOiBzdHJpbmcgPSBmaWVsZHMoz4QpWzBdXG4gICAgICAgICBpZiAoY3RyVG9EYXRhVHlwZS5nZXQoY1/PgykgIT09IGN0clRvRGF0YVR5cGUuZ2V0KGNfz4QpKSB7XG4gICAgICAgICAgICB1c2VyRXJyb3IoYCR7Y1/Pg30gYW5kICR7Y1/PhH0gYXJlIGNvbnN0cnVjdG9ycyBvZiBkaWZmZXJlbnQgZGF0YXR5cGVzLmApXG4gICAgICAgICB9XG4gICAgICAgICBjb25zdCBjzrrMhTE6IFtzdHJpbmcsIEtdW10gPSB6aXAoZmllbGRzKM+DKSwgz4MuX19jaGlsZHJlbiBhcyBLW10pLFxuICAgICAgICAgICAgICAgY866zIUyOiBbc3RyaW5nLCBLXVtdID0gemlwKGZpZWxkcyjPhCksIM+ELl9fY2hpbGRyZW4gYXMgS1tdKVxuICAgICAgICAgYXNzZXJ0KGPOusyFMS5sZW5ndGggPT09IGPOusyFMi5sZW5ndGgpXG4gICAgICAgICBjb25zdCBjzrrMhTogW3N0cmluZywgS11bXSA9IHppcFdpdGgoKFtjMSwgzroxXTogW3N0cmluZywgS10sIFtjMiwgzroyXTogW3N0cmluZywgS10pOiBbc3RyaW5nLCBLXSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQoYzEgPT09IGMyKVxuICAgICAgICAgICAgcmV0dXJuIFtjMSwgzroxID09PSB1bmRlZmluZWQgPyDOujIgOiAozroyID09PSB1bmRlZmluZWQgPyDOujEgOiBqb2luKM66MSwgzroyKSldXG4gICAgICAgICB9XG4gICAgICAgICApKGPOusyFMSwgY866zIUyKVxuICAgICAgICAgcmV0dXJuIGRhdGFFbGltKC4uLmPOusyFKShrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoXCJVbmRlZmluZWQgam9pbi5cIiwgz4MsIM+EKVxuICAgICAgfVxuICAgfVxufVxuXG4vLyBjzrrMhSBub24tZW1wdHkgYW5kIGNvbnN0cnVjdG9ycyBhbGwgb2YgdGhlIHNhbWUgZGF0YXR5cGUuXG5leHBvcnQgZnVuY3Rpb24gZGF0YUVsaW08SyBleHRlbmRzIENvbnQ+ICguLi5jzrrMhTogW3N0cmluZywgS11bXSk6IChrOiBJZCkgPT4gRWxpbTxLPiB7XG4gICBjb25zdCBkOiBEYXRhVHlwZSA9IF9fbm9uTnVsbChjdHJUb0RhdGFUeXBlLmdldChjzrrMhVswXVswXSkpLFxuICAgICAgICAgY8yFOiBzdHJpbmdbXSA9IGPOusyFLm1hcCgoKFtjLCBfXSkgPT4gYykpLFxuICAgICAgICAgY8yFyrk6IHN0cmluZ1tdID0gWy4uLmQuY3Rycy5rZXlzKCldLCAvLyBzb3J0ZWRcbiAgICAgICAgIGbMhTogQ29udFtdID0gW11cbiAgIGxldCBuOiBudW1iZXIgPSAwXG4gICBmb3IgKGxldCBuyrk6IG51bWJlciA9IDA7IG7KuSA8IGPMhcq5Lmxlbmd0aDsgKytuyrkpIHtcbiAgICAgIGlmIChjzIUuaW5jbHVkZXMoY8yFyrlbbsq5XSkpIHtcbiAgICAgICAgIGbMhS5wdXNoKGPOusyFW24rK11bMV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgZsyFLnB1c2godW5kZWZpbmVkIGFzIGFueSlcbiAgICAgIH1cbiAgIH1cbiAgIHJldHVybiBhdChkLmVsaW1DIGFzIENsYXNzPERhdGFFbGltPEs+PiwgLi4uZsyFKVxufVxuXG5leHBvcnQgY2xhc3MgVmFyRWxpbTxLIGV4dGVuZHMgQ29udD4gZXh0ZW5kcyBFbGltPEs+IHtcbiAgIHg6IFN0ciA9IF9cbiAgIM66OiBLID0gX1xuXG4gICBzdGF0aWMgaXM8SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPik6IM+DIGlzIFZhckVsaW08Sz4ge1xuICAgICAgcmV0dXJuIM+DIGluc3RhbmNlb2YgVmFyRWxpbVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyRWxpbTxLIGV4dGVuZHMgQ29udD4gKHg6IFN0ciwgzro6IEspOiAoazogSWQpID0+IFZhckVsaW08Sz4ge1xuICAgcmV0dXJuIGF0PFZhckVsaW08Sz4+KFZhckVsaW0sIHgsIM66KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlfZndkICjOvjogTWF0Y2g8RXhwcj4pOiBBbm5vdGF0aW9uIHtcbiAgIHJldHVybiDOvi50dsyFLnRvQXJyYXkoKS5yZWR1Y2UoKM6xOiBBbm5vdGF0aW9uLCB0djogRXhwbFZhbHVlKTogQW5ub3RhdGlvbiA9PiBib29sXy5tZWV0KM6xLCBpc86xKHR2KSksIGJvb2xfLnRvcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5X2J3ZCAozr46IE1hdGNoPEV4cHI+LCDOsTogQW5ub3RhdGlvbik6IHZvaWQge1xuICAgzr4udHbMhS50b0FycmF5KCkuZm9yRWFjaCgodHY6IEV4cGxWYWx1ZSk6IHZvaWQgPT4gc2V0am9pbs6xKM6xLCB0dikpXG59XG4iLCJpbXBvcnQgeyBHcmFtbWFyLCBQYXJzZXIgfSBmcm9tIFwibmVhcmxleVwiXG5pbXBvcnQgeyBfX25vbk51bGwsIGFzLCBhc3NlcnQsIHVzZXJFcnJvciB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBCYXNlVHlwZXMsIENvbnMsIExpc3QsIE5pbCwgUGFpciB9IGZyb20gXCIuL0Jhc2VUeXBlc1wiXG5pbXBvcnQgeyBleHByQ2xhc3MgfSBmcm9tIFwiLi9EYXRhVHlwZVwiXG5pbXBvcnQgeyBFbnYsIEV4dGVuZEVudiwgZW1wdHlFbnYsIGV4dGVuZEVudiB9IGZyb20gXCIuL0VudlwiXG5pbXBvcnQgeyBFdmFsIH0gZnJvbSBcIi4vRXZhbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4vRXhwclwiXG5pbXBvcnQgXCIuL0dyYXBoaWNzXCIgLy8gZm9yIGRhdGF0eXBlc1xuaW1wb3J0IGdyYW1tYXIgZnJvbSBcIi4vUGFyc2VcIlxuaW1wb3J0IHsgUHJpbVZhbHVlLCBTdHIgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyDOvSwgYXQsIG51bSwgc3RyIH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuLy8gS2luZGVyZ2FydGVuIG1vZHVsZXMuXG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kdWxlIHtcbiAgIGV4cG9ydCBsZXQgcmVzb3VyY2VTZXJ2ZXJVcmw6IHN0cmluZyAvLyBzaG91bGQgbm90IGVuZCBpbiBcIi9cIiwgdXNlIFwiLlwiIGZvciBsb2NhbCBydW5cblxuICAgLy8gRGVmaW5lIGFzIGNvbnN0YW50cyB0byBlbmZvcmNlIHNoYXJpbmc7IGNvdWxkIHVzZSBtZW1vaXNhdGlvbi5cbiAgIGV4cG9ydCBsZXQgcHJlbHVkZTogRW52XG4gICBleHBvcnQgbGV0IGdyYXBoaWNzOiBFbnZcblxuICAgZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpc2UgKHJlc291cmNlU2VydmVyVXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGFzc2VydChNb2R1bGUucmVzb3VyY2VTZXJ2ZXJVcmwgPT09IHVuZGVmaW5lZClcbiAgICAgIE1vZHVsZS5yZXNvdXJjZVNlcnZlclVybCA9IF9fbm9uTnVsbChyZXNvdXJjZVNlcnZlclVybCwgYHJlc291cmNlU2VydmVyVXJsIGlzICR7cmVzb3VyY2VTZXJ2ZXJVcmx9YClcbiAgICAgIEJhc2VUeXBlcy5pbml0aWFsaXNlKClcbiAgICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGlzaW5nIGJhc2UgdHlwZXNcIilcbiAgICAgIHByZWx1ZGUgPSBsb2FkTW9kdWxlKGVtcHR5RW52KCksIFwicHJlbHVkZVwiKVxuICAgICAgZ3JhcGhpY3MgPSBsb2FkTW9kdWxlKHByZWx1ZGUsIFwiZ3JhcGhpY3NcIilcbiAgIH1cbn1cblxuZnVuY3Rpb24gaW1wb3J0XyAoLi4ubW9kdWxlczogRW52W10pOiBFbnYge1xuICAgaWYgKG1vZHVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHlFbnYoKVxuICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttLCAuLi5tc10gPSBtb2R1bGVzXG4gICAgICByZXR1cm4gbS5jb25jYXQoaW1wb3J0XyguLi5tcykpXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmlsZSAoZm9sZGVyOiBzdHJpbmcsIGZpbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICBhc3NlcnQoTW9kdWxlLnJlc291cmNlU2VydmVyVXJsICE9PSB1bmRlZmluZWQsIFwiTW9kdWxlIHN5c3RlbSBub3QgaW5pdGlhbGlzZWQuXCIpXG4gICBsZXQgdGV4dDogc3RyaW5nXG4gICBjb25zdCB4bWxodHRwOiBYTUxIdHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdFxuICAgY29uc3QgdXJsOiBzdHJpbmcgPSBNb2R1bGUucmVzb3VyY2VTZXJ2ZXJVcmwgKyBcIi9cIiArIGZvbGRlciArIFwiL1wiICsgZmlsZSArIFwiLmZsZFwiXG4gICBjb25zb2xlLmxvZyhgT3BlbmluZyAke3VybH1gKVxuICAgeG1saHR0cC5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpXG4gICB4bWxodHRwLnNlbmQoKVxuICAgaWYgKHhtbGh0dHAuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHRleHQgPSB4bWxodHRwLnJlc3BvbnNlVGV4dFxuICAgfVxuICAgaWYgKHRleHQhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBhc3NlcnQoZmFsc2UsIGAke3VybH0gY291bGQgbm90IGJlIGxvYWRlZC5gKVxuICAgfSBlbHNlICB7XG4gICAgICByZXR1cm4gdGV4dCFcbiAgIH1cbn1cblxuLy8gTm90IHN1cmUgaWYgTmVhcmxleSBjYW4gcGFyc2UgYXJiaXRyYXJ5IG5vbi10ZXJtaW5hbCwgYXMgb3Bwb3NlZCB0byByb290LlxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRNb2R1bGUgKM+BOiBFbnYsIGZpbGU6IHN0cmluZyk6IEVudiB7XG4gICBjb25zdCBzcmM6IHN0cmluZyA9IGxvYWRGaWxlKFwiZmx1aWQvbGliXCIsIGZpbGUpXG4gICBjb25zdCBzcmPKuTogc3RyaW5nID0gc3JjICsgXCIgaW4gMFwiXG4gICBjb25zdCBlOiBFeHByLkRlZnMgPSBhcyhzdWNjZXNzZnVsUGFyc2Uoc3JjyrkpLCBFeHByLkRlZnMpXG4gICByZXR1cm4gRXZhbC5kZWZzKM+BLCBlLmRlZsyFLCBlbXB0eUVudigpKVsxXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlbldpdGhJbXBvcnRzIChmaWxlOiBzdHJpbmcsIC4uLm1vZHVsZXM6IEVudltdKTogW0VudiwgRXhwcl0ge1xuICAgcmV0dXJuIHBhcnNlV2l0aEltcG9ydHMobG9hZEZpbGUoXCJmbHVpZC9leGFtcGxlXCIsIGZpbGUpLCAuLi5tb2R1bGVzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkRhdGFzZXRBcyAoZmlsZTogc3RyaW5nLCB4OiBzdHJpbmcpOiBFeHRlbmRFbnYge1xuICAgY29uc3QgW8+BLCBlXTogW0VudiwgRXhwcl0gPSBwYXJzZVdpdGhJbXBvcnRzKGxvYWRGaWxlKFwiZmx1aWQvZGF0YXNldFwiLCBmaWxlKSlcbiAgIHJldHVybiBFbnYuc2luZ2xldG9uKHN0cih4KSjOvSgpKSwgRXZhbC5ldmFsXyjPgSwgZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVdpdGhJbXBvcnRzIChzcmM6IHN0cmluZywgLi4ubW9kdWxlczogRW52W10pOiBbRW52LCBFeHByXSB7XG4gICBhc3NlcnQoTW9kdWxlLnJlc291cmNlU2VydmVyVXJsICE9PSB1bmRlZmluZWQsIFwiTW9kdWxlIHN5c3RlbSBub3QgaW5pdGlhbGlzZWQuXCIpXG4gICByZXR1cm4gW2ltcG9ydF8oX19ub25OdWxsKE1vZHVsZS5wcmVsdWRlKSwgX19ub25OdWxsKE1vZHVsZS5ncmFwaGljcyksIC4uLm1vZHVsZXMpLCBzdWNjZXNzZnVsUGFyc2Uoc3JjKV1cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2thY2gvbmVhcmxleS9pc3N1ZXMvMjc2I2lzc3VlY29tbWVudC0zMjQxNjIyMzRcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZXNzZnVsUGFyc2UgKHN0cjogc3RyaW5nKTogRXhwciB7XG4gICBjb25zdCB7IHJlc3VsdHMgfTogUGFyc2VyID0gbmV3IFBhcnNlcihHcmFtbWFyLmZyb21Db21waWxlZChncmFtbWFyKSkuZmVlZChzdHIpXG4gICBpZiAocmVzdWx0cy5sZW5ndGggPiAxKSB7XG4gICAgICB1c2VyRXJyb3IoXCJBbWJpZ3VvdXMgcGFyc2UuXCIpXG4gICB9IGVsc2VcbiAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdXNlckVycm9yKFwiVW5zdWNjZXNzZnVsIHBhcnNlLlwiKVxuICAgfVxuICAgcmV0dXJuIHJlc3VsdHNbMF1cbn1cblxuZXhwb3J0IHR5cGUgUmVjb3JkID0gTGlzdDxQYWlyPFN0ciwgUHJpbVZhbHVlPj4gLy8gZW50cnkgaW4gZGF0YXNldFxuXG4vLyBjcmVhdGUgYW4gZXhwcmVzc2lvbiBhbmQgZXZhbHVhdGUgaXQsIHNvIHdlIGhhdmUgYW4gZXhwbGFpbmVkIHZhbHVlXG5leHBvcnQgZnVuY3Rpb24gYmluZERhdGFzZXQgKM+BOiBFbnYsIHZzOiBPYmplY3RbXSwgeDogc3RyaW5nKTogRXh0ZW5kRW52IHtcbiAgIHJldHVybiBleHRlbmRFbnYoz4EsIHN0cih4KSjOvSgpKSwgRXZhbC5ldmFsXyjPgSwgYXNMaXN0KHZzLm1hcChhc1JlY29yZCkpKSlcbn1cblxuZnVuY3Rpb24gYXNSZWNvcmQgKHY6IE9iamVjdCk6IEV4cHIge1xuICAgcmV0dXJuIGFzTGlzdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2KS5tYXAoayA9PiBhc1BhaXIoaywgKHYgYXMgYW55KVtrXSkpKVxufVxuXG5mdW5jdGlvbiBhc1BhaXIgKGs6IHN0cmluZywgdjogdW5rbm93bik6IEV4cHIge1xuICAgcmV0dXJuIGF0KGV4cHJDbGFzcyhQYWlyKSwgYXNQcmltVmFsdWUoayksIGFzUHJpbVZhbHVlKHYpKSjOvSgpKVxufVxuXG5mdW5jdGlvbiBhc0xpc3QgKGXMhTogRXhwcltdKTogRXhwciB7XG4gICBsZXQgZcyFyrk6IEV4cHIgPSBhdChleHByQ2xhc3MoTmlsKSkozr0oKSlcbiAgIGZvciAobGV0IGUgb2YgWy4uLmXMhV0ucmV2ZXJzZSgpKSB7XG4gICAgICBlzIXKuSA9IGF0KGV4cHJDbGFzcyhDb25zKSwgZSwgZcyFyrkpKM69KCkpXG4gICB9XG4gICByZXR1cm4gZcyFyrlcbn1cblxuZnVuY3Rpb24gYXNQcmltVmFsdWUgKHY6IHVua25vd24pOiBFeHByIHtcbiAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIEV4cHIuY29uc3ROdW0obnVtKHYpKM69KCkpKSjOvSgpKVxuICAgfSBlbHNlXG4gICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBFeHByLmNvbnN0U3RyKHN0cih2KSjOvSgpKSkozr0oKSlcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXNlckVycm9yKGBJbGwtZm9ybWVkIGRhdGE6IGV4cGVjdGVkIHN0cmluZyBvciBudW1iZXIsIGZvdW5kICR7dHlwZW9mIHZ9LmApXG4gICB9XG59XG4iLCIvLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBuZWFybGV5LCB2ZXJzaW9uIDIuMTkuMVxuLy8gaHR0cDovL2dpdGh1Yi5jb20vSGFyZG1hdGgxMjMvbmVhcmxleVxuLy8gQnlwYXNzZXMgVFM2MTMzLiBBbGxvdyBkZWNsYXJlZCBidXQgdW51c2VkIGZ1bmN0aW9ucy5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGlkKGQ6IGFueVtdKTogYW55IHsgcmV0dXJuIGRbMF07IH1cbmRlY2xhcmUgdmFyIHdoaXRlc3BhY2U6IGFueTtcbmRlY2xhcmUgdmFyIHNpbmdsZUxpbmVDb21tZW50OiBhbnk7XG5kZWNsYXJlIHZhciBpZGVudDogYW55O1xuZGVjbGFyZSB2YXIgc3RyaW5nOiBhbnk7XG5kZWNsYXJlIHZhciBudW1iZXI6IGFueTtcbmRlY2xhcmUgdmFyIGNvbXBhcmVPcDogYW55O1xuZGVjbGFyZSB2YXIgZXhwb25lbnRPcDogYW55O1xuZGVjbGFyZSB2YXIgcHJvZHVjdE9wOiBhbnk7XG5kZWNsYXJlIHZhciBzdW1PcDogYW55O1xuXG5jb25zdCBtb28gPSByZXF1aXJlKCdtb28nKVxuY29uc3QgbGV4ZXIgPSBtb28uY29tcGlsZSh7XG4gICBpZGVudDoge1xuICAgICAgbWF0Y2g6IC9bYS16QS1aX11bMC05YS16QS1aX10qJyovLCAvLyBncmVlZHlcbiAgICAgIHR5cGU6IG1vby5rZXl3b3Jkcyh7XG4gICAgICAgIGtleXdvcmQ6IFtcIl9cIiwgXCJhc1wiLCBcIm1hdGNoXCIsIFwiZnVuXCIsIFwiaW5cIiwgXCJsZXRcIiwgXCJsZXRyZWNcIiwgXCJwcmltaXRpdmVcIiwgXCJ0eXBlbWF0Y2hcIl0sXG4gICAgICB9KVxuICAgfSxcbiAgIHdoaXRlc3BhY2U6IHtcbiAgICAgIG1hdGNoOiAvWyBcXGZcXHRcXHJcXG5dKy8sXG4gICAgICBsaW5lQnJlYWtzOiB0cnVlXG4gICB9LFxuICAgc2luZ2xlTGluZUNvbW1lbnQ6IC9cXC9cXC8uKiQvLFxuICAgLy8gSlNPTiBncmFtbWFyIGZvciBudW1iZXJzLCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzE1OS5odG1sI3NlY3Rpb24tNi5cbiAgIC8vIFNlZW1zIE1vbyByZXF1aXJlcyB1cyB0byB1c2Ugbm9uLWNhcHR1cmluZyBncm91cHMgKD86KVxuICAgbnVtYmVyOiAvXFwtPyg/OjB8WzEtOV1bMC05XSopKD86XFwuWzAtOV0rKT8oPzpbZXxFXVstfCtdP1swLTldKyk/LyxcbiAgIHN0cmluZzogL1wiKD86XFxcXFtcIlxcXFxdfFteXFxuXCJcXFxcXSkqXCIvLFxuICAgLy8gbm90IHF1aXRlIHN1cmUgd2h5IEkgY2FuJ3QgdXNlIGxpdGVyYWxzIGhlcmU6XG4gICBzdW1PcDogL1xcLXxcXCtcXCt8XFwrLyxcbiAgIGV4cG9uZW50T3A6IC9cXCpcXCovLFxuICAgcHJvZHVjdE9wOiAvXFwqfFxcLy8sIC8vIG11c3QgY29tZSBhZnRlciBleHBvbmVudE9wXG4gICBjb21wYXJlT3A6IC89PXw8PXw8fD49fD4vLFxuICAgc3ltYm9sOiBbXCIoXCIsIFwiKVwiLCBcIj1cIiwgXCLihpJcIiwgXCI7XCIsIFwie1wiLCBcIn1cIiwgXCIsXCIsIFwiW1wiLCBcIl1cIiwgXCIuLi5cIl0sIC8vIG11c3QgY29tZSBhZnRlciBjb21wYXJlT3Bcbn0pXG5cblxuaW1wb3J0IHsgX19jaGVjaywgYXNzZXJ0LCB1c2VyRXJyb3IgfSBmcm9tIFwiLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgQ29ucywgTGlzdCwgTmlsLCBQYWlyIH0gZnJvbSBcIi4vQmFzZVR5cGVzXCJcbmltcG9ydCB7IEN0ciwgY3RyRm9yLCBleHByQ2xhc3MsIHR5cGVzIH0gZnJvbSBcIi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuL0V4cHJcIlxuaW1wb3J0IHsgc2luZ2xldG9uLCB1bmlvbldpdGggfSBmcm9tIFwiLi9GaW5pdGVNYXBcIlxuaW1wb3J0IHsgRGF0YUVsaW0sIGRhdGFFbGltLCB2YXJFbGltIH0gZnJvbSBcIi4vTWF0Y2hcIlxuaW1wb3J0IHsgU3RyIH0gZnJvbSBcIi4vVmFsdWVcIlxuaW1wb3J0IHsgzr0sIGF0LCBudW0sIHN0ciB9IGZyb20gXCIuL1ZlcnNpb25lZFwiXG5cbmltcG9ydCBDb250ID0gRXhwci5Db250XG5cbi8vIENvbnN0cnVjdG9ycyBtdXN0IHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGxldHRlciwgYSBsYSBIYXNrZWxsLiBXaWxsIGZpeCB0aGlzIGFzIHBhcnQgb2YgaXNzdWUgIzQ5LlxuZnVuY3Rpb24gaXNDdHIgKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICBjb25zdCBjaDogc3RyaW5nID0gc3RyLmNoYXJBdCgwKVxuICAgcmV0dXJuIGNoID09PSBjaC50b1VwcGVyQ2FzZSgpICYmIGNoICE9PSBjaC50b0xvd2VyQ2FzZSgpXG59XG5cbnR5cGUgTWtDb250ID0gKM66OiBDb250KSA9PiBDb250XG5cbmZ1bmN0aW9uIGNvbXBvc2UgKG1rX866MTogTWtDb250LCBta1/OujI6IE1rQ29udCk6IE1rQ29udCB7XG4gICByZXR1cm4gKM66OiBDb250KSA9PiBta1/OujEobWtfzroyKM66KSlcbn1cblxuaW50ZXJmYWNlIE5lYXJsZXlUb2tlbiB7ICB2YWx1ZTogYW55O1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59O1xuXG5pbnRlcmZhY2UgTmVhcmxleUxleGVyIHtcbiAgcmVzZXQ6IChjaHVuazogc3RyaW5nLCBpbmZvOiBhbnkpID0+IHZvaWQ7XG4gIG5leHQ6ICgpID0+IE5lYXJsZXlUb2tlbiB8IHVuZGVmaW5lZDtcbiAgc2F2ZTogKCkgPT4gYW55O1xuICBmb3JtYXRFcnJvcjogKHRva2VuOiBOZWFybGV5VG9rZW4pID0+IHN0cmluZztcbiAgaGFzOiAodG9rZW5UeXBlOiBzdHJpbmcpID0+IGJvb2xlYW47XG59O1xuXG5pbnRlcmZhY2UgTmVhcmxleVJ1bGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbHM6IE5lYXJsZXlTeW1ib2xbXTtcbiAgcG9zdHByb2Nlc3M/OiAoZDogYW55W10sIGxvYz86IG51bWJlciwgcmVqZWN0Pzoge30pID0+IGFueTtcbn07XG5cbnR5cGUgTmVhcmxleVN5bWJvbCA9IHN0cmluZyB8IHsgbGl0ZXJhbDogYW55IH0gfCB7IHRlc3Q6ICh0b2tlbjogYW55KSA9PiBib29sZWFuIH07XG5cbmludGVyZmFjZSBHcmFtbWFyIHtcbiAgTGV4ZXI6IE5lYXJsZXlMZXhlciB8IHVuZGVmaW5lZDtcbiAgUGFyc2VyUnVsZXM6IE5lYXJsZXlSdWxlW107XG4gIFBhcnNlclN0YXJ0OiBzdHJpbmc7XG59O1xuXG5jb25zdCBncmFtbWFyOiBHcmFtbWFyID0ge1xuICBMZXhlcjogbGV4ZXIsXG4gIFBhcnNlclJ1bGVzOiBbXG4gICAge1wibmFtZVwiOiBcInJvb3RFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJfXCIsIFwiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZV0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJyb290RXhwclwiLCBcInN5bWJvbHNcIjogW1wiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIl8kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJ3aGl0ZXNwYWNlXCIpID8ge3R5cGU6IFwid2hpdGVzcGFjZVwifSA6IHdoaXRlc3BhY2UpXX0sXG4gICAge1wibmFtZVwiOiBcIl8kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJzaW5nbGVMaW5lQ29tbWVudFwiKSA/IHt0eXBlOiBcInNpbmdsZUxpbmVDb21tZW50XCJ9IDogc2luZ2xlTGluZUNvbW1lbnQpXX0sXG4gICAge1wibmFtZVwiOiBcIl8kZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwid2hpdGVzcGFjZVwiKSA/IHt0eXBlOiBcIndoaXRlc3BhY2VcIn0gOiB3aGl0ZXNwYWNlKV19LFxuICAgIHtcIm5hbWVcIjogXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwic2luZ2xlTGluZUNvbW1lbnRcIikgPyB7dHlwZTogXCJzaW5nbGVMaW5lQ29tbWVudFwifSA6IHNpbmdsZUxpbmVDb21tZW50KV19LFxuICAgIHtcIm5hbWVcIjogXCJfJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiXyRlYm5mJDFcIiwgXCJfJGVibmYkMSRzdWJleHByZXNzaW9uJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJfXCIsIFwic3ltYm9sc1wiOiBbXCJfJGVibmYkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcImV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVFeHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwclwiLCBcInN5bWJvbHNcIjogW1wiZGVmczFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJleHByXCIsIFwic3ltYm9sc1wiOiBbXCJmdW5cIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJleHByXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwclwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmczEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJpblwifV19LFxuICAgIHtcIm5hbWVcIjogXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1wiZGVmczEkbWFjcm9jYWxsJDJcIl19LFxuICAgIHtcIm5hbWVcIjogXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiZGVmczEkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiZGVmczEkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImRlZnMxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZzMSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcImRlZnMxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0XCIsIFwiZGVmczEkbWFjcm9jYWxsJDFcIiwgXCJleHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbZGVmcywgLCBlXSkgPT4gRXhwci5kZWZzKGRlZnMsIGUpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiY29tcGFyZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVFeHByXCIsIFwiY29tcGFyZU9wXCIsIFwic3VtRXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBvcCwgZTJdKSA9PiBFeHByLmJpbmFyeUFwcChlMSwgc3RyKG9wKSjOvSgpKSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiY29tcGFyZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInN1bUV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzdW1FeHByXCIsIFwic3ltYm9sc1wiOiBbXCJzdW1FeHByXCIsIFwic3VtT3BcIiwgXCJwcm9kdWN0RXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBvcCwgZTJdKSA9PiBFeHByLmJpbmFyeUFwcChlMSwgc3RyKG9wKSjOvSgpKSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwic3VtRXhwclwiLCBcInN5bWJvbHNcIjogW1wicHJvZHVjdEV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwcm9kdWN0RXhwclwiLCBcInN5bWJvbHNcIjogW1wicHJvZHVjdEV4cHJcIiwgXCJwcm9kdWN0T3BcIiwgXCJleHBvbmVudEV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtlMSwgb3AsIGUyXSkgPT4gRXhwci5iaW5hcnlBcHAoZTEsIHN0cihvcCkozr0oKSksIGUyKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcInByb2R1Y3RFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJleHBvbmVudEV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJleHBvbmVudEV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImV4cG9uZW50RXhwclwiLCBcImV4cG9uZW50T3BcIiwgXCJhcHBDaGFpblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBvcCwgZTJdKSA9PiBFeHByLmJpbmFyeUFwcChlMSwgc3RyKG9wKSjOvSgpKSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwb25lbnRFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJhcHBDaGFpblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImFwcENoYWluXCIsIFwic3ltYm9sc1wiOiBbXCJzaW1wbGVFeHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiYXBwQ2hhaW5cIiwgXCJzeW1ib2xzXCI6IFtcImFwcENoYWluXCIsIFwic2ltcGxlRXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UxLCBlMl0pID0+IEV4cHIuYXBwKGUxLCBlMikozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJzaW1wbGVFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXJpYWJsZVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInN0cmluZ1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcIm51bWJlclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInBhcmVudGhFeHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwic2ltcGxlRXhwclwiLCBcInN5bWJvbHNcIjogW1wicGFpclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInNpbXBsZUV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzaW1wbGVFeHByXCIsIFwic3ltYm9sc1wiOiBbXCJjb25zdHJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInN5bWJvbHNcIjogW1widmFyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeF0pID0+IEV4cHIudmFyXyh4KSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcInZhciRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJpZGVudFwiKSA/IHt0eXBlOiBcImlkZW50XCJ9IDogaWRlbnQpXX0sXG4gICAge1wibmFtZVwiOiBcInZhciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widmFyJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXIkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInZhclwiLCBcInN5bWJvbHNcIjogW1widmFyJG1hY3JvY2FsbCQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6ICAoW1t4XV0sIF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICBpZiAoaXNDdHIoeC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdFxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBzdHIoeC52YWx1ZSkozr0oKSkgXG4gICAgICAgIH0gfSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcInN0cmluZ1wiKSA/IHt0eXBlOiBcInN0cmluZ1wifSA6IHN0cmluZyldfSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJzdHJpbmckbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzdHJpbmckbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInN0cmluZyRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nXCIsIFwic3ltYm9sc1wiOiBbXCJzdHJpbmckbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbbGl0XV0pID0+IEV4cHIuY29uc3RTdHIoc3RyKChsaXQudmFsdWUgYXMgc3RyaW5nKS5zbGljZSgxLCAtMSkpKM69KCkpKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcIm51bWJlciRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogWyhsZXhlci5oYXMoXCJudW1iZXJcIikgPyB7dHlwZTogXCJudW1iZXJcIn0gOiBudW1iZXIpXX0sXG4gICAge1wibmFtZVwiOiBcIm51bWJlciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibnVtYmVyJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibnVtYmVyJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJudW1iZXIkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcIm51bWJlclwiLCBcInN5bWJvbHNcIjogW1wibnVtYmVyJG1hY3JvY2FsbCQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbW2xpdF1dKSA9PiBFeHByLmNvbnN0TnVtKG51bShuZXcgTnVtYmVyKGxpdC52YWx1ZSBhcyBzdHJpbmcpLnZhbHVlT2YoKSkozr0oKSkpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwicGFyZW50aEV4cHIkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFyZW50aEV4cHIkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIpXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJlbnRoRXhwciRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFyZW50aEV4cHJcIiwgXCJzeW1ib2xzXCI6IFtcInBhcmVudGhFeHByJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcInBhcmVudGhFeHByJG1hY3JvY2FsbCQzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlLF0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiKFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wicGFpciRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFpciRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIixcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpciRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wicGFpciRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhaXIkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXIkbWFjcm9jYWxsJDRcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInBhaXIkbWFjcm9jYWxsJDZcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIpXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhaXIkbWFjcm9jYWxsJDVcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXIkbWFjcm9jYWxsJDZcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyJG1hY3JvY2FsbCQ1XCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyJG1hY3JvY2FsbCQ2XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcInBhaXIkbWFjcm9jYWxsJDNcIiwgXCJleHByXCIsIFwicGFpciRtYWNyb2NhbGwkNVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZTEsICwgZTIsXSkgPT4gYXQoZXhwckNsYXNzKFBhaXIpLCBlMSwgZTIpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIltcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3QkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3QkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxpc3QkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJdXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImxpc3QkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3QkbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0JG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0JG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0XCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0JG1hY3JvY2FsbCQxXCIsIFwibGlzdE9wdFwiLCBcImxpc3QkbWFjcm9jYWxsJDNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIGUsIF0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJjb25zdHJcIiwgXCJzeW1ib2xzXCI6IFtcImN0clwiLCBcImFyZ3NcIl0sIFwicG9zdHByb2Nlc3NcIjogIChbYywgZcyFXSwgXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgIGFzc2VydChjIGluc3RhbmNlb2YgU3RyKVxuICAgICAgICAgICBjb25zdCBjdHI6IEN0ciA9IGN0ckZvcihjLnZhbClcbiAgICAgICAgICAgaWYgKGN0ci5hcml0eSAhPT0gZcyFLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIGF0KGV4cHJDbGFzcyhjdHIuQyksIC4uLmXMhSkozr0oKSlcbiAgICAgICAgfSB9LFxuICAgIHtcIm5hbWVcIjogXCJjdHIkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwiaWRlbnRcIikgPyB7dHlwZTogXCJpZGVudFwifSA6IGlkZW50KV19LFxuICAgIHtcIm5hbWVcIjogXCJjdHIkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImN0ciRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImN0ciRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiY3RyJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJjdHJcIiwgXCJzeW1ib2xzXCI6IFtcImN0ciRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAgKFtbeF1dLCBfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgaWYgKCFpc0N0cih4LnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHN0cih4LnZhbHVlKSjOvSgpKVxuICAgICAgICB9IH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IFtdfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIihcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiYXJncyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3MkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIixcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3MkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiYXJncyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJleHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlXSkgPT4gZX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJGVibmYkMVwiLCBcImFyZ3MkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIpXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3MkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3MkbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcImFyZ3MkZWJuZiQxXCIsIFwiYXJncyRtYWNyb2NhbGwkM1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZSwgZXMsXSkgPT4gW2UsIC4uLmVzXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcInR5cGVtYXRjaFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVtYXRjaCRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW1hdGNoJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW1hdGNoJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiYXNcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW1hdGNoJG1hY3JvY2FsbCQzJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDRcIl19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVtYXRjaCRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaCRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQzJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbWF0Y2gkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVtYXRjaCRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVtYXRjaFwiLCBcInN5bWJvbHNcIjogW1widHlwZW1hdGNoJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcInR5cGVtYXRjaCRtYWNyb2NhbGwkM1wiLCBcInR5cGVNYXRjaGVzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlLCAsIG1dKSA9PiBFeHByLnR5cGVtYXRjaChlLCBtKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3QkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3QkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjtcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmTGlzdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZWZMaXN0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImRlZkxpc3QkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmTGlzdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJkZWZcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIGRlZl0pID0+IGRlZn0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3QkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJkZWZMaXN0JGVibmYkMVwiLCBcImRlZkxpc3QkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImRlZkxpc3RcIiwgXCJzeW1ib2xzXCI6IFtcImRlZlwiLCBcImRlZkxpc3QkZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbZGVmLCBkZWZzXSkgPT4gTGlzdC5mcm9tQXJyYXkoW2RlZiwgLi4uZGVmc10pfSxcbiAgICB7XCJuYW1lXCI6IFwiZGVmXCIsIFwic3ltYm9sc1wiOiBbXCJsZXRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZWZcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlY1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImRlZlwiLCBcInN5bWJvbHNcIjogW1wicHJpbVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcImxldFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsZXQkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcImxldCRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0JG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0JG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsZXQkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0JG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0JG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiPVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsZXQkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImxldCRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxldCRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibGV0JG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsZXRcIiwgXCJzeW1ib2xzXCI6IFtcImxldCRtYWNyb2NhbGwkMVwiLCBcInZhclwiLCBcImxldCRtYWNyb2NhbGwkM1wiLCBcImV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIHgsICwgZV0pID0+IEV4cHIubGV0Xyh4LCBlKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcImxldHJlY1wifV19LFxuICAgIHtcIm5hbWVcIjogXCJsZXRyZWMkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsZXRyZWMkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJsZXRyZWMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjtcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGV0cmVjJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsZXRyZWMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJyZWNEZWZcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIHJlY0RlZl0pID0+IHJlY0RlZn0sXG4gICAge1wibmFtZVwiOiBcImxldHJlYyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxldHJlYyRlYm5mJDFcIiwgXCJsZXRyZWMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImxldHJlY1wiLCBcInN5bWJvbHNcIjogW1wibGV0cmVjJG1hY3JvY2FsbCQxXCIsIFwicmVjRGVmXCIsIFwibGV0cmVjJGVibmYkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgcmVjRGVmLCDOtF0pID0+IEV4cHIubGV0UmVjKExpc3QuZnJvbUFycmF5KFtyZWNEZWYsIC4uLs60XSkpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwicHJpbSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcInByaW1pdGl2ZVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJwcmltJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbXCJwcmltJG1hY3JvY2FsbCQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwicHJpbSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wicHJpbSRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInByaW0kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInByaW0kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInByaW0kbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInByaW0kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJwcmltXCIsIFwic3ltYm9sc1wiOiBbXCJwcmltJG1hY3JvY2FsbCQxXCIsIFwidmFyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCB4XSkgPT4gRXhwci5wcmltKHgpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwicmVjRGVmJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiZnVuXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInJlY0RlZiRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1wicmVjRGVmJG1hY3JvY2FsbCQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwicmVjRGVmJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJyZWNEZWYkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJyZWNEZWYkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInJlY0RlZiRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicmVjRGVmJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJyZWNEZWYkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJyZWNEZWZcIiwgXCJzeW1ib2xzXCI6IFtcInJlY0RlZiRtYWNyb2NhbGwkMVwiLCBcInZhclwiLCBcIm1hdGNoZXNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIGYsIM+DXSkgPT4gRXhwci5yZWNEZWYoZiwgz4MpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwiZnVuJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiZnVuXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImZ1biRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1wiZnVuJG1hY3JvY2FsbCQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiZnVuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJmdW4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJmdW4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImZ1biRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiZnVuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJmdW4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJmdW5cIiwgXCJzeW1ib2xzXCI6IFtcImZ1biRtYWNyb2NhbGwkMVwiLCBcIm1hdGNoZXNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIM+DXSkgPT4gRXhwci5mdW4oz4MpKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIm1hdGNoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoQXMkbWFjcm9jYWxsJDJcIl19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaEFzJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hBcyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hBcyRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMVwiXX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDRcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJhc1wifV19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaEFzJG1hY3JvY2FsbCQzJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzJG1hY3JvY2FsbCQ0XCJdfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hBcyRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hBcyRtYWNyb2NhbGwkMyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoQXMkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoQXMkbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoQXMkbWFjcm9jYWxsJDMkbWFjcm9jYWxsJDFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaEFzXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaEFzJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiLCBcIm1hdGNoQXMkbWFjcm9jYWxsJDNcIiwgXCJtYXRjaGVzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBlLCAsIM+DXSkgPT4gRXhwci5tYXRjaEFzKGUsIM+DKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXNcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIntcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXMkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoZXMkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoZXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjtcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcIm1hdGNoZXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJtYXRjaFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbV0pID0+IG19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRlYm5mJDFcIiwgXCJtYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwifVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaGVzJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaGVzJG1hY3JvY2FsbCQ0XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlcyRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hlc1wiLCBcInN5bWJvbHNcIjogW1wibWF0Y2hlcyRtYWNyb2NhbGwkMVwiLCBcIm1hdGNoXCIsIFwibWF0Y2hlcyRlYm5mJDFcIiwgXCJtYXRjaGVzJG1hY3JvY2FsbCQzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBtLCBtcyxdKSA9PiBbbSwgLi4ubXNdLnJlZHVjZShEYXRhRWxpbS5qb2luKX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwi4oaSXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm1hdGNoJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJtYXRjaCRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibWF0Y2hcIiwgXCJzeW1ib2xzXCI6IFtcInBhdHRlcm5cIiwgXCJtYXRjaCRtYWNyb2NhbGwkMVwiLCBcImV4cHJcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtta1/OuiwgLCBlXSkgPT4gbWtfzrooZSl9LFxuICAgIHtcIm5hbWVcIjogXCJtYXRjaFwiLCBcInN5bWJvbHNcIjogW1wicGF0dGVyblwiLCBcIm1hdGNoZXNcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtta1/OujEsIM+DXSkgPT4gbWtfzroxKEV4cHIuZnVuKM+DKSjOvSgpKSl9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlc1wiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZU1hdGNoZXMkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJ7XCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZU1hdGNoZXMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCI7XCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVNYXRjaGVzJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwidHlwZU1hdGNoXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBtXSkgPT4gbX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoZXMkZWJuZiQxXCIsIFwidHlwZU1hdGNoZXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwifVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoZXMkbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoZXMkbWFjcm9jYWxsJDRcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaGVzXCIsIFwic3ltYm9sc1wiOiBbXCJ0eXBlTWF0Y2hlcyRtYWNyb2NhbGwkMVwiLCBcInR5cGVNYXRjaFwiLCBcInR5cGVNYXRjaGVzJGVibmYkMVwiLCBcInR5cGVNYXRjaGVzJG1hY3JvY2FsbCQzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBtLCBtcyxdKSA9PiBbbSwgLi4ubXNdLnJlZHVjZSgobTEsIG0yKSA9PiB1bmlvbldpdGgobTEsIG0yLCAoZTogRXhwciwgZcq5OiBFeHByKTogRXhwciA9PiB1c2VyRXJyb3IoXCJPdmVybGFwcGluZyB0eXBlY2FzZSBicmFuY2hlcy5cIikpKX0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaCRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIuKGklwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2gkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVNYXRjaCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVNYXRjaCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1widHlwZU1hdGNoJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlTWF0Y2hcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVuYW1lXCIsIFwidHlwZU1hdGNoJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAgKFt4LCAsIGVdKSA9PiB7XG4gICAgICAgICAgIGFzc2VydCh4IGluc3RhbmNlb2YgU3RyKVxuICAgICAgICAgICBpZiAoIXR5cGVzLmhhcyh4LnZhbCkpIHtcbiAgICAgICAgICAgICAgdXNlckVycm9yKGBUeXBlIG5hbWUgJHt4LnZhbH0gbm90IGZvdW5kLmApXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHNpbmdsZXRvbih4LCBlKVxuICAgICAgICB9IH0sXG4gICAge1wibmFtZVwiOiBcInR5cGVuYW1lJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcImlkZW50XCIpID8ge3R5cGU6IFwiaWRlbnRcIn0gOiBpZGVudCldfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW5hbWUkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVuYW1lJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZW5hbWUkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInR5cGVuYW1lJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ0eXBlbmFtZVwiLCBcInN5bWJvbHNcIjogW1widHlwZW5hbWUkbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbeF1dKSA9PiBzdHIoeC52YWx1ZSkozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0XCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiBhdChleHByQ2xhc3MoTmlsKSkozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIsXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RPcHQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdE9wdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdE9wdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0T3B0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RPcHQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdE9wdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwiZXhwclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgZV0pID0+IGV9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdE9wdCRlYm5mJDFcIiwgXCJsaXN0T3B0JGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0T3B0XCIsIFwic3ltYm9sc1wiOiBbXCJleHByXCIsIFwibGlzdE9wdCRlYm5mJDFcIiwgXCJsaXN0UmVzdE9wdFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW2UsIGVzLCBlyrldKSA9PiBbZSwgLi4uZXMsIGXKuV0ucmV2ZXJzZSgpLnJlZHVjZSgoZcyFLCBlKSA9PiBhdChleHByQ2xhc3MoQ29ucyksIGUsIGXMhSkozr0oKSkpfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IGF0KGV4cHJDbGFzcyhOaWwpKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHQkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHQkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLi4uXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdCRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RSZXN0T3B0JG1hY3JvY2FsbCQxXCIsIFwibGlzdFJlc3RPcHQkbWFjcm9jYWxsJDNcIiwgXCJleHByXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCAsIGVdKSA9PiBlfSxcbiAgICB7XCJuYW1lXCI6IFwicGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1widmFyaWFibGVfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcImNvbnN0cl9wYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIl9cIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMSRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW1widmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMlwiXX0sXG4gICAge1wibmFtZVwiOiBcInZhcmlhYmxlX3BhdHRlcm4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInZhcmlhYmxlX3BhdHRlcm4kbWFjcm9jYWxsJDEkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJ2YXJpYWJsZV9wYXR0ZXJuJG1hY3JvY2FsbCQxJG1hY3JvY2FsbCQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1widmFyaWFibGVfcGF0dGVybiRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiAozro6IENvbnQpID0+IHZhckVsaW0oc3RyKFwiX1wiKSjOvSgpKSwgzropKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwidmFyaWFibGVfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1widmFyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeF0pID0+ICjOujogQ29udCkgPT4gdmFyRWxpbSh4LCDOuikozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIixcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiKVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDVcIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkNVwiLCBcInN5bWJvbHNcIjogW1wicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJwYWlyX3BhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcInBhaXJfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInBhdHRlcm5cIiwgXCJwYWlyX3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJwYXR0ZXJuXCIsIFwicGFpcl9wYXR0ZXJuJG1hY3JvY2FsbCQ1XCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCBta1/OujEsICwgbWtfzroyLCAsXSkgPT4gKM66OiBDb250KSA9PiBkYXRhRWxpbShbUGFpci5uYW1lLCBjb21wb3NlKG1rX866MSwgbWtfzroyKSjOuildKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIltcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdF9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0X3BhdHRlcm4kbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0X3BhdHRlcm4kbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdF9wYXR0ZXJuJG1hY3JvY2FsbCQ0XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiXVwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0X3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkNFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibGlzdF9wYXR0ZXJuJG1hY3JvY2FsbCQ0XCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0X3BhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcImxpc3RPcHRfcGF0dGVyblwiLCBcImxpc3RfcGF0dGVybiRtYWNyb2NhbGwkM1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbWtfzrosIF0pID0+IG1rX866fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdE9wdF9wYXR0ZXJuXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiAozro6IENvbnQpID0+IGRhdGFFbGltKFtOaWwubmFtZSwgzrpdKSjOvSgpKX0sXG4gICAge1wibmFtZVwiOiBcImxpc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wibGlzdDFfcGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImxpc3QxX3BhdHRlcm5cIiwgXCJzeW1ib2xzXCI6IFtcInBhdHRlcm5cIiwgXCJsaXN0UmVzdE9wdF9wYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbbWtfzroxLCBta1/OujJdKSA9PiAozro6IENvbnQpID0+IGRhdGFFbGltKFtDb25zLm5hbWUsIGNvbXBvc2UobWtfzroxLCBta1/OujIpKM66KV0pKM69KCkpfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gKM66OiBDb250KSA9PiBkYXRhRWxpbShbTmlsLm5hbWUsIM66XSkozr0oKSl9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIi4uLlwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ0XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkM1wiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcImxpc3RSZXN0T3B0X3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJwYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbLCAsIG1rX866XSkgPT4gbWtfzrp9LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiLFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ1XCIsIFwic3ltYm9sc1wiOiBbXCJsaXN0UmVzdE9wdF9wYXR0ZXJuJG1hY3JvY2FsbCQ2XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNVwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwibGlzdFJlc3RPcHRfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wibGlzdFJlc3RPcHRfcGF0dGVybiRtYWNyb2NhbGwkNVwiLCBcImxpc3QxX3BhdHRlcm5cIl0sIFwicG9zdHByb2Nlc3NcIjogKFssIG1rX866XSkgPT4gbWtfzrp9LFxuICAgIHtcIm5hbWVcIjogXCJjb25zdHJfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW1wiY3RyXCIsIFwiYXJnc19wYXR0ZXJuXCJdLCBcInBvc3Rwcm9jZXNzXCI6ICAoW2MsIG1rX866c10sIF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICBhc3NlcnQoYyBpbnN0YW5jZW9mIFN0cilcbiAgICAgICAgICAgaWYgKGN0ckZvcihjLnZhbCkuYXJpdHkgIT09IG1rX866cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdFxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiAozro6IENvbnQpID0+IGRhdGFFbGltKFtjLnZhbCwgbWtfzrpzLnJlZHVjZShjb21wb3NlLCAozro6IENvbnQpID0+IM66KSjOuildKSjOvSgpKVxuICAgICAgICB9IH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVyblwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gW119LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIoXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiYXJnc19wYXR0ZXJuJG1hY3JvY2FsbCQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJGVibmYkMSRzdWJleHByZXNzaW9uJDEkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIsXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3NfcGF0dGVybiRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJG1hY3JvY2FsbCQxXCIsIFwicGF0dGVyblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbWtfzrpdKSA9PiBta1/Oun0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3NfcGF0dGVybiRlYm5mJDFcIiwgXCJhcmdzX3BhdHRlcm4kZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoZCkgPT4gZFswXS5jb25jYXQoW2RbMV1dKX0sXG4gICAge1wibmFtZVwiOiBcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIilcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuJG1hY3JvY2FsbCQzXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDNcIiwgXCJzeW1ib2xzXCI6IFtcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkNFwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwiYXJnc19wYXR0ZXJuXCIsIFwic3ltYm9sc1wiOiBbXCJhcmdzX3BhdHRlcm4kbWFjcm9jYWxsJDFcIiwgXCJwYXR0ZXJuXCIsIFwiYXJnc19wYXR0ZXJuJGVibmYkMVwiLCBcImFyZ3NfcGF0dGVybiRtYWNyb2NhbGwkM1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoWywgbWtfzrosIG1rX866cyxdKSA9PiBbbWtfzrosIC4uLm1rX866c119LFxuICAgIHtcIm5hbWVcIjogXCJjb21wYXJlT3AkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwiY29tcGFyZU9wXCIpID8ge3R5cGU6IFwiY29tcGFyZU9wXCJ9IDogY29tcGFyZU9wKV19LFxuICAgIHtcIm5hbWVcIjogXCJjb21wYXJlT3AkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVPcCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImNvbXBhcmVPcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiY29tcGFyZU9wJG1hY3JvY2FsbCQyXCIsIFwiX1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW3gsIF0pID0+IHh9LFxuICAgIHtcIm5hbWVcIjogXCJjb21wYXJlT3BcIiwgXCJzeW1ib2xzXCI6IFtcImNvbXBhcmVPcCRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW1t4XV0pID0+IHgudmFsdWV9LFxuICAgIHtcIm5hbWVcIjogXCJleHBvbmVudE9wJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcImV4cG9uZW50T3BcIikgPyB7dHlwZTogXCJleHBvbmVudE9wXCJ9IDogZXhwb25lbnRPcCldfSxcbiAgICB7XCJuYW1lXCI6IFwiZXhwb25lbnRPcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wiZXhwb25lbnRPcCRtYWNyb2NhbGwkMlwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImV4cG9uZW50T3AkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcImV4cG9uZW50T3AkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcImV4cG9uZW50T3BcIiwgXCJzeW1ib2xzXCI6IFtcImV4cG9uZW50T3AkbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbeF1dKSA9PiB4LnZhbHVlfSxcbiAgICB7XCJuYW1lXCI6IFwicHJvZHVjdE9wJG1hY3JvY2FsbCQyXCIsIFwic3ltYm9sc1wiOiBbKGxleGVyLmhhcyhcInByb2R1Y3RPcFwiKSA/IHt0eXBlOiBcInByb2R1Y3RPcFwifSA6IHByb2R1Y3RPcCldfSxcbiAgICB7XCJuYW1lXCI6IFwicHJvZHVjdE9wJG1hY3JvY2FsbCQxXCIsIFwic3ltYm9sc1wiOiBbXCJwcm9kdWN0T3AkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJwcm9kdWN0T3AkbWFjcm9jYWxsJDFcIiwgXCJzeW1ib2xzXCI6IFtcInByb2R1Y3RPcCRtYWNyb2NhbGwkMlwiLCBcIl9cIl0sIFwicG9zdHByb2Nlc3NcIjogKFt4LCBdKSA9PiB4fSxcbiAgICB7XCJuYW1lXCI6IFwicHJvZHVjdE9wXCIsIFwic3ltYm9sc1wiOiBbXCJwcm9kdWN0T3AkbWFjcm9jYWxsJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKFtbeF1dKSA9PiB4LnZhbHVlfSxcbiAgICB7XCJuYW1lXCI6IFwic3VtT3AkbWFjcm9jYWxsJDJcIiwgXCJzeW1ib2xzXCI6IFsobGV4ZXIuaGFzKFwic3VtT3BcIikgPyB7dHlwZTogXCJzdW1PcFwifSA6IHN1bU9wKV19LFxuICAgIHtcIm5hbWVcIjogXCJzdW1PcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wic3VtT3AkbWFjcm9jYWxsJDJcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJzdW1PcCRtYWNyb2NhbGwkMVwiLCBcInN5bWJvbHNcIjogW1wic3VtT3AkbWFjcm9jYWxsJDJcIiwgXCJfXCJdLCBcInBvc3Rwcm9jZXNzXCI6IChbeCwgXSkgPT4geH0sXG4gICAge1wibmFtZVwiOiBcInN1bU9wXCIsIFwic3ltYm9sc1wiOiBbXCJzdW1PcCRtYWNyb2NhbGwkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiAoW1t4XV0pID0+IHgudmFsdWV9XG4gIF0sXG4gIFBhcnNlclN0YXJ0OiBcInJvb3RFeHByXCIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBncmFtbWFyO1xuIiwiaW1wb3J0IHsgX19jaGVjaywgYXMsIGFzc2VydCwgdXNlckVycm9yIH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IEJvb2wsIHRydWVfLCBmYWxzZV8gfSBmcm9tIFwiLi9CYXNlVHlwZXNcIlxuaW1wb3J0IHsgRXhwbFZhbHVlLCBleHBsVmFsdWUgfSBmcm9tIFwiLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgRXhwbCB9IGZyb20gXCIuL0V4cGxcIlxuaW1wb3J0IHsgSWQsIE51bSwgUHJpbU9wVGFnLCBQcmltVmFsdWUsIFN0ciwgXywgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiXG5pbXBvcnQgeyDOvSwgYXQsIG51bSwgc3RyIH0gZnJvbSBcIi4vVmVyc2lvbmVkXCJcblxuZXhwb3J0IHR5cGUgVW5hcnk8VCwgVj4gPSAoeDogVCkgPT4gKGs6IElkKSA9PiBWXG5leHBvcnQgdHlwZSBCaW5hcnk8VCwgVSwgVj4gPSAoeDogVCwgeTogVSkgPT4gKGs6IElkKSA9PiBWXG5cbi8vIEluIHRoZSBmb2xsb3dpbmcgdHdvIGNsYXNzZXMsIHdlIHN0b3JlIHRoZSBvcGVyYXRpb24gd2l0aG91dCBnZW5lcmljIHR5cGUgcGFyYW1ldGVycywgYXMgZmllbGRzIGNhbid0XG4vLyBoYXZlIHBvbHltb3JwaGljIHR5cGUuIFRoZW4gYWNjZXNzIHRoZSBvcGVyYXRpb24gdmlhIGEgbWV0aG9kIGFuZCByZWluc3RhdGUgdGhlIHBvbHltb3JwaGlzbSB2aWEgYSBjYXN0LlxuXG5leHBvcnQgY2xhc3MgUHJpbU9wPFRhZyBleHRlbmRzIFByaW1PcFRhZz4gZXh0ZW5kcyBWYWx1ZTxUYWc+IHtcbiAgIG5hbWU6IHN0cmluZyA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIFVuYXJ5T3AgZXh0ZW5kcyBQcmltT3A8XCJVbmFyeU9wXCI+IHtcbiAgIG9wOiBVbmFyeTxQcmltVmFsdWUsIFZhbHVlPiA9IF9cbn1cblxuZXhwb3J0IGNsYXNzIEJpbmFyeU9wIGV4dGVuZHMgUHJpbU9wPFwiQmluYXJ5T3BcIj4ge1xuICAgb3A6IEJpbmFyeTxQcmltVmFsdWUsIFByaW1WYWx1ZSwgVmFsdWU+ID0gX1xufVxuXG5jb25zdCBjZWlsaW5nOiBVbmFyeTxOdW0sIE51bT4gPSB4ID0+IG51bShNYXRoLmNlaWwoeC52YWwpKVxuXG4vLyBVc2VkIHRvIHRha2UgYXJiaXRyYXJ5IHZhbHVlIGFzIGFkZGl0aW9uYWwgYXJndW1lbnQsIGJ1dCBub3cgcHJpbWl0aXZlcyBoYXZlIHByaW1pdGl2ZSBhcmd1bWVudHMuXG5jb25zdCBkZWJ1Z0xvZzogVW5hcnk8TnVtIHwgU3RyLCBWYWx1ZT4gPSB2ID0+IChrOiBJZCkgPT4geyBcbiAgIGNvbnNvbGUubG9nKHYpOyBcbiAgIHJldHVybiB2IFxufVxuXG5jb25zdCBmbG9vcjogVW5hcnk8TnVtLCBOdW0+ID0geCA9PiBudW0oTWF0aC5mbG9vcih4LnZhbCkpXG5jb25zdCBsb2c6IFVuYXJ5PE51bSwgTnVtPiA9IHggPT4gbnVtKE1hdGgubG9nKGFzKHgsIE51bSkudmFsKSlcbmNvbnN0IG51bVRvU3RyOiBVbmFyeTxOdW0sIFN0cj4gPSB4ID0+IHN0cih4LnZhbC50b1N0cmluZygpKVxuXG4vLyBObyBsb25nZXIgc3VwcG9ydCBvdmVybG9hZGVkIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhdHRlcm4tbWF0Y2hpbmcgc2VtYW50aWNzIGlzIG5vbi10cml2aWFsOyBtaWdodCByZXF1aXJlIHR5cGVjYXNlLlxuLy8gSWYgd2Ugd2FudCBpbnRlZ2VyIGRpdmlzaW9uLCBhcHBhcmVudGx5IH5+KHggLyB5KSB3aWxsIHJvdW5kIGluIHRoZSByaWdodCBkaXJlY3Rpb24uXG5jb25zdCBkaXY6IEJpbmFyeTxOdW0sIE51bSwgTnVtPiA9ICh4LCB5KSA9PiAoazogSWQpID0+IHtcbiAgIGNvbnN0IG46IE51bSA9IG51bShhcyh4LCBOdW0pLnZhbCAvIGFzKHksIE51bSkudmFsKShrKVxuICAgaWYgKCFpc0Zpbml0ZShuLnZhbCkpIHtcbiAgICAgIHVzZXJFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIiwgeCwgeSlcbiAgIH1cbiAgIHJldHVybiBuXG59XG5cbmNvbnN0IGNvbmNhdDogQmluYXJ5PFN0ciwgU3RyLCBTdHI+ID0gKHgsIHkpID0+IHN0cihhcyh4LCBTdHIpLnZhbCArIGFzKHksIFN0cikudmFsKVxuXG5jb25zdCBlcXVhbDogQmluYXJ5PE51bSB8IFN0ciwgTnVtIHwgU3RyLCBCb29sPiA9ICh4LCB5KSA9PiB7XG4gICBpZiAoeCBpbnN0YW5jZW9mIE51bSAmJiB5IGluc3RhbmNlb2YgTnVtKSB7XG4gICAgICByZXR1cm4geC52YWwgPT09IHkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2VcbiAgIGlmICh4IGluc3RhbmNlb2YgU3RyICYmIHkgaW5zdGFuY2VvZiBTdHIpIHtcbiAgICAgIHJldHVybiB4LnZhbCA9PT0geS52YWwgPyB0cnVlXygpIDogZmFsc2VfKClcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXNlckVycm9yKGBFeHBlY3RlZCAke051bS5uYW1lfSBvciAke1N0ci5uYW1lfS5gKVxuICAgfVxufVxuXG5jb25zdCBlcnJvcjogVW5hcnk8U3RyLCBWYWx1ZT4gPSBtZXNzYWdlID0+IGFzc2VydChmYWxzZSwgXCJGbHVpZCBlcnJvcjpcXG5cIiArIG1lc3NhZ2UudmFsKVxuXG5jb25zdCBncmVhdGVyRXE6IEJpbmFyeTxOdW0gfCBTdHIsIE51bSB8IFN0ciwgQm9vbD4gPSAoeCwgeSkgPT4ge1xuICAgaWYgKHggaW5zdGFuY2VvZiBOdW0gJiYgeSBpbnN0YW5jZW9mIE51bSkge1xuICAgICAgcmV0dXJuIHgudmFsID49IHkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2VcbiAgIGlmICh4IGluc3RhbmNlb2YgU3RyICYmIHkgaW5zdGFuY2VvZiBTdHIpIHtcbiAgICAgIC8vIHN0cmluZyBjb21wYXJpc29uIGRlbGVnYXRlcyB0byBjZW50cmFsIGltcGxlbWVudGF0aW9uIGZvciBjb25zaXN0ZW5jeVxuICAgICAgcmV0dXJuIHguZ2VxKHkpID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVzZXJFcnJvcihgRXhwZWN0ZWQgJHtOdW0ubmFtZX0gb3IgJHtTdHIubmFtZX0uYClcbiAgIH1cbn1cblxuY29uc3QgZ3JlYXRlcjogQmluYXJ5PE51bSwgTnVtLCBCb29sPiA9ICh4LCB5KSA9PiBhcyh4LCBOdW0pLnZhbCA+IGFzKHksIE51bSkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG5cbmNvbnN0IGxlc3NFcTogQmluYXJ5PE51bSwgTnVtLCBCb29sPiA9ICh4LCB5KSA9PiB7XG4gICBpZiAoeCBpbnN0YW5jZW9mIE51bSAmJiB5IGluc3RhbmNlb2YgTnVtKSB7XG4gICAgICByZXR1cm4gYXMoeCwgTnVtKS52YWwgPD0gYXMoeSwgTnVtKS52YWwgPyB0cnVlXygpIDogZmFsc2VfKClcbiAgIH0gZWxzZVxuICAgaWYgKHggaW5zdGFuY2VvZiBTdHIgJiYgeSBpbnN0YW5jZW9mIFN0cikge1xuICAgICAgcmV0dXJuIHgubGVxKHkpID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVzZXJFcnJvcihgRXhwZWN0ZWQgJHtOdW0ubmFtZX0gb3IgJHtTdHIubmFtZX0uYClcbiAgIH1cbn1cblxuY29uc3QgbGVzczogQmluYXJ5PE51bSwgTnVtLCBCb29sPiA9ICh4LCB5KSA9PiBhcyh4LCBOdW0pLnZhbCA8IGFzKHksIE51bSkudmFsID8gdHJ1ZV8oKSA6IGZhbHNlXygpXG5jb25zdCBtaW51czogQmluYXJ5PE51bSwgTnVtLCBOdW0+ID0gKHgsIHkpID0+IG51bShhcyh4LCBOdW0pLnZhbCAtIGFzKHksIE51bSkudmFsKVxuY29uc3QgcGx1czogQmluYXJ5PE51bSwgTnVtLCBOdW0+ID0gKHgsIHkpID0+IG51bShhcyh4LCBOdW0pLnZhbCArIGFzKHksIE51bSkudmFsKVxuY29uc3QgcG93OiBCaW5hcnk8TnVtLCBOdW0sIE51bT4gPSAoeCwgeSkgPT4gbnVtKGFzKHgsIE51bSkudmFsICoqIGFzKHksIE51bSkudmFsKVxuY29uc3QgdGltZXM6IEJpbmFyeTxOdW0sIE51bSwgTnVtPiA9ICh4LCB5KSA9PiBudW0oYXMoeCwgTnVtKS52YWwgKiBhcyh5LCBOdW0pLnZhbClcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcyBmb3IgYnVpbGRpbmcgdGhlIG1hcHMuIEV4cG9ydCB0byBhbGxvdyBvdGhlciBtb2R1bGVzIHRvIHByb3ZpZGUgb3BlcmF0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiB1bmFyeV88VCBleHRlbmRzIFByaW1WYWx1ZSwgViBleHRlbmRzIFZhbHVlPiAob3A6IFVuYXJ5PFQsIFY+KTogRXhwbFZhbHVlPFVuYXJ5T3A+IHtcbiAgIHJldHVybiBleHBsVmFsdWUoRXhwbC5jb25zdF8oKSjOvSgpKSwgYXQoVW5hcnlPcCwgb3AubmFtZSwgb3ApKM69KCkpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5XzxUIGV4dGVuZHMgUHJpbVZhbHVlLCBVIGV4dGVuZHMgUHJpbVZhbHVlLCBWIGV4dGVuZHMgVmFsdWU+IChvcDogQmluYXJ5PFQsIFUsIFY+KTogRXhwbFZhbHVlPEJpbmFyeU9wPiB7XG4gICByZXR1cm4gZXhwbFZhbHVlKEV4cGwuY29uc3RfKCkozr0oKSksIGF0KEJpbmFyeU9wLCBvcC5uYW1lLCBvcCkozr0oKSkpXG59XG5cbi8vIFByaW1pdGl2ZXMgd2l0aCBpZGVudGlmaWVycyBhcyBuYW1lcyBhcmUgdW5hcnkgYW5kIGZpcnN0LWNsYXNzLlxuZXhwb3J0IGNvbnN0IHVuYXJ5T3BzOiBNYXA8c3RyaW5nLCBFeHBsVmFsdWU8VW5hcnlPcD4+ID0gbmV3IE1hcChbXG4gICBbY2VpbGluZy5uYW1lLCB1bmFyeV8oY2VpbGluZyldLFxuICAgW2RlYnVnTG9nLm5hbWUsIHVuYXJ5XyhkZWJ1Z0xvZyldLFxuICAgW2Vycm9yLm5hbWUsIHVuYXJ5XyhlcnJvcildLFxuICAgW2Zsb29yLm5hbWUsIHVuYXJ5XyhmbG9vcildLFxuICAgW2xvZy5uYW1lLCB1bmFyeV8obG9nKV0sXG4gICBbbnVtVG9TdHIubmFtZSwgdW5hcnlfKG51bVRvU3RyKV1cbl0pXG4gICBcbmV4cG9ydCBjb25zdCBiaW5hcnlPcHM6IE1hcDxzdHJpbmcsIEV4cGxWYWx1ZTxCaW5hcnlPcD4+ID0gbmV3IE1hcChbXG4gICBbXCItXCIsIGJpbmFyeV8obWludXMpXSxcbiAgIFtcIitcIiwgYmluYXJ5XyhwbHVzKV0sXG4gICBbXCIqXCIsIGJpbmFyeV8odGltZXMpXSxcbiAgIFtcIioqXCIsIGJpbmFyeV8ocG93KV0sXG4gICBbXCIvXCIsIGJpbmFyeV8oZGl2KV0sXG4gICBbXCI9PVwiLCBiaW5hcnlfKGVxdWFsKV0sXG4gICBbXCI+XCIsIGJpbmFyeV8oZ3JlYXRlcildLFxuICAgW1wiPj1cIiwgYmluYXJ5XyhncmVhdGVyRXEpXSxcbiAgIFtcIjxcIiwgYmluYXJ5XyhsZXNzKV0sXG4gICBbXCI8PVwiLCBiaW5hcnlfKGxlc3NFcSldLFxuICAgW1wiKytcIiwgYmluYXJ5Xyhjb25jYXQpXVxuXSlcbiIsImltcG9ydCB7IENsYXNzLCBfX25vbk51bGwsIGFic3VyZCwgYXNzZXJ0IH0gZnJvbSBcIi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IE9yZCB9IGZyb20gXCIuL3V0aWwvT3JkXCJcbmltcG9ydCB7IFZhbHVlRGVsdGEsIF9fZGVsdGFzIH0gZnJvbSBcIi4vRGVsdGFcIlxuXG4vLyBVc2UgdG8gaW5pdGlhbGlzZSBmaWVsZHMgZm9yIHJlZmxlY3Rpb24sIHdpdGhvdXQgcmVxdWlyaW5nIGNvbnN0cnVjdG9ycy5cbmV4cG9ydCBjb25zdCBfOiBhbnkgPSB1bmRlZmluZWQgXG5cbi8vIFNvbWV3aGF0IHBlcnZlcnNlIHRvIGRvIHRoaXMsIGJ1dCBuZWVkIHNvbWUgdHlwZSBzYWZldHkhXG5leHBvcnQgdHlwZSBEYXRhVmFsdWVUYWcgPVxuICAgXCJWaWV3cG9ydFwiIHwgXCJDaXJjbGVcIiB8IFwiR3JvdXBcIiB8IFwiTGluZVwiIHwgXCJNYXJrZXJcIiB8IFwiT3JpZW50XCIgfCBcIlBvbHlsaW5lXCIgfCBcIlBvbHltYXJrZXJzXCIgfCBcIlNjYWxlXCIgfCBcIlRyYW5zbGF0ZVwiIHwgXCJUZXh0XCIgfCBcIlRyYW5zZm9ybVwiIHwgXCJDaXJjbGVcIiB8IFwiQXJyb3doZWFkXCIgfFxuICAgXCJCb29sXCIgfCBcIkNsb3N1cmVcIiB8IFwiRGF0YUV4cGxcIiB8IFwiRWxpbVwiIHwgXCJNYXRjaFwiIHwgXCJFbnZcIiB8IFwiRXhwbFwiIHwgXCJFeHBsLkRlZlwiIHwgXCJFeHBsLlJlY0RlZlwiIHwgXCJFeHBsVmFsdWVcIiB8IFwiRXhwclwiIHwgXCJFeHByLkRlZlwiIHwgIFxuICAgXCJMaXN0XCIgfCBcIk9wdGlvblwiIHwgXCJPcmRlcmluZ1wiIHwgXCJQYWlyXCIgfCBcIlBsdWdcIiB8IFwiUG9pbnRcIiB8IFwiRXhwci5SZWNEZWZcIiB8IFwiUmVjdFwiIHwgXCJUcmVlXCIgfCBcIlRva2VuXCJcbmV4cG9ydCB0eXBlIExleGVtZVRhZyA9IFwiV2hpdGVzcGFjZVwiIHwgXCJTaW5nbGVMaW5lQ29tbWVudFwiIHwgXCJPcGVyYXRvclwiXG5leHBvcnQgdHlwZSBQcmltT3BUYWcgPSBcIlVuYXJ5T3BcIiB8IFwiQmluYXJ5T3BcIlxuZXhwb3J0IHR5cGUgVmFsdWVUYWcgPSBEYXRhVmFsdWVUYWcgfCBMZXhlbWVUYWcgfCBQcmltT3BUYWcgfCBcIklkXCIgfCBcIk51bVwiIHwgXCJTdHJcIlxuXG4vLyBWYWx1ZSBpbiB0aGUgbWV0YWxhbmd1YWdlLlxuZXhwb3J0IGNsYXNzIFZhbHVlPFRhZyBleHRlbmRzIFZhbHVlVGFnID0gVmFsdWVUYWc+IHtcbiAgIHJlYWRvbmx5IF9fdGFnITogVGFnXG5cbiAgIF9fY2hpbGQgKGs6IGtleW9mIHRoaXMpOiBQZXJzaXN0ZW50IHtcbiAgICAgIHJldHVybiB0aGlzW2tdIGFzIHVua25vd24gYXMgUGVyc2lzdGVudFxuICAgfVxuXG4gICAvLyBQcm9iYWJseSBjb25mdXNpbmdseSwgXCJjaGlsZHJlblwiIGlzbid0IGEgdXNlci1sZXZlbCBub3Rpb247IHNwZWNpZmljYWxseSwgd3JhcHBlcnNcbiAgIC8vIGxpa2UgTnVtIGFuZCBTdHIgaGF2ZSBjaGlsZHJlbiB3aGljaCBhcmUgbm90IG9ic2VydmFibGUgdGhyb3VnaCBwYXR0ZXJuLW1hdGNoaW5nLlxuICAgZ2V0IF9fY2hpbGRyZW4gKCk6IFBlcnNpc3RlbnRbXSB7XG4gICAgICByZXR1cm4gZmllbGRzKHRoaXMpLm1hcChrID0+IHRoaXMuX19jaGlsZChrKSlcbiAgIH1cbn1cblxuLy8gQWRkcmVzcyBvciBsb2NhdGlvbiBvZiBwZXJzaXN0ZW50IG9iamVjdC5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJZCBleHRlbmRzIFZhbHVlPFwiSWRcIj4ge1xuICAgdGFnPFRhZyBleHRlbmRzIHN0cmluZz4gKHRhZzogVGFnKTogVGFnZ2VkSWQ8VGFnPiB7XG4gICAgICByZXR1cm4gdGFnZ2VkSWQodGhpcywgdGFnKVxuICAgfVxufVxuXG5jbGFzcyBGdW5jdGlvbklkIGV4dGVuZHMgSWQge1xuICAgZjogRnVuY3Rpb24gPSBfXG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uSWQgKGY6IEZ1bmN0aW9uKTogRnVuY3Rpb25JZCB7XG4gICByZXR1cm4gbWFrZShGdW5jdGlvbklkLCBmKVxufVxuXG5leHBvcnQgY2xhc3MgQXBwbGljYXRpb25JZCBleHRlbmRzIElkIHtcbiAgIGs6IE1lbW9JZCA9IF9cbiAgIHY6IFBlcnNpc3RlbnQgPSBfXG59XG5cbmV4cG9ydCB0eXBlIE1lbW9JZCA9IEZ1bmN0aW9uSWQgfCBBcHBsaWNhdGlvbklkXG5cbmZ1bmN0aW9uIGFwcGxpY2F0aW9uSWQgKGs6IE1lbW9JZCwgdjogUGVyc2lzdGVudCk6IEFwcGxpY2F0aW9uSWQge1xuICAgcmV0dXJuIG1ha2UoQXBwbGljYXRpb25JZCwgaywgdilcbn1cblxuZXhwb3J0IGNsYXNzIFRhZ2dlZElkPFRhZyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBJZCB7XG4gICBrOiBJZCA9IF9cbiAgIHByb3A6IFRhZyA9IF9cbn1cblxuZnVuY3Rpb24gdGFnZ2VkSWQ8VGFnIGV4dGVuZHMgc3RyaW5nPiAoazogSWQsIHByb3A6IFRhZyk6IFRhZ2dlZElkPFRhZz4ge1xuICAgcmV0dXJuIG1ha2UoVGFnZ2VkSWQsIGssIHByb3ApIGFzIFRhZ2dlZElkPFRhZz5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9JZCAoZjogRnVuY3Rpb24sIHbMhTogSXRlcmFibGU8YW55Pik6IE1lbW9JZCB7XG4gICBjb25zdCBmyrk6IEZ1bmN0aW9uSWQgPSBmdW5jdGlvbklkKGYpXG4gICBsZXQgazogTWVtb0lkID0gZsq5XG4gICBmb3IgKGxldCB2IG9mIHbMhSkge1xuICAgICAgayA9IGFwcGxpY2F0aW9uSWQoaywgdilcbiAgIH1cbiAgIHJldHVybiBrXG59XG5cbi8vIEZ1bmN0aW9ucyBhcmUgcGVyc2lzdGVudCB0byBzdXBwb3J0IHByaW1pdGl2ZXMuIFByaW1pdGl2ZSBkYXRhdHlwZXMgbGlrZSBOdW0gYW5kIFN0ciBjb250YWluXG4vLyBFUzYgcHJpbWl0aXZlcyBsaWtlIG51bWJlciBhbmQgc3RyaW5nLCB3aGljaCBhcmUgKGN1cnJlbnRseSkgXCJwZXJzaXN0ZW50XCIgZm9yIGludGVybmluZyBwdXJwb3Nlc1xuLy8gYnV0IGFyZSBub3QgXCJ2YWx1ZXNcIiBiZWNhdXNlIHRoZXkgYXJlIG5vdCBvYnNlcnZhYmxlIHRvIHVzZXIgY29kZS4gQm9vbGVhbnMgYXJlIHBlcnNpc3RlbnRcbi8vIHRvIHN1cHBvcnQgYW5ub3RhdGlvbiBoZWxwZXJzLlxuZXhwb3J0IHR5cGUgUGVyc2lzdGVudCA9IFZhbHVlIHwgYm9vbGVhbiB8IHN0cmluZyB8IG51bWJlciB8IEZ1bmN0aW9uXG5cbmV4cG9ydCB0eXBlIFByaW1WYWx1ZSA9IE51bSB8IFN0clxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmltICh2OiBWYWx1ZSk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHYgaW5zdGFuY2VvZiBOdW0gfHwgdiBpbnN0YW5jZW9mIFN0clxufVxuXG5leHBvcnQgY2xhc3MgTnVtIGV4dGVuZHMgVmFsdWU8XCJOdW1cIj4ge1xuICAgdmFsOiBudW1iZXIgPSBfXG5cbiAgIHRvU3RyaW5nICgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMudmFsLnRvU3RyaW5nKClcbiAgIH1cbn1cblxuXG5cbmV4cG9ydCBjbGFzcyBTdHIgZXh0ZW5kcyBWYWx1ZTxcIlN0clwiPiBpbXBsZW1lbnRzIE9yZDxTdHI+IHtcbiAgIHZhbDogc3RyaW5nID0gX1xuXG4gICB0b1N0cmluZyAoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBgXCIke3RoaXMudmFsfVwiYFxuICAgfVxuXG4gICBsZXEgKHN0cjogU3RyKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy52YWwubG9jYWxlQ29tcGFyZShzdHIudmFsKSA8PSAwXG4gICB9XG5cbiAgIGVxIChzdHI6IFN0cik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMudmFsLmxvY2FsZUNvbXBhcmUoc3RyLnZhbCkgPT09IDBcbiAgIH1cblxuICAgZ2VxIChzdHI6IFN0cik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMudmFsLmxvY2FsZUNvbXBhcmUoc3RyLnZhbCkgPj0gMFxuICAgfVxufVxuXG4vLyBNZXJnZWFibGUgc3RhdGUgZGVsdGFzIGFyZSBkaXNqb2ludC5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludG8gKHRndDogVmFsdWVEZWx0YSwgc3JjOiBWYWx1ZURlbHRhKTogdm9pZCB7XG4gICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goKHByb3A6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCF0Z3QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgIHRndFtwcm9wXSA9IHNyY1twcm9wXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGFic3VyZChcbiAgICAgICAgICAgIGBJbmNvbXBhdGlibGUgdXBkYXRlIG9mIGZpZWxkIFwiJHtwcm9wfVwiIGF0IHJldmlzaW9uLmAsXG4gICAgICAgICAgICB0Z3RbcHJvcF0sIFxuICAgICAgICAgICAgc3JjW3Byb3BdXG4gICAgICAgICApXG4gICAgICB9XG4gICB9KVxufVxuXG4vLyBDdXJyaWVkIG1hcCBmcm9tIGNvbnN0cnVjdG9ycyBhbmQgYXJndW1lbnRzIHRvIGNhY2hlZCB2YWx1ZXM7IGN1cnJpZWQgYmVjYXVzZSBjb21wb3NpdGUga2V5cyB3b3VsZCBcbi8vIHJlcXVpcmUgZWl0aGVyIGN1c3RvbSBlcXVhbGl0eSwgd2hpY2ggaXNuJ3QgcG9zc2libGUgd2l0aCBFUzYgbWFwcywgb3IgaW50ZXJuaW5nLCB3aGljaCB3b3VsZCBlc3NlbnRpYWxseVxuLy8gaW52b2x2ZSB0aGUgc2FtZSBtZW1vaXNhdGlvbiBsb2dpYy5cbmV4cG9ydCB0eXBlIE1lbW9UYWJsZSA9IE1hcDxQZXJzaXN0ZW50LCBQZXJzaXN0ZW50IHwgTWFwPFBlcnNpc3RlbnQsIE9iamVjdD4+IC8vIGFwcHJveGltYXRlIHJlY3Vyc2l2ZSB0eXBlXG5cbi8vIEhhc2gtY29uc2VkIGNvbnN0cnVjdG9ycyBhcmUgaW52YXJpYW50IGFjcm9zcyB3b3JsZHMuXG5jb25zdCBfX2N0ck1lbW86IE1lbW9UYWJsZSA9IG5ldyBNYXBcblxuZnVuY3Rpb24gbG9va3VwQXJnPFQgZXh0ZW5kcyBQZXJzaXN0ZW50PiAoZjogTWVtb2lzYWJsZTxUPiwgbTogTWVtb1RhYmxlLCB2zIU6IFBlcnNpc3RlbnRbXSwgbjogbnVtYmVyKTogUGVyc2lzdGVudCB8IE1hcDxQZXJzaXN0ZW50LCBPYmplY3Q+IHtcbiAgIC8vIGZvciBtZW1vaXNhdGlvbiBwdXJwb3NlcywgdHJlYXQgZidzIGtleSBhcyBhcmd1bWVudCAtMVxuICAgY29uc3QgazogUGVyc2lzdGVudCA9IG4gPT09IC0xID8gZi5rZXkgOiB2zIVbbl1cbiAgIGxldCB2OiBQZXJzaXN0ZW50IHwgTWFwPFBlcnNpc3RlbnQsIE9iamVjdD4gfCB1bmRlZmluZWQgPSBtLmdldChrKVxuICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG4gPT09IHbMhS5sZW5ndGggLSAxKSB7XG4gICAgICAgICB2ID0gZi5jYWxsKHbMhSlcbiAgICAgICAgIHYgPSB2ISAvLyBUUyBjb25mdXNlZDsgdGhpbmtzIHYgY2FuIGJlIHVuZGVmaW5lZCBoZXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgdiA9IG5ldyBNYXBcbiAgICAgIH1cbiAgICAgIG0uc2V0KGssIHYpXG4gICB9XG4gICByZXR1cm4gdlxufVxuXG4vLyBVbmlmeSBtZW1vLWZ1bmN0aW9ucyBhbmQgaW50ZXJuZWQgY2xhc3Nlcy5cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb2lzYWJsZTxUIGV4dGVuZHMgUGVyc2lzdGVudD4ge1xuICAga2V5OiBQZXJzaXN0ZW50XG4gICBjYWxsIChhcmdzOiBQZXJzaXN0ZW50W10pOiBUXG59XG5cbmNsYXNzIE1lbW9DdHI8VCBleHRlbmRzIFZhbHVlPiBpbXBsZW1lbnRzIE1lbW9pc2FibGU8VD4ge1xuICAgQzogQ2xhc3M8VD5cblxuICAgY29uc3RydWN0b3IgKEM6IENsYXNzPFQ+KSB7XG4gICAgICB0aGlzLkMgPSBDXG4gICB9XG5cbiAgIGdldCBrZXkgKCk6IFBlcnNpc3RlbnQge1xuICAgICAgcmV0dXJuIHRoaXMuQ1xuICAgfSBcblxuICAgY2FsbCAodsyFOiBQZXJzaXN0ZW50W10pOiBUIHtcbiAgICAgIGNvbnN0IHY6IFQgPSBuZXcgdGhpcy5DXG4gICAgICBjb25zdHJ1Y3QoZmFsc2UsIHYsIHbMhSlcbiAgICAgIE9iamVjdC5mcmVlemUodilcbiAgICAgIHJldHVybiB2XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZW1vQ2FsbDxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKG1lbW86IE1lbW9UYWJsZSwgZjogTWVtb2lzYWJsZTxUPiwgdsyFOiBQZXJzaXN0ZW50W10pOiBUIHtcbiAgIGxldCB2OiBQZXJzaXN0ZW50IHwgTWFwPFBlcnNpc3RlbnQsIE9iamVjdD4gPSBsb29rdXBBcmcoZiwgbWVtbywgdsyFLCAtMSlcbiAgIGZvciAobGV0IG46IG51bWJlciA9IDA7IG4gPCB2zIUubGVuZ3RoOyArK24pIHtcbiAgICAgIC8vIHNpbmNlIHRoZXJlIGFyZSBtb3JlIGFyZ3VtZW50cywgdGhlIGxhc3QgdiB3YXMgYSAocG9zc2libHkgbmVzdGVkKSBtYXBcbiAgICAgIHYgPSBsb29rdXBBcmcoZiwgdiBhcyBNZW1vVGFibGUsIHbMhSwgbilcbiAgIH1cbiAgIHJldHVybiB2IGFzIFRcbn1cblxuLy8gRXhwZXJpbWVudGVkIHdpdGggZGljdGlvbmFyeS1iYXNlZCBjb25zdHJ1Y3Rpb24gcGF0dGVybjsgZWxpbWluYXRlcyBmaWVsZCBvcmRlciBtaXNtYXRjaCBhcyBhIHBvc3NpYmxlXG4vLyBzb3VyY2Ugb2YgZXJyb3IsIGJ1dCB0aGUgYmVuZWZpdCBpcyB2ZXJ5IHNtYWxsIGFuZCBkb2Vzbid0IHJlYWxseSBzdWl0IHRoZSBtZW1vaXNhdGlvbiBwYXR0ZXJuLlxuZXhwb3J0IGZ1bmN0aW9uIG1ha2U8VCBleHRlbmRzIFZhbHVlPiAoQzogQ2xhc3M8VD4sIC4uLnbMhTogUGVyc2lzdGVudFtdKTogVCB7XG4gICByZXR1cm4gbWVtb0NhbGwoX19jdHJNZW1vLCBuZXcgTWVtb0N0cihDKSwgdsyFKVxufVxuXG4vLyBEZXBlbmRzIGhlYXZpbHkgb24gKDEpIGdldE93blByb3BlcnR5TmFtZXMoKSByZXR1cm5pbmcgZmllbGRzIGluIGRlZmluaXRpb24tb3JkZXI7IGFuZCAoMilcbi8vIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyBzdXBwbHlpbmcgYXJndW1lbnRzIGluIHRoZSBzYW1lIG9yZGVyLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdDxUIGV4dGVuZHMgVmFsdWU+IChjb21wYXJlOiBib29sZWFuLCB0Z3Q6IFQsIHbMhTogUGVyc2lzdGVudFtdKTogVmFsdWVEZWx0YSB8IG51bGwge1xuICAgY29uc3QgZsyFOiAoa2V5b2YgVClbXSA9IGZpZWxkcyh0Z3QpLFxuICAgICAgICAg4bqfOiBWYWx1ZURlbHRhIHwgbnVsbCA9IGNvbXBhcmUgPyB7fSA6IG51bGxcbiAgIGFzc2VydChmzIUubGVuZ3RoID09PSB2zIUubGVuZ3RoKVxuICAgbGV0IG46IG51bWJlciA9IDBcbiAgIGbMhS5mb3JFYWNoKChwcm9wOiBrZXlvZiBUKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBzcmM6IFBlcnNpc3RlbnQgPSB2zIVbbisrXVxuICAgICAgaWYgKGNvbXBhcmUgJiYgdGd0Ll9fY2hpbGQocHJvcCkgIT09IHNyYykge1xuICAgICAgICAg4bqfIVtwcm9wIGFzIHN0cmluZ10gPSB7IGJlZm9yZTogdGd0Ll9fY2hpbGQocHJvcCksIGFmdGVyOiBzcmMgfVxuICAgICAgfVxuICAgICAgKHRndCBhcyBhbnkpW3Byb3BdID0gc3JjXG4gICB9KVxuICAgcmV0dXJuIOG6n1xufVxuXG4vLyBFeGNsdWRlIG1ldGFkYXRhIGFjY29yZGluZyB0byBvdXIgY29udmVudGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkIChwcm9wOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgIHJldHVybiAhcHJvcC5zdGFydHNXaXRoKFwiX19cIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkczxUPiAodjogVCk6IChrZXlvZiBUKVtdIHtcbiAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2KS5maWx0ZXIoaXNGaWVsZCkgYXMgKGtleW9mIFQpW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGFkYXRhRmllbGRzICh2OiBWYWx1ZSk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2KS5maWx0ZXIoZiA9PiAhaXNGaWVsZChmKSAmJiBmICE9PSBcIl9faWRcIilcbn1cbiIsImltcG9ydCB7IENsYXNzLCBfX25vbk51bGwsIGFzc2VydCB9IGZyb20gXCIuL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBEZWx0YSwgQ2hhbmdlLCBfX2RlbHRhcyB9IGZyb20gXCIuL0RlbHRhXCJcbmltcG9ydCB7IElkLCBNZW1vaXNhYmxlLCBNZW1vVGFibGUsIFBlcnNpc3RlbnQsIE51bSwgU3RyLCBWYWx1ZSwgXywgY29uc3RydWN0LCBmaWVsZHMsIG1ha2UsIG1lbW9DYWxsIH0gZnJvbSBcIi4vVmFsdWVcIlxuXG4vLyBWZXJzaW9uZWQgb2JqZWN0cyBhcmUgcGVyc2lzdGVudCBvYmplY3RzIHRoYXQgaGF2ZSBzdGF0ZSB0aGF0IHZhcmllcyBhY3Jvc3Mgd29ybGRzLiBJbnRlcmZhY2UgYmVjYXVzZSB0aGUgXG4vLyBzYW1lIGRhdGF0eXBlIGNhbiBiZSBpbnRlcm5lZCBpbiBzb21lIGNvbnRleHRzIGFuZCB2ZXJzaW9uZWQgaW4gb3RoZXJzLlxuZXhwb3J0IHR5cGUgVmVyc2lvbmVkPFQ+ID0gVmVyc2lvbmVkXyAmIFRcblxuLy8gV2h5IGRvIHZlcnNpb25lZCBvYmplY3RzIG5lZWQgdG8gc3RvcmUgdGhlaXIgaWQ/XG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25lZF8ge1xuICAgX19pZDogSWRcbiAgIF9f4bqfOiBEZWx0YSAvLyBkZWx0YXMgc2hvdWxkIGJlIHJlc3RyaWN0ZWQgdG8ga2V5cyBvZiB0eXBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uZWQ8VCBleHRlbmRzIFZhbHVlPiAodjogVCk6IHYgaXMgVmVyc2lvbmVkPFQ+IHtcbiAgIHJldHVybiAodiBhcyBWZXJzaW9uZWQ8VD4pLl9faWQgIT09IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNWZXJzaW9uZWQ8VCBleHRlbmRzIFZhbHVlPiAodjogVCk6IFZlcnNpb25lZDxUPiB7XG4gICBpZiAodmVyc2lvbmVkKHYpKSB7XG4gICAgICByZXR1cm4gdlxuICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnQoZmFsc2UsIGAke3Z9IGlzIG5vdCB2ZXJzaW9uZWQuYClcbiAgIH1cbn1cblxuLy8gRm9yIHZlcnNpb25lZCBvYmplY3RzIHRoZSBtYXAgaXMgbm90IGN1cnJpZWQgYnV0IHRha2VzIGFuIChpbnRlcm5lZCkgY29tcG9zaXRlIGtleS4gVGhpcyBzdG9yZXMgb25seSBcImRlcml2ZWRcIlxuLy8gKGludGVybmFsKSB2ZXJzaW9uZWQgbm9kZXMsIG5vdCBleHRlcm5hbC5cbnR5cGUgVmVyc2lvbmVkVmFsdWVzID0gTWFwPElkLCBWZXJzaW9uZWQ8VmFsdWU+PlxuY29uc3QgX192ZXJzaW9uZWQ6IFZlcnNpb25lZFZhbHVlcyA9IG5ldyBNYXAoKVxuY29uc3QgX19yZWFjaGFibGU6IFNldDxWZXJzaW9uZWQ8VmFsdWU+PiA9IG5ldyBTZXQoKSAvLyBzdWJzZXQgb2YgX192ZXJzaW9uZWQgcmVhY2hhYmxlIGF0IGN1cnJlbnQgcmV2aXNpb25cblxuLy8gVGhlIChwb3NzaWJseSBhbHJlYWR5IGV4dGFudCkgdmVyc2lvbmVkIG9iamVjdCB1bmlxdWVseSBpZGVudGlmaWVkIGJ5IGEgbWVtby1rZXkuIEFzIGFuIGlkZW1wb3RlbnQgc2lkZS1lZmZlY3QsXG4vLyByZWNvcmQgaG93IHRoZSBvYmplY3QgZGlmZmVycyBmcm9tIGl0cyBwcmV2aW91cyB2ZXJzaW9uLiBFeHRlcm5hbCBub2RlcyBhcmUgYWx3YXlzIGNyZWF0ZWQgZnJlc2guXG5leHBvcnQgZnVuY3Rpb24gYXQ8VCBleHRlbmRzIFZhbHVlPiAoQzogQ2xhc3M8VD4sIC4uLnbMhTogUGVyc2lzdGVudFtdKTogKGs6IElkKSA9PiBWZXJzaW9uZWQ8VD4ge1xuICAgcmV0dXJuIChrOiBJZCkgPT4ge1xuICAgICAgbGV0IHY6IFZlcnNpb25lZDxWYWx1ZT4gfCB1bmRlZmluZWQgPSBfX3ZlcnNpb25lZC5nZXQoaylcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIGNvbnN0IHY6IFZlcnNpb25lZDxUPiA9IGNyZWF0ZShDLCAuLi52zIUpKGspXG4gICAgICAgICBpZiAoIShrIGluc3RhbmNlb2YgRXh0ZXJuKSkge1xuICAgICAgICAgICAgX192ZXJzaW9uZWQuc2V0KGssIHYpXG4gICAgICAgICAgICBfX3JlYWNoYWJsZS5hZGQodilcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiB2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgYXNzZXJ0KCEoayBpbnN0YW5jZW9mIEV4dGVybikpXG4gICAgICAgICBfX3JlYWNoYWJsZS5hZGQodilcbiAgICAgICAgIHJlc2V0KHYsIEMsIC4uLnbMhSlcbiAgICAgICAgIHJldHVybiB2IGFzIFZlcnNpb25lZDxUPlxuICAgICAgfVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlPFQgZXh0ZW5kcyBWYWx1ZT4gKEM6IENsYXNzPFQ+LCAuLi52zIU6IFBlcnNpc3RlbnRbXSk6IChrOiBJZCkgPT4gVmVyc2lvbmVkPFQ+IHtcbiAgIHJldHVybiAoazogSWQpID0+IHtcbiAgICAgIGNvbnN0IHY6IFZlcnNpb25lZDxUPiA9IG5ldyBDIGFzIFZlcnNpb25lZDxUPlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHYsIFwiX19pZFwiLCB7XG4gICAgICAgICB2YWx1ZTogayxcbiAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHYsIFwiX1/hup9cIiwge1xuICAgICAgICAgLy8gVGhlIGRlbHRhIG1hcCBpcyBwYXJ0aWFsOyB0aGUgYWJzZW5jZSBvZiBhbiBlbnRyeSBpcyBlcXVpdmFsZW50IHRvIGFuIGVtcHR5IGRlbHRhLiBUaGlzIGFsbG93c1xuICAgICAgICAgLy8gZGVsdGFzIHRvIGJlIGNsZWFyZWQgc2ltcGx5IGJ5IHJlbW92aW5nIGFsbCBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgICAgIGdldDogZnVuY3Rpb24gKCk6IERlbHRhIHtcbiAgICAgICAgICAgIGxldCDhup86IERlbHRhIHwgdW5kZWZpbmVkID0gX19kZWx0YXMu4bqfzIUuZ2V0KHRoaXMpXG4gICAgICAgICAgICBpZiAo4bqfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgIOG6nyA9IG5ldyBDaGFuZ2Uoe30pXG4gICAgICAgICAgICAgICBfX2RlbHRhcy7hup/MhS5zZXQodGhpcywg4bqfKVxuICAgICAgICAgICAgICAgcmV0dXJuIOG6n1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHJldHVybiDhup9cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0sXG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSlcbiAgICAgIGNvbnN0cnVjdChmYWxzZSwgdiwgdsyFKVxuICAgICAgX19kZWx0YXMuY3JlYXRlZCh2KVxuICAgICAgcmV0dXJuIHZcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0PFQgZXh0ZW5kcyBWYWx1ZT4gKHY6IFZhbHVlLCBDOiBDbGFzczxUPiwgLi4udsyFOiBQZXJzaXN0ZW50W10pOiB2b2lkIHtcbiAgIGlmICh2IGluc3RhbmNlb2YgQykge1xuICAgICAgX19kZWx0YXMuY2hhbmdlZCh2LCBjb25zdHJ1Y3QodHJ1ZSwgdiwgdsyFKSEpXG4gICB9IGVsc2Uge1xuICAgICAgcmVjbGFzc2lmeSh2LCBDKVxuICAgICAgY29uc3RydWN0KGZhbHNlLCB2LCB2zIUpXG4gICAgICBfX2RlbHRhcy5yZWNsYXNzaWZpZWQodilcbiAgIH1cbn1cblxuLy8gU2hvdWxkIGVtdWxhdGUgdGhlIHBvc3Qtc3RhdGUgb2YgXCJuZXcgQ1wiLiBQcm9iYWJseSBuZWVkIHRvIHdvcnJ5IGFib3V0IGhvdyB0aGlzIHdvcmtzIHdpdGggaW5oZXJpdGVkIHByb3BlcnRpZXMuXG5mdW5jdGlvbiByZWNsYXNzaWZ5PFQgZXh0ZW5kcyBWYWx1ZT4gKHY6IFZhbHVlLCBjdHI6IENsYXNzPFQ+KTogdm9pZCB7XG4gICBjb25zdCBwcm90bzogT2JqZWN0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBjdHIpXG4gICBhc3NlcnQgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2KSAhPT0gcHJvdG8pXG4gICBmb3IgKGNvbnN0IGsgb2YgZmllbGRzKHYpKSB7XG4gICAgICBhc3NlcnQoZGVsZXRlIHZbayBhcyBrZXlvZiBPYmplY3RdKVxuICAgfVxuICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHYsIHByb3RvKVxufVxuXG4vLyBBIG1lbW8ga2V5IHdoaWNoIGlzIHNvdXJjZWQgZXh0ZXJuYWxseSB0byB0aGUgc3lzdGVtLiAoVGhlIG5hbWUgXCJFeHRlcm5hbFwiIGlzIGFscmVhZHkgdGFrZW4uKVxuZXhwb3J0IGNsYXNzIEV4dGVybiBleHRlbmRzIElkIHtcbiAgIGlkOiBudW1iZXIgPSBfXG59XG5cbmZ1bmN0aW9uIGV4dGVybiAoaWQ6IG51bWJlcik6IEV4dGVybiB7XG4gICByZXR1cm4gbWFrZShFeHRlcm4sIGlkKVxufVxuXG4vLyBGcmVzaCBrZXlzIHJlcHJlc2VudCBpbnB1dHMgdG8gdGhlIHN5c3RlbSwgZS5nLiBhZGRyZXNzZXMgb2Ygc3ludGF4IG5vZGVzIHByb3ZpZGVkIGJ5IGFuIGV4dGVybmFsIHN0cnVjdHVyZSBlZGl0b3IuXG5leHBvcnQgY29uc3Qgzr06ICgpID0+IEV4dGVybiA9XG4gICAoKCkgPT4ge1xuICAgICAgbGV0IGNvdW50OiBudW1iZXIgPSAwXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgcmV0dXJuIGV4dGVybihjb3VudCsrKVxuICAgICAgfVxuICAgfSkoKVxuXG5leHBvcnQgZnVuY3Rpb24gbnVtICh2YWw6IG51bWJlcik6IChrOiBJZCkgPT4gVmVyc2lvbmVkPE51bT4ge1xuICAgcmV0dXJuIGF0KE51bSwgdmFsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyICh2YWw6IHN0cmluZyk6IChrOiBJZCkgPT4gVmVyc2lvbmVkPFN0cj4ge1xuICAgcmV0dXJuIGF0KFN0ciwgdmFsKVxufVxuXG5jb25zdCBfX2Z1bk1lbW86IE1lbW9UYWJsZSA9IG5ldyBNYXBcblxuLy8gU2hvdWxkIGNsZWFyIG1lbW8gdGFibGUgYXQgZWFjaCByZXZpc2lvbiwgYnV0IHRoZXJlIGFyZSBubyBtZW1vLWZ1bmN0aW9ucyBhdCB0aGUgbW9tZW50LlxuZXhwb3J0IGZ1bmN0aW9uIG5ld1JldmlzaW9uICgpOiB2b2lkIHtcbiAgIF9fZGVsdGFzLmNsZWFyKClcbiAgIF9fdmVyc2lvbmVkLmZvckVhY2goKHY6IFZlcnNpb25lZDxWYWx1ZT4sIGs6IElkKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIV9fcmVhY2hhYmxlLmhhcyh2KSkge1xuICAgICAgICAgX192ZXJzaW9uZWQuZGVsZXRlKGspXG4gICAgICB9XG4gICB9KVxuICAgX19yZWFjaGFibGUuY2xlYXIoKVxufVxuXG5leHBvcnQgdHlwZSBNZW1vRnVuVHlwZTxUIGV4dGVuZHMgUGVyc2lzdGVudD4gPSAoLi4udsyFOiBQZXJzaXN0ZW50W10pID0+IFRcblxuY2xhc3MgTWVtb0Z1bjxUIGV4dGVuZHMgUGVyc2lzdGVudD4gaW1wbGVtZW50cyBNZW1vaXNhYmxlPFQ+IHtcbiAgIGY6IE1lbW9GdW5UeXBlPFQ+XG5cbiAgIGNvbnN0cnVjdG9yIChmOiBNZW1vRnVuVHlwZTxUPikge1xuICAgICAgdGhpcy5mID0gZlxuICAgfVxuXG4gICBnZXQga2V5ICgpOiBQZXJzaXN0ZW50IHtcbiAgICAgIHJldHVybiB0aGlzLmZcbiAgIH1cblxuICAgY2FsbCAodsyFOiBQZXJzaXN0ZW50W10pOiBUIHtcbiAgICAgIHJldHVybiB0aGlzLmYuYXBwbHkobnVsbCwgdsyFKVxuICAgICAgLy8gZm9yIGFuIFwiaW5zdGFuY2VcIiB2ZXJzaW9uIHdoZXJlIHbMhVswXSBpcyBcInRoaXNcIiwgdXNlOlxuICAgICAgLy8gcmV0dXJuIHRoaXMuZi5hcHBseSh2zIVbMF0sIHbMhS5zbGljZSgxKSlcbiAgIH1cbn1cblxuLy8gTWVtb2lzYXRpb24uXG5leHBvcnQgZnVuY3Rpb24gbWVtbzxUIGV4dGVuZHMgUGVyc2lzdGVudD4gKGY6IE1lbW9GdW5UeXBlPFQ+LCAuLi52zIU6IFBlcnNpc3RlbnRbXSk6IFQge1xuICAgcmV0dXJuIG1lbW9DYWxsKF9fZnVuTWVtbywgbmV3IE1lbW9GdW4oZiksIHbMhSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmZvbnQvd29mZjtiYXNlNjQsZDA5R1JrOVVWRThBQUVKRUFBNEFBQUFBWVZRQUFRQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJDUVZORkFBQS8wQUFBQURRQUFBQTBQMkpQdWtOR1JpQUFBQWU4QUFBemtRQUFSbldaLzFGM1JrWlVUUUFBUUFRQUFBQWFBQUFBSEV4TCtlRkhSRVZHQUFBN1VBQUFBRDBBQUFCSUJDY0V6RWRRVDFNQUFEMUFBQUFDandBQUJuNy93aGxKUjFOVlFnQUFPNUFBQUFHd0FBQUR2bDB0YUlKUFV5OHlBQUFCb0FBQUFGY0FBQUJnZWdrUVJHTnRZWEFBQUFXc0FBQUIvQUFBQW9JR09pV3dhR1ZoWkFBQUFVUUFBQUEwQUFBQU50U3FuSTlvYUdWaEFBQUJlQUFBQUNBQUFBQWtCd0FEU21odGRIZ0FBRUFnQUFBQ0l3QUFBL0lLeWlzTGJXRjRjQUFBQVpnQUFBQUdBQUFBQmdEOVVBQnVZVzFsQUFBQitBQUFBN1FBQUFlODJrZ2cwSEJ2YzNRQUFBZW9BQUFBRXdBQUFDRC9oZ0F5ZUp4allHUmdZR0Jrei9sK2RiWjRQTC9OVndadTVoZEFFWWFkcWhxUFlmVC95SDhQbUY4d3p3QnlPUmlZUUtJQWpWME9JWGljWTJCa1lHRDY4cCtINFFUemkvK1IveU9aWHpBQVJWREFId0M0L2doT0FBQlFBQUQ5QUFCNG5HTmdaaEptakdOZ1pXQmg2bUtLWUdCZzhJYlFRREVqUmdrR0JpWnVWaVltSm1ZbUpwWUdCb2IxRGd3S1hneFE0T2ppNUFxa0ZINHpNWDM1ejhOd2dua0dvd0tRendpU1k3ekNkSVJCQVFoWkFCWGVETXdBZUp5bFZNdHVHemNVdlpJc0NVWlFWMWtFUlZPZzVhS3JRaGxwWkttUW9xS0EvQTVnd0lGdG9OM09neDR4bW9mQW9XUnIxYTlvVjEwWHlMYjloaTc3TWYyREh0NmhiTGhCRXlEVmdPVFI1WDBjWGw1ZUlucGUrNTVxVlAxK3FYa08xK2haN1crSDY5U3VmK1p3Zzc2by8rRHdEblhxUHp2Y3BHR2o0M0NMT28zRTRUYjl1dk83dzd2MGFiTncrQWw5M3Z6RDRUMzZ1clgxMzZGUFdqODYvSlRhclRVaTFuWjJRYWpMMFMydTBUZTFQeDJ1MDE2OTdYQ0R2cTEvNWZBT2lYcnBjSlBtOWQ4Y2JwRm9IRHZjcm8wYmR3N3YwcGZOQzRlZjBLRDVrOE43ZE5iOHkrRU9QVzk5NS9CVDJtdmQwQ0VWdEtRTmFWS1UwSndNQ1hxTDRkT0V4aGhkaHljMFlqeWdQcjRCMEl4aTJJWWtnYS9nb1lTdHBBeXJvRmVVVTRSZERkOTJEbmd2Smc5NzFqTEZKK2p5UG1iSi95UldDZTMxdmU0REUvODlUTTZncjJBaDRUVmtEd25QZ280d3I4QmtBVjRCdkVlSXBzQk5ZbGdlcHh4bHkwYy80cVBmNFVPSHhYS2pWVEkzNHEzd0orTkpGL05rMUJXRGZuOGdabkVSU25HMUtZM01TdkVxandxOUxIUmdaT3dKTVV0VGNXa3RTM0VwUzZuWFZzcE8vRWRPenFTS1pScEtuVWd0anZRcVdtUkJHYzFWTG5NeE8vWFlqNjc4NkswZndnSFdmQ1RGaHo2bmE3NFNBOUtDaGtpWG9BTmNRNEUwMEd3dGM2WEYrYlc0TXJFWWpzUkJVVUJzazU4Z1ZTblNwUEZYSnFzMEFQQnhiSnZrQ1UwUjVRaCtqaGs5eExQUnFsZ3ZIcUw0WG44d21jNk9EbzZuVmNEemE0UjdVY1g2b1BXN0poZFFPK0g3ZjZEekdvYUNhNkNTMm5YSzlheTVKaXVwUi92NHBuei9DOGdMQkx1Qk5FWDRrSFdHR0Q2U05NYWdpK3NUVVpGL2ZTWDZmY0MrUHowc3RMUlNiMzkvbWdVTFdaZ2JMMVdoN3cwOWZ6UWVmZFNKSGwrWjRvb0xNQXkvbHBoZmtyMktCV1FGR1ArL0tyZnZSZElkZGxKb2x0aGRzNThONURZVEVldVdYT2VXd3h3ZUMyamExMkFMeW5xem1kdmdQVXNuQ1ptcFpoK25pQnlDWVpkUGtiTVh5OFh1VlIxQ2M0RXAxeVcwaTZTWVljUVNBLzNxL3h0RTFxd2JNemVEdVdCKzNuMEJxMUlFd3VnZ2xsbWdGNks0K2NEVDZRcDVGNldyVXExbHVoR3BpbVJleWxpWXVTNVd5VnljcTd3d202VUVDSFdnTitJMEM4KzZJc2hqa1FVYmdZZXRaYUx3dERXTVZDNGlxVTJBOWMxS3F6SldrVkZGWHZKTGpKbDZ3QWM1NFlzeDNGYnNFV2tXYXhYazRrU3ZqQUpONG1aamtOU1gxTU4zeTUvSEJWQzFWby9iYUlhOWJmSnBic3p5WmE5M2UzdnJCYmJsZUZHUjlTejNqL0hXdy9YYml3bXdlbXlmQWYxM2pGNHFreUQxNWlaTDM5ZDJIcmNaK25jVDJyYWRmd0JpWG9Ec2VKeGpZR0JnWm9CZ0dRWkdJTW5BV0FQa01ZTDVMSXdKUURxRXdZR0JsVUdFb1k3aFA2TWhveE5qTUdNaVl3VmpIZU1rcHVOTUo1bnVNcTlrM3NOOFFFRkVRVXBCVGtGSlFVM0JRTUZLd1VWaGphS3dvcEtpbXFLZUVwTVNteEsva3BDU3FKS1VrcHlTdHBLSFVvSlNxdXFwMzB6Ly93Tk5WMkJZQURUVmtUR0lNUUZvYWkzUTFHTkFVMjlBVFJWV2tGQ1FVVkFBbTJxSnhWUkJvS21TY0ZOVGdLWXkvdi8vLytIL0EvLzcvemY4TC95Zit0Ly92L2QvaTMrcy8xaitmdnVyL1ZmeXI5aURJdzhPUGpqd1lQK0RQUTgyUDFqOVlORUQ2L3RYN3grL2YrVCszbnV2N2oyL2QvL2V2WHQzN3QyOGQrM2VxWHZyN2syL04rVzJBZXN2U01oUUh6Q3lNUkEwbXBHSm1ZV1ZqWjJEazR1Ymg1ZVBYMEJRU0ZoRVZFeGNRbEpLV2taV1RsNUJVVWxaUlZWTlhVTlRTMXRIVjAvZndOREkyTVRVek56QzBzcmF4dGJPM3NIUnlkbkYxYzNkdzlQTDI4Zlh6ejhnTUNnNEpEUXNQQ0l5S2pvbU5pNmVvYVcxdlhQaXREa0xGeXhhc25qcDhwVXJWcTFldTJiZCtvMmJOMjNadG5YWHp0MTc3aGNrSmFjL0xKdWZsL215Sk9ONzI0d3ZoVDkrcHBhK2VmL3UydGVzcWl2TGR0UW41bncrOWUxdGR2V2poSWJtcVllUFhMOXg1KzdOVzl0LzdULys3UG1UcDcvL1BDaS9mZTl4VTFkamQwZHZYMy9QNUNrTWsyYk5ubm5nOUtYOGMrY3ZWRnkrZUFZQTR5ek9lM2ljWTJCbUFJUC96UXhHREZnQUFDaEVBYmdBZUp5ZGV3dEFUTm4vK0IzVG5iazdFYnB1MkdWbUpDa0trWlNORUV1SlZtL1JDNzNvL1pSWDFtdkxVV3dlZWNzamVaZEhTa1ZHR05KNERTdnY1Mkt4RnV2cmMyZlAyUDJmTzFNZSs5MzlmcisvdjJudXZYUFA1NXp6T1ovMzUzTU9FV1ZpUW9sRW9yWkRNeUlUWWxPOC9IelRwdGdQUzB5Y1JvbGFVQ0xLam05RDhmMUV2R01MdnIrWTUwencxL2pRNzdOK3Q2TTdtU3hxM1ltaTJuU1NaTGZ0UkxsM2NsdGhUbjBsOUdDbzFwUUYxWm15b3F5cEhsUS95cGthU25sUjQ2Z2dLb0tLb1JLcERHb090WWo2Z1ZwRGJhSDJVZVhpMitJMzRqL1RFMkw3OUJuYXgzZ2JMdHo2dXJzSXQzNURqYmRoN2tteEk5SlRFaU9pWW1PZEhQbzZ1M2pIUjBaSFJLYW14Y1pIcEVWT1NZcElTWXVOaUpzU0d4VTFQREl1TFNJcEpYRksrdVMwMVBSNDBoeWJtRURHNk52WG9iL3g1cElTTVNWMmNrUmNiRUpVYkVKc1dsWnNRbHBrZEVwRVhFUVM2VFk5TWprOUlpNGhNYzF3ajR0TVRUVThSS2RFa25sU2pDOFRaMFFtUkVjcS9XSWlsVk5pbzJQVHlLc3NaV1RDNU1RcGtWT1U4UkdUWTJJVElwV2t3NVNJU1hHUnl0VEVxTFRNaUpSSVpWUmlpdEtJV0d4Q3RESXRKbEttOU10S2lveUttQnlacW95TG5SeVprRXI2cHlVcXN4TFRsYkdweXNtSlNWa3BzZEV4WkgxS204bTJTZ2NYWnhjN2NuWHBiNmZzMjZkUFgrWFFLWW1USXBXK1dhbHBrZkdwdldUS29YRnhTaCtoUTZyU0p6STFNaVVqY2tvdmdpVVo2Z01PNUpsTUxLQ1JGSm1TbHFWTWpQcDhGSm5TZzZ3akpTa3hSU0NyTWlKaGlqSTJyUm03eEpSVU84T3IrSWdzSlNHUmNwS3dUT09TSXFmWUtkTlRoYXVNRUNVMUtTNGlTL2dSbjBoNEVpczhrWmVUNHhLRkZSSXlwS1ZFSktSR1JhYWtrSitac1dreGllbHBCcndpcHllbEVKS1RNVEpUWXRQU0loT1VCcVprUk1SOXdKU3NVL2Eva3A0TUd5ZThtQktSRnZIdjVQK0UraktoSlNOV0dDUWlWU2xJa3pBZjRVT0tNaTZDVUpJMEMxS1M4ZzlzY2ZpTUxhTWl5VUJ4a3lKVG9rbUg0U25wazZmRlI2UWFNRXRRRGgzWlMybGtWSXFSVVNtZk04cUE2ZDh3NlQrUEtSRDl2L0xsLzhZVjJkL3k1ZSs0OHQrV2F6UXNTaTgvSlRFdFNzZitTc0c2ZlBhU0l2OUVWQXRLVEpsUU5DV2hwTVJRZkVISktGT3FKZFdLTWlNR3BRM1ZsaktuV0tvZHhSSGowcDdxUUhXa3ZxUytvam9SUXlPbkZKU1M2a0paVWwySjBlbEd6RTUzeW9heUpjYW5KMlZIMlZPOXFONVVIOHFCNmt1TWtTUFZuM0tpQmhDajVFSU5wTDZtWEtsQjFHREtqUnBDemFLR1VlN1VjR29FOVEwMWtocEZlVkNlMUdoaXVNWlFZeWx2Nmx0aXdId29YOHFQOHFjQ3FFQml6TVpUd2RRRWFpSVZRb1ZTWWFMdnFYQmkzaVpSMGRRVXFvaUtvdVpUdXloRVRhVUtSVGxVTVRXWDJreXRwN1pSTzZuWjFHb3FsVXFoRmxLcnFLWFVkR29qdFk3YVNzMGtobkEzdFljcW8vWlNwZFJpYWo5VlRoMmdEbEtIcUNQVVlhcUNxcVRXVWxYVU1hcWFxcUZxcWFQVURpcVBPa21wcUJOVUhYV0sya0N0cE01Ulo2aXpsSWFxcHhxb1pkUjU2akoxZ2JwSVhhSitwTFRVRmVvcVZVSmRvMjVTamRSMTZoWjFnOXBFTGFmdVUzZW91OVE5NmdFeHd3K0pPVjVDRlZENTFBcnFPSFdiT2sycHFVZFVKREhVT2FKYzZqdHFIcldBK3A3S3BoYUpGb3VRYUFreDRybkVxRE5VT2hWTFpSS0Rua1FsVTJsVUZqV0Rta2JGVVpORmVhSjhhbzFvcVdpWjZBZFJnV2k1YUFXMVhiUlN0RXBVS0ZvdFdpTmFLMW9uV2kvYUlOcEl4Vk1KMUh2Qlo0d2hCRTRsazJQUkF0SFRGdE5iTEcyaGJ2R24yRkVjSUk0Unp4RXZGWmVKL3pCUm1pU1kzS1k3ME5OcERmMVNraTQ1STNrbytWUGFWVHBNR2ltdFpGS1lGUXoveGVndjBCZEZYNXlRV2NvOFpHR3lwVEtWN0lZcGErcHFHbUM2M1BSTlM3ZVd2aTJUV2k1c3VhdmxiNjFzVzdtMkd0c3FyaFZxdGJQVnhWWVBXNzB6NjJ5V1psYmJ1bE5yNTlZVFdsOXBZOWFtZDV1TU5zVnRxdHNxMjdxM25kaTIzTHlsK1RqemFQUHQ1blhtdjdJRDJYaDJDVnZVVHRUT290MzBkc2ZiMWJWN3pBM2prSVhJd3RzaW9YMjM5cTd0VjNTUWRKQjNjT3JnMVdGYmg2b092M1ZVZHV6ZmNYdkhJeDF2ZmluOThzc3ZwMzJaODZYcXk4YXZYTDVLN0dUVGFXYW5razdhVG45Mjd0ZDVTdWY5Y3BGOHAveU0vSWxDb3VpdEdLdUlWeXhSSEZLMlVBNVdUbEl1VXU1UzhsMjZkUW51Y3FzTHR2elMwc1V5ekhLbVpXM1hZVjFUdW03cGVzZXFnMVdnVldHMzN0MDAzWDZ6N21BOTJqckxlcFgxUWV2YjNjWGRsM1EvMGYwbkc2bk5BSnNwTmt0dEttMzcyQWJaWnRzZXNIM1lvMVdQeUI0cmVwVDB1TkhUcEtkZno4YWUvN0t6dEJ0cE44a3V6MDVuMzlGK29QMjM5clB0OCt3cjdGLzJrdlhxMGN1OVYyU3ZtbDZYZWozcHBlLzlWVy83M3NON1QreWQycnV3ZDBQdkYzM00rOFQzeWU5VDJxZk9ZYXlEcW0rYnZyWjl5L3AxN3hmUjcvdCs5ZjN1OXZ2TlVlSTQyUEZJZjVmK05VNHRuT3lkZ3B6Mk9qMGEwTjRWSGVWZkhCV1JxOVZSTVRMaGMzVGY2bk1ra0k5UGNYZ3dMSWVuaU1aS2ZKd0Q4Z1BwQzJpOUpOVHdESVB4Y3ZLRHIrV0VKeXo4TXNNcThyY1FLUDVOcHZrOW9CeTA3RVZ3MXdWeDd2clZXZ2w3YndPMjRwUXlNMjgrSHJKRjRLQytweGFEQXgvUHFTSGJXd0xkY0xieHlhd29BNmFxd1VrTk1abWlmZndNOFR1TE0yZ25USVdPS0I1UE5UeStRVWh0aHphRDAwdnk0SUIyUU14WVJDZmdHTnpSK0N3OGZvR1FOMUFvSFR2aEZ1VHhOYUlmUXdwSEJoSGVkRVMwV2RaNVR3My9WbU4rUmd1dHFxRzlscDBGQmJ3dDU3SFZiemU2Z0M0ZVZWMWV4bFRqNTl5MTFMcXd4U01YMnd4S0NFUU1Xek5oTVJleDJITjMyQW5HTzV3KzZITjl3dE5GRER2TG8vcUNGS1FGRDY4aEVDT3dzS3kyM2NmQUptbjFrdU1aSlJPWnVtbzZzaUx3a0IxaUxrd1lJYlZkWU9lT01JT3cyZXZneDRtTUdSUmtxK015WUo5NnR4cG1xT2RubXU5WHd5ejFjZUhDVmgvbnYrVEx1VjhHTjlyWURCNXNhOXM0K0tYOFpXUGpMd3B2aXk0eVBsSnYvbG1UMENJWFd0ak00eVA1STF6UWRuM2crNW0xU2JRWnRNM1NKR1hvYkRUbTFkZVJGc0sxN0I1ZGQ1N2xCcUllMkJVUEFGZjZ5djQ3eDlGVDVzM2dPdnZ1ZzhkMmtTUFBRNzdsb1F4N3lHbXlteWZxaWpENzJ4Q1FvZWZvN0pGVDF4ZzI3dGV1cnhIdUI4NDBadm51SEJybUZ1c2ZsN1lwNkRTcVpzNVZIVHl0cW9qeWxSL1E5K1BZUXlIakpvWU1Sb1BSeUJQb0pycXk3K0RUV3NZTWF3VXBRSm5tdjZyWm9sK2JoWUM4eG82L3R4T3BOR0tZb0V2ajdMREZlT3lNY0MrRW5XcXgweVBjaGpsK2tIWUdlZWhiQkM3a3J3cE03a0ZucHJrZktEWGlNOWlSZXdZV1I4RVpRUzhFVG9IZzFCZmFNQUdUNlR0WVhtbUpzQXY1bTRoTm5MRFE3eXRkVUtZSS9JZ2tMaU9DNm8yN1NyQ3lNc01YdW9RNjRGYlYwVStnelJQY3ByclVBVnBCbDhxTU9xd01wYzBlUUxGYUJIV2t6NS84Q2RJbkhhZDdBN21vSVIzUzFUaWRMRU9GbFVUR0c4QkdETEhQT0V1WkdWNE1reldpL2JCU0ROVlF6T0dWSHJCU1l0UVdFVkVWTWZoWGMxMEpXR1IreHNFTVhXeW0rVExRczBtOFNCZkErV3pDZGU5amFiYnMxSFRhTEZ2RHZ5RGphT0dSVmd5N2RGTTRIQmFGSTdFRGRpakRrUkFHWVdVUUNRN2dFQVdST0V6aFlRSzkxdUJ2c1FrMm1VMXV2WEN2MmZBdG1JREpHbkxycFNDYVpsaitEakxXSzdMODBRaVB3amFWL3NDQ0NkTC9vU1ZLZ2pUOFBZMklkOWFLK1VVYVRzOGdTSVZrK3ZJbDdXVkVsQXZNdXAvRkVvUkZ5SGwwcGlWemJUNjk5c0tKdzVmUk5YUW1CQTFDbmhPRHdzTVl2QThmUk01OEFCS3doeklONUd2TWVhVTJRTXMraFhCNHpPMlNQSDBRcFhRZTVUTlE0WVRDOXFTZVo5elM2QVBkYjRiL2hxQTFlbk1GUVh2MHlPL3F3UFZNVGg3TnZtb29PbkVPTlNLUTJXdXdHUFZISTZNajNKajZhZlNPbzFVbHB4Rnp1eWJNelg1NDlBQkZsTUdRdUdwNGE2MklLTlJpc2dKSHNzYmVDQi9RaHlJWE9JMFFkdFVpQks2dkVkSjBRN1M3QlY2TUlJZTN6ak5pZWtNRFFSclJuOVNVdWRTZjFLaTVGT1NTSVNMSkVQZzlXcUFYMDVWYmo2MDlocGhYVjBaMjd6ZGloSU5pREJwZm1uU0NHUjVINzNkcERIdUVHT2owK21mb0RCWjlYdUNPaW1sbzZxTDRiR1lweE1KaDQvaW5OYkF2VTFTdGhZdGtYSTZNNjRTd0x6NUh4L2drKzZGQkRMWjQwUmM2UXNjWGo4QUMyRjVQY0d2NU5CUStQMjBtazV0SHUrUHgzRThOOVUrZk5uZzVPSGg2OWVybFdmK1RYR0NuaFVhazRwM0ZmQUlaVCsvc0FiOUljTVY3aTFzSTl1c3NETE1lVmd2MFYybER0TENNWE5obk1KWTM1ZGczcmhrQjdxZ1hnMXUvSFFTbVlQcjJPclNXbzZjQld0Y2lKay9LdmpoYlZOR0F0QXpRdmJWZHV2UjJ4N1NjZlliY0t6elBaakRzQzBnQU8yNllYK0R3NFg2MVY2NmNxTDBzdjN3aWNKaUNmVk9NNzNETzNtTjY5L1krZStlTyt1d1QrUlAxR0dkQjdHQ2ZzUDZteFlPYnhUMEV2bkNPM25leStBUzZ6b0JGajBlNEkrN1lveSsyd096VDNnU1YzZWp3OGkzcm1MeGNXZ3ZqdWVZbE41TkFidFFrV1BkQm0vZ0JSSjMwVWhOQnB3ektDRnRJMjg5Q20wRWhML0YxZ3I0OUtPYzNpcTd6QldMK0huK0cweGZnZVNpRUY2NXEvVkFJNGNsWFVQZGc5VTlxQTlSMTNvN3o1Z3ZVVWdMWncvajBjWWpyL0JLT0g0cEQ5T1NMU0J2TVEwZjA1RXFiOVJCOFlvM0dIUHlBNnFuOVNjczJ3Zzc0bmtOZ0RVNnpFUXhHUUR1ZlZTSXI1RHgybGlYejR6eTZzS0c2NGp5NmlLb25vcEVJeTdCamRDNXV3VGhycGV6VHJVWW5Dc2xacWxkcWFGQy9VWWtPcSs5cGVHKzFtRWU4UGVjeUVsczQrazgrV0VlNGR4bE1YeXhseWcrRSt5ajJYZWR5SlJsbndvcUNFWU83OU1KV1dONzM1Tmg3aXRObzMvWmR1NWs4eWJKSjI3SU9JdVluVUlJSWhzSW8zQnRZUEFhSEU4OCtnQmlZU09MbEIwQzRBaXlJMGplY2d4YU1sOFRmclh1b0RSbHVDTFlFT3hoSVBzSjlDQmxCMlFYM3hHSVg1VGV6NTYxY3FVQnJsMjVjdHA2NUMvdDhpZVMvSTl3ZnErR1p1OFQ0STkwd1Fnc25HTXRaeVlnMUtOU1pjTjFrWnNlUUJyYXBJVWRqL2x3TDVkZkRyN052bjF0QW5BU203NFFlUnhUb3pWaU56WEpCS3ZrYkc0Nm9VU01EWDJKeEJmNUNqcU1sV2c4TzVCTG90TFpQUXA4aFU3OVI0RzRTYnhQb0xtSGZndlJzYUs5ZUxwTzZLckJjWXZDSFBFOGs4THBZUjBFdkxzREZMWFVvV1lzbkZrRlhHRUErd3QxVDhTTzZNYkVraEttdm9zZmNzTnZUajBCRTQ3N0UzRTdEMDREY0lWb0JYNkJmVGxaZElXN2NpUmpMS3hyUmZTMGZjbDE4M3dLeUpUQUNBa0VHYzJFdUpuYzhRb0d6RFJncUpSRDNDbHRpYTJ4dFRXNXhDcXlVbUswaHk5NnNnWVVhMFhPaUU2N3drTE9XQ2FyeThMTjNjRWVENzhCQ0FJM2U3WDJRbHF4a1FwWUdEbXFnVUZnTVAxTXIxdlhYbVhKZTlRTjNZNU8vUWZjK2VyUHRSaFVEditLRkhqQUlmeWNOaUIrUk9leHZWdjRBblkrckRpTEw2bXJFUVoxSmNPQXR0T0xuRmxwNHlGdmdoMXBka0R0VzZ5MUE3VTVjMlFXak16SGdLY1I4QnVSNlpHbDBOc1RETkdyRmE4Q0NXOWZqVXRBTFloanRxdUNMWndwK2xidCt1dFF4czYrbDNBdEY3NTl6bWpFN1ZwVEJpMHFOYzMwY2h4Y1ZTdUNWWHZRdnBHL0Z0d2NkWExWQytENVdmMGZFeVJWcGRCYWZnZlBXaEVLRUx1ZklXUHh6QWVsanBIR1NZTGhiQ0lQeGVSSllvZWYzSTFoQm5oSFM4OFFMNklKSWxJam42NitRVUdsQ1VRWnhidnlpMTBSQ1NlK3hXblk5akNYZEhZUWxzWHU2eTlpSitoZTVVak5ZM2l4RC9BMGlSdHZoSFdjakcyUmhLek5iUkVoMld3TklZQnVSWUFQSmJzT1hFckI2VkUrY0s5djNMTFpTNEVrR1dXQWt3Rlg0alJ3WjVvczVCV1lJNHN1SkhEMDJERnQzWFF6bThDY0hEbStKVnJuRHNMY2tGaWUrM3BMY2htRjNTL0xTUWE0YmlvOXllQ3BabGZUTXNYY0lXQWFpc0QzWUU5Mk53UGJrRTRXanlDOTdpSkR6dGtUTVBzVk5kVjJRcXRzY3RFUVFnRzgvUkRnY0h0SEFyR3o0RWYzQ0dCR1Y0d1JoNFRvTEUyajNHYTd0SkdaR0FqUmNoLzNYeGZ3OFhUdXVoMkh4Z2h1Q3BZVHExM1FXSEh5bjBSLzJnTy9lV3hDQmVHY1VpTHRhWGthODNrdEMxWjR5czkxRzBjbmgzNHNieVp1dkVXd21NeUxZb1FzYWhQQXNRbXpDYUY1RTJQS2FYeUp3QmYwK25GMTkwd2dhK1Q3b0xxTFpIZkFOL3lZUHdUZjZOM2ZKUzEzUTErUmxFSGJWdjhsRm1EVDFKMWZobVJaa1RKanRCLzRQTWJRbVkvUkFNQjgvd29WNjVpY0U4WEFWNHZEVlp3aXY1aGxZQUk4Y0VBN0dwYlJoVlVLc1pGZ1ZuT0xzWkdaR2RkOGllSSt0WkJ4N21SQ0c5bEhwaWxTaUJoTEFadXFTT096MFIwdHdVdlhVRlQyWC9DVzRLd04xRnNjbW5kcUk2M1N4UHBuMHg4N0FhY1I3Y0I4T25INXZpWjM4bjc4djZpa3hlNkJyb3lVcnY4bm5zK0Uzb1lRN1M1WlhSSnptZS9ERjc4OGluTVdQbUNDb0EyNUxramsrUjR6YmtsenVLRW5selBBVC9neFlpYjREWHpHWUVTL1hpNlJnMmVxa0RKaXRnbzVxYytLRGwybllHbmdDQjduZU1uWldINW0vU2F5VXJYRWdmQkhBZUdjMTdNZzAxMnJnUFVtUnRCWWFDVnR6UFU5NjJLc3g2U3hSWmVzM2I2RUxkTEY2aTYxSkJEUTRLZHlMeWVWYmVFaDROLzFHem5Ma1FDekNsT3V0dDI5djNDTCtXWFJob0tYY3JFZTJtbWZVeFBtTCtXaStLeGVpR2xQc3RRVGI1OWtwRWU1Qy9wNHB3VDZ2ZnNuWjRpTXF4djhRblI0Ym5oaElZc3pjVWJmUU8vVHUvQzBRNWRhaXc0bWJZNW5QTUR5b2hmZGtJWHlwTG9mejBMZklsWVRYRDk0K2hsZzJheXRMM0FWM2VXTUoxb3F6cUhINzRYcmk3OWhaZ3pSa2xYbzNtTU85dlVER0JPckdRRXRMMTRHWWttUFJ5RnR2RldiWmFuQlZRUTkxYzR5MkRPSzR2ckk4RmRlUGNMcVVXQmM3TlN4UUx5Z3dCMXBEdk5kaFBvWnpsTEdOaFdxYWZkcWZVQTh2VU1Nb05lalYyWmtDbFY5cjJCZW5zVFduSHEyTmYwb29GM1VJTEY4cjJGdjhGQThTWUEzS2xmcGZHYjdlbCtBcjc5NEZkOEtkUVdRTlh5a3VvSVp0NVFUaEFSTHJDYzc0Uy9rUTVMbDNTaTFUQ0ErNFg2N2QvZ1ZhbkhleGxTL0ZsSk43VDhUWXV0MytSUWl2akJRUmFRV0hJaVlzZ3dVU2NJTjJLOWI4c3NPbnF4d1hhdUNvRkJpZjg5aFVQZ1o1UkNjRU1ibndwNGNnS3FSdlRDYllQVGZYUGg4b0xNcWVMTXBKeHI1YXErdkVEU0RMZmtJV2xaQ2hHL3NSSmkwT3p5Qkozdm9GNjNNMmtGVXA1MFBMN1FyK2xJZStTaHEyME45VFBoZk55WitieitRc29kbEs4TkdkRllicFlaem1qSUNpR09RQ3c5N25hR0N4Qkw3SGkwbGF1UW9LWURaTXRVRTRHVWZUQnJSME9abWlCd1RZdmdtWTJNbGl3MEt6RGJLWkwveTE2OFRlK3JCYVpzVzZ4OXNEN2VTNFdBTjUwZ2Q3Ny83eTRlZUh4WHVoMFZGSjNuRTNSNjBQUXI3SUsyR2FQNU5MeFB2eWNHbGVUSDRzaW1ITVBwbGlzNGF0UEUvSTRVeDQ3Q0pqSzlFMnRDMW5HMk8ycGxtYzRWOUVTTXFKUEEyVXVWdDhiVkFmMHBEZHJEdU5XbnlJMC9BdDhpVC9TWGNrYk9WMUlnK052QnVlODFmOWtSc1VTUEZ4WUtQSVYvS2xCQzBQQ2R0SWhPZy9DYjIraFVhaWQrTTMvbFhnRGZKT1ltaEVWdHRYazUxWm5HbCtROE9ldVVGSXVWNVNYL25nVi9rR1ZKaTdQSWRoVjY5dW9Oa3pzNWZPekp1T1hGQnc4UFR4QXNZN0huaEs4MGJtUmFNSWtsSGJHOGx4VkFzaGhCeXRlU1huU3VRR1pRdUtJQ0thSWdhQmlQZ3I2T0NCTzloNHY4VFZFaXROK2xINUhyVDdoNjJybUp3emRPYmNsQVZwaUptVXRPYVNnZ1RLWDBuTkRGb2UwOHlGNlh5S3hTRENnTUV5ZHJxYlFaalFWVjZlYWI2R0QyYkwrQmd5K2hCaUhKT3dyVjVPYkw4dEwzZEY0S09QdVVyTW94RE1vSWRRSXdTZmEzU2U3T28xQkJwc0RJM0VoYlRoMnhFWDBrYmY3aW9DR3o1bWtNR0ZVUG8yWkppMmZCc1NpcmMxUEZOOEc3cEpob210elJBakUrSnlla0lFT09DSW54QU9nbndTUlNXNElOd0d1Mk1MY0hjZ01UNU9JRjJJOGt6TDBJM0xORi9IajJmTFhncVl5dGlrQmFOSmNqK1VFTWtlcWVHVm1uaVVObUsrTTJrY1p2UW9hbmlubnAvQnMycnpRczBXRFh1ckVGWng3SlhLaWtra252eEdhbjhzN3FUOG5OcFhFcnk0Y3I4Q2hralpRK2lGUjBsYVBvbVF0K1JyU3RBTGhyemN2NlN5Umw2bkhpM3hDWXF6RjdxeFYwYUVUUW9sVE5maC9OOW5pVzZweGJkMDg3Zy9acWwvbnlYOXk2eFBEYlBDRXJqTXNZMmhZWWNJVjc2Ui9oeTB5MGMrMnJ0T1VyTWtORktCeWJTVnFJY21jVXNPa3l0TnkvRklSRDFJWWlDTlhCd2FMUGYxUGljNWVXelh6MEkzdHZGU3hhRktPVW1xc3RYcjFLSkgvQ3d4djVzMzRiS1NZa0pDVUJTSzJqRjFBeE84ZlU1ZUJQSkVrNExpSTVqeXlmU0c3ZnVPSEVGbHFDeGhUeFpUazdRNnR4dzFvRVBIZHBZenhwSWpucHpCdndHcXVlYjRCay9udFB4cWR3bDdMd3VzT0hlWjJWdzFMeUVabkJiazFXSTRkSXpydnpid0t2b1ovVng3OWY1YXBqcVBxODQ1a0x4cEdxTTZSSWNmRzFmc25jK2NtZUFseGUxbnUzWkhtQ04vTjdwRCs5bU1WL1VacVRyL1ZQSGhZNEpieXB3MkpYbENEbU5HZUZhaWhnMUV0c2NTZVIvTUt6anNla3R5WVEwd0pHMDlndlpuYkk5bnFvN1JrOHQ5Tm93amV1a3lFWXN4cTNEczZmMGNsM1R6NXQzVStBY29BVmVwMlZzMWI2WVc3ZExBSHhveHY1bmtwMkVWQVFGMDJONkFqUUdJZkthSHhUSUJ4OFBDamdmUU1XSFRBNWY0THZiZEdMZ3ZqQWtJcUFnN2ZweXVpRDArL1RnaW40MFZlNW5qQVJVVkFjZnBmUlViYXhmWExhbWJYaHRUd2VoTnNSMzMyNjE3cjM2OTZkUzE2OWRPM2EwSDN2dE5xQm5BSU5VakZUd2pzYzBpcmZnR3BITCtNQUFQMHNJZ0dLRENBeHFsQllYUUJ5RVZibzBnSEo0NUlSeUluNUowNXFrVGdnajhETGRCeUo4QUZHU2p3YlFnVGU2NngwWnBHc0RoTjJwNEkvWFc1elE5bVdHRldwZXBOcitoRGRWQ3NOWmZ5ejdseCtza1hHYXRWM2xmeExDTnZWejhyQlRJL1dqODlpeUdmZnB0Y21nRThrQmUreU5xVXhqb1BJb3V6eWhKUnBQUUlLL1VBT1NIL0xhbG4yVThwdEc3QnpWR1BVSXYwT05qQ0V6UXllbDd4dTlqMkN1MUpmdkswUmwwY2RJaDN4ME1ibEZIaDI2SjNvSnEwT1oxRjU2Z3MyaFA1T3BrQnR0aFArNWtNbjBrb3lZQmpVT1RJMk5pWmpNZXU0bjdqdGcwWmdzNmljcExpL2V2WTRRSTZ1bHJVZExybjE2TGszUmZjY05sNEdjeDNKaUQvNlNDWDFXUFZhSnQ2bmRxZnJKYXNQLzd1TGsrNDBPL0lkN1k4KzZUWjZldnZWWmNSTFVScTN5Wk9zbnNWMThmc3lOQzBOblpEbmZBRmc5dGlZTi9ncTZvTno5bjlGY3ZjU05rYW90dmlNNHY0c2RsYk04b3ozeFgzVkJ0dmtzTm5kWHNSdWpFdTNKVmFPKzZEY1hNRW1LWFF2T2pWWWpPWForekZXMG14Skh1U1Q3WlhSNk9KczJQbWNyc2pxSzNidHl4cWhReGg3WmtSaW5tcDB0eGgvRElNUXJmWTBrcU9UdjRDWHpGeGN3UEhKRVFYMWhjOHhQYVN5S3lYYnlUcUphbnhUQ2ZkK1JHeXVBb0RDYzNvcVhFSFBIYjFFSjV4STdURjNqekFUaEJMZm1IYXFaQUQ5aXZBcm5xclVBUUdLNEdIelZZcWNXd0JqcHhhaGpUS0NGSjhKZ0dZaGZCaHo1WGNIUVB5ZDN2Qis4bkdVWmZpZHFmZXlvNWNteUI5MGpmSEcvRlVBbXVTZnRBanlmOEM1Vm9GbXdSdzNLZEpZZTMrTU1XZ3NOSWZtQTFoRmFMamdsWE1iem1MM0QzdmVyNzkvZnk2dCsvM3V2Ky9mcjYrL0lKRnI2aG9iNitvWlYxZFpYQ045U1htSjVxTmN3M0ZuQ3Z3NjhjcE9PZWFtSzloY290OVBIR2ZYQzZCR01UdmtDdEx5Q3pKRUM1Q3E2Um9Id2RXY2ROZU02Tmtna3ZTMVZnclFKT1pRNFdyemVySjZyWnQyREJaM0k3Skk4MmhzVEZoc1ZNVWZpaTVNMHpEektCOFhTeGQyM3lCWFFUbmE5QTExRnRiUG5ZbFliaXhaRTFwZnRSRmJvMDlxQTdDVDRpWnNTT1o2cW0wc1dsbTFmdUo0emJsUndkR3BMdXIyRGZwbjRJNFU4TElYdytTVFU4Q0E2VE15RHVNN2Q0UzB2c25xZU1yUmt0WTI5NXljeUtkSllFN1pVYWFFUHN5VW9oL2YxT2dwWDkzTEJGMXdjdVlLYlFqOVhvaXFETit5SU5VVXdWclA1UU80UHpobEwwRXh4ZmZxOTBvZG9jQnFwSnR0TEhZaElSdTR0akJteVlRYS8rWWMyeWpRVEo1WW5aVTZkbUp5aFNVUElQYVlYTXpHaDY1OHk5OC9jZ1JuV20rR3gxMVBiSmlsbm91NXk1M3pPNVMyaUJhdlVrdTFjVDF3c3V3b2pwdWxETzN6QW1tUzJBeUR3c3FSWVJjUThqbEg0bmNITlV2WjM5S0svK0E4NTcvZnpzZlAxZHViZUZmMFNvOTdjUmxhb1Q1VWRPcTh0RC9KcEU5NHdndXQrZjQ4Yks4RkU4bk55RUpCcHMvRlhnbEhGTkRWbnFSWm5ieUt6dWFrZ2w0cWxtVTQvcmd2bEJuTGVNUFhqY1hpMWwwNC8vckZaNVMvVjVlQlRIQitpeWduYlJwRVVmK0g0NlRXRDVoV0REZlN2VDk0UFhCbnl6am84eFRLQ0NGUmtQVlpEYU5Ib1BOYjlCelQ2QlVkTTQ5dms0R2Z2a2R0UDZmaHNqNDIvamJFRnltdEg2U2xXaVBpWEl6MXpTVVdHUUlMQTBvRGFyVEpkZ1JHMVBtWURhMURJamFsbWZvTGFueklqYTdDUSsyWWhhQ2NpYVpFL0J4aWNKOGlkdmtyK2dlSHJiMzhwZlhObC9FOEJwd1FZQmpDOGpFa2hDRncxZlEzeHNCUkUyYW9DV0JFdVQ0RHZpRzYyeDB4cUVCeU5NM3huekRyMUJkODZzZmNzTVdVRm5lMDRJRzRXK1FST3EwQVVFTW5Bc3pZTVd6QjEzS2ZzcTFlaVVQeWtFSGdNclF5M3dWbk10OEVWVExSRDY4RE9GaFBWL2dpM1RtUXFhOFQvQkJoQlluODlnejZ2bXF3ekFQellEUDI0QzNzZC96L25LMkJ0K012WkgvOC82M0hsdERrSEVMYkIzbXZ1OGJPcFR3Si8vNENjKzZWQmVDckpTYzBDbDBMS1V2V0RvQkgrZzYzaXNVTUs0aTgvb2drWWdmTVpZMGZpMWFTZ0NsODlmNGdKazBSYUJNak5laERUUVFYUFpVQlRrbDVPUTQ2WlFZNm5TNkIwbCtvajNRZmNRdElOZ09JWVFEdWJORU5MZzB3akJadGdoUE81QU5MNkZPM09ReTV1dFFraHZKbXdNR3RTOFZETTVROWRmMkIyRVNqWDc0djlVRThYUlNDZ3lJanlOWWU4Z0hBRHRzRFY0SkRHQncvOC9UUVg3WWs4RlhaQmJnQXJRaCtycWgrcm9MbUlJUHhaSW9iMnV2eUFnLzlSY3FEc2x5TVEvTlE4aXpUNmZOTmUvTm4rdXpSSTQrclFKaEgyWFJUTE9vQ1pXTmxVNWp6V1AwbHpvak5WbENsajhVL1BQdjBzTk52c2ZtcGVTWnA4UHpYZGVpMmE5WHFGZDhmb1RDRHhhVi84QkNhSFFESHRWZ2dEODUxb3pWZy96dnlMUldzQXFGVW1wRi81OTJmblRjcWRCQjR3bHo4SlBTcDRsM1dWc29GRHl4STkxN1FWVldFZFVvZEJmMWx3QlhVMFc5RzlGVUZ6T2N3Sk4vaU5NZjc1WUlNeC9oRmxLWUh3K3dPd1FVRFFBc2JjTVVEQU45eVdKVi9SZks5MXlpQWJTQU5NVXdpajZYbndYQWZNWEJQTmJIekd2ZkUwbUJDdkNjTEQ2YkZhOUo4bS9taFg0d1N2ZVJnUWRlR3N4RE9QenVJZ0k2SWNkY1QvY3J6d2MrcEZQWDl6djhHSGN6L0RzR0Y1TzhPaEgvN1U2WEtBYnhVWHRkUnRJajY0ZHVLUFBKenFEdXUzcmU4YVRjWE1waTcxMml6NGJkRHYrQ1lKb0pPQ09ZQnA2SGZOb2JBTXozcCtyOE52cWpvWWdQQUNMY0Zmc2lRWWpyMjBUeXBtWU1pNU1sYXBGMTFDemZxSkdWSjlTVFZKeFk2MVZrTGJQeXExNEpaOW9zS24vME16eGZ4ck02RDgwSjVKbW4rWm1JcXQzdFFjSitRNStBTkQzNEU5OG9OeWlEd0wvU2VHMFNSdUVJdmxRb1JBTmZUSS9xWk1QQlVjU0pqNDZTOHlZVUg2V0tiQWo5SEdYYUhHS1VDdS85bUllbG1CcGozbHVobHI1R3VIa3hMWU12cXQ2WVFic1VKdmYxY0I2N1F3dHUyb3U5T0NydUV0N0g3NlRzNFhVaFJNaFh6dDRUaDJvOEpZS1RXMGFBN0FaRm4vajJVVXhFODFjTW5NcHd3Yk05Wkd5K1hNM0x0eVV1eEZCRi9UOEtRSkw5Q2JnWnl3emVNdmUxUFdTL2JYb0JnTW1BeHFVdVAvNExsZ20xeDhpb2RNbnRkUzd4TjBZeTZuSG1zdXBjNXJLcWNjY1pHNXc5eSsxMS84TVgwdlk1UEZYK09qU3BoN1Z6VDFtTnZXb2RwQkZraDdqWld6RkhhQm90anI0czc2L0d2VEcwTFdpdVd0bVU5Y0tCeGtlVDBKYm9oL1ZSRDhxL0QvckNjeHIwbkVCWVhLTWhqMDB0N2x6MnR5bTNvZm1PcEIrRkU3biszNHdVWjkwLzlIZzhxcTFGWUxQVzZkaGE0YzBqNUE5cEdtRTJpRmtoTnJqRy9qK3pWNE9pajh0dm03U3dINk5XRmNKY2R4T0tZSU9RMTloK1pKUmFFUk12Ri82c2JFSDNKRWI4aVM1SW5Ob0FuMmdySHJqQ2JRUDNVblBzMkVTc0ZocWlWdG40clo5cm9mY1VmeUM2bmRXM2RnNzVITHNKWFFGYVhjZWEyQUNEOUVKazZPaXYwWk0vNkNyOXhRcnBCNFc4NlM5eG5qWUJmaHNQVnQvZFdPZEhNSlUzUDJ6NTI0OHJQTnlKTkdtd1ZtV3EyTXkrQ0dHMHJtM21uMzVOMVZzZ3lNMHYyWUQ1ak1ZWDdmL1h6ZjRzcXlHWHJJNEgrV2ovNjBhM2t5enU0SWQvYmVhTmU0RFZZSUEvbWVvUk41VGtMcFBnSXdpZDFITHZ2dHNOQmtCSk1MMjBpQnM3NEkvZGlIeVFzWmRSZVJsMVY4UU9NVzMrdWhKbTByTkRNSENVTmMxRkpyampQc1RmOS80b2lueitkaElVSHZ3c1VwZFFOb0pSbzBHako0R2Y0UzBFWkwzUWszaDYrYVI4Q2lTeGpkallxemZ4bVRBWVVPWi9sOWFFaTYyYk5vVk1HNVpHTXF3Y2t3SnV3THdrRS9qSnUvckZrREhsMHpkSGx2Q2VFZlJPekozSisyZHhtREt0elFhV3B5azJab3ova2NDYTIyWjNGeWF2VFhoWUppaDh0UHRRMFcybXdMODBRbXdYZ0l0ODZEdk1EREhabUQyb2RZTUhRUlZOZVowKzVvS3p1ZGRaT3krcG9MelZxQUVUZjJSYU9wNS8yYjBtNWo1ZVFVYUQ0TTdodURvbjBGQytBUkRmTlFNWVdRMm9jRUxBOUFFNHppZENCU2g3QzBEWlY4RU44TTMyeFNCWkorQ1Y4T3pUMzJ0RWRnb0ZqdUpXT3o0SE1scnZNTUhYang0QU5SMTlYV1Npc0p1a291MnU4ZmZnL3VHd2tPQkJJZUFIMGxNY2FOd3FPUHpvdnRvZU1WdG5sWTRCWVVqQTY5UUtJcGNrN0NWaWQvTHBlL01Qb2dxa0lHWnFCSWRtTDBqaFFqT1hXN2FMbytSZFBnZS80MWpFTzZHckN5RnJhZlJSYjVsNFl6SHlOMXg1eS9RQjZlcE11c1JXS00zYndXSDBKQitNdm9RMDF5SkZvU3ZpVVd6ak5Yb21zRXlkcGFiREZzWUpmaS93ZVVhWmZrVE1FSjVJMkNHRWZBd0FjeHdrL1UyQ3ZVK0Era1BCMy9zWXZPYXdBdFdPVXZEWmhtN0hDRmQwZ2tPdXcxRktyYUswRFJJOXJIcWJFQkdxRHhYTmxXZXB3dVY1OHFoTW1pck0zamszY2FpZ3NBczQrN1JlNjFZS0NwbzRQVGZiMW9Fb0JGWjN3NWtjbm5UenpiOEpNUCtzdUgzQVFPQzlNOUNkRjNUaE1Fc0FZT2FvVEpzeDlkL0NCcWExUFlUemYrM1hYNjluY1JsQkJweCt4TENNM2hySWJXNVE3SWNnanlNUlpkd0hCNzdONXRHZXJGa29Bc2Fkb3RZNWtzYWhIZ0w4blJsNEFEYW1GSVpUMTdVWCtkYkUzbDYxSlJTZVVpd0R3N0NVandQMi8rR1E2Rk13ZnVTaElxa1UvczBlSi9FSFQva2hrdnc2Z2tRZWhkOFFQNHJlQ2xPa29qNithZk82NjdXNEx6KytNeDVPYVBBeUxCUllUOE8ydWxHTE1PWFJzdndzeVYwVlp4R2QzZldYaXR6dnhoNzdSK2RsUHNHcnZ1NC9wanFRUXdTRWV3WFFKM3EzMTJ1TGYzRVVYMklwei9ibS84ZUtybUpzdVk5bXJ2RVdsbVpHelpxaVA0YWQycks0VGZPZ3lTZkw1d3hrYmRiSWMwaEhBbjBRTm1VbFJpanVNOVNFc05XdUpCYmZiSWIzaDJ5alpNWmRqV2VHeWJid3JkaEc1djJOdUxna0dHcXA0YXBHc2xVV0tIbXZ5VjVqVnFFK0xWaS9tdCtBSWNwdEJuYTBnWGw2NjlxMENhMGFjSDY3NWk5MVhUaXhxa3JZMUYzRkRWa2xndVRoSzJ3cVZDRnBwQVhma3pQQzVybE53Yk5RSmxMWnkxbnBrMmd0OHpZdVdDSGNGcHh6ODAxV3VZOHZBVlRSRGVWMUlqU0pjQXh0Z2djaldvV2JsQ3pJb1B2NE04WVVCYmF3Mkd6b0svQ2xyc0IyZkNRZjZ4S1B1R3ZxSzVuaXBJcXhKQksrc3dMREVzZWo4YWpzT0o1dFV5WVpKbXpPdmcydW8zVU5jdnVHT3JLYjE2TExyNFdYOVIxNHd5Q3o5Y0swWkpvcXhBcmlTRk9KK2RVWVljQ0E4TW0rZnRYVEtxdHJUaWtraHZpSTZFNHB4THRWSXZCRjNmaDVzek9uSitGa2xEYUpsU0NEcFRzcWFsaEprZ21UWjBRakh4UjBPSFlLclFIN1YyelpiTmh3a2JCWmtkQUl4dStoTDhpV09raVlxWEQvV1hOTlVZM3ZwTVlHSUo1SDJTTnJVNGpHdTZEbFNGSDY0cE84Sy9yUkEzbkw5K0Y3bmUwNThVUWRvSUwvVjhxa1hPSVBrZWRFc0ZYR2hpbkVmT2xmQlJYY0VxdlFMUWJtanczWlJhektwUXVXbDZ5ckFFdHdvcDRuRGdGVTB5RFpQK3pYZkRkRC9BbEErUHdkUWthc0h6U2lwbk1PY21DNHZsbDZCNERsNlZtcmtJUldqanJ3T2RBTWFmUDhlQnpKR2E4aStIdDc3UEV2ODhpYi8rWTVmSDdMTW5INDhaMVlNTVcxZkh4WEpqczg1ZmhFRTRXUFZCZzhTaWNmUjRaem1NSWgzanJoRU84NFlaRHZNYVQ2OC9ndHZpWllZUmZjYll3enNmWHZHQ2NMQTJTTDRBYitodmZQL3Y0bXY5V0RlR1pJc2dsaHVtY0lGWTRISWQ3UTdqK3ZJWS9EK0ZxSEM0eDA2amhqaHI4UG9QeXc0SGVFSWp2R0c5K0d2Q0RRRFVPbE1BZHcxMmd4d2g0SjdvQzc4VGt5OW5lY1AzbGx4czNmdm5GOVlhdHJhdXJyWnlRUmpodEREU3h5K25HcjdoZEVpUUxCNC9odmtYVGhVQmxxMUl5WUxFS0dCVk1WTTNQTk4rbWdtQlZ0bkNwRUM3c1Z4VGNKZVk2WE9adkVVSGs1emk4MHJ0KytOV0h0N0ZvZWg0K0JML2t6Mzl5Q0IydkY0cTFwOEZiRE8xaEFRZFNHRDV4RDFiaVNDRGZxajNOQUJjRkFDOENRQXp2OEtxcG9JUklRc25JaVZOcE0zMXZZbzNHWjRydzEveGlNWlpPNDhiSnpLcGh6QWxvWHdlZXhQak1GL01MK1QrNHVDMFQxL2tTOHpCbWJDcHV4VUFwbXVHTFN4Q2RtN280aGFqSjlDVXpsa3huWUFISzhzTnhpTjZFR2RVM3o5RnhWRk95cFpTcGlxV2p4cm9udUNQY0ZibS95Z0FyWmdqYWRLSUcwWXMzTHQ1SUxOQzJKZHZ5dGpEZm9FMTFKeEc5QjF4Zk5RS0g2bEREOUQwWmpKbnRndU82UWNkRTBLSWUrbGNScmtNM0xpVmtRb0FuK2hZRkhGa01wc3h1S2JTRjFuZWdOWUoyekU5VExydTREL0xGWG5LOFI1cWFtcFNSa01Kc25rSnZYRmUwZnNOYVpyWjBxZldSdmlCQjE5SFp3NGR2TWJpTWQrT2djOVdSQTZxaTBGRnkxSFY0TndkYmhyRExVT2Fmb29aRU5WeFZpL2x1UXFYL3RqOTB3cityNFhmb0tPRzNxamdIaERsOEVYTndzUmRDK2o1cTRpeGY1aUZRNEpjSHlGVjRSdmlsMnJCQi9nOWFEaWZuYm9LSEcrSGhadEZla2x1dkFsdXg3aUc4NEZaS0lSUjdnak5PeDJuWUV6dmpVT0luUGZFQVNKTkRld1N5dWl2M21HOGxvNGYxbW1DSmVxQis1YU0xaXdweWxxUGxERXlRTHMxYmtpL25meWptY2hjdnlwSHI4eVE1dWN2eUZCQWtSU3Z5Vi94UWNLN2hZZmx6OUFMZG4zVE9xMkJCL253MGp6R0xubC9IVzJXb01tRjduZWp3ZWJqWUlINnRHOGFWYkRsY2ZCYTlRUTl4SzRUSG9qa29jL0VjWnJGazVxNXhGK3lKZnhWM3M4RjlNWE1XTTlBTzNCNkFKMlRER2hKenQ4S3M0bXNVR0Q4dG1ZSCs3OTA1MS9GWDM0RDQ4dU43aXB2b3hNaTFJWE93MGhPM3RVV00yWGxDbFFjM1JmeEJyWGkzQlgreldvS1g2VnpjRUY3KzNvVStYOENCSSs5RWIxRHR1Ymx5UDdOVXNucGltZU1HUHdaNjZyc1JnbjZoNjNCR0JKMGJvS0pCckhQUWRlRE92RzgvRnNUdnN4cDBXVkJodUVuTmtudlU2d2FkTXQ5eXZ6Ky9WRC8vS1h1UjM5NkRxNWV5OS9RdStSSllEODlwOWd6T2hYc29uMitQMENsOUdrSVRZUzNtYWZZZTNvN2ZvZWIvbFdBOHl2d2haUDViZmZtYnZSNFMzdHdXN2VWM2lma0czWFZ1UE1JKzc2L1QzNmN1VE15ZHp1Ukt2dCs0WU1mQ0xReHV6M080UTlEYWlLc2xNRUFmYjVDV0VQaXFBaXd5Z0NrWEhhdmliMWFKZFhFa3lYdzBydDVSUGdBRmpmSC9OdURzdU5Na3hISHdHT1hRLzhMSVc0cmJxTzdNY2ZWbDE1cUlCc1RjdUhMMnVVSy9FVXM0ei9BYTlabXlFdzJLSzZoNmJLVmZSRmlRcHlkaWVBbWtjNmNySXR6OW8zdzhGZjVvOHNHUlYwcExUMXk3U0RpQ003SGo4ZDl0ajVxRDhzeUVzK3hGZUtSN3dIMzNROXJ5VE1Tdzk2YWlxZGtweVpHVFozdVJWSmxoTHlMc3NCcVRkUTFBbHJOQ01wT3paMlhOSndFQ21yRjgzbEptVGpCZHVHRDd2RzJvREpXdUs5cTlkVy9SYVFSaU1nZ0NwOWtrVVFNSDlNdUs0OFc3MXF3dktsaUhWcU4xaTVZdlpNem1nTlhodlllcnlWZFV4VThUODNONGR5NWhmSEp5QklwQ3FldGlOaWF1amQ0ZWpNYWg0T2o0YjVtZGFmUzJBeVdsVldndjJqbGoxNHlhcEpLWmgxQTlPbEJlWE1za1lpc3VJVGc1ZVJLS1JDbnJZemNtcnZtMFl5cTk3ZUQyMG1yU2NjZU0zWjkzSkNpNFZvQnRwYWlXbnlUbXJmaDhMbnE5UC80Q3IwSW9sQmkza2RnV0QwRW9ET3pSaEc2bE0wNkFLV3hFcUFJdlFmUkZzSVdSQ0ZWaVI4TERPU3VPaUU3VmlQa1ZMemlrMHR0Q0VNcmpiU0NRUEkvSG1XZ2l6VS9FRjdnaitra2hVZ01vUDdsR2ZJcC94aUYvM2hZSG9WeTlMUTRrejhHUWlhcm9QUHhIRStqODBEb2kwS0k2UGxSTWJNVmJEb2Z3bHY0SWgra3RJVVRmUlVYQ2lpN0NTWW51dUp4ZU1HZCthczRjNW50SmJ1SENqZk0yTWRnV0tzRWFEdEFyTnY2d1lkbGFKayt5ZE03eTlJSVpqRm1FOGN4ZGgrZUZUYWZ1d0VjNGdYYTErZWlkUmpoNmQ3Vy9EQnpWd3FHMWQwMkgxaUthaitwbFoyNHpkb3ZRc0krYk81MFhPajN1VHhKcWNDUnBwUEZzR1grOEhYK055OXFnQzlxQVZ4WENqa0lKbFA0QVh4Vzg3MWNvL2VRdFkzajd3L3UraFYrZ2xqSzFUTjJ5cGRaVTI3SlZKOHFkcFlZSi82K3lIV1ZOOWFhR1VvRlVPSlZPTGFKMlVQV2lqcUlob2dtaWRORWMwUXJSYWRIVkZuU0wxaTI2dEhCdE1heUZmNHZKTFJhMjJOU2lYR3dxN2lqK1d1d3VEaGFuaXZQRVJlSUQ0aXZpZHlhTXlYQ1RNU1lSSmlrbTgweVdtV3d4S1RXcE1qbHQwbWp5bUJiVGJXa3Iyb24yb0gzcFlEcWQvcDVlUVQrbFgwdE1KQllsNmNYVHBxVW5KeVp1VHQ0dDM3MjV1RVJoNmhFUTdPVVZVS1BSSEsrcHJ6OGU3Q0UzSFlpTVVZL3BwOUFDc055MGVZUHFzOTBwVTdEWE0xZ3RQRHpYNE9ld2tCZHI5S1BmQi9HQkduMXJpU24vSmsvS0Q5Uy8rVWs0V2UwdVFQMURsYjY1U0M4M2JTNXMvM1c3aVh5RTl3UGtwcjduUm0vK0dtRXB3cExSQ0hkR3VCRCtCREhDRTVIendKRGhhQ2p5MlJ0ZnkzaE9wRlZENzhUZEZ3NkRRS3RyaUxobldJNy90RWJnaXg0MUhyaUsxT2hJMnE0UXh0UmRQMHBDUXErT21mNyt1T01tQ0pmem85ejEzMHF4ckFvN1F3ekVWSUV6eU1qeU4vRGRpZnVNeGc5d05EeHdRTEJCM3gzaFUxcXlLUDBpRDk1T291K3J2eUg4ZncrU2hlb0hJTjZCdjBHYm5rYmR3YW9QQWNFbWVPUjMyTTVRZi93UjFSYnZQMHZrMlJTbDVDVXVUU1BSN1BmYnZxOUFwUXhFU2tIaVd0dGIzZytOU2cwUFl3NU9wQStXQ29WTTV0YUJ5UU1WMlZKVDU1Q1JQWVdhNU0vUWM5bDV1YW1RU2JaemVZc3RsekM0NDRlNmtrTFJpQzd1T0hHSkNTcW5reVA4cDR4QXZkRHdxL04vWmt3YnIxKzUvK3prMkw2RXpHSm9LYmxRV0h0RnZoNXR5Rm4zUFdNNmZlbjAvT21Jc1JzekFiZFI0SFkyM2kvMWRocmVEc1JTVXc5OWpFWmlXcEs2S1RVMU5UTXhjV3ZtVnZuV3JadUlBT1hGNW9laEZFWXYwc0FDcWVsL08xc3FNVFhXQ3o0dGdSbnJDSExUcGlPT3hreTJ1V0pnR245bTdCWlAxQTg1aFpHZ29lL0Q1TjN6bVhPejZKcnNnelBSUk9Udm0rcVAvTkNra3FSeXhtY0tYZUhSa0hJWlBVYVB5OUZycEFtdThsekxqRnBIajEwVHR3NVZvS1BITmgxQjFXaFB5cVpJeGpSM2IwNEYyc2J3SWc5TXNNWnV1TjI4MmJZSkozK1RRNkVIUGlyRnpNbFJZQ28vaXpTbE80NFoyWVJTOGxNWVUyY0VmdnFFV0FjNk15QTFMZ1Jsb1JuNUpMVTAzYlN3YVBFbWRBdnRQMUtpWldBTy80QUlaMWQ5ZThKMDNodFdTNGhqMXFNSmZCdUUxTGdNd1hiUTA2Yk5XaVZvbVZ4UU00VnBjbEhLenAxRjI0cUxNN2JGeDJla0pCTVdSWUViZGdTU2tSRENPc0pVaU1Ma0xtUUpCR1ZIUEpYSTVHZ1NGSGNHZC9KUjRzNTRKTkVaSlpaamQvSlJnaHkra1p0K0dsZGpFbWNUcERJUldNQVg5Skh5cXNPb0FWM3hMQnVLaGlPZjZEbWVUTjA4ZXVXdXZkdUlKS0tEU1dncW1oSVhsNVRNa01tY2tROGNJVkxjQjNVMzVJS21Hc2lWYko5ZTl0MFJSS2gwYUVlVlFDVzN5MUpDMkgxbzd3ZkNTc2Q0ZnQwejdnaElCY0tTMzEvMDNSRjUrenpTaXdSNzhXbEFEeVRBcDAySEliS0N6V2dNK0FrS0kwZlFDZUx6eUtQeHVJUGhxSU1wSWEwSVcya1F5Yy92WUVwRFduL1l0bnJiVGxTRXRzemRrczJZYnAyN0xYc3JVZTB0dFN0cW1YREp3cFE1S2ZIRXdhY1ZwcTVpVEZNTFUxYWxJbStVRmpndmtESDlOS09XQ3ltMXduUnFVdkxVcVVuRmUvWnNGNzdKaE1LZmNrVXVzRVh4QVFYYXRBbURmeGRxdVZHcWlZRkZ6cGh5QnNvREVlTmxkWk1BZi9ZRDIvbkIzRU9TUWNjR1F4c0VkZ3c0L1VSNDB3VjZYQ08yc2FNY1lTYzNMSEVOWUNiQjNCUFlQbDk2OGRRbFlCRDBZR0FrWVdadlBBSzc0dmFFOGFFRXRHc0RGbC94WkV4dm9mT1FQWW9NZm5ma0pTZW5rU01HRExndzRwNzgzb1ZMZHhXbWZtR2hmbjVobFNkT1ZBamZVRCs1NmY4RGhsbUVjd0FBQUhpY0hjdkJEWUFnRkFUUjRVZVVnMFhSbDBaN0Zhb1FEMDdJWnBKM1dSS3dXN1dna01pMnVtRGowQ2VYdm5sMGMwSG4xWU5QTC9QSEQ5OVpDUFFBQUFCNG5JMVR1MG9EUVJROU14dVRLSkpzSGdZSklZaUVGQlppRWNSQ0xDeFVCQ0dJV2tvV0phS0VLRWtzRkUzaEY0aGY0RWRZV3ZnVmFxMndXTm9yNkprN294Q1RnTVhlNTdsbjdyMHpDd1ZnREJWY1FUV0NUaE54ZW1wcmUzTUtlZURyQ3lQTUsyaEVqRVZmd1VNMENCb2RsT3V0WUErempjT0RBQldSaThldC9TYVcyNmNuYmF5eFRrdXRyVGVlUnhialdXbVpvend2aHlMS21NY1NWckNEWGRUUmRIVTExaGg5UlJ4WWNZMEh2Q2xmTFZnT1ZYVzZadlBxUk4yb08vV28zYms2Yi9QYTRmV3RpOSt6bXh4bmZjRVpXbWpqQ09meUtjYVNTQ09ETEtZeGgyVlVHZk1sN3VFSnozaW5yWkNRdmlMa0tLQ0VHVGRuVEhJcG1kZEgrT3NaYWZBZVdmUGt0ZWo0UUhRL3pyS21lM0FULzhSbGh1S3lmL2hzWlZ4dTU0T1pkWW12OXNRL0dkOXdjVTgyV0pEdFFKZ1Z0L1hUZ1pFZTVhUlk5dHhSaDlFeVoxNzZHb1NvOWlBMGRVbjZIY1ppL09SUVpMVVBxWW1JOWQxN3JPL1c2K1FjNTdzMERGRk8rY29OK0dSS2lSV0tGZUhyVGN0dUw0ajJ1VWVqUStwTDhUT2lRMnJEa1VEWG9ib09aZjZtRkJuTWJSUmx6eFlYRlZ4S2RQajdoalJQMDY1ZmJicjhCcnQ1U0RGNG5LV1VPMHhVUVJTRy8zMXdsMTFad0FVUmZHQmlRNk5HWWdpRTBxZ1lDeCtJWXVnc0RJWEd3bGlMTDZ6ZDFnUWt1aUxob1pHWUc0MUxoTVFnMjFqWUdCYkxXMU5nUlNBWnY1bGRSSTBTWU8rWGMrL00zRG5uL0hQbTNsRklVa0tOT3FUUWphdTNiNnBjVVVaa2pPeWIwUFZydCt5WUNqM2VoWG1HOFppbU4rem1lcXBUbCs3b3NaNW9TRlVhTW5ONmhqM0hNaWJRQzU0alprS2oyQmp0Y2J3bXpLcGVFV0dTdm85bHpWZk5NamVCZDRCM2dIZFE5QTd3RHZBTzhBNzAxbnpESXlCR3hvMHUwVnZDZndsVnZ2bEFhNDY0OCtZNzk3eTdlMnBScTlyVXJubmxGUzdydEtvams5RWphRDNBU3JObTBYekJWakRmaktxVUsyVVdTL0tYeVprKzA3Zkp1Wm1pNWN5Q0dUU0RwV1Vtam05NlRXOEovaGxZTEtDVXJRWGsvam5WSzFxMTZzMlBiV1pMRjh5MXN5WnQrVzNFdHZzWVcwWlQybGw2ZzFpKzhiZWN2N2pUNnp1MnRsYjdaRFFuenl6UVd0ZzR1cHU1emN0OXNmNGZhdHlUdlBXMlZkeUwvL3RuN1BlenlWeC9xU1J6dnhrb1JGbVA1bXE5WEh4disxdXVxL1A5dFZlb0Q2dFdUUkRXWVlpb0dhSTZCdmJQYmxHTXY3dFZjZjd3TnUzZ0wyOVhVaDBRMGtVb1V6ZVU2d29rMUFNVkdvQ2twcUJDSDZGQ014RFJaMGh5UnVSVnFSV3RFaUdzbzR3a2lWc0p1emd4cXBpOTE3SFBjUkFTVGtmSTZZZzRIV1ZPUjB6SG9VNG5JS21UVUtsVFVPWDB4WFVhcW5VR2R1c3M3TlE1U09rODFPZ0M3RmNuMUxxVjFIUEtkcWxCbDZCUmwyR1BXMXZZclMzcTF1YnByaDZoeDY0d3BxY1E1MHdlUnNOTFNHcEVZMlFmMTJzeXZvR1VKdVdUNngzVTZMMnl4TFIxOFZ4ZFBFNzVhVFIvZ2hyTlFvT3JVY3pWcU56VktNNjZiUldhMkp0bTltVHRyTzFBY1RlNmVsQjBUL2YxUUEvVmo2b3A0czRRSTIrOWZ3S3B5a2N1QUFBQkFBQUFDQUFBQUFRQURnQUNhV1JsYjNKdmJXNEFBV3hoZEc0QUNBQUdBQUFBQUFBQkFBSUFDQUFNQUFIL1ZnQUJBQUI0bkdOZ1lHQmtBSUpiakN1a1FQUk9WWTNITUJvQU55NEZjUUFBZUp4dGs3MXJVMkVVeHAvenZyR0dFaStkMURna2JZVFkwaGQ2YVVvUWc5RllpaWwrWUNCK2RPcUZPT2lvZ29PYlVEbzdGOXpGUVJ3Y0hCejZOM1J3RkZvcHVObG82S2JYNTV6ZWhGZzYvRGozL1RpZnozdGxBTWhaNDc0N2piY3U0Q0taOXkxVTNUWml5ZUV4cVpPOGZFSFpiZUV1Nzdia0RxcnFJODl4aXZlcjVBbUpzKzlxOXEzVU0ySzdUMStOTVVUMnNPQ25NZTgrQU80bEVzM3A5dkhBZGZnZGtQaEpybmVRU0o3c0lkSTdNdUQrS3p0TC9BMmVOek43NUxQSWRjUjRYZGRMLy9pUEZuZkNOZE5mUER2SFBscGFNKzBNODk5akxPQWdQV1R2c2V1aHpSeHFaNjNlV2NicFdROXRIQ2pwTHMvMSs2SHZZcG43eTh4cGZ1b2p0M0ZMM21PR05sSWZxM2NIRVMzSUZNODBmd0hmMEpGYytwdjUxMGF6RDV4SFlNMEJKUmZTdjNxSDMwM20zT2Q4aXRKQm1UR1diR2FjdmU3eHJDOXZVTE85cDZnb3JLMmh1ZDJqbzNsekhYRy9McS9OL3lybmRKMWNJb0hyWUhNL0FadmJkamJUTWFpREl6Y2xuLzRrZldwMVpxakRjVmpYaGxuVlloelZvbW54dWpiM0UrQjhZOU1pL0k5cXBUM1NmdGZaMlB5SE9oeEgzMWpIdEd5UG8xcGtXaytwbG53REVlMEVlNzdtdHl6ZW91bzRlalBValJaWlRxV3Z1ZW16UXM2VEV0ZGZ5U2ZxWGJNOGRVenEyL0kvcUc4T2w0ZXd0L1VSQVhPV2E0QlYzbnRHaXRKQWc2emdYYnBtdVhkUjRuNWI0L29YcUxneS81Vk5UTHZQdU9EbVdCZDcxTHYyaHE2ZzRndW9TWUlDOHkrUXBSRU41aTZ5eitnZkk2YkdSd0E9XCIiLCIvLyBGaXJzdC1jbGFzcyBtb2R1bGUuXG5leHBvcnQgY2xhc3MgU1ZHIHtcbiAgIHN0YXRpYyBOUzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICBwcml2YXRlIGhpZGRlbk1ldHJpY3NFbGVtZW50OiBTVkdTVkdFbGVtZW50XG5cbiAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHRoaXMuaGlkZGVuTWV0cmljc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLk5TLCBcInN2Z1wiKVxuICAgICAgdGhpcy5oaWRkZW5NZXRyaWNzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBcIilcbiAgICAgIHRoaXMuaGlkZGVuTWV0cmljc0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMFwiKVxuICAgICAgdGhpcy5oaWRkZW5NZXRyaWNzRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIlxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlbk1ldHJpY3NFbGVtZW50KVxuICAgfVxuXG4gICB0ZXh0V2lkdGggKHRleHQ6IFNWR1RleHRFbGVtZW50KTogbnVtYmVyIHtcbiAgICAgIHRoaXMuaGlkZGVuTWV0cmljc0VsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dClcbiAgICAgIGNvbnN0IHdpZHRoOiBudW1iZXIgPSB0ZXh0LmdldEJCb3goKS53aWR0aFxuICAgICAgdGV4dC5yZW1vdmUoKVxuICAgICAgcmV0dXJuIHdpZHRoXG4gICB9XG5cbiAgIHRleHRIZWlnaHQgKHRleHQ6IFNWR1RleHRFbGVtZW50KTogbnVtYmVyIHtcbiAgICAgIHRoaXMuaGlkZGVuTWV0cmljc0VsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dClcbiAgICAgIGNvbnN0IGhlaWdodDogbnVtYmVyID0gdGV4dC5nZXRCQm94KCkuaGVpZ2h0XG4gICAgICB0ZXh0LnJlbW92ZSgpXG4gICAgICByZXR1cm4gaGVpZ2h0XG4gICB9XG59XG4iLCJpbXBvcnQgeyBsYXN0LCBudGggfSBmcm9tIFwiLi4vLi4vc3JjL3V0aWwvQXJyYXlcIlxuaW1wb3J0IHsgQUNsYXNzLCBDbGFzcywgX19jaGVjaywgX19ub25OdWxsLCBhYnN1cmQsIGFzLCBhc3NlcnQsIHVzZXJFcnJvciB9IGZyb20gXCIuLi8uLi9zcmMvdXRpbC9Db3JlXCJcbmltcG9ydCB7IGJvb2xfIH0gZnJvbSBcIi4uLy4uL3NyYy91dGlsL0xhdHRpY2VcIlxuaW1wb3J0IHsgX19zbGljZSwgYW5ub3RhdGVkLCBpc86xLCBzZXTOsSB9IGZyb20gXCIuLi8uLi9zcmMvQW5ub3RhdGlvblwiXG5pbXBvcnQgeyBDb25zLCBMaXN0LCBOb25FbXB0eSwgUGFpciB9IGZyb20gXCIuLi8uLi9zcmMvQmFzZVR5cGVzXCJcbmltcG9ydCB7IGV4cHJDbGFzcyB9IGZyb20gXCIuLi8uLi9zcmMvRGF0YVR5cGVcIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUsIGV4cGxWYWx1ZSB9IGZyb20gXCIuLi8uLi9zcmMvRGF0YVZhbHVlXCJcbmltcG9ydCB7IENoYW5nZSwgTmV3LCBWYWx1ZURlbHRhIH0gZnJvbSBcIi4uLy4uL3NyYy9EZWx0YVwiXG5pbXBvcnQgeyBFeHBsIH0gZnJvbSBcIi4uLy4uL3NyYy9FeHBsXCJcbmltcG9ydCB7IEV4cHIgfSBmcm9tIFwiLi4vLi4vc3JjL0V4cHJcIlxuaW1wb3J0IHsgRGF0YUVsaW0sIFZhckVsaW0gfSBmcm9tIFwiLi4vLi4vc3JjL01hdGNoXCJcbmltcG9ydCB7IE51bSwgUGVyc2lzdGVudCwgU3RyLCBWYWx1ZSwgZmllbGRzIH0gZnJvbSBcIi4uLy4uL3NyYy9WYWx1ZVwiXG5pbXBvcnQgeyBhc1ZlcnNpb25lZCwgcmVzZXQgfSBmcm9tIFwiLi4vLi4vc3JjL1ZlcnNpb25lZFwiXG5cbmltcG9ydCBEYXRhRXhwciA9IEV4cHIuRGF0YUV4cHJcbmltcG9ydCBEZWYgPSBFeHByLkRlZlxuaW1wb3J0IExldCA9IEV4cHIuTGV0XG5pbXBvcnQgTGV0UmVjID0gRXhwci5MZXRSZWNcbmltcG9ydCBQcmltID0gRXhwci5QcmltXG5pbXBvcnQgUmVjRGVmID0gRXhwci5SZWNEZWZcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEN1cnNvciB7XG4gICBhYnN0cmFjdCBvbjogVmFsdWVcbiAgIGFic3RyYWN0IHRvPFQgZXh0ZW5kcyBEYXRhVmFsdWU+IChDOiBDbGFzczxUPiwgazoga2V5b2YgVCk6IHRoaXNcbiAgIGFic3RyYWN0IGF0PFQgZXh0ZW5kcyBWYWx1ZT4gKEM6IEFDbGFzczxUPiwgZjogKG86IFQpID0+IHZvaWQpOiBDdXJzb3JcblxuICAgbm90QW5ub3RhdGVkICgpOiB0aGlzIHtcbiAgICAgIHJldHVybiB1c2VyRXJyb3IoXCJOb3QgYW4gYW5ub3RhdGVkIG5vZGUuXCIsIHRoaXMub24pXG4gICB9XG5cbiAgIGFzc2VydDxUIGV4dGVuZHMgVmFsdWU+IChDOiBBQ2xhc3M8VD4sIHByZWQ6ICh2OiBUKSA9PiBib29sZWFuKTogQ3Vyc29yIHtcbiAgICAgIHJldHVybiB0aGlzLmF0KEMsIHYgPT4gYXNzZXJ0KHByZWQodikpKVxuICAgfVxuXG4gICDOsXNldCAoKTogdGhpcyB7XG4gICAgICBpZiAoYW5ub3RhdGVkKHRoaXMub24pKSB7XG4gICAgICAgICBhc3NlcnQoaXPOsSh0aGlzLm9uKSA9PT0gYm9vbF8udG9wKVxuICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5ub3RBbm5vdGF0ZWQoKVxuICAgICAgfVxuICAgfVxuXG4gICDOsWNsZWFyICgpOiB0aGlzIHtcbiAgICAgIGlmIChhbm5vdGF0ZWQodGhpcy5vbikpIHtcbiAgICAgICAgIGFzc2VydChpc86xKHRoaXMub24pID09PSBib29sXy5ib3QpXG4gICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB0aGlzLm5vdEFubm90YXRlZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIHNldM6xICgpOiB0aGlzIHtcbiAgICAgIGlmIChhbm5vdGF0ZWQodGhpcy5vbikpIHtcbiAgICAgICAgIHNldM6xKGJvb2xfLnRvcCwgdGhpcy5vbilcbiAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHRoaXMubm90QW5ub3RhdGVkKClcbiAgICAgIH1cbiAgIH1cblxuICAgY2xlYXLOsSAoKTogdGhpcyB7XG4gICAgICBpZiAoYW5ub3RhdGVkKHRoaXMub24pKSB7XG4gICAgICAgICBzZXTOsShib29sXy5ib3QsIHRoaXMub24pXG4gICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB0aGlzLm5vdEFubm90YXRlZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIC8vIEhlbHBlcnMgc3BlY2lmaWMgdG8gY2VydGFpbiBkYXRhdHlwZXMuXG5cbiAgIHRyZWVOb2RlVmFsdWUgKCk6IHRoaXMge1xuICAgICAgcmV0dXJuIHRoaXMudG8oTm9uRW1wdHksIFwidFwiKVxuICAgICAgICAgICAgICAgICAudG8oUGFpciwgXCJzbmRcIilcbiAgIH1cblxuICAgbnRoIChuOiBudW1iZXIpOiB0aGlzIHtcbiAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy50byhDb25zLCBcImhlYWRcIilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdGhpcy50byhDb25zLCBcInRhaWxcIikubnRoKG4gLSAxKVxuICAgICAgfVxuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXhwbFZhbHVlQ3Vyc29yIGV4dGVuZHMgQ3Vyc29yIHtcbiAgIGFuY2VzdG9yczogRXhwbFZhbHVlW11cbiAgIHJlYWRvbmx5IHR2OiBFeHBsVmFsdWVcblxuICAgY29uc3RydWN0b3IgKGFuY2VzdG9yczogRXhwbFZhbHVlW10sIHR2OiBFeHBsVmFsdWUpIHtcbiAgICAgIHN1cGVyKClcbiAgICAgIHRoaXMuYW5jZXN0b3JzID0gYW5jZXN0b3JzXG4gICAgICB0aGlzLnR2ID0gdHZcbiAgIH1cblxuICAgc3RhdGljIGRlc2NlbmRhbnQgKHByZXY6IEV4cGxWYWx1ZUN1cnNvciB8IG51bGwsIHR2OiBFeHBsVmFsdWUpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgcmV0dXJuIG5ldyBFeHBsVmFsdWVDdXJzb3IocHJldiA9PT0gbnVsbCA/IFtdIDogWy4uLnByZXYuYW5jZXN0b3JzLCBwcmV2LnR2XSwgdHYpXG4gICB9XG5cbiAgIHN0YXRpYyBwYXJlbnQgKGNoaWxkOiBFeHBsVmFsdWVDdXJzb3IpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgYXNzZXJ0KGNoaWxkLmFuY2VzdG9ycy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIG5ldyBFeHBsVmFsdWVDdXJzb3IoY2hpbGQuYW5jZXN0b3JzLnNsaWNlKDAsIGNoaWxkLmFuY2VzdG9ycy5sZW5ndGggLSAxKSwgbGFzdChjaGlsZC5hbmNlc3RvcnMpKVxuICAgfVxuXG4gICBnZXQgb24gKCk6IFZhbHVlIHtcbiAgICAgIHJldHVybiB0aGlzLnR2XG4gICB9XG5cbiAgIHRvPFQgZXh0ZW5kcyBEYXRhVmFsdWU+IChDOiBDbGFzczxUPiwgazoga2V5b2YgVCk6IHRoaXMge1xuICAgICAgcmV0dXJuIEV4cGxWYWx1ZUN1cnNvci5kZXNjZW5kYW50KHRoaXMsIEV4cGwuZXhwbENoaWxkKHRoaXMudHYudCwgYXModGhpcy50di52LCBDKSwgaykpIGFzIHRoaXNcbiAgIH1cblxuICAgdG9DaGlsZCAobjogbnVtYmVyKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGlmICh0aGlzLnR2LnYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgICAgIGNvbnN0IHR2czogRXhwbFZhbHVlW10gPSBFeHBsLmV4cGxDaGlsZHJlbih0aGlzLnR2LnQsIHRoaXMudHYudilcbiAgICAgICAgIGlmICgwIDw9IG4gJiYgbiA8IHR2cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBFeHBsVmFsdWVDdXJzb3IuZGVzY2VuZGFudCh0aGlzLCBudGgodHZzLCBuKSlcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoXCJOb3QgYSBkYXRhIHZhbHVlXCIpXG4gICAgICB9XG4gICB9XG5cbiAgIHRvQ2hpbGRPZmZzZXQgKHR2OiBFeHBsVmFsdWUsIG9mZnNldDogbnVtYmVyKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGlmICh0aGlzLnR2LnYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgICAgIGNvbnN0IHR2czogRXhwbFZhbHVlW10gPSBFeHBsLmV4cGxDaGlsZHJlbih0aGlzLnR2LnQsIHRoaXMudHYudilcbiAgICAgICAgIGNvbnN0IG46IG51bWJlciA9IHR2cy5maW5kSW5kZXgodHZfID0+IHR2XyA9PT0gdHYpXG4gICAgICAgICBpZiAobiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyRXJyb3IoXCJOb3QgYSBjaGlsZFwiKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ2hpbGQobiArIG9mZnNldClcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdXNlckVycm9yKFwiTm90IGEgZGF0YSB2YWx1ZVwiKVxuICAgICAgfVxuICAgfVxuXG4gICBuZXh0U2libGluZyAoKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGlmICh0aGlzLmhhc1BhcmVudCgpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy51cCgpLnRvQ2hpbGRPZmZzZXQodGhpcy50diwgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgfVxuXG4gICBwcmV2U2libGluZyAoKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGlmICh0aGlzLmhhc1BhcmVudCgpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy51cCgpLnRvQ2hpbGRPZmZzZXQodGhpcy50diwgLTEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgIH1cblxuICAgaGFzUGFyZW50ICgpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPiAwXG4gICB9XG5cbiAgIHVwICgpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgcmV0dXJuIEV4cGxWYWx1ZUN1cnNvci5wYXJlbnQodGhpcylcbiAgIH1cblxuICAgdG9CaW5hcnlBcmcxIChvcE5hbWU6IHN0cmluZyk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICBjb25zdCB0OiBFeHBsLkJpbmFyeUFwcCA9IGFzKHRoaXMudHYudCwgRXhwbC5CaW5hcnlBcHApXG4gICAgICBhc3NlcnQodC5vcE5hbWUudmFsID09PSBvcE5hbWUpXG4gICAgICByZXR1cm4gRXhwbFZhbHVlQ3Vyc29yLmRlc2NlbmRhbnQodGhpcywgdC50djEpXG4gICB9XG5cbiAgIHRvQmluYXJ5QXJnMiAob3BOYW1lOiBzdHJpbmcpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgY29uc3QgdDogRXhwbC5CaW5hcnlBcHAgPSBhcyh0aGlzLnR2LnQsIEV4cGwuQmluYXJ5QXBwKVxuICAgICAgYXNzZXJ0KHQub3BOYW1lLnZhbCA9PT0gb3BOYW1lKVxuICAgICAgcmV0dXJuIEV4cGxWYWx1ZUN1cnNvci5kZXNjZW5kYW50KHRoaXMsIHQudHYyKVxuICAgfVxuXG4gICBhdDxUIGV4dGVuZHMgVmFsdWU+IChDOiBBQ2xhc3M8VD4sIGY6IChvOiBUKSA9PiB2b2lkKTogdGhpcyB7XG4gICAgICBmKGFzPFZhbHVlLCBUPih0aGlzLnR2LnYsIEMpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgIH1cblxuICAgaXNDaGFuZ2VkIChzX+G6nzogVmFsdWVEZWx0YSk6IEV4cGxWYWx1ZUN1cnNvciB7XG4gICAgICBhc3NlcnQoYXNWZXJzaW9uZWQodGhpcy50di52KS5fX+G6ny5lcShuZXcgQ2hhbmdlKHNf4bqfKSkpXG4gICAgICByZXR1cm4gdGhpc1xuICAgfVxuXG4gICBpc1VuY2hhbmdlZCAoKTogRXhwbFZhbHVlQ3Vyc29yIHtcbiAgICAgIGFzc2VydChhc1ZlcnNpb25lZCh0aGlzLnR2LnYpLl9f4bqfLmVxKG5ldyBDaGFuZ2Uoe30pKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICB9XG5cbiAgIGlzTmV3ICgpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgYXNzZXJ0KGFzVmVyc2lvbmVkKHRoaXMudHYudikuX1/hup8gaW5zdGFuY2VvZiBOZXcpXG4gICAgICByZXR1cm4gdGhpc1xuICAgfVxuXG4gICB0b1Rlcm1pbmFsICgpOiBFeHBsVmFsdWVDdXJzb3Ige1xuICAgICAgbGV0IHQ6IEV4cGwgPSB0aGlzLnR2LnRcbiAgICAgIHdoaWxlICh0IGluc3RhbmNlb2YgRXhwbC5Ob25UZXJtaW5hbCkge1xuICAgICAgICAgdCA9IHQudFxuICAgICAgfVxuICAgICAgcmV0dXJuIEV4cGxWYWx1ZUN1cnNvci5kZXNjZW5kYW50KHRoaXMsIGV4cGxWYWx1ZSh0LCB0aGlzLnR2LnYpKSAgICAgIFxuICAgfSAgIFxufVxuXG5leHBvcnQgY2xhc3MgRXhwckN1cnNvciBleHRlbmRzIEN1cnNvciB7XG4gICByZWFkb25seSB2OiBWYWx1ZSAvLyB3b3VsZCBwcmVmZXIgU3ludGF4Tm9kZSwgYnV0IHdlIGFsc28gdHJhdmVyc2UgXCJhZG1pbnN0cmF0aXZlXCIgbm9kZXMgbGlrZSBjb25zIGNlbGxzLlxuXG4gICBjb25zdHJ1Y3RvciAodjogVmFsdWUpIHtcbiAgICAgIHN1cGVyKClcbiAgICAgIHRoaXMudiA9IHZcbiAgIH1cblxuICAgZ2V0IG9uICgpOiBWYWx1ZSB7XG4gICAgICByZXR1cm4gdGhpcy52XG4gICB9XG5cbiAgIC8vIE5vIHdheSB0byBzcGVjaWZ5IG9ubHkgXCJvd25cIiBwcm9wZXJ0aWVzIHN0YXRpY2FsbHkuXG4gICB0bzxUIGV4dGVuZHMgRGF0YVZhbHVlPiAoQzogQ2xhc3M8VD4sIHByb3A6IGtleW9mIFQpOiB0aGlzIHtcbiAgICAgIGNvbnN0IHbKuTogVFtrZXlvZiBUXSA9IGFzPFBlcnNpc3RlbnQsIFQ+KHRoaXMudiwgQylbcHJvcF0gLy8gVHlwZVNjcmlwdCBub25zZW5zZVxuICAgICAgcmV0dXJuIG5ldyBFeHByQ3Vyc29yKHbKuSBhcyBhbnkpIGFzIHRoaXNcbiAgIH1cblxuICAgLy8gQWxsb3cgdGhlIGRhdGEgdmFsdWUgY2xhc3MgdG8gYmUgdXNlZCB0byBuYXZpZ2F0ZSB0aGUgZGF0YSBleHByZXNzaW9uIGZvcm0uXG4gICBjb25zdHJfdG88VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+LCBwcm9wOiBrZXlvZiBUKTogRXhwckN1cnNvciB7XG4gICAgICByZXR1cm4gdGhpcy50bzxEYXRhRXhwcj4oZXhwckNsYXNzKEMpLCBwcm9wIGFzIGtleW9mIERhdGFFeHByKVxuICAgfVxuXG4gICB0b0Nhc2U8VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+KTogRXhwckN1cnNvciB7XG4gICAgICBjb25zdCB2yrk6IFZhbHVlID0gX19ub25OdWxsKChhcyh0aGlzLnYsIERhdGFFbGltKSBhcyBhbnkpW0MubmFtZV0pXG4gICAgICByZXR1cm4gbmV3IEV4cHJDdXJzb3Iodsq5KVxuICAgfVxuXG4gICBzdGF0aWMgZGVmcyAoZGVmczogTGlzdDxEZWY+KTogTWFwPHN0cmluZywgTGV0IHwgUHJpbSB8IFJlY0RlZj4ge1xuICAgICAgY29uc3QgZGVmc8q5OiBNYXA8c3RyaW5nLCBMZXQgfCBQcmltIHwgUmVjRGVmPiA9IG5ldyBNYXBcbiAgICAgIGZvciAoOyBDb25zLmlzKGRlZnMpOyBkZWZzID0gZGVmcy50YWlsKSB7XG4gICAgICAgICBjb25zdCBkZWY6IERlZiA9IGRlZnMuaGVhZFxuICAgICAgICAgaWYgKGRlZiBpbnN0YW5jZW9mIExldCB8fCBkZWYgaW5zdGFuY2VvZiBQcmltKSB7XG4gICAgICAgICAgICBkZWZzyrkuc2V0KGRlZi54LnZhbCwgZGVmKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgTGV0UmVjKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZWNEZWZzOiBMaXN0PFJlY0RlZj4gPSBkZWYuzrQ7IENvbnMuaXMocmVjRGVmcyk7IHJlY0RlZnMgPSByZWNEZWZzLnRhaWwpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IHJlY0RlZjogUmVjRGVmID0gcmVjRGVmcy5oZWFkXG4gICAgICAgICAgICAgICBkZWZzyrkuc2V0KHJlY0RlZi54LnZhbCwgcmVjRGVmKVxuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFic3VyZCgpXG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmc8q5XG4gICB9XG5cbiAgIHRvRGVmICh4OiBzdHJpbmcpOiBFeHByQ3Vyc29yIHtcbiAgICAgIGNvbnN0IGhlcmU6IEV4cHJDdXJzb3IgPSB0aGlzLnRvKEV4cHIuRGVmcywgXCJkZWbMhVwiKSxcbiAgICAgICAgICAgIGRlZnM6IE1hcDxzdHJpbmcsIExldCB8IFByaW0gfCBSZWNEZWY+ID0gRXhwckN1cnNvci5kZWZzKGhlcmUudiBhcyBMaXN0PERlZj4pXG4gICAgICBhc3NlcnQoZGVmcy5oYXMoeCksIGBObyBkZWZpbml0aW9uIG9mIFwiJHt4fVwiIGZvdW5kLmApXG4gICAgICByZXR1cm4gbmV3IEV4cHJDdXJzb3IoZGVmcy5nZXQoeCkhKVxuICAgfVxuXG4gICBhdDxUIGV4dGVuZHMgVmFsdWU+IChDOiBBQ2xhc3M8VD4sIGY6IChvOiBUKSA9PiB2b2lkKTogRXhwckN1cnNvciB7XG4gICAgICBmKGFzPFZhbHVlLCBUPih0aGlzLnYsIEMpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgIH1cblxuICAgdmFyXyAoeDogc3RyaW5nKTogdGhpcyB7XG4gICAgICB0aGlzLmFzc2VydChWYXJFbGltLCDPgyA9PiDPgy54LnZhbCA9PT0geClcbiAgICAgIHJldHVybiB0aGlzLnRvKFZhckVsaW0sIFwizrpcIikgICAgICBcbiAgIH1cblxuICAgLy8gRWRpdGluZyBBUEkuXG5cbiAgIHNldE51bSAobjogbnVtYmVyKTogRXhwckN1cnNvciB7XG4gICAgICByZXNldCh0aGlzLnYsIE51bSwgbilcbiAgICAgIHJldHVybiB0aGlzXG4gICB9XG5cbiAgIHNldFN0ciAoc3RyXzogc3RyaW5nKTogRXhwckN1cnNvciB7XG4gICAgICByZXNldCh0aGlzLnYsIFN0ciwgc3RyXylcbiAgICAgIHJldHVybiB0aGlzXG4gICB9XG5cbiAgIGNvbnN0cl9zcGxpY2U8VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+LCBwcm9wczogKGtleW9mIFQpW10sIG1ha2VOb2RlOiAoZcyFOiBFeHByW10pID0+IEV4cHJbXSk6IEV4cHJDdXJzb3Ige1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlPERhdGFWYWx1ZT4oXG4gICAgICAgICBleHByQ2xhc3MoQyksIFxuICAgICAgICAgcHJvcHMgYXMgKGtleW9mIERhdGFWYWx1ZSlbXSwgXG4gICAgICAgICAoZcyFOiBQZXJzaXN0ZW50W10pOiBFeHByW10gPT4gbWFrZU5vZGUoZcyFLm1hcChlID0+IGFzKGUsIEV4cHIuRXhwcikpKVxuICAgICAgKVxuICAgfSBcblxuICAgc3BsaWNlPFQgZXh0ZW5kcyBWYWx1ZT4gKEM6IENsYXNzPFQ+LCBwcm9wczogKGtleW9mIFQpW10sIG1ha2VOb2RlOiAodsyFOiBQZXJzaXN0ZW50W10pID0+IFBlcnNpc3RlbnRbXSk6IEV4cHJDdXJzb3Ige1xuICAgICAgY29uc3QgdjogVCA9IGFzPFBlcnNpc3RlbnQsIFQ+KHRoaXMudiwgQyksIFxuICAgICAgICAgICAgdsyFOiBQZXJzaXN0ZW50W10gPSB2Ll9fY2hpbGRyZW4sXG4gICAgICAgICAgICBuzIU6IG51bWJlcltdID0gcHJvcHMubWFwKHByb3AgPT4gX19jaGVjayhmaWVsZHModikuaW5kZXhPZihwcm9wKSwgbiA9PiBuICE9IC0xKSksXG4gICAgICAgICAgICB2zIXKuTogUGVyc2lzdGVudFtdID0gbWFrZU5vZGUobsyFLm1hcCgobjogbnVtYmVyKTogUGVyc2lzdGVudCA9PiB2zIVbbl0pKVxuICAgICAgbsyFLmZvckVhY2goKG46IG51bWJlciwgbTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgICB2zIVbbl0gPSB2zIXKuVttXVxuICAgICAgfSlcbiAgICAgIHJlc2V0KHYsIEMsIC4uLnbMhSlcbiAgICAgIHJldHVybiB0aGlzXG4gICB9IFxufVxuIiwiaW1wb3J0IHsgbGFzdCB9IGZyb20gXCIuLi91dGlsL0FycmF5XCJcbmltcG9ydCB7IENsYXNzLCBfX2xvZywgX19ub25OdWxsLCBhYnN1cmQsIGFzLCBhc3NlcnQsIGlkLCB1c2VyRXJyb3IgfSBmcm9tIFwiLi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IENvbnMsIExpc3QgfSBmcm9tIFwiLi4vQmFzZVR5cGVzXCJcbmltcG9ydCB7IEV4cGxWYWx1ZSB9IGZyb20gXCIuLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgQ2lyY2xlLCBHcm91cCwgR3JhcGhpY3NFbGVtZW50LCBMaW5lLCBNYXJrZXIsIFBvbHlsaW5lLCBQb2x5bWFya2VycywgUG9pbnQsIFJlY3QsIFNjYWxlLCBUZXh0LCBUcmFuc2Zvcm0sIFRyYW5zbGF0ZSwgVmlld3BvcnQgfSBmcm9tIFwiLi4vR3JhcGhpY3NcIlxuaW1wb3J0IHsgVW5hcnksIHVuYXJ5XywgdW5hcnlPcHMgfSBmcm9tIFwiLi4vUHJpbWl0aXZlXCJcbmltcG9ydCB7IElkLCBOdW0sIFN0ciB9IGZyb20gXCIuLi9WYWx1ZVwiXG5pbXBvcnQgeyBudW0gfSBmcm9tIFwiLi4vVmVyc2lvbmVkXCJcbmltcG9ydCB7IFNWRyB9IGZyb20gXCIuL0NvcmVcIlxuaW1wb3J0IHsgRXhwbFZhbHVlQ3Vyc29yIH0gZnJvbSBcIi4vQ3Vyc29yXCJcbmltcG9ydCB7IFBvaW50SW50ZXJhY3RvciwgUmVjdEludGVyYWN0b3IgfSBmcm9tIFwiLi9JbnRlcmFjdG9yXCJcbmltcG9ydCB7IFBhbmUgfSBmcm9tIFwiLi9QYW5lXCJcbmltcG9ydCB7IGJvcmRlciwgY2lyY2xlLCBncm91cCwgbGluZVJvdW5kZWQsIG1hcmtlckVuc3VyZURlZmluZWQsIHBvbHlsaW5lLCByZWN0LCBzdmdFbGVtZW50LCB0ZXh0RWxlbWVudF9ncmFwaGljYWwgfSBmcm9tIFwiLi9SZW5kZXJlclwiXG5cbmNvbnN0IGZvbnRTaXplOiBudW1iZXIgPSAxMlxuZXhwb3J0IGNvbnN0IHN2ZzogU1ZHID0gbmV3IFNWRygpXG5cbnR5cGUgVHJhbnNmb3JtRnVuID0gKFt4LCB5XTogW251bWJlciwgbnVtYmVyXSkgPT4gW251bWJlciwgbnVtYmVyXVxuXG5mdW5jdGlvbiBzY2FsZSAoeF9zY2FsZTogbnVtYmVyLCB5X3NjYWxlOiBudW1iZXIpOiBUcmFuc2Zvcm1GdW4ge1xuICAgcmV0dXJuIChbeCwgeV0pOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgIHJldHVybiBbeCAqIHhfc2NhbGUsIHkgKiB5X3NjYWxlXVxuICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGUgKHhfaW5jOiBudW1iZXIsIHlfaW5jOiBudW1iZXIpOiBUcmFuc2Zvcm1GdW4ge1xuICAgcmV0dXJuIChbeCwgeV0pOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgIHJldHVybiBbeCArIHhfaW5jLCB5ICsgeV9pbmNdXG4gICB9XG59XG5cbmZ1bmN0aW9uIGludmVydFNjYWxlIChzY2FsZTogVHJhbnNmb3JtRnVuKTogVHJhbnNmb3JtRnVuIHtcbiAgIHJldHVybiAoW3gsIHldKTogW251bWJlciwgbnVtYmVyXSA9PiB7XG4gICAgICBjb25zdCBbeF9zY2FsZSwgeV9zY2FsZV06IFtudW1iZXIsIG51bWJlcl0gPSBzY2FsZShbMSwgMV0pXG4gICAgICByZXR1cm4gW3ggLyB4X3NjYWxlLCB5IC8geV9zY2FsZV1cbiAgIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRnVuICh0OiBUcmFuc2Zvcm0pOiBUcmFuc2Zvcm1GdW4ge1xuICAgaWYgKHQgaW5zdGFuY2VvZiBTY2FsZSkge1xuICAgICAgYXNzZXJ0KHQueC52YWwgPj0gMCAmJiB0LnkudmFsID49IDApXG4gICAgICByZXR1cm4gc2NhbGUodC54LnZhbCwgdC55LnZhbClcbiAgIH0gZWxzZVxuICAgaWYgKHQgaW5zdGFuY2VvZiBUcmFuc2xhdGUpIHtcbiAgICAgIGFzc2VydChpc0Zpbml0ZSh0LngudmFsKSAmJiBpc0Zpbml0ZSh0LnkudmFsKSlcbiAgICAgIHJldHVybiB0cmFuc2xhdGUodC54LnZhbCwgdC55LnZhbClcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWJzdXJkKClcbiAgIH1cbn1cblxuZnVuY3Rpb24gcG9zdGNvbXBvc2UgKGYxOiBUcmFuc2Zvcm1GdW4sIGYyOiBUcmFuc2Zvcm1GdW4pOiBUcmFuc2Zvcm1GdW4ge1xuICAgcmV0dXJuIChbeCwgeV0pOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgIHJldHVybiBmMShmMihbeCwgeV0pKVxuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR3JhcGhpY3NSZW5kZXJlciB7XG4gICBlZGl0b3I6IFBhbmUuUGFuZVxuICAgcm9vdDogU1ZHU1ZHRWxlbWVudFxuICAgYW5jZXN0b3JzOiBTVkdFbGVtZW50W10gLy8gc3RhY2sgb2YgZW5jbG9zaW5nIFNWRyBlbGVtZW50c1xuICAgdHJhbnNsYXRpb25zOiBUcmFuc2Zvcm1GdW5bXSAvLyBzdGFjayBvZiAodW5jb21wb3NlZCkgYWN0aXZlIHRyYW5zbGF0aW9ucywgZWFjaCByZWxhdGl2ZSB0byBwYXJlbnQgU1ZHXG4gICBzY2FsaW5nczogVHJhbnNmb3JtRnVuW10gLy8gc3RhY2sgb2Ygc3VjY2Vzc2l2ZWx5IGNvbXBvc2VkIHNjYWxpbmdzLCBlYWNoIHJlbGF0aXZlIHRvIHJvb3QgU1ZHXG4gICBzaG93SW52aXNpYmxlOiBib29sZWFuID0gZmFsc2VcblxuICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBpc24ndCBzdXBwb3J0ZWQgb24gU1ZHRWxlbWVudCwgc28gaXQgY29udGFpbnMgYSBncm91cCBlbGVtZW50IHdpdGggdGhlIGludmVyc2lvbiB0cmFuc2Zvcm0uXG4gICBjb25zdHJ1Y3RvciAoZWRpdG9yOiBQYW5lLlBhbmUsIHJvb3Q6IFNWR1NWR0VsZW1lbnQsIGluaXRpYWxBbmNlc3RvcjogU1ZHRWxlbWVudCkge1xuICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICAgIHRoaXMuYW5jZXN0b3JzID0gW2luaXRpYWxBbmNlc3Rvcl1cbiAgICAgIHRoaXMudHJhbnNsYXRpb25zID0gW2lkXVxuICAgICAgdGhpcy5zY2FsaW5ncyA9IFtpZF1cbiAgIH1cblxuICAgZ2V0IGN1cnJlbnQgKCk6IFNWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIHRoaXMuYW5jZXN0b3JzW3RoaXMuYW5jZXN0b3JzLmxlbmd0aCAtIDFdXG4gICB9XG5cbiAgIC8vIHNjYWxpbmcgYXBwbGllcyB0byB0cmFuc2xhdGVkIGNvb3JkaW5hdGVzXG4gICBnZXQgdHJhbnNmb3JtICgpOiBUcmFuc2Zvcm1GdW4ge1xuICAgICAgcmV0dXJuIHBvc3Rjb21wb3NlKHRoaXMuc2NhbGUsIGxhc3QodGhpcy50cmFuc2xhdGlvbnMpKVxuICAgfVxuXG4gICBnZXQgc2NhbGUgKCk6IFRyYW5zZm9ybUZ1biB7XG4gICAgICByZXR1cm4gbGFzdCh0aGlzLnNjYWxpbmdzKVxuICAgfVxuXG4gICByZW5kZXIgKHRnOiBFeHBsVmFsdWU8R3JhcGhpY3NFbGVtZW50PiwgW3csIGhdOiBbbnVtYmVyLCBudW1iZXJdKTogdm9pZCB7XG4gICAgICBhc3NlcnQodGhpcy5hbmNlc3RvcnMubGVuZ3RoID09PSAxKVxuICAgICAgY29uc3Qgcm9vdDogU1ZHRWxlbWVudCA9IHRoaXMuY3VycmVudFxuICAgICAgd2hpbGUgKHJvb3QuZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChyb290LmZpcnN0Q2hpbGQpXG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aDogbnVtYmVyID0gcGFyc2VGbG9hdChfX25vbk51bGwocm9vdC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSkpXG4gICAgICBjb25zdCBoZWlnaHQ6IG51bWJlciA9IHBhcnNlRmxvYXQoX19ub25OdWxsKHJvb3QuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpKSlcbiAgICAgIHRoaXMud2l0aExvY2FsRnJhbWUoXG4gICAgICAgICBzY2FsZSh3aWR0aCAvIHcsIGhlaWdodCAvIGgpLFxuICAgICAgICAgaWQsXG4gICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnQoRXhwbFZhbHVlQ3Vyc29yLmRlc2NlbmRhbnQobnVsbCwgdGcpKVxuICAgICAgICAgfVxuICAgICAgKVxuICAgfVxuXG4gICByZW5kZXJFbGVtZW50ICh0ZzogRXhwbFZhbHVlQ3Vyc29yLyo8R3JhcGhpY3NFbGVtZW50PiovKTogU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBHcmFwaGljc0VsZW1lbnQgPSBhcyh0Zy50di52LCBHcmFwaGljc0VsZW1lbnQpXG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIENpcmNsZSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuY2lyY2xlKHRnKVxuICAgICAgfSBlbHNlIFxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAodGcpXG4gICAgICB9IGVsc2UgXG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIExpbmUpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmxpbmUodGcpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChnIGluc3RhbmNlb2YgUG9seWxpbmUpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnBvbHlsaW5lKHRnKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIFBvbHltYXJrZXJzKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5wb2x5bWFya2Vycyh0ZylcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBSZWN0KSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5yZWN0KHRnKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnRleHQodGcpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChnIGluc3RhbmNlb2YgVmlld3BvcnQpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0KHRnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICAvLyBTY2FsaW5ncyBhY2N1bXVsYXRlIGFzIHdlIGdvIGRvd24uIFRyYW5zbGF0aW9ucyBkb24ndCwgYmVjYXVzZSB3ZSB1c2UgbmVzdGVkIFNWR3MuXG4gICB3aXRoTG9jYWxGcmFtZTxUPiAoc2NhbGU6IFRyYW5zZm9ybUZ1biwgdHJhbnNsYXRlOiBUcmFuc2Zvcm1GdW4sIGxvY2FsUmVuZGVyOiAoKSA9PiBUKTogVCB7XG4gICAgICBsZXQgcmVzdWx0OiBUXG4gICAgICB0aGlzLnNjYWxpbmdzLnB1c2gocG9zdGNvbXBvc2UobGFzdCh0aGlzLnNjYWxpbmdzKSwgc2NhbGUpKVxuICAgICAgdGhpcy50cmFuc2xhdGlvbnMucHVzaCh0cmFuc2xhdGUpXG4gICAgICByZXN1bHQgPSBsb2NhbFJlbmRlcigpXG4gICAgICB0aGlzLnRyYW5zbGF0aW9ucy5wb3AoKVxuICAgICAgdGhpcy5zY2FsaW5ncy5wb3AoKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgfVxuXG4gICAvLyBTY2FsZSBjaXJjbGUgYnkgcHJvZHVjdCBvZiB4LCB5IHNjYWxpbmcgZmFjdG9ycyB0byBtYWludGFpbiByYXRpbyBvZiBhcmVhIHRvIGZpeGVkIHJlY3RhbmdsZSBhcyBhbiBpbnZhcmlhbnQuXG4gICBjaXJjbGUgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxSZWN0PiovKTogU1ZHQ2lyY2xlRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBDaXJjbGUgPSBhcyh0Zy50di52LCBDaXJjbGUpXG4gICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLnRyYW5zZm9ybShbZy54LnZhbCwgZy55LnZhbF0pXG4gICAgICBjb25zdCBbeF9zY2FsZSwgeV9zY2FsZV0gPSB0aGlzLnNjYWxlKFsxLCAxXSlcbiAgICAgIGNvbnN0IHI6IFNWR0NpcmNsZUVsZW1lbnQgPSBjaXJjbGUoeCwgeSwgZy5yYWRpdXMudmFsICogeF9zY2FsZSAqIHlfc2NhbGUsIFwibm9uZVwiLCBnLmZpbGwudmFsLCB0aGlzLmNpcmNsZSlcbiAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZChyKVxuICAgICAgcmV0dXJuIHJcbiAgIH1cblxuICAgZ3JvdXAgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxHcm91cD4qLyk6IFNWR0dFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IFNWR0dFbGVtZW50ID0gZ3JvdXAoKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKGcpXG4gICAgICB0aGlzLmFuY2VzdG9ycy5wdXNoKGcpXG4gICAgICBmb3IgKGxldCB0Z8yFOiBFeHBsVmFsdWVDdXJzb3IvKjxMaXN0PEdyYXBoaWNzRWxlbWVudD4+Ki8gPSB0Zy50byhHcm91cCwgXCJnc1wiKTsgXG4gICAgICAgICAgIENvbnMuaXMoYXModGfMhS50di52LCBMaXN0KSk7IHRnzIUgPSB0Z8yFLnRvKENvbnMsIFwidGFpbFwiKSkge1xuICAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50KHRnzIUudG8oQ29ucywgXCJoZWFkXCIpKVxuICAgICAgfVxuICAgICAgdGhpcy5hbmNlc3RvcnMucG9wKClcbiAgICAgIHJldHVybiBnXG4gICB9XG5cbiAgIC8vIEZvciBsaW5lL3BvbHlsaW5lLCBlYWNoIHBvaW50IGlzIGNvbnNpZGVyZWQgYSBcImNoaWxkXCIsIGFuZCB0aGVyZWZvcmUgc3ViamVjdCB0byBteSBsb2NhbCBzY2FsaW5nLlxuICAgbGluZSAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPFBvbHlsaW5lPiovKTogU1ZHTGluZUVsZW1lbnQge1xuICAgICAgY29uc3QgZzogTGluZSA9IGFzKHRnLnR2LnYsIExpbmUpXG4gICAgICBjb25zdCBbW3gxLCB5MV0sIFt4MiwgeTJdXSA9IFtcbiAgICAgICAgIHRoaXMudHJhbnNmb3JtKFtnLnAxLngudmFsLCBnLnAxLnkudmFsXSksIFxuICAgICAgICAgdGhpcy50cmFuc2Zvcm0oW2cucDIueC52YWwsIGcucDIueS52YWxdKVxuICAgICAgXVxuICAgICAgY29uc3QgbDogU1ZHTGluZUVsZW1lbnQgPSBsaW5lUm91bmRlZCh4MSwgeTEsIHgyLCB5MiwgZy5zdHJva2UudmFsLCBnLnN0cm9rZVdpZHRoLnZhbClcbiAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZChsKVxuICAgICAgcmV0dXJuIGxcbiAgIH1cblxuICAgcG9seWxpbmUgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxQb2x5bGluZT4qLyk6IFNWR1BvbHlsaW5lRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBQb2x5bGluZSA9IGFzKHRnLnR2LnYsIFBvbHlsaW5lKVxuICAgICAgY29uc3QgcHM6IFtudW1iZXIsIG51bWJlcl1bXSA9IGcucG9pbnRzLnRvQXJyYXkoKS5tYXAoKHA6IFBvaW50KTogW251bWJlciwgbnVtYmVyXSA9PiB7XG4gICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oW3AueC52YWwsIHAueS52YWxdKVxuICAgICAgfSlcbiAgICAgIGNvbnN0IGw6IFNWR1BvbHlsaW5lRWxlbWVudCA9IHBvbHlsaW5lKHBzLCBnLnN0cm9rZS52YWwsIGcuc3Ryb2tlV2lkdGgudmFsKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKGwpXG4gICAgICByZXR1cm4gbFxuICAgfVxuXG4gICAvLyBQb2x5bWFya2VycyBoYXZlIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSBwb2ludHMsIGluIHRoZSAqcGFyZW50KiBzY2FsaW5nLlxuICAgcG9seW1hcmtlcnMgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxQb2x5bWFya2Vycz4qLyk6IFNWR0dFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IFNWR0dFbGVtZW50ID0gZ3JvdXAoKVxuICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKGcpXG4gICAgICB0aGlzLmFuY2VzdG9ycy5wdXNoKGcpXG4gICAgICBjb25zdCBpbnZTY2FsZTogVHJhbnNmb3JtRnVuID0gaW52ZXJ0U2NhbGUodGhpcy5zY2FsZSlcbiAgICAgIGZvciAobGV0IHRnzIU6IEV4cGxWYWx1ZUN1cnNvci8qPExpc3Q8R3JhcGhpY3NFbGVtZW50Pj4qLyA9IHRnLnRvKFBvbHltYXJrZXJzLCBcIm1hcmtlcnNcIiksXG4gICAgICAgICAgICAgICB0cHM6IEV4cGxWYWx1ZUN1cnNvci8qPExpc3Q8UG9pbnQ+Ki8gPSB0Zy50byhQb2x5bWFya2VycywgXCJwb2ludHNcIik7IFxuICAgICAgICAgICBDb25zLmlzKGFzKHRnzIUudHYudiwgTGlzdCkpIHx8IENvbnMuaXMoYXModHBzLnR2LnYsIExpc3QpKTsgXG4gICAgICAgICAgIHRnzIUgPSB0Z8yFLnRvKENvbnMsIFwidGFpbFwiKSwgdHBzID0gdHBzLnRvKENvbnMsIFwidGFpbFwiKSkge1xuICAgICAgICAgaWYgKCFDb25zLmlzKGFzKHRnzIUudHYudiwgTGlzdCkpIHx8ICFDb25zLmlzKGFzKHRwcy50di52LCBMaXN0KSkpIHtcbiAgICAgICAgICAgIHVzZXJFcnJvcihgJHtQb2x5bWFya2Vycy5uYW1lfTogbW9yZSBtYXJrZXJzIHRoYW4gcG9pbnRzLmApXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHA6IEV4cGxWYWx1ZUN1cnNvci8qPFBvaW50PiovID0gdHBzLnRvKENvbnMsIFwiaGVhZFwiKVxuICAgICAgICAgICAgY29uc3QgcDogUG9pbnQgPSBhcyh0cC50di52LCBQb2ludClcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMudHJhbnNmb3JtKFtwLngudmFsLCBwLnkudmFsXSlcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlclZpZXdwb3J0OiBTVkdTVkdFbGVtZW50ID0gc3ZnRWxlbWVudCh0cnVlLCB4LCB5LCAxMCwgMTAsIGZhbHNlLCB0aGlzLnBvbHltYXJrZXJzKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LmFwcGVuZENoaWxkKG1hcmtlclZpZXdwb3J0KVxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvcnMucHVzaChtYXJrZXJWaWV3cG9ydClcbiAgICAgICAgICAgIHRoaXMud2l0aExvY2FsRnJhbWUoXG4gICAgICAgICAgICAgICBpbnZTY2FsZSxcbiAgICAgICAgICAgICAgIGlkLCBcbiAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcjogU1ZHRWxlbWVudCA9IHRoaXMucmVuZGVyRWxlbWVudCh0Z8yFLnRvKENvbnMsIFwiaGVhZFwiKSlcbiAgICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgaW5zdGFuY2VvZiBTVkdDaXJjbGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICBuZXcgUG9pbnRJbnRlcmFjdG9yKHRoaXMuZWRpdG9yLCB0cCwgbWFya2VyKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvcnMucG9wKClcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYW5jZXN0b3JzLnBvcCgpXG4gICAgICByZXR1cm4gZ1xuICAgfVxuXG4gICByZWN0ICh0ZzogRXhwbFZhbHVlQ3Vyc29yLyo8UmVjdD4qLyk6IFNWR1JlY3RFbGVtZW50IHtcbiAgICAgIGNvbnN0IGc6IFJlY3QgPSBhcyh0Zy50di52LCBSZWN0KVxuICAgICAgY29uc3QgW3gsIHldID0gdGhpcy50cmFuc2Zvcm0oW2cueC52YWwsIGcueS52YWxdKVxuICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5zY2FsZShbZy53aWR0aC52YWwsIGcuaGVpZ2h0LnZhbF0pXG4gICAgICBhc3NlcnQod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMClcbiAgICAgIGNvbnN0IHI6IFNWR1JlY3RFbGVtZW50ID0gcmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBcIm5vbmVcIiwgZy5maWxsLnZhbCwgdGhpcy5yZWN0KVxuICAgICAgbmV3IFJlY3RJbnRlcmFjdG9yKHRoaXMuZWRpdG9yLCB0ZywgcilcbiAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZChyKVxuICAgICAgcmV0dXJuIHJcbiAgIH1cblxuICAgdGV4dCAodGc6IEV4cGxWYWx1ZUN1cnNvci8qPFRleHQ+Ki8pOiBTVkdUZXh0RWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBUZXh0ID0gYXModGcudHYudiwgVGV4dCksXG4gICAgICAgICAgICBbeCwgeV06IFtudW1iZXIsIG51bWJlcl0gPSB0aGlzLnRyYW5zZm9ybShbZy54LnZhbCwgZy55LnZhbF0pLFxuICAgICAgICAgICAgdDogU1ZHVGV4dEVsZW1lbnQgPSB0ZXh0RWxlbWVudF9ncmFwaGljYWwoeCwgeSwgZm9udFNpemUsIGcuc3RyLnZhbClcbiAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZCh0KVxuICAgICAgdC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIilcbiAgICAgIHQuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgYCR7Zy5hbmNob3IudmFsfWApXG4gICAgICB0LnNldEF0dHJpYnV0ZShcImFsaWdubWVudC1iYXNlbGluZVwiLCBgJHtnLmJhc2VsaW5lLnZhbH1gKVxuICAgICAgcmV0dXJuIHRcbiAgIH1cblxuICAgdmlld3BvcnQgKHRnOiBFeHBsVmFsdWVDdXJzb3IvKjxWaWV3cG9ydD4qLyk6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgY29uc3QgZzogVmlld3BvcnQgPSBhcyh0Zy50di52LCBWaWV3cG9ydClcbiAgICAgIC8vIGRpbWVuc2lvbnMgYXJlIHJlbGF0aXZlIHRvIHBhcmVudCBjb29yZGluYXRlIHNwYWNlLCBzbyBub3QgdHJhbnNmb3JtZWQgYnkgZydzIHNjYWxpbmdcbiAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMudHJhbnNmb3JtKFtnLngudmFsLCBnLnkudmFsXSlcbiAgICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuc2NhbGUoW2cud2lkdGgudmFsLCBnLmhlaWdodC52YWxdKVxuICAgICAgYXNzZXJ0KHdpZHRoID49IDAgJiYgaGVpZ2h0ID49IDApXG4gICAgICBjb25zdCBvdXRlclN2ZzogU1ZHU1ZHRWxlbWVudCA9IHN2Z0VsZW1lbnQoZmFsc2UsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZhbHNlLCB0aGlzLnZpZXdwb3J0KVxuICAgICAgaWYgKGcuZmlsbC52YWwgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICBvdXRlclN2Zy5hcHBlbmRDaGlsZChyZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQsIFwibm9uZVwiLCBnLmZpbGwudmFsLCB0aGlzLnZpZXdwb3J0KSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZChvdXRlclN2ZylcbiAgICAgIGlmICh0aGlzLnNob3dJbnZpc2libGUpIHtcbiAgICAgICAgIHRoaXMuY3VycmVudC5hcHBlbmRDaGlsZChib3JkZXIoeCwgeSwgd2lkdGgsIGhlaWdodCwgXCJncmF5XCIsIHRydWUpKVxuICAgICAgfVxuICAgICAgdGhpcy5hbmNlc3RvcnMucHVzaChvdXRlclN2ZylcbiAgICAgIGNvbnN0IG1hcmdpbjogbnVtYmVyID0gZy5tYXJnaW4udmFsXG4gICAgICBjb25zdCBbd2lkdGjKuSwgaGVpZ2h0yrldOiBbbnVtYmVyLCBudW1iZXJdID0gW01hdGgubWF4KHdpZHRoIC0gbWFyZ2luICogMiksIGhlaWdodCAtIG1hcmdpbiAqIDJdXG4gICAgICBjb25zdCBpbm5lclNjYWxlOiBUcmFuc2Zvcm1GdW4gPSAoW3gsIHldOiBbbnVtYmVyLCBudW1iZXJdKSA9PiB7XG4gICAgICAgICByZXR1cm4gW3ggKiB3aWR0aMq5IC8gd2lkdGgsIHkgKiBoZWlnaHTKuSAvIGhlaWdodF1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyVmlld3BvcnQ6IFNWR1NWR0VsZW1lbnQgPSBzdmdFbGVtZW50KHRydWUsIG1hcmdpbiwgbWFyZ2luLCB3aWR0aMq5LCBoZWlnaHTKuSwgZmFsc2UsIHRoaXMudmlld3BvcnQpXG4gICAgICB0aGlzLmN1cnJlbnQuYXBwZW5kQ2hpbGQoaW5uZXJWaWV3cG9ydClcbiAgICAgIHRoaXMuYW5jZXN0b3JzLnB1c2goaW5uZXJWaWV3cG9ydClcbiAgICAgIHRoaXMud2l0aExvY2FsRnJhbWUoXG4gICAgICAgICBwb3N0Y29tcG9zZShpbm5lclNjYWxlLCB0cmFuc2Zvcm1GdW4oZy5zY2FsZSkpLFxuICAgICAgICAgdHJhbnNmb3JtRnVuKGcudHJhbnNsYXRlKSxcbiAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRWxlbWVudCh0Zy50byhWaWV3cG9ydCwgXCJnXCIpKVxuICAgICAgICAgfVxuICAgICAgKVxuICAgICAgdGhpcy5hbmNlc3RvcnMucG9wKClcbiAgICAgIHRoaXMuYW5jZXN0b3JzLnBvcCgpXG4gICAgICByZXR1cm4gb3V0ZXJTdmdcbiAgIH1cblxuICAgc2V0TWFya2VyTWlkIChlbDogU1ZHRWxlbWVudCwgQzogQ2xhc3M8TWFya2VyPiwgY29sb3VyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGNvbnN0IG1hcmtlcklkOiBzdHJpbmcgPSBtYXJrZXJFbnN1cmVEZWZpbmVkKHRoaXMucm9vdCwgQywgY29sb3VyKSAvLyByZXZpc2l0IGNhc3RcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm1hcmtlci1taWRcIiwgYHVybCgjJHttYXJrZXJJZH0pYClcbiAgIH1cbn1cblxue1xuICAgLy8gQWRkaXRpb25hbCBwcmltaXRpdmVzIHRoYXQgcmVseSBvbiBvZmZsaW5lIHJlbmRlcmluZyB0byBjb21wdXRlIHRleHQgbWV0cmljcy4gQ29tYmluaW5nIHRoZXNlIHdvdWxkIFxuICAgLy8gcmVxdWlyZSBtb3JlIGdlbmVyYWwgcHJpbWl0aXZlcyB0aGF0IGNhbiByZXR1cm4gdHVwbGVzLlxuICAgY29uc3QgdGV4dFdpZHRoOiBVbmFyeTxTdHIsIE51bT4gPSAoc3RyOiBTdHIpOiAoazogSWQpID0+IE51bSA9PiB7XG4gICAgICByZXR1cm4gbnVtKHN2Zy50ZXh0V2lkdGgodGV4dEVsZW1lbnRfZ3JhcGhpY2FsKDAsIDAsIGZvbnRTaXplLCBzdHIudmFsKSkpXG4gICB9XG4gICBcbiAgIGNvbnN0IHRleHRIZWlnaHQ6IFVuYXJ5PFN0ciwgTnVtPiA9IChzdHI6IFN0cik6IChrOiBJZCkgPT4gTnVtID0+IHtcbiAgICAgIHJldHVybiBudW0oc3ZnLnRleHRIZWlnaHQodGV4dEVsZW1lbnRfZ3JhcGhpY2FsKDAsIDAsIGZvbnRTaXplLCBzdHIudmFsKSkpXG4gICB9XG4gICBcbiAgIHVuYXJ5T3BzLnNldCh0ZXh0V2lkdGgubmFtZSwgdW5hcnlfKHRleHRXaWR0aCkpXG4gICB1bmFyeU9wcy5zZXQodGV4dEhlaWdodC5uYW1lLCB1bmFyeV8odGV4dEhlaWdodCkpXG59XG4iLCJpbXBvcnQgdGlwcHkgZnJvbSBcInRpcHB5LmpzXCJcbmltcG9ydCB7IEluc3RhbmNlIGFzIFRvb2x0aXAsIFBsYWNlbWVudCB9IGZyb20gXCJ0aXBweS5qc1wiXG5pbXBvcnQgXCJ0aXBweS5qcy9kaXN0L3RpcHB5LmNzc1wiXG5pbXBvcnQgXCJ0aXBweS5qcy90aGVtZXMvbGlnaHQtYm9yZGVyLmNzc1wiXG5pbXBvcnQgeyBDbGFzcywgX19sb2csIF9fbm9uTnVsbCwgYXMgfSBmcm9tIFwiLi4vdXRpbC9Db3JlXCJcbmltcG9ydCB7IGJvb2xfIH0gZnJvbSBcIi4uL3V0aWwvTGF0dGljZVwiXG5pbXBvcnQgeyBEaXJlY3Rpb24sIGlzzrEsIHNldM6xIH0gZnJvbSBcIi4uL0Fubm90YXRpb25cIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUgfSBmcm9tIFwiLi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi4vRXhwbFwiXG5pbXBvcnQgeyBQb2ludCwgUmVjdCB9IGZyb20gXCIuLi9HcmFwaGljc1wiXG5pbXBvcnQgeyBOdW0sIFBlcnNpc3RlbnQsIFN0ciwgZmllbGRzIH0gZnJvbSBcIi4uL1ZhbHVlXCJcbmltcG9ydCB7IEV4cGxWYWx1ZUN1cnNvciB9IGZyb20gXCIuL0N1cnNvclwiXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSBcIi4vUGFuZVwiXG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuL1JlbmRlcmVyXCJcblxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcCAoZWxlbWVudDogU1ZHRWxlbWVudCwgcGxhY2VtZW50OiBQbGFjZW1lbnQpOiBUb29sdGlwIHtcbiAgIHJldHVybiB0aXBweShlbGVtZW50LCB7IHRoZW1lOiBcImxpZ2h0LWJvcmRlclwiLCBwbGFjZW1lbnQgfSlcbn1cblxuYWJzdHJhY3QgY2xhc3MgSW50ZXJhY3RvcjxUIGV4dGVuZHMgRGF0YVZhbHVlLCBVIGV4dGVuZHMgU1ZHRWxlbWVudD4ge1xuICAgZWRpdG9yOiBQYW5lLlBhbmVcbiAgIEM6IENsYXNzPFQ+XG4gICB0b29sdGlwOiBUb29sdGlwXG4gICBjdXJzb3I6IEV4cGxWYWx1ZUN1cnNvci8qPFBhaXI8TnVtLCBOdW0+PiovXG4gICBlbGVtZW50OiBVXG4gICBwcm9wRm9jdXM6IGtleW9mIFQgfCBudWxsID0gbnVsbFxuXG4gICBjb25zdHJ1Y3RvciAoZWRpdG9yOiBQYW5lLlBhbmUsIEM6IENsYXNzPFQ+LCBjdXJzb3I6IEV4cGxWYWx1ZUN1cnNvci8qPFBhaXI8TnVtLCBOdW0+PiovLCBlbGVtZW50OiBVKSB7XG4gICAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgICAgdGhpcy5DID0gQ1xuICAgICAgdGhpcy50b29sdGlwID0gY3JlYXRlVG9vbHRpcChlbGVtZW50LCBlZGl0b3IudG9vbHRpcFBsYWNlbWVudClcbiAgICAgIHRoaXMuZWRpdG9yLnRvb2x0aXBzLmFkZCh0aGlzLnRvb2x0aXApXG4gICAgICB0aGlzLmN1cnNvciA9IGN1cnNvclxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxuICAgICAgY29uc3QgcDogVCA9IGFzKGN1cnNvci50di52LCBDKVxuICAgICAgY29uc3QgcHJvcHNGb2N1czogKGtleW9mIFQpW10gPSB0aGlzLmZvY3VzZWRQcm9wcyhjdXJzb3IudHYgYXMgRXhwbFZhbHVlPFQ+KVxuICAgICAgaWYgKHByb3BzRm9jdXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgdGhpcy50b29sdGlwLnNldENvbnRlbnQodGhpcy5wcm9wVmFsdWVzKHAsIHByb3BzRm9jdXMpKVxuICAgICAgICAgdGhpcy50b29sdGlwLnNob3coKVxuICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZm9jdXNcIilcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZTogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKVxuICAgICAgfSlcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIChlOiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICB0aGlzLm9uTW91c2VPdXQoZSlcbiAgICAgIH0pXG4gICB9XG5cbiAgIC8vIE5vbi1wcmltaXRpdmUgZGVwZW5kZW5jaWVzIHJlbmRlciBhcyBhIGJ1bGxldC5cbiAgIHByb3BWYWx1ZXMgKGc6IFQsIHByb3BzOiAoa2V5b2YgVClbXSk6IHN0cmluZyB7XG4gICAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBwcm9wcy5tYXAoKHByb3A6IGtleW9mIFQpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgY29uc3QgcHJvcFZhbDogUGVyc2lzdGVudCA9IGcuX19jaGlsZChwcm9wKVxuICAgICAgICAgY29uc3QgcHJvcFN0cjogc3RyaW5nID0gcHJvcFZhbCBpbnN0YW5jZW9mIE51bSA/IFxuICAgICAgICAgICAgICAgcm91bmQocHJvcFZhbC52YWwpIDpcbiAgICAgICAgICAgICAgIHByb3BWYWwgaW5zdGFuY2VvZiBTdHIgPyBcbiAgICAgICAgICAgICAgICAgIHByb3BWYWwudmFsIDogXCLigKJcIlxuICAgICAgICAgcmV0dXJuIGAke3Byb3B9OiAke3Byb3BTdHJ9YFxuICAgICAgfSlcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiPC9icj5cIilcbiAgIH1cblxuICAgZm9jdXNlZFByb3BzPFQgZXh0ZW5kcyBEYXRhVmFsdWU+ICh0djogRXhwbFZhbHVlPFQ+KTogKGtleW9mIFQpW10ge1xuICAgICAgcmV0dXJuIGZpZWxkcyh0di52KS5maWx0ZXIoKHByb3A6IGtleW9mIFQpID0+IHtcbiAgICAgICAgIGNvbnN0IHR2XzogRXhwbFZhbHVlID0gRXhwbC5leHBsQ2hpbGQodHYudCwgdHYudiwgcHJvcClcbiAgICAgICAgIHJldHVybiBfX25vbk51bGwodGhpcy5lZGl0b3IuZGlyZWN0aW9uKSA9PT0gRGlyZWN0aW9uLkZ3ZCA/IGJvb2xfLm5lZ2F0ZShpc86xKHR2XykpIDogaXPOsSh0dl8pXG4gICAgICB9KVxuICAgfVxuXG4gICBhYnN0cmFjdCBwcm9wRm9yICh4X3Byb3A6IG51bWJlciwgeV9wcm9wOiBudW1iZXIpOiBrZXlvZiBUXG5cbiAgIG9uTW91c2VNb3ZlIChlOiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICBjb25zdCB2OiBUID0gYXModGhpcy5jdXJzb3IudHYudiwgdGhpcy5DKVxuICAgICAgY29uc3QgcmVjdDogQ2xpZW50UmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgLy8gaW52ZXJ0IHNpZ24gb24geSBheGlzIGJlY2F1c2Ugb2YgZ2xvYmFsIGludmVyc2lvbiBmb3IgU1ZHIGdyYXBoaWNzXG4gICAgICBjb25zdCB4X3Byb3A6IG51bWJlciA9IE1hdGgubWF4KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgMCkgLyByZWN0LndpZHRoXG4gICAgICBjb25zdCB5X3Byb3A6IG51bWJlciA9IE1hdGgubWluKHJlY3QuYm90dG9tIC0gZS5jbGllbnRZLCByZWN0LmhlaWdodCkgLyByZWN0LmhlaWdodFxuICAgICAgY29uc3QgcHJvcEZvY3VzOiBrZXlvZiBUID0gdGhpcy5wcm9wRm9yKHhfcHJvcCwgeV9wcm9wKVxuICAgICAgaWYgKHRoaXMucHJvcEZvY3VzICE9PSBwcm9wRm9jdXMpIHtcbiAgICAgICAgIHRoaXMucHJvcEZvY3VzID0gcHJvcEZvY3VzXG4gICAgICAgICB0aGlzLmVkaXRvci5id2RTbGljZSgoKSA9PiB7XG4gICAgICAgICAgICBzZXTOsShib29sXy50b3AsIHRoaXMuY3Vyc29yLnRvKHRoaXMuQywgcHJvcEZvY3VzKS50dilcbiAgICAgICAgIH0pXG4gICAgICAgICB0aGlzLnRvb2x0aXAuc2V0Q29udGVudCh0aGlzLnByb3BWYWx1ZXModiwgW3Byb3BGb2N1c10pKVxuICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJmb2N1c1wiKVxuICAgICAgfVxuICAgfVxuXG4gICBvbk1vdXNlT3V0IChlOiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICB0aGlzLnByb3BGb2N1cyA9IG51bGxcbiAgICAgIHRoaXMuZWRpdG9yLmJ3ZFNsaWNlKCgpID0+IHt9KVxuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c1wiKVxuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9pbnRJbnRlcmFjdG9yIGV4dGVuZHMgSW50ZXJhY3RvcjxQb2ludCwgU1ZHRWxlbWVudD4ge1xuICAgY29uc3RydWN0b3IgKGVkaXRvcjogUGFuZS5QYW5lLCB0cDogRXhwbFZhbHVlQ3Vyc29yLyo8UG9pbnQ+Ki8sIG1hcmtlcjogU1ZHRWxlbWVudCkge1xuICAgICAgc3VwZXIoZWRpdG9yLCBQb2ludCwgdHAsIG1hcmtlcilcbiAgIH1cblxuICAgcHJvcEZvciAoeF9wcm9wOiBudW1iZXIsIHlfcHJvcDogbnVtYmVyKToga2V5b2YgUG9pbnQge1xuICAgICAgcmV0dXJuIFwieVwiXG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZWN0SW50ZXJhY3RvciBleHRlbmRzIEludGVyYWN0b3I8UmVjdCwgU1ZHUmVjdEVsZW1lbnQ+IHtcbiAgIGNvbnN0cnVjdG9yIChlZGl0b3I6IFBhbmUuUGFuZSwgdGc6IEV4cGxWYWx1ZUN1cnNvci8qPFJlY3Q+Ki8sIHI6IFNWR1JlY3RFbGVtZW50KSB7XG4gICAgICBzdXBlcihlZGl0b3IsIFJlY3QsIHRnLCByKVxuICAgfVxuXG4gICAvLyBEZXRlcm1pbmUgd2hpY2ggXCJkaWFnb25hbCBxdWFkcmFudFwiIG9mIHRoZSB1bml0IHNxdWFyZSBbMSwgMV0gY29udGFpbnMgW3gsIHldLCBhbmRcbiAgIC8vIHRoZW4gbWFwIHRvIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgcHJvcEZvciAoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBrZXlvZiBSZWN0IHtcbiAgICAgIGNvbnN0IGNvcm5lcjogW2tleW9mIFJlY3QsIGtleW9mIFJlY3RdID0geSA+IHggPyBbXCJ4XCIsIFwiaGVpZ2h0XCJdIDogW1wieVwiLCBcIndpZHRoXCJdXG4gICAgICByZXR1cm4geSA8IDEgLSB4ID8gY29ybmVyWzBdIDogY29ybmVyWzFdXG4gICB9XG59XG4iLCJpbXBvcnQgeyBJbnN0YW5jZSBhcyBUb29sdGlwLCBQbGFjZW1lbnQgfSBmcm9tIFwidGlwcHkuanNcIlxuaW1wb3J0IHsgX19ub25OdWxsLCBhcyB9IGZyb20gXCIuLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgRGlyZWN0aW9uLCBTbGljZSwgX19zbGljZSB9IGZyb20gXCIuLi9Bbm5vdGF0aW9uXCJcbmltcG9ydCB7IERhdGFWYWx1ZSwgRXhwbFZhbHVlLCBleHBsVmFsdWUgfSBmcm9tIFwiLi4vRGF0YVZhbHVlXCJcbmltcG9ydCB7IF9fZGVsdGFzIH0gZnJvbSBcIi4uL0RlbHRhXCJcbmltcG9ydCB7IEVudiB9IGZyb20gXCIuLi9FbnZcIlxuaW1wb3J0IHsgRXZhbCB9IGZyb20gXCIuLi9FdmFsXCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi4vRXhwbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4uL0V4cHJcIlxuaW1wb3J0IHsgQXJyb3doZWFkIH0gZnJvbSBcIi4uL0dyYXBoaWNzXCJcbmltcG9ydCB7IG5ld1JldmlzaW9uIH0gZnJvbSBcIi4uL1ZlcnNpb25lZFwiXG5pbXBvcnQgeyBFeHBsVmFsdWVDdXJzb3IgfSBmcm9tIFwiLi9DdXJzb3JcIlxuaW1wb3J0IHsgbWFya2VyRW5zdXJlRGVmaW5lZCwgc3ZnUm9vdEVsZW1lbnQgfSBmcm9tIFwiLi9SZW5kZXJlclwiXG5pbXBvcnQgeyBWaWV3IH0gZnJvbSBcIi4vVmlld1wiXG5pbXBvcnQgXCIuL3N0eWxlcy5jc3NcIlxuXG4vLyBQcmV2aW91c2x5IEVkaXRvciwgYnV0IGNsYXNoZXMgYSBiaXQgd2l0aCB0aGUgV3JhdHRsZXIgY2xhc3Mgb2YgdGhlIHNhbWUgbmFtZS5cbmV4cG9ydCBtb2R1bGUgUGFuZSB7XG4gICBleHBvcnQgZnVuY3Rpb24gaW5pdGlhbGlzZSAocmVzb3VyY2VTZXJ2ZXJVcmw6IHN0cmluZyk6IHZvaWQge1xuICAgICAgVmlldy5pbml0aWFsaXNlKHJlc291cmNlU2VydmVyVXJsKVxuICAgfVxuXG4gICBleHBvcnQgaW50ZXJmYWNlIExpc3RlbmVyIHtcbiAgICAgIG9uQndkU2xpY2UgKGVkaXRvcjogUGFuZSwgZXh0ZXJuRGVwczogU2xpY2UpOiB2b2lkXG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBQYW5lIHtcbiAgICAgIGxpc3RlbmVyOiBMaXN0ZW5lclxuICAgICAgcm9vdFBhbmU6IFNWR1NWR0VsZW1lbnRcbiAgICAgIHRvb2x0aXBzOiBTZXQ8VG9vbHRpcD5cbiAgICAgIHRvb2x0aXBQbGFjZW1lbnQ6IFBsYWNlbWVudCAvLyBtYWtlIGZvciBuaWNlciBleGFtcGxlc1xuICAgICAgz4FfZXh0ZXJuYWw6IEVudlxuICAgICAgz4FfaW1wb3J0czogRW52XG4gICAgICBlOiBFeHByXG4gICAgICB0djogRXhwbFZhbHVlXG4gICAgICBoZXJlITogRXhwbFZhbHVlQ3Vyc29yXG4gICAgICBkaXJlY3Rpb246IERpcmVjdGlvblxuICAgICAgc2xpY2U6IFNsaWNlID0gbmV3IFNldCgpXG5cbiAgICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgIGxpc3RlbmVyOiBMaXN0ZW5lcixcbiAgICAgICAgIGFwcFJvb3Q6IEhUTUxFbGVtZW50LFxuICAgICAgICAgW3dpZHRoLCBoZWlnaHRdOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgdG9vbHRpcFBsYWNlbWVudDogUGxhY2VtZW50LFxuICAgICAgICAgz4FfZXh0ZXJuYWw6IEVudixcbiAgICAgICAgIM+BX2ltcG9ydHM6IEVudixcbiAgICAgICAgIGU6IEV4cHJcbiAgICAgICkge1xuICAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyXG4gICAgICAgICB0aGlzLnJvb3RQYW5lID0gc3ZnUm9vdEVsZW1lbnQod2lkdGgsIGhlaWdodClcbiAgICAgICAgIHRoaXMudG9vbHRpcHMgPSBuZXcgU2V0KClcbiAgICAgICAgIHRoaXMudG9vbHRpcFBsYWNlbWVudCA9IHRvb2x0aXBQbGFjZW1lbnRcbiAgICAgICAgIG1hcmtlckVuc3VyZURlZmluZWQodGhpcy5yb290UGFuZSwgQXJyb3doZWFkLCBcImJsdWVcIilcbiAgICAgICAgIGFwcFJvb3QuYXBwZW5kQ2hpbGQodGhpcy5yb290UGFuZSlcbiAgICAgICAgIHRoaXMuz4FfZXh0ZXJuYWwgPSDPgV9leHRlcm5hbFxuICAgICAgICAgdGhpcy7PgV9pbXBvcnRzID0gz4FfaW1wb3J0c1xuICAgICAgICAgdGhpcy5lID0gZVxuICAgICAgICAgLy8gZXZhbHVhdGUgdHdpY2Ugc28gd2UgY2FuIHN0YXJ0IHdpdGggYW4gZW1wdHkgZGVsdGFcbiAgICAgICAgIHRoaXMudHYgPSBFdmFsLmV2YWxfKHRoaXMuz4EsIHRoaXMuZSlcbiAgICAgICAgIHRoaXMuaGVyZSA9IEV4cGxWYWx1ZUN1cnNvci5kZXNjZW5kYW50KG51bGwsIHRoaXMudHYpXG4gICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5Gd2RcbiAgICAgICAgIG5ld1JldmlzaW9uKClcbiAgICAgICAgIEV2YWwuZXZhbF8odGhpcy7PgSwgdGhpcy5lKSAvLyByZWVzdGFibGlzaCByZWFjaGFibGUgbm9kZXNcbiAgICAgIH1cblxuICAgICAgZ2V0IM+BICgpOiBFbnYge1xuICAgICAgICAgcmV0dXJuIHRoaXMuz4FfZXh0ZXJuYWwuY29uY2F0KHRoaXMuz4FfaW1wb3J0cylcbiAgICAgIH1cblxuICAgICAgdmlzaWJsZVRvb2x0aXBzICgpOiBUb29sdGlwW10ge1xuICAgICAgICAgcmV0dXJuIFsuLi50aGlzLnRvb2x0aXBzXS5maWx0ZXIodG9vbHRpcCA9PiB0b29sdGlwLnN0YXRlLmlzVmlzaWJsZSlcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbGlzZSAoKTogdm9pZCB7XG4gICAgICAgICB0aGlzLnJlbmRlcigpXG4gICAgICAgICBjb25zdCB0aGlzXzogdGhpcyA9IHRoaXNcbiAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1OTcwNjBcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ua2V5ZG93biA9IGZ1bmN0aW9uIChldjogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PSAzNykgeyAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgICB0aGlzXy5oZXJlID0gdGhpc18uaGVyZS5wcmV2U2libGluZygpXG4gICAgICAgICAgICAgICAgICB0aGlzXy5yZW5kZXIoKVxuICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PSAzOCkgeyAvLyB1cFxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfLmhlcmUuaGFzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNfLmhlcmUgPSB0aGlzXy5oZXJlLnVwKClcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNfLnJlbmRlcigpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgIGlmIChldi5rZXlDb2RlID09IDM5KSB7IC8vIHJpZ2h0XG4gICAgICAgICAgICAgICAgICB0aGlzXy5oZXJlID0gdGhpc18uaGVyZS5uZXh0U2libGluZygpXG4gICAgICAgICAgICAgICAgICB0aGlzXy5yZW5kZXIoKVxuICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PSA0MCkgeyAvLyBkb3duXG4gICAgICAgICAgICAgICAgICBpZiAodGhpc18uaGVyZS50di52IGluc3RhbmNlb2YgRGF0YVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICB0aGlzXy5oZXJlID0gdGhpc18uaGVyZS50b0NoaWxkKDApXG4gICAgICAgICAgICAgICAgICAgICB0aGlzXy5yZW5kZXIoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZG9jdW1lbnQub25rZXlwcmVzcyA9IGZ1bmN0aW9uIChldjogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICBpZiAoZXYua2V5ID09PSBcIlZcIikge1xuICAgICAgICAgICAgICAgICAgVmlldy5leGlzdGluZ1ZpZXcodGhpc18uaGVyZS50dikudG9nZ2xlVmFsdWUoKVxuICAgICAgICAgICAgICAgICAgdGhpc18ucmVuZGVyKClcbiAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gXCJFXCIpIHtcbiAgICAgICAgICAgICAgICAgIFZpZXcuZXhpc3RpbmdWaWV3KHRoaXNfLmhlcmUudHYpLnRvZ2dsZUV4cGwoKVxuICAgICAgICAgICAgICAgICAgdGhpc18ucmVuZGVyKClcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYndkU2xpY2UgKHNldE5lZWRlZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICAgX19zbGljZS5yZXNldChEaXJlY3Rpb24uQndkKVxuICAgICAgICAgc2V0TmVlZGVkKClcbiAgICAgICAgIEV2YWwuZXZhbF9id2QodGhpcy5lLCB0aGlzLnR2KVxuICAgICAgICAgX19zbGljZS5hbm4gPSBfX3NsaWNlLnJlc3RyaWN0VG8odGhpcy7PgV9leHRlcm5hbC52YWx1ZXMoKSlcbiAgICAgICAgIHRoaXMubGlzdGVuZXIub25Cd2RTbGljZSh0aGlzLCBfX3NsaWNlLmFubilcbiAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gRGlyZWN0aW9uLkJ3ZFxuICAgICAgICAgdGhpcy5zbGljZSA9IF9fc2xpY2UuYW5uXG4gICAgICB9XG5cbiAgICAgIC8vIEZvcndhcmQtc2xpY2Ugd2l0aCByZXNwZWN0IHRvIHN1cHBsaWVkIHNsaWNlIG9mIM+BX2V4dGVybmFsLlxuICAgICAgZndkU2xpY2UgKGV4dGVybkRlcHM6IFNsaWNlKTogdm9pZCB7XG4gICAgICAgICBfX3NsaWNlLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5Gd2RcbiAgICAgICAgIF9fc2xpY2UuYW5uID0gZXh0ZXJuRGVwc1xuICAgICAgICAgRXZhbC5ldmFsX2Z3ZCh0aGlzLmUsIHRoaXMudHYpXG4gICAgICAgICBfX3NsaWNlLmFubiA9IF9fc2xpY2UucmVzdHJpY3RUbyhbdGhpcy50dl0pXG4gICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5Gd2RcbiAgICAgICAgIHRoaXMuc2xpY2UgPSBfX3NsaWNlLmFublxuICAgICAgfVxuXG4gICAgICByZW5kZXIgKCk6IHZvaWQge1xuICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDgzMTA2NDNcbiAgICAgICAgIGNvbnN0IGNoaWxkcmVuOiBDaGlsZE5vZGVbXSA9IEFycmF5LmZyb20odGhpcy5yb290UGFuZS5jaGlsZE5vZGVzKVxuICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IENoaWxkTm9kZSk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBTVkdEZWZzRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgIHRoaXMucm9vdFBhbmUucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gICAgICAgICAgICB9XG4gICAgICAgICB9KVxuICAgICAgICAgdGhpcy50b29sdGlwcy5mb3JFYWNoKHRvb2x0aXAgPT4gdG9vbHRpcC5kZXN0cm95KCkpXG4gICAgICAgICB0aGlzLnRvb2x0aXBzLmNsZWFyKClcbiAgICAgICAgIFZpZXcucmVuZGVyKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIG9uRWRpdCAoKTogdm9pZCB7XG4gICAgICAgICB0aGlzLnR2ID0gRXZhbC5ldmFsXyh0aGlzLs+BLCB0aGlzLmUpXG4gICAgICAgICB0aGlzLmhlcmUgPSBFeHBsVmFsdWVDdXJzb3IuZGVzY2VuZGFudChudWxsLCBleHBsVmFsdWUoYXModGhpcy50di50LCBFeHBsLkRlZnMpLnQsIHRoaXMudHYudikpXG4gICAgICAgICAvLyBjdXJzb3IgbWF5IG5vIGxvbmdlciBiZSB2YWxpZCwgaG93IHRvIGRlYWwgd2l0aCB0aGF0P1xuICAgICAgICAgdGhpcy5yZW5kZXIoKVxuICAgICAgfVxuXG4gICAgICBvblZpZXdDaGFuZ2UgKCk6IHZvaWQge1xuICAgICAgICAgdGhpcy5yZW5kZXIoKVxuICAgICAgfVxuICAgfVxufVxuIiwiaW1wb3J0IHsgUGxhY2VtZW50IH0gZnJvbSBcInRpcHB5LmpzXCJcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgRGlyZWN0aW9uLCBTbGljZSwgX19zbGljZSB9IGZyb20gXCIuLi9Bbm5vdGF0aW9uXCJcbmltcG9ydCB7IEVudiB9IGZyb20gXCIuLi9FbnZcIlxuaW1wb3J0IHsgRXhwciB9IGZyb20gXCIuLi9FeHByXCJcbmltcG9ydCB7IFBhbmUgfSBmcm9tIFwiLi9QYW5lXCJcbmltcG9ydCB7IFZpZXcgfSBmcm9tIFwiLi9WaWV3XCJcblxuZXhwb3J0IGNsYXNzIFBhbmVDb29yZGluYXRvciBpbXBsZW1lbnRzIFBhbmUuTGlzdGVuZXIge1xuICAgYXBwUm9vdDogSFRNTEVsZW1lbnRcbiAgIM+BX2V4dGVybmFsOiBFbnZcbiAgIHBhbmVzOiBTZXQ8UGFuZS5QYW5lPiA9IG5ldyBTZXQoKVxuXG4gICBjb25zdHJ1Y3RvciAoYXBwUm9vdDogSFRNTEVsZW1lbnQsIM+BX2V4dGVybmFsOiBFbnYpIHtcbiAgICAgIHRoaXMuYXBwUm9vdCA9IGFwcFJvb3RcbiAgICAgIHRoaXMuz4FfZXh0ZXJuYWwgPSDPgV9leHRlcm5hbFxuICAgfVxuXG4gICBhZGRQYW5lICjPgTogRW52LCBlOiBFeHByLCB0b29sdGlwUGxhY2VtZW50OiBQbGFjZW1lbnQgPSBcInRvcFwiKTogUGFuZS5QYW5lIHtcbiAgICAgIGNvbnN0IHBhbmU6IFBhbmUuUGFuZSA9XG4gICAgICAgICBuZXcgUGFuZS5QYW5lKHRoaXMsIHRoaXMuYXBwUm9vdCwgVmlldy5kZWZhdWx0RGltcywgdG9vbHRpcFBsYWNlbWVudCwgdGhpcy7PgV9leHRlcm5hbCwgz4EsIGUpXG4gICAgICBwYW5lLmluaXRpYWxpc2UoKVxuICAgICAgdGhpcy5wYW5lcy5hZGQocGFuZSlcbiAgICAgIHJldHVybiBwYW5lXG4gICB9XG5cbiAgIHJlbW92ZVBhbmUgKHBhbmU6IFBhbmUuUGFuZSk6IHZvaWQge1xuICAgICAgYXNzZXJ0KHRoaXMucGFuZXMuaGFzKHBhbmUpKVxuICAgICAgdGhpcy5wYW5lcy5kZWxldGUocGFuZSlcbiAgIH1cblxuICAgb25Cd2RTbGljZSAoZWRpdG9yOiBQYW5lLlBhbmUsIGV4dGVybkRlcHM6IFNsaWNlKTogdm9pZCB7XG4gICAgICAvLyBjb25zaWRlciBhdmFpbGFiaWxpdHkgb2Ygz4FfZXh0ZXJuYWwgb25seTsgdHJlYXQgz4EgYW5kIGUgYXMgdW5saW1pdGVkIHJlc291cmNlc1xuICAgICAgWy4uLnRoaXMucGFuZXNdXG4gICAgICAgICAuZmlsdGVyKGVkaXRvcl8gPT4gZWRpdG9yXyAhPT0gZWRpdG9yKVxuICAgICAgICAgLmZvckVhY2goKGVkaXRvcl86IFBhbmUuUGFuZSk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgZWRpdG9yXy5md2RTbGljZShleHRlcm5EZXBzKVxuICAgICAgICAgICAgZWRpdG9yXy5yZW5kZXIoKSAvLyBUT0RPOiBqdXN0IHJlZG8gc2VsZWN0aW9uIHJlbmRlcmluZ1xuICAgICAgICAgfSlcbiAgICAgIF9fc2xpY2UucmVzZXQoRGlyZWN0aW9uLkZ3ZClcbiAgIH1cbn1cbiIsImltcG9ydCB7IENsYXNzLCBfX25vbk51bGwsIGFic3VyZCwgYXMsIGFzc2VydCwgY2xhc3NOYW1lIH0gZnJvbSBcIi4uL3V0aWwvQ29yZVwiXG5pbXBvcnQgeyBDaGFuZ2UsIE5ldywgUmVjbGFzc2lmeSB9IGZyb20gXCIuLi9EZWx0YVwiXG5pbXBvcnQgeyBzdHJpbmdzIH0gZnJvbSBcIi4uL0V4cHJcIlxuaW1wb3J0IHsgQXJyb3doZWFkLCBNYXJrZXIgfSBmcm9tIFwiLi4vR3JhcGhpY3NcIlxuaW1wb3J0IHsgVmFsdWUsIGlzUHJpbSB9IGZyb20gXCIuLi9WYWx1ZVwiXG5pbXBvcnQgeyB2ZXJzaW9uZWQgfSBmcm9tIFwiLi4vVmVyc2lvbmVkXCJcbmltcG9ydCB7IFNWRyB9IGZyb20gXCIuL0NvcmVcIlxuaW1wb3J0IFwiLi9zdHlsZXMuY3NzXCJcblxuLy8gTWF5YmUgdGhlcmUgYXJlIHNvbWUgYnVpbHQtaW4gdHlwZXMgZm9yIHRoaXMsIGJ1dCBkb24ndCBjYXJlIHlldFxudHlwZSBQb2ludCA9IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfVxudHlwZSBEaW1zID0gUG9pbnQgJiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH1cblxuZXhwb3J0IGNvbnN0IHN2ZzogU1ZHID0gbmV3IFNWRygpXG5jb25zdCBmb250U2l6ZTogbnVtYmVyID0gMThcbmNvbnN0IGNsYXNzZXM6IHN0cmluZyA9IFwiY29kZVwiXG4vLyBiaXphcnJlbHksIGlmIEkgZG8gdGhpcyBsYXRlciwgZm9udCBtZXRyaWNzIGFyZSBib3JrZWQ6XG5jb25zdCBsaW5lSGVpZ2h0ID0gc3ZnLnRleHRIZWlnaHQodGV4dEVsZW1lbnQoZm9udFNpemUsIGNsYXNzZXMsIFwibVwiKSkgLy8gcmVwcmVzZW50YXRpdmUgY2hhcmFjdGVyIFxuLy8gQVNDSUkgc3BhY2VzIHNlZW0gdG8gYmUgdHJpbW1lZDsgb25seSBVbmljb2RlIHNwYWNlIHRoYXQgc2VlbXMgdG8gcmVuZGVyIG1vbm9zcGFjZWQgaXMgdGhpczogXG5jb25zdCBzcGFjZV9jaGFyOiBzdHJpbmcgPSBcIlxcdTAwYTBcIlxuY29uc3Qgc2hhcGVSZW5kZXJpbmc6IHN0cmluZyA9IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCJcblxuLy8gUG9wdWxhdGUgZXhwbGljaXR5LCByYXRoZXIgdGhhbiB1c2luZyBhIG1lbW9pc2VkIGZ1bmN0aW9uLlxudHlwZSBEaW1lbnNpb25zID0geyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9XG5leHBvcnQgY29uc3QgX19kaW1lbnNpb25zOiBNYXA8U1ZHRWxlbWVudCwgRGltZW5zaW9ucz4gPSBuZXcgTWFwKClcblxuZXhwb3J0IGZ1bmN0aW9uIGFycm93ICjhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdFbGVtZW50IHtcbiAgIHJldHVybiBrZXl3b3JkKFwiYXJyb3dcIiwg4bqfX3N0eWxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9yZGVyICh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHN0cm9rZTogc3RyaW5nLCBkYXNoZWQ6IGJvb2xlYW4pOiBTVkdSZWN0RWxlbWVudCB7XG4gICBjb25zdCBiOiBTVkdSZWN0RWxlbWVudCA9IHJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3Ryb2tlLCBcIm5vbmVcIiwgYm9yZGVyKVxuICAgYi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIwLjVcIilcbiAgIGlmIChkYXNoZWQpIHtcbiAgICAgIGIuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjEsMVwiKVxuICAgfVxuICAgcmV0dXJuIGJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJvcmRlcl9jaGFuZ2VkIChnOiBTVkdTVkdFbGVtZW50KTogU1ZHU1ZHRWxlbWVudCB7XG4gICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfTogRGltZW5zaW9ucyA9IF9fbm9uTnVsbChfX2RpbWVuc2lvbnMuZ2V0KGcpKVxuICAgY29uc3QgYjogU1ZHUmVjdEVsZW1lbnQgPSBib3JkZXIoZy54LmJhc2VWYWwudmFsdWUsIGcueS5iYXNlVmFsLnZhbHVlLCB3aWR0aCwgaGVpZ2h0LCBcImJsdWVcIiwgdHJ1ZSlcbiAgIGcuYXBwZW5kQ2hpbGQoYilcbiAgIHJldHVybiBnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRCb3JkZXJfZm9jdXMgKGc6IFNWR1NWR0VsZW1lbnQpOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19ub25OdWxsKF9fZGltZW5zaW9ucy5nZXQoZykpXG4gICBjb25zdCBiOiBTVkdSZWN0RWxlbWVudCA9IGJvcmRlcihnLnguYmFzZVZhbC52YWx1ZSwgZy55LmJhc2VWYWwudmFsdWUsIHdpZHRoLCBoZWlnaHQsIFwiZ3JheVwiLCBmYWxzZSlcbiAgIGcuYXBwZW5kQ2hpbGQoYilcbiAgIHJldHVybiBnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFja2V0IChnczogU1ZHRWxlbWVudFtdLCDhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdTVkdFbGVtZW50IHtcbiAgIHJldHVybiBob3JpeihrZXl3b3JkKFwiYnJhY2tldExcIiwg4bqfX3N0eWxlKSwgLi4uZ3MsIGtleXdvcmQoXCJicmFja2V0UlwiLCDhup9fc3R5bGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2VudHJlRG90ICjhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdFbGVtZW50IHtcbiAgIHJldHVybiB0ZXh0KFwi4oCiXCIsIOG6n19zdHlsZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1hICjhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdFbGVtZW50IHtcbiAgIHJldHVybiBrZXl3b3JkKFwiY29tbWFcIiwg4bqfX3N0eWxlKVxufVxuXG4vLyBXaGV0aGVyIHRoZSBjZW50cmUgb2YgcjEgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIGNlbnRyZSBvZiByMi5cbmZ1bmN0aW9uIGxlZnRPZiAocjE6IERpbXMsIHIyOiBEaW1zKTogYm9vbGVhbiB7XG4gICByZXR1cm4gcjEueCArIHIxLndpZHRoIC8gMiA8PSByMi54ICsgcjIud2lkdGhcbn1cblxuLy8gVE9ETzogcmVtZW1iZXIgd2hhdCB0aGlzIGlzIGZvci5cbmZ1bmN0aW9uIGJsYWggKHg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHByb3BvcnRpb246IG51bWJlcik6ICBudW1iZXIge1xuICAgcmV0dXJuIHggKyBwcm9wb3J0aW9uICogbGVuZ3RoXG59XG5cbi8vIE9mZnNldCBtaWdodCBiZSBiZXR0ZXIgY29tcHV0ZWQgYXMgYSBmdW5jdGlvbiBvZiBkaXN0YW5jZSBiZXR3ZWVuIHAxIGFuZCBwMi5cbmZ1bmN0aW9uIGN1cnZlZExpbmUgKHAxOiBQb2ludCwgcDI6IFBvaW50LCBvZmZzZXQ6IG51bWJlcik6IHN0cmluZyB7XG4gICBjb25zdCBtcDogUG9pbnQgPSB7IHg6IChwMi54ICsgcDEueCkgKiAwLjUsIHk6IChwMi55ICsgcDEueSkgKiAwLjUgfVxuICAgLy8gYW5nbGUgb2YgcGVycGVuZGljdWxhciB0byBsaW5lXG4gICBjb25zdCB0aGV0YSA9IE1hdGguYXRhbjIocDIueSAtIHAxLnksIHAyLnggLSBwMS54KSAtIE1hdGguUEkgLyAyXG4gICBjb25zdCBjb250cm9sOiBQb2ludCA9IHsgeDogbXAueCArIG9mZnNldCAqIE1hdGguY29zKHRoZXRhKSwgeTogbXAueSArIG9mZnNldCAqIE1hdGguc2luKHRoZXRhKSB9XG4gICByZXR1cm4gYE0gJHtwMS54fSAke3AxLnl9IFEgJHtjb250cm9sLnh9ICR7Y29udHJvbC55fSAke3AyLnh9ICR7cDIueX1gXG59XG5cbi8vIEZhY3RvciBhbGwgZWxlbWVudCBjcmVhdGlvbiB0aHJvdWdoIHRoaXMgc28gd2UgY2FuIHRhZyB3aXRoIGV4dHJhIG1ldGFkYXRhLlxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudDxLIGV4dGVuZHMga2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXA+KG5hbWU6IEssIGNyZWF0ZWRCeTogRnVuY3Rpb24pOiBTVkdFbGVtZW50VGFnTmFtZU1hcFtLXSB7XG4gICBjb25zdCBlOiBTVkdFbGVtZW50VGFnTmFtZU1hcFtLXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcuTlMsIG5hbWUpXG4gICBlLnNldEF0dHJpYnV0ZShcImRhdGEtY3JlYXRlZC1ieVwiLCBjcmVhdGVkQnkubmFtZSlcbiAgIHJldHVybiBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25uZWN0b3IgKGcxOiBTVkdTVkdFbGVtZW50LCBnMjogU1ZHU1ZHRWxlbWVudCk6IFNWR0VsZW1lbnQge1xuICAgY29uc3QgZzFfOiBEaW1zID0gZGltcyhnMSlcbiAgIGNvbnN0IGcyXzogRGltcyA9IGRpbXMoZzIpXG4gICBjb25zdCBbZnJvbUJvdHRvbSwgZnJvbVRvcF06IFtudW1iZXIsIG51bWJlcl0gPSBbMC4xLCAwLjldXG4gICBjb25zdCBjb25uZWN0b3JfOiBTVkdQYXRoRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIGNvbm5lY3RvcilcbiAgIGNvbnN0IGN1cnZlT2Zmc2V0OiBudW1iZXIgPSA1IC8vIHNvbWV3aGF0IGFyYml0cmFyeVxuICAgaWYgKGxlZnRPZihnMV8sIGcyXykpIHtcbiAgICAgIGNvbm5lY3Rvcl8uc2V0QXR0cmlidXRlKFwiZFwiLCBcbiAgICAgICAgIGN1cnZlZExpbmUoXG4gICAgICAgICAgICB7IHg6IGcxXy54ICsgZzFfLndpZHRoLCB5OiBibGFoKGcxXy55LCBnMV8uaGVpZ2h0LCBmcm9tQm90dG9tKSB9LFxuICAgICAgICAgICAgeyB4OiBnMl8ueCwgeTogYmxhaChnMl8ueSwgZzJfLmhlaWdodCwgZnJvbUJvdHRvbSkgfSxcbiAgICAgICAgICAgIGN1cnZlT2Zmc2V0XG4gICAgICAgICApXG4gICAgICApXG4gICB9IGVsc2Uge1xuICAgICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJkXCIsIFxuICAgICAgICAgY3VydmVkTGluZShcbiAgICAgICAgICAgIHsgeDogZzFfLngsIHk6IGJsYWgoZzFfLnksIGcxXy5oZWlnaHQsIGZyb21Ub3ApIH0sXG4gICAgICAgICAgICB7IHg6IGcyXy54ICsgZzJfLndpZHRoLCB5OiBibGFoKGcyXy55LCBnMl8uaGVpZ2h0LCBmcm9tVG9wKSB9LFxuICAgICAgICAgICAgY3VydmVPZmZzZXRcbiAgICAgICAgIClcbiAgICAgIClcbiAgIH1cbiAgIGNvbm5lY3Rvcl8uc2V0QXR0cmlidXRlKFwic2hhcGUtcmVuZGVyaW5nXCIsIHNoYXBlUmVuZGVyaW5nKVxuICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJibHVlXCIpIC8vIGhhcmRjb2RlZFxuICAgY29ubmVjdG9yXy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpXG4gICBjb25uZWN0b3JfLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCIxLDFcIilcbiAgIGNvbm5lY3Rvcl8uc2V0QXR0cmlidXRlKFwibWFya2VyLWVuZFwiLCBcInVybCgjQXJyb3doZWFkLWJsdWUpXCIpIC8vIGV4dHJhY3QgdG8gaGVscGVyIGZ1bmN0aW9uXG4gICByZXR1cm4gY29ubmVjdG9yX1xufVxuXG4vLyBDb3VsZG4ndCBnZXQgZ2V0U2NyZWVuQ1RNIG9yIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byB3b3JrIHByb3Blcmx5IChwZXJoYXBzIGJlY2F1c2Ugb2YgbmVzdGVkIFNWR3M/KSBzbyBqdXN0IHVzZSB0aGlzIHRvIGNvbXB1dGUgXG4vLyBjb29yZGluYXRlcyBvZiBnIHJlbGF0aXZlIHRvIHJvb3QgU1ZHLlxuZnVuY3Rpb24gY29vcmRpbmF0ZXMgKGc6IFNWR1NWR0VsZW1lbnQpOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0ge1xuICAgaWYgKGcgaW5zdGFuY2VvZiBTVkdTVkdFbGVtZW50KSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IGcucGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIFNWR1NWR0VsZW1lbnQgPyBjb29yZGluYXRlcyhnLnBhcmVudEVsZW1lbnQpOiB7IHg6IDAsIHk6IDB9XG4gICAgICByZXR1cm4geyB4OiB4ICsgZy54LmJhc2VWYWwudmFsdWUsIHk6IHkgKyBnLnkuYmFzZVZhbC52YWx1ZSB9XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9XG4gICB9XG59IFxuXG5leHBvcnQgZnVuY3Rpb24gZGVsaW1pdCAoZGVsaW1pdGVyOiAoKSA9PiBTVkdFbGVtZW50LCAuLi5nczogU1ZHRWxlbWVudFtdKTogU1ZHRWxlbWVudFtdIHtcbiAgIGNvbnN0IGdzyrk6IFNWR0VsZW1lbnRbXSA9IFtdXG4gICBncy5mb3JFYWNoKChnOiBTVkdFbGVtZW50LCBuOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgIGdzyrkucHVzaChnKVxuICAgICAgaWYgKG4gPCBncy5sZW5ndGggLSAxKSB7XG4gICAgICAgICBnc8q5LnB1c2goZGVsaW1pdGVyKCkpXG4gICAgICB9XG4gICB9KVxuICAgcmV0dXJuIGdzyrlcbn1cblxuZnVuY3Rpb24gZGltcyAoZzogU1ZHU1ZHRWxlbWVudCk6IERpbXMge1xuICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH06IERpbWVuc2lvbnMgPSBfX25vbk51bGwoX19kaW1lbnNpb25zLmdldChnKSlcbiAgIGNvbnN0IHsgeCwgeSB9ID0gY29vcmRpbmF0ZXMoZylcbiAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZV9sZWZ0IChnOiBTVkdTVkdFbGVtZW50KTogU1ZHU1ZHRWxlbWVudCB7XG4gICBjb25zdCB7IGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19kaW1lbnNpb25zLmdldChnKSFcbiAgIGNvbnN0IGVkZ2U6IFNWR0xpbmVFbGVtZW50ID0gbGluZShcbiAgICAgIGcueC5iYXNlVmFsLnZhbHVlLCBcbiAgICAgIGcueS5iYXNlVmFsLnZhbHVlLCBcbiAgICAgIGcueC5iYXNlVmFsLnZhbHVlLCBcbiAgICAgIGcueS5iYXNlVmFsLnZhbHVlICsgaGVpZ2h0LCBcbiAgICAgIFwiZ3JheVwiLFxuICAgICAgMVxuICAgKVxuICAgZWRnZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCI0XCIpXG4vLyAgIGVkZ2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjIsMlwiKVxuICAgZy5hcHBlbmRDaGlsZChlZGdlKVxuICAgcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VfYm90dG9tIChnOiBTVkdTVkdFbGVtZW50KTogU1ZHU1ZHRWxlbWVudCB7XG4gICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfTogRGltZW5zaW9ucyA9IF9fZGltZW5zaW9ucy5nZXQoZykhXG4gICBjb25zdCBlZGdlOiBTVkdMaW5lRWxlbWVudCA9IGxpbmUoXG4gICAgICBnLnguYmFzZVZhbC52YWx1ZSwgXG4gICAgICBnLnkuYmFzZVZhbC52YWx1ZSArIGhlaWdodCwgXG4gICAgICBnLnkuYmFzZVZhbC52YWx1ZSArIHdpZHRoLCBcbiAgICAgIGcueS5iYXNlVmFsLnZhbHVlICsgaGVpZ2h0LCBcbiAgICAgIFwiZ3JheVwiLFxuICAgICAgMVxuICAgKVxuICAgZWRnZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIyXCIpXG4vLyAgIGVkZ2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjIsMlwiKVxuICAgZy5hcHBlbmRDaGlsZChlZGdlKVxuICAgcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2lzICjhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdFbGVtZW50IHtcbiAgIHJldHVybiB0ZXh0KFwi4oCmXCIsIOG6n19zdHlsZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwICgpOiBTVkdHRWxlbWVudCB7XG4gICByZXR1cm4gY3JlYXRlRWxlbWVudChcImdcIiwgZ3JvdXApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob3JpeiAoLi4uZ3M6IFNWR0VsZW1lbnRbXSk6IFNWR1NWR0VsZW1lbnQge1xuICAgY29uc3QgZzogU1ZHU1ZHRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgaG9yaXopXG4gICBsZXQgd2lkdGhfc3VtOiBudW1iZXIgPSAwLFxuICAgICAgIGhlaWdodF9tYXg6IG51bWJlciA9IDBcbiAgIGdzLmZvckVhY2goKGfKuTogU1ZHRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgZ8q5LnNldEF0dHJpYnV0ZShcInhcIiwgYCR7d2lkdGhfc3VtfWApXG4gICAgICBnyrkuc2V0QXR0cmlidXRlKFwieVwiLCBgMGApXG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfTogRGltZW5zaW9ucyA9IF9fZGltZW5zaW9ucy5nZXQoZ8q5KSFcbiAgICAgIHdpZHRoX3N1bSArPSB3aWR0aFxuICAgICAgaGVpZ2h0X21heCA9IE1hdGgubWF4KGhlaWdodF9tYXgsIGhlaWdodClcbiAgICAgIGcuYXBwZW5kQ2hpbGQoZ8q5KVxuICAgfSlcbiAgIF9fZGltZW5zaW9ucy5zZXQoZywgeyB3aWR0aDogd2lkdGhfc3VtLCBoZWlnaHQ6IGhlaWdodF9tYXggfSlcbiAgIHJldHVybiBnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob3JpelNwYWNlICguLi5nczogU1ZHRWxlbWVudFtdKTogU1ZHU1ZHRWxlbWVudCB7XG4gICByZXR1cm4gaG9yaXooLi4uZGVsaW1pdChzcGFjZSwgLi4uZ3MpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5d29yZCAoc3RyOiBrZXlvZiB0eXBlb2Ygc3RyaW5ncywg4bqfX3N0eWxlOiBEZWx0YVN0eWxlKTogU1ZHRWxlbWVudCB7XG4gICByZXR1cm4gdGV4dChzdHJpbmdzW3N0cl0sIOG6n19zdHlsZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmUgKHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIsIHN0cm9rZTogc3RyaW5nLCBzdHJva2VXaWR0aDogbnVtYmVyKTogU1ZHTGluZUVsZW1lbnQge1xuICAgY29uc3QgbDogU1ZHTGluZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwibGluZVwiLCBsaW5lKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgc2hhcGVSZW5kZXJpbmcpXG4gICBsLnNldEF0dHJpYnV0ZShcIngxXCIsIGAke3JvdW5kKHgxKX1gKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBgJHtyb3VuZCh5MSl9YClcbiAgIGwuc2V0QXR0cmlidXRlKFwieDJcIiwgYCR7cm91bmQoeDIpfWApXG4gICBsLnNldEF0dHJpYnV0ZShcInkyXCIsIGAke3JvdW5kKHkyKX1gKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgc3Ryb2tlKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYCR7cm91bmQoc3Ryb2tlV2lkdGgpfWApXG4gICByZXR1cm4gbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZVJvdW5kZWQgKHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIsIHN0cm9rZTogc3RyaW5nLCBzdHJva2VXaWR0aDogbnVtYmVyKTogU1ZHTGluZUVsZW1lbnQge1xuICAgY29uc3QgbDogU1ZHTGluZUVsZW1lbnQgPSBsaW5lKHgxLCB5MSwgeDIsIHkyLCBzdHJva2UsIHN0cm9rZVdpZHRoKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpXG4gICByZXR1cm4gbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyIChDOiBDbGFzczxNYXJrZXI+LCBjb2xvdXI6IHN0cmluZyk6IFNWR01hcmtlckVsZW1lbnQge1xuICAgY29uc3QgbTogU1ZHTWFya2VyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJtYXJrZXJcIiwgbWFya2VyKVxuICAgbS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBtYXJrZXJJZChDLCBjb2xvdXIpKVxuICAgbS5zZXRBdHRyaWJ1dGUoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICBtLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgY29sb3VyKVxuICAgbS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgY29sb3VyKVxuICAgcmV0dXJuIG1cbn1cblxuZnVuY3Rpb24gbWFya2VySWQgKEM6IENsYXNzPE1hcmtlcj4sIGNvbG91cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgIHJldHVybiBgJHtDLm5hbWV9LSR7Y29sb3VyfWBcbn1cblxuZXhwb3J0IHR5cGUgTWFya2VyRmFjdG9yeSA9IChjb2xvdXI6IHN0cmluZykgPT4gU1ZHTWFya2VyRWxlbWVudFxuXG5sZXQgbWFya2VyRmFjdG9yeTogTWFwPHN0cmluZywgTWFya2VyRmFjdG9yeT5cblxue1xuICAgbWFya2VyRmFjdG9yeSA9IG5ldyBNYXAoKVxuICAgbWFya2VyRmFjdG9yeS5zZXQoQXJyb3doZWFkLm5hbWUsIG1hcmtlcl9hcnJvd2hlYWQpXG59XG5cbi8vIEFzc3VtZSByb290IGhhcyBhIHVuaXF1ZSBkZWZzIGVsZW1lbnQgY2FsbGVkIFwiZGVmc1wiLiBSZXR1cm4gY29tcG9zaXRlIG1hcmtlciBpZC5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXJFbnN1cmVEZWZpbmVkIChyb290OiBTVkdTVkdFbGVtZW50LCBDOiBDbGFzczxNYXJrZXI+LCBjb2xvdXI6IHN0cmluZyk6IHN0cmluZyB7XG4gICBjb25zdCBpZDogc3RyaW5nID0gbWFya2VySWQoQywgY29sb3VyKVxuICAgbGV0IG1hcmtlcjogRWxlbWVudCB8IG51bGwgPSByb290LmdldEVsZW1lbnRCeUlkKGlkKVxuICAgaWYgKG1hcmtlciA9PT0gbnVsbCkge1xuICAgICAgbWFya2VyID0gX19ub25OdWxsKG1hcmtlckZhY3RvcnkuZ2V0KEMubmFtZSkpKGNvbG91cilcbiAgICAgIGNvbnN0IGRlZnM6IFNWR0RlZnNFbGVtZW50ID0gYXMocm9vdC5nZXRFbGVtZW50QnlJZChcImRlZnNcIiksIFNWR0RlZnNFbGVtZW50KVxuICAgICAgZGVmcy5hcHBlbmRDaGlsZChtYXJrZXIpXG4gICAgICBhc3NlcnQocm9vdC5nZXRFbGVtZW50QnlJZChpZCkgPT09IG1hcmtlcilcbiAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobWFya2VyIGluc3RhbmNlb2YgU1ZHTWFya2VyRWxlbWVudClcbiAgIH1cbiAgIHJldHVybiBpZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyX2Fycm93aGVhZCAoY29sb3VyOiBzdHJpbmcpOiBTVkdNYXJrZXJFbGVtZW50IHtcbiAgIGNvbnN0IG06IFNWR01hcmtlckVsZW1lbnQgPSBtYXJrZXIoQXJyb3doZWFkLCBjb2xvdXIpXG4gICBjb25zdCBsZW5ndGg6IG51bWJlciA9IDYsXG4gICAgICAgICB3aWR0aDogbnVtYmVyID0gNFxuICAgbS5zZXRBdHRyaWJ1dGUoXCJyZWZYXCIsIGAke2xlbmd0aH1gKVxuICAgbS5zZXRBdHRyaWJ1dGUoXCJyZWZZXCIsIGAke3dpZHRoIC8gMn1gKVxuICAgbS5zZXRBdHRyaWJ1dGUoXCJtYXJrZXJXaWR0aFwiLCBcIjE2XCIpXG4gICBtLnNldEF0dHJpYnV0ZShcIm1hcmtlckhlaWdodFwiLCBcIjE2XCIpXG4gICBjb25zdCBwYXRoOiBTVkdQYXRoRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIG1hcmtlcl9hcnJvd2hlYWQpXG4gICBtLmFwcGVuZENoaWxkKHBhdGgpXG4gICBwYXRoLnNldEF0dHJpYnV0ZShcInNoYXBlLXJlbmRlcmluZ1wiLCBzaGFwZVJlbmRlcmluZylcbiAgIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBgTSAke2xlbmd0aH0gJHt3aWR0aCAvIDJ9IEwgMCAke3dpZHRofSBMIDAgMCBaYClcbiAgIHJldHVybiBtXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUgKHg6IG51bWJlciwgeTogbnVtYmVyLCByYWRpdXM6IG51bWJlciwgc3Ryb2tlOiBzdHJpbmcsIGZpbGw6IHN0cmluZywgY3JlYXRlZEJ5OiBGdW5jdGlvbik6IFNWR0NpcmNsZUVsZW1lbnQge1xuICAgY29uc3QgcjogU1ZHQ2lyY2xlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgY3JlYXRlZEJ5KVxuICAgci5zZXRBdHRyaWJ1dGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgc2hhcGVSZW5kZXJpbmcpXG4gICByLnNldEF0dHJpYnV0ZShcImN4XCIsIGAke3JvdW5kKHgpfWApXG4gICByLnNldEF0dHJpYnV0ZShcImN5XCIsIGAke3JvdW5kKHkpfWApXG4gICByLnNldEF0dHJpYnV0ZShcInJcIiwgYCR7cm91bmQocmFkaXVzKX1gKVxuICAgci5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgc3Ryb2tlKVxuICAgci5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGZpbGwpXG4gICByZXR1cm4gclxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50aGVzaXNlIChnOiBTVkdFbGVtZW50LCDhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdTVkdFbGVtZW50IHtcbiAgIHJldHVybiBob3JpeihrZXl3b3JkKFwicGFyZW5MXCIsIOG6n19zdHlsZSksIGcsIGtleXdvcmQoXCJwYXJlblJcIiwg4bqfX3N0eWxlKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmVudGhlc2lzZUlmIChwYXJlbnM6IGJvb2xlYW4sIGc6IFNWR1NWR0VsZW1lbnQsIOG6n19zdHlsZTogRGVsdGFTdHlsZSk6IFNWR1NWR0VsZW1lbnQge1xuICAgcmV0dXJuIHBhcmVucyA/IHBhcmVudGhlc2lzZShnLCDhup9fc3R5bGUpIDogZ1xufVxuXG4vLyBUT0RPOiB1c2UgUG9pbnQgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmU/XG5mdW5jdGlvbiBwb2ludHNUb1N0cmluZyAocMyFOiBbbnVtYmVyLCBudW1iZXJdW10pOiBzdHJpbmcge1xuICAgcmV0dXJuIHDMhS5tYXAoKFt4LCB5XTogW251bWJlciwgbnVtYmVyXSkgPT4gYCR7cm91bmQoeCl9LCR7cm91bmQoeSl9YCkuam9pbihcIiBcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lIChwzIU6IFtudW1iZXIsIG51bWJlcl1bXSwgc3Ryb2tlOiBzdHJpbmcsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiBTVkdQb2x5bGluZUVsZW1lbnQge1xuICAgY29uc3QgbDogU1ZHUG9seWxpbmVFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHBvbHlsaW5lKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgc2hhcGVSZW5kZXJpbmcpXG4gICBsLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHNUb1N0cmluZyhwzIUpKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgc3Ryb2tlKVxuICAgbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYCR7cm91bmQoc3Ryb2tlV2lkdGgpfWApXG4gICBsLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIilcbiAgIGwuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgIHJldHVybiBsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0ICh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHN0cm9rZTogc3RyaW5nLCBmaWxsOiBzdHJpbmcsIGNyZWF0ZWRCeTogRnVuY3Rpb24pOiBTVkdSZWN0RWxlbWVudCB7XG4gICBjb25zdCByOiBTVkdSZWN0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIGNyZWF0ZWRCeSlcbiAgIHIuc2V0QXR0cmlidXRlKFwic2hhcGUtcmVuZGVyaW5nXCIsIHNoYXBlUmVuZGVyaW5nKVxuICAgci5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGAke3JvdW5kKHgpfWApXG4gICByLnNldEF0dHJpYnV0ZShcInlcIiwgYCR7cm91bmQoeSl9YClcbiAgIHIuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7cm91bmQod2lkdGgpfWApXG4gICByLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtyb3VuZChoZWlnaHQpfWApXG4gICByLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBzdHJva2UpXG4gICByLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgZmlsbClcbiAgIHJldHVybiByXG59XG5cbi8vIFJvdW5kaW5nIHRvIHBpeGVsIGJvdW5kYXJpZXMgKGFsdGhvdWdoIG9mdGVuIGRlc2lyYWJsZSBmb3IgU1ZHLCBlLmcuIHRvIGdldCBzaGFycCBsaW5lcykgZG9lc24ndCB3b3JrIHdlbGwgXG4vLyBmb3Igc21hbGwgc2hhcGVzLCBidXQgd2UgZG9uJ3QgbmVlZCB0byBtYWludGFpbiB0aGUgZnVsbCBtb25zdHJvc2l0eSB0aGF0IGFyZSBmbG9hdGluZy1wb2ludCBudW1iZXJzLiBSb3VuZCBcbi8vIHRvIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcywgY2FzdCB0byBudW1iZXIgdG8gc3RyaXAgdHJhaWxpbmcgemVyb3MsIGFuZCB0aGVuIGNhc3QgYmFjayB0byBzdHJpbmcuXG4vLyBUaGlzIHNlZW1zIHRvIGJlIHN1ZmZpY2llbnQgcHJlY2lzaW9uIGZvciBTVkcgYnV0IGlzIGFsc28gaHVtYW4tZnJpZW5kbHkuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQgKG46IG51bWJlcik6IHN0cmluZyB7XG4gICByZXR1cm4gKCtuLnRvRml4ZWQoMykpLnRvU3RyaW5nKClcbn1cblxuLy8gTmVlZHMgdG8gYmUgYXQgdGhlIGJvdHRvbSBpbiB0aGUgei1vcmRlciwgYW5kIG9wYXF1ZS5cbmV4cG9ydCBmdW5jdGlvbiBzaGFkaW5nIChnOiBTVkdTVkdFbGVtZW50LCBmaWxsOiBzdHJpbmcpOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHN2ZzogU1ZHU1ZHRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgc2hhZGluZylcbiAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19kaW1lbnNpb25zLmdldChnKSFcbiAgIGNvbnN0IGJhY2tncm91bmQ6IFNWR1JlY3RFbGVtZW50ID0gcmVjdChnLnguYmFzZVZhbC52YWx1ZSwgZy55LmJhc2VWYWwudmFsdWUsIHdpZHRoLCBoZWlnaHQsIFwibm9uZVwiLCBmaWxsLCBzaGFkaW5nKVxuICAgYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcbiAgIHN2Zy5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kKVxuICAgc3ZnLmFwcGVuZENoaWxkKGcpXG4gICBfX2RpbWVuc2lvbnMuc2V0KHN2ZywgeyB3aWR0aCwgaGVpZ2h0IH0pXG4gICByZXR1cm4gc3ZnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGFjZSAoKTogU1ZHRWxlbWVudCB7XG4gICByZXR1cm4gdGV4dChgJHtzcGFjZV9jaGFyfWAsIERlbHRhU3R5bGUuVW5jaGFuZ2VkKVxufVxuXG4vLyBDb250ZW50IGJlbG93IG9yIHRvIHRoZSBsZWZ0IGlzIGNsaXBwZWQgYXV0b21hdGljYWxseTsgY29udGVudCB0byBhYm92ZSBvciB0byB0aGUgcmlnaHQgaXMgY2xpcHBlZCBcbi8vIGlmIHdlIHNldCB3aWR0aCBhbmQgaGVpZ2h0LlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0VsZW1lbnQgKG92ZXJmbG93OiBib29sZWFuLCB4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGRlZnM6IGJvb2xlYW4sIGNyZWF0ZWRCeTogRnVuY3Rpb24pOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHN2ZzogU1ZHU1ZHRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgY3JlYXRlZEJ5KVxuICAgc3ZnLnNldEF0dHJpYnV0ZShcInhcIiwgYCR7cm91bmQoeCl9YClcbiAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGAke3JvdW5kKHkpfWApXG4gICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7cm91bmQod2lkdGgpfWApXG4gICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGAke3JvdW5kKGhlaWdodCl9YClcbiAgIC8vIHVzZSBpbmxpbmUgc3R5bGUgcmF0aGVyIHRoYW4gYW4gYXR0cmlidXRlLCBvdGhlcndpc2UgYW55IGFjdGl2ZSBzdHlsaW5nIHdpbGwgb3ZlcnJpZGVcbiAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgb3ZlcmZsb3c6ICR7b3ZlcmZsb3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCJ9YClcbiAgIGlmIChkZWZzKSB7XG4gICAgICBjb25zdCBkOiBTVkdEZWZzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIGNyZWF0ZWRCeSlcbiAgICAgIGQuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJkZWZzXCIpXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoZClcbiAgIH1cbiAgIHJldHVybiBzdmdcbn1cblxuLy8gQ2hyb21lIGRvZXNuJ3QgYXBwZWFyIHRvIGZ1bGx5IHN1cHBvcnQgU1ZHIDIuMCB5ZXQ7IGluIHBhcnRpY3VsYXIsIHRyYW5zZm9ybSBhdHRyaWJ1dGVzIG9uIHN2ZyBlbGVtZW50cyBhcmUgXG4vLyBpZ25vcmVkIChleGNlcHQgYXQgdGhlIHJvb3QpLiBUbyBpbnZlcnQgdGhlIHktYXhpcywgd2UgaGF2ZSB0byBhZGQgYSBuZXN0ZWQgZyBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybS5cbmV4cG9ydCBmdW5jdGlvbiBzdmdFbGVtZW50X2ludmVydGVkICh3OiBudW1iZXIsIGg6IG51bWJlcik6IFtTVkdTVkdFbGVtZW50LCBTVkdHRWxlbWVudF0ge1xuICAgY29uc3Qgc3ZnOiBTVkdTVkdFbGVtZW50ID0gc3ZnRWxlbWVudChmYWxzZSwgMCwgMCwgdywgaCwgdHJ1ZSwgc3ZnRWxlbWVudF9pbnZlcnRlZClcbiAgIGNvbnN0IGc6IFNWR0dFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImdcIiwgc3ZnRWxlbWVudF9pbnZlcnRlZClcbiAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIGBzY2FsZSgxLC0xKSB0cmFuc2xhdGUoMCwkey1ofSlgKVxuICAgZy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3fWApXG4gICBnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtofWApXG4gICBzdmcuYXBwZW5kQ2hpbGQoZylcbiAgIHJldHVybiBbc3ZnLCBnXVxufVxuXG4vLyBUb3AtbGV2ZWwgU1ZHIG5vZGUgd2l0aCBhIFwiZGVmc1wiIGVsZW1lbnQgd2l0aCBpZCBcImRlZnNcIi5cbmV4cG9ydCBmdW5jdGlvbiBzdmdSb290RWxlbWVudCAodzogbnVtYmVyLCBoOiBudW1iZXIpOiBTVkdTVkdFbGVtZW50IHtcbiAgIGNvbnN0IHN2ZzogU1ZHU1ZHRWxlbWVudCA9IHN2Z0VsZW1lbnQoZmFsc2UsIDAsIDAsIHcsIGgsIHRydWUsIHN2Z1Jvb3RFbGVtZW50KVxuICAgLy8gU2VlIGh0dHBzOi8vdmVjdGEuaW8vYmxvZy9ndWlkZS10by1nZXR0aW5nLXNoYXJwLWFuZC1jcmlzcC1zdmctaW1hZ2VzXG4gICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgLTAuNSAtMC41ICR7dy50b1N0cmluZygpfSAke2gudG9TdHJpbmcoKX1gKVxuICAgc3ZnLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiXG4gICBzdmcuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcbiAgIHJldHVybiBzdmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRleHQgKHN0cjogc3RyaW5nLCDhup9fc3R5bGU6IERlbHRhU3R5bGUpOiBTVkdUZXh0RWxlbWVudCB7XG4gICBjb25zdCB0ZXh0OiBTVkdUZXh0RWxlbWVudCA9IHRleHRFbGVtZW50KGZvbnRTaXplLCBbY2xhc3Nlcywg4bqfX3N0eWxlXS5qb2luKFwiIFwiKSwgc3RyKVxuICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgkezB9LCR7bGluZUhlaWdodCAvIDJ9KWApXG4gICB0ZXh0LnNldEF0dHJpYnV0ZShcImFsaWdubWVudC1iYXNlbGluZVwiLCBcImNlbnRyYWxcIilcbiAgIGNvbnN0IHdpZHRoOiBudW1iZXIgPSBzdmcudGV4dFdpZHRoKHRleHQpXG4gICBfX2RpbWVuc2lvbnMuc2V0KHRleHQsIHsgd2lkdGgsIGhlaWdodDogbGluZUhlaWdodCB9KVxuICAgdGV4dC5yZW1vdmUoKVxuICAgcmV0dXJuIHRleHRcbn1cblxuZnVuY3Rpb24gdGV4dEVsZW1lbnQgKGZvbnRTaXplOiBudW1iZXIsIGNsYXNzXzogc3RyaW5nLCBzdHI6IHN0cmluZyk6IFNWR1RleHRFbGVtZW50IHtcbiAgIGNvbnN0IHRleHQ6IFNWR1RleHRFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInRleHRcIiwgdGV4dEVsZW1lbnQpXG4gICB0ZXh0LnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIm5vbmVcIilcbiAgIHRleHQuc2V0QXR0cmlidXRlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplLnRvU3RyaW5nKCkpIC8vIHdhc24ndCBhYmxlIHRvIHNldCB0aGlzIHRocm91Z2ggQ1NTIGZvciBzb21lIHJlYXNvblxuICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjbGFzc18pIC8vIHNldCBzdHlsaW5nIGJlZm9yZSBjcmVhdGluZyB0ZXh0IG5vZGUsIGZvciBmb250IG1ldHJpY3MgdG8gYmUgY29ycmVjdFxuICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcbiAgIHRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyKSlcbiAgIHJldHVybiB0ZXh0XG59XG5cbi8vIEZsaXAgdGV4dCB2ZXJ0aWNhbGx5IHRvIGNhbmNlbCBvdXQgdGhlIGdsb2JhbCB2ZXJ0aWNhbCBmbGlwLiBEb24ndCBzZXQgeCBhbmQgeSBidXQgZXhwcmVzc1xuLy8gcG9zaXRpb24gdGhyb3VnaCBhIHRyYW5zbGF0aW9uIHNvIHRoYXQgdGhlIHNjYWxpbmcgZG9lc24ndCBhZmZlY3QgdGhlIHBvc2l0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIHRleHRFbGVtZW50X2dyYXBoaWNhbCAoeDogbnVtYmVyLCB5OiBudW1iZXIsIGZvbnRTaXplOiBudW1iZXIsIHN0cjogc3RyaW5nKTogU1ZHVGV4dEVsZW1lbnQge1xuICAgY29uc3QgdGV4dDogU1ZHVGV4dEVsZW1lbnQgPSB0ZXh0RWxlbWVudChmb250U2l6ZSwgXCJsYWJlbFwiLCBzdHIpXG4gICBsZXQgdHJhbnNmb3JtOiBzdHJpbmcgPSBgdHJhbnNsYXRlKCR7cm91bmQoeCl9LCR7cm91bmQoeSl9KWBcbiAgIHRleHQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSArIFwiIHNjYWxlKDEsLTEpXCIpXG4gICByZXR1cm4gdGV4dFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCAodjogVmFsdWUpOiBTVkdTVkdFbGVtZW50IHtcbiAgIHJldHVybiBob3Jpeih0ZXh0KGBUT0RPOiAke2NsYXNzTmFtZSh2KX1gLCBEZWx0YVN0eWxlLlVuY2hhbmdlZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJ0ICguLi5nczogU1ZHRWxlbWVudFtdKTogU1ZHU1ZHRWxlbWVudCB7XG4gICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInN2Z1wiLCB2ZXJ0KVxuICAgbGV0IGhlaWdodF9zdW06IG51bWJlciA9IDAsXG4gICAgICAgd2lkdGhfbWF4OiBudW1iZXIgPSAwXG4gICBncy5mb3JFYWNoKChnyrk6IFNWR0VsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgIGfKuS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGAke2hlaWdodF9zdW19YClcbiAgICAgIGfKuS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGAwYClcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9OiBEaW1lbnNpb25zID0gX19kaW1lbnNpb25zLmdldChnyrkpIVxuICAgICAgaGVpZ2h0X3N1bSArPSBoZWlnaHRcbiAgICAgIHdpZHRoX21heCA9IE1hdGgubWF4KHdpZHRoX21heCwgd2lkdGgpXG4gICAgICBnLmFwcGVuZENoaWxkKGfKuSlcbiAgIH0pXG4gICBfX2RpbWVuc2lvbnMuc2V0KGcsIHsgd2lkdGg6IHdpZHRoX21heCwgaGVpZ2h0OiBoZWlnaHRfc3VtIH0pXG4gICByZXR1cm4gZ1xufVxuXG5leHBvcnQgZW51bSBEZWx0YVN0eWxlIHtcbiAgIE5ldyA9IFwibmV3XCIsXG4gICBDaGFuZ2VkID0gXCJjaGFuZ2VkXCIsXG4gICBVbmNoYW5nZWQgPSBcInVuY2hhbmdlZFwiXG59XG5cbi8vIERlbHRhLXN0eWxpbmcgZm9yIHRoZSBjb25zdHJ1Y3RvciBjb21wb25lbnQgb2YgYSB2YWx1ZSAobm90IGl0cyBjaGlsZCBwb2ludGVycykuIEluIHBhcnRpY3VsYXIsIHByaW1pdGl2ZXMgYXBwZWFyIGNoYW5nZWRcbi8vIGlmZiB0aGVpciB2YWx1ZSBoYXMgY2hhbmdlZCwgd2hlcmVhcyBub24tcHJpbWl0aXZlcyBhcHBlYXIgY2hhbmdlZCBpZmYgcmVjbGFzc2lmaWVkLiBDaGFuZ2VzIHRvIGNoaWxkIHBvaW50ZXJzIG11c3QgYmVcbi8vIHZpc3VhbGlzZWQgc2VwYXJhdGVseS5cbmV4cG9ydCBmdW5jdGlvbiBkZWx0YVN0eWxlICh2OiBWYWx1ZSk6IERlbHRhU3R5bGUge1xuICAgaWYgKHZlcnNpb25lZCh2KSkge1xuICAgICAgaWYgKHYuX1/hup8gaW5zdGFuY2VvZiBOZXcpIHtcbiAgICAgICAgIHJldHVybiBEZWx0YVN0eWxlLk5ld1xuICAgICAgfSBlbHNlXG4gICAgICBpZiAodi5fX+G6nyBpbnN0YW5jZW9mIENoYW5nZSkge1xuICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHYuX1/hup8uY2hhbmdlZCkubGVuZ3RoID4gMCAmJiBpc1ByaW0odikpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWx0YVN0eWxlLkNoYW5nZWRcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGVsdGFTdHlsZS5VbmNoYW5nZWRcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHYuX1/hup8gaW5zdGFuY2VvZiBSZWNsYXNzaWZ5KSB7XG4gICAgICAgICByZXR1cm4gRGVsdGFTdHlsZS5DaGFuZ2VkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICB9XG59IFxuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6Zm9udC93b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBRjNZQUJJQUFBQUF3OEFBQVFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFCZHZBQUFBQndBQUFBY2NxL2owa2RFUlVZQUFGaGtBQUFBSFFBQUFCNEFKZ0d6UjFCUFV3QUFXdndBQUFLK0FBQUZ5a1VVc1FwSFUxVkNBQUJZaEFBQUFuVUFBQVFRaXBtdnRrOVRMeklBQUFJUUFBQUFXUUFBQUdCcStHUXJZMjFoY0FBQUJMQUFBQUpPQUFBRFRsTW1iVjFqZG5RZ0FBQUlRQUFBQUNJQUFBQWlBSmdJS21ad1oyMEFBQWNBQUFBQTl3QUFBV0dTUWRyNloyRnpjQUFBV0ZRQUFBQVFBQUFBRUFBYkFBbG5iSGxtQUFBTHVBQUFRL1FBQUpkSWhLK3QrbWhsWVdRQUFBR1VBQUFBTmdBQUFEWUJFeFVoYUdobFlRQUFBY3dBQUFBaEFBQUFKQVliQlJOb2JYUjRBQUFDYkFBQUFrSUFBQWF5dTZyZ1VteHZZMkVBQUFoa0FBQURVUUFBQTF6SlJPN2liV0Y0Y0FBQUFmQUFBQUFnQUFBQUlBUEhBZmx1WVcxbEFBQlByQUFBQXZJQUFBYW9WbklMTkhCdmMzUUFBRktnQUFBRnNnQUFDbWxudnBURGNISmxjQUFBQi9nQUFBQkhBQUFBVE5LbVRob0FBUUFBQUFFRkhuV1psYnhmRHp6MUFCOEREQUFBQUFETzZXbUhBQUFBQU0rdVpEbityUDlNQkp3QzdnQUFBQWdBQWdBQUFBQUFBSGljWTJCa1lHQzY4RitBZ1lIbHpiODEvN05ZNWpBQVJaQUI0eG9BbzJBSE5BQUFBQUFCQUFBQnJRQk5BQVFBVmdBSEFBRUFBQUFBQUFvQUFBSUFBVlFBQkFBQmVKeGpZR2Jjd3ppQmdaV0JnYW1meVpPQmdXRWFsTjdDWU1Sd0NTakt4c3JNek1yS3hNS3lnSUVoMzRHQndac0JDa0k4Zy93WkhCaDRmN013WGZndkFGUjVnZUdEQWdQRFpKQWM0eEltR1NDbHdNQUNBTUVVRHVVQUFBQjRuSTFWc1lvYlFRelZySzl5RG5MRkVzNXdtRFJIWEF4cGs4SjFTSkVQeUNmTWgrUVQvQWxiWHBIaU9FS3FLOXhkWTBnSVd4b1RVb1F0VWkwQkIwL2VTSm81ZWUyWUdCN2FrVVlqelpOR2RnM0o3OWJJWHpSem5pN2Rtc2cxY1R2NlFIWDFubXJZTHFGL0JaQUw4WGV5WTI4TlpCK0NqdGV1b1RGQWlqcnArVHZKQjk3emhuM1diQ01HL0t0VjBzVmxXbGRYTkFFbzI1SERCQ0NKRjl0c2cwK3lzYjNzdTVMY2RVM3B6TkY1WElxUG5JOTRjK2RqcS9mcGNPWkhuRDNPZmladnVaUG1xdkc3L0ozaWE0NTFrWjc5cDhKSjdIRm1XeTBRU3podFhaRDd3bit1ZXpQM0x6VHVUTTZLUGU5SjNQbllqODV4eDREOGhFdU96enFQdkwzbUVRU3dUYkdlNjc0WjhFeHJ3N1dvRnBJNy9OUFpXK0hsRU5XS2VadVVPcTF6N01TWjFBTFlKRzV6SFlhdzliTW90VmlUWTk2UEFMeHROZWM5bVBpYmxNTWUvNGRRUFdwaDBaaWFwRndhNWNGSXZqdmluWkNwVjJ2dHg5cjB6a21wdkp5U3VlOHozeHRGcC9nTy9ORDNWMkRxMDlJWHFjdWpibCtXbnZIRnB4L0dQU0tQNWp0NmkvcXVsQWZQbk94SnFTZDY4bC9TNWhQTVRKQSs2ZjlYOGp0ZmxIcTJwY2ZDNE95Z2RSL0VCMmNkNXlFNHc3dDhDdm1jdmhYZGxHaDNUeFF2SU84VVdPOCtRK2NnYndEczNuMFZXM3hDODdqRTl4L2dKOWF2YzQ1RFdYSnU1RjN5VExqVnQ1eHpDcHhyclhQbUd2ZWVuWFZsRGhOaXZlUStDOHo5R1BOYmFwdjA1djN5M0Z3ZDlnWFBoSHRCL3JZeSsyWnB1TGhSV0U0K0FmR1JqL2lPWjF5YU4vbS94T3NNOUdVbWtzNHA0Y0NzaWY0Q1Q3dmp4Z0FBZUp5dGsxZFBsRUVVaHArekg2NklpRXBSQkZ5SFZSR3NvQ0tDRFpIZUZSVjdGNUhlaktCQ2pJcTlFbXVzc1JmRUVudU5tT2lOUDhBYmhZLzRDeXhYSnZzNTducEJ2UERLazh5Wk01T1pkMmFlY3dZdzhMUXdSSHNrV1kvRVBmYVNTTjJua2tnUDdEcnFRNVBFU2JvMFNZc3QxQlpuZTIvN1pIZ1ozb2F2NFc4RUdaR09ac2MzRmFoQ2xFTTVWWVNLVmdrcVdWV3BPdFVhN25UNk80TitlbG5XN3hPMGp1S0N4RXVtMWduV091OXNIdzBNdStIajFvbHdiSFY4VlFFcVdJVXA1ZGFKLzBzSHJXTllQNnd2MWx1cjNYcGp0VmxSbHA5cnE2dktsZXZLY1dXNzBsd3BydGl1ejEwMVpvR1piK2FadVdhV21XUW1tREdtM1RRNlAzUVdkaFIzRk5tM2VONzdIOHh1ODNHVDgzRHNib0x0VDJUajMrYTVpNWViZEUrODZZVVB2ZkhWclB6b1N6LzY0MDhBZ1FReGdJRUVNNGdRUW5XT0J1TmdpT1laanBPaERHTTRFWXdna2loR01vclJqR0VzNDRnbWh2Rk1ZQ0t4VENLT3ljU1R3QlNtTW8zcHpOQVpua2tTczBnbVJlYzdqWFF5eUNTTGJITElKWTk4WmpPSEF1WXlqL2tVc29DRkxHSXhTMWpLTXBhemdwV3MwdmZmeFc3MnNwK2puT0k4bDduRUZhNXhsZXZjcEpWYjNLYU51OXpoSHZkNXdDTWU4cGluUE9FbEwzakZhNm1nbHJVVVVTSlZOSENSYXNxa2dZMlVhdTA5bk5hK3pzMnBtUHB1N01wcDFQNEd6OW5HR2lvMXpFVDNmSVd1MTJwV3M1MmRuSlFBQ1pRaVdTZWxVaWJGc3A1bmVrVzdyc0lOVWkrMVVpZU51cTRyMlNRbFVpNDFOSE9BSFJ4a0g0YzVRZ3VIT000SnZlTVlaem5IR2I1THFtUlRvMzlEaG1TeVdYSWtTOUorQVgyMmxzRUFBSGljWFpBOVRzUXdFSVZqRWhaeUF5UUx5U05yS1ZhMjZLbFNPSkZRbXJDaDhEVDhTTHNTMlRzZ3BhRnh3Vm5lZGlsek1RVGVCRlpBNC9GN28vbjBacENZR25uajkwSzg4eUErMytBdTkzbjYrR0FoakZKbDV5Q2VMRTRNeElvc1VxTXFwTXRxN1RXcm9NTHRKcWhLdlR4dmtDMm5HaHZid05jS1NldTcrTjU3UXNIeStOMHkzMWhrQjB3MllRSkh3TzRic0pzQWNmN0Q0dFRVQ3VsVjQrODhlaWRST0paRXFzVFllSXhPRXJQRjRwZ3gxdGZ1WWs1N1pyQllXWnpQaE5hamtFZzRoRmxwUWgrQ0RIR0RIejMrMVlOSS9odkZieU5lb0J4RTMweWRYcE04R0pvMHhZVHNMSEpUdDc2TUVZbnRGK1ZnYTF3QWVKemJ3S0ROc0ltUmtVbWJjUk1UaU56TzVHRm5vQ3pLd0tITnNKM1JEOGJjeE16T3JyMkJRY0cxTmxQQ1paTUJPMlB4cGdKT0lNSFBDeVFTK0lHRVBwQUFBRVFnRU5ZQUFCQUFOd0E4QUFBQUN2OU1BQW9BdEFBS0FaOEFEd0hnQUFvQ0hBQUtBbGdBQ2dBQWVKdzl3bTlJR2dzQUFIQlRNek56YXVaTUxlM3V2RHZQODg3dXY2ZHp6bGVtZHpGa1NNUVlJVVBpRWZHUVI0UU1QenhFSXZaQllrZ01pWkRIaUloNGpJaVFFVEVpSGlQMlFjWWovQkFSOFJnU2o1Q1FpQmp4M3FmSDc2ZFFLQ3IvKzB0eDBUWGQ5YVdycVN3cHE4b0Q1Ym5LcW1KVWNkVzBha1cxb2JwVlc5V3o2Z04xcXh2dXJuUi8wa1ExVmMxOWo5Q1Q3bG5zV2RYcXRGdmFtOTUwNzhmZWF4Mmp5K3ZPKzhiN0Z2dTI5RnE5cVA5ZGY5TS8xYi9hLzkyUU1ud3hQRHlhZmxReEtvMEx4cnF4WlRLWUlGUENsRFVWVE11bXR2bWxlWDhBR2xnWnVMY1VMZjhNNG9PbHdhWlZiUzFicng3SEh1L2JVRnZPMWhvYUgzby8xTFJIN1I4Y2VvZm9LRGxxamlzbitwL1h6dm93TUR3M2ZER2lIaW1QdkhmcFhJdXUzMXp2WEZVMzQ0NjRpKzV0ZDJkMGJqUTMyaGk5QTh5QUUrQ0FOOEF5c0Fac0F2dWdCWFNET0NpQTQyQUtmQVgrQ1g0RHo4RXI4QlpTUWdiSURzRVFCWWxRSEhvQnpVTHowQkpVaEdvZXlCUHdoRDBKVDlxVDhkVGhOSnlCRitBOFhJSlg0WFVranJ4QVpwRjVaQWtwSW1Xa2ltd2l1eWlEUnRFcGRBYk5vam0wZ081NkdXL1VPK1dkOFdhOU9XL2Ird1BUWWhiTWplRllEZHZCNnRneDFzRE9zQmJXOFNsOGVwL05CL255dmx0Y2lSdHdPdzdqRkI3Qkpmd1N2OGJ2L1JxLzJUL2l4L3ljUCtaLzduL3BuL1AvU3VpSUlsRW1xc1Ftc1VzY0VpZkVLWEZKWEpOMkVpWXBNa0pLNURUNW12eUZmRU11aysvSURYS2J2QWxRZ1VMZ0pIQWF1QXhjQis3SE5HUG1zYVd4QjBwSFdTbUFJaWlSaWxONzlCUTlRMmZwSEYyZ1YrZ0tYYU4zNkRwOVREZm9NN3BGZHhnRm8yZHNUSWxwc0FrMnpXYllCVGJQbHRoVmRwM2RZdmZZejl3TWwrVnlYSUZiNFNwY2pkdmg2dHd4MStET3VCWXY4T044aW4vRi84ei93ZGY1SS80cmY4cGY4RmQ4aDM4UW5JSW96QXByd2tmaGUxQVpGSUp6d2JYZ2NmQTgyQkdOWWtwY0Y3ZkVQZkd6K0ZWc2luK0xiZkZIeUJCeWg0VFE4MUFtdEJES2gwcWhnN0EyVElYWHd0dmh3L0MzY1B1SjlHUXBvbzZzUjNZaWUwOHpUeStqODgvd1o1MllObWFNUWJIeVQ0Rng4NFJ6QXAxZzRvYjR3K1R1NU9Ia1NTS2J0Q1NKWkNJNW4zeWJQRXJlU1FhSmtkTFNoblFrTmFVTHFTVzFwVHRaSVd0bG8yeVRZWm1SWTNKS3pzZzUrYTM4NFY4QmZCVDhBQUFBZUp6RnZRdDRHOWQxSUR4M0FCQUVTUkNEOTVNQVNKQUErQ1lCQWdPUzRGTVVTWWw2VUMrVGxreEpsbVNMY216TGxtVUxkdUxFVVcyTGNlVkhZc1dpRTIrcWJaU0hIRGNHSVVRTjh6ZVAzV1piTjEvK0ZrM2ROSDlYMnlyZEpOMjJTYXZkT1AzYUpBYjMzRE1QekVDZ3pPUnZkMjJSNEwyNE0zUHZ1ZWVlOXpuRGFCajRqeXl5UHFhVzZXV0dtQTh3V1diemZMYXgyN3ZTYUJpK0V4dlYwS2cyaWcwV0dxeG0rTTZyWFdSUTI1NnQ1bFpzNUozOEZkdXFqVjBZdFZmYlhMYW9MV1didHMzYkZtMFoyNUp0MlZhemtHVzVsUVI1WjlTdVR6Z1RrUVNmbUVyTUpZNG56aVRPSlM0bWFoYnluMDFjUzdBTFBiMHR0bEJqVThMY0YyK00yVFhESk5IWHhZYWFxdlJWZHBzakh1T0hTVHptc051cTlQV2tnZENlWkVJdmZQU0ZZUmhaOUJiL3hPY2p2ZDU4MzRRNTJOM1ltdGJYMXRmbzlGVXREVjFOWFNHYnRaNnI1NmFjRm92TFpiRTR2VjR2K1pIWFcveWZWUk14Ujd2ZmF0TWJqTFVXbHEwUHVZSkJEV3VzSHpmVjFaa2VNTHRjWnJpQVlaa29BT3A1Z0pPR01UR1RBcFFZZ0FVakFjWUlEU01BWmtWUDNybDJSbjlPZjFHdldiaTJVMzlJZnhMK0dEWG85VTU5Uk0vcnRiQmUvVFU5WGE4MXJnbnArNUxDc2tKTjRkaXNLZWIydXB4ZW44dnBZWDNGRng1MytieE9sOWZMcksweExuS0srUjRiNXNLd1V3eFh4ZFJtNk5heHVIOXZraHVNbHdrd0h4SG1aWWVwMkd2RmVibWg0WllhZW1qb05XS2pGaHExZEN1MVJBZGI2ZWF5NVBvS1E5N0o2cm1zNW5wV3gyVU5CZnJiV01ocXVLeXBrT1VLV2NKbHpZV3NwWkJsdUt3VmZ6dWhuOHY2Q3RrRzZPZXkva0kyVU9qcEpmcVFQZzQvSVI1LytEait4UFh3WXlMUUlHL3FEdFR0MSswM0pvMForS0Yvd1U5OW9qNVRuNnovZXFZdVF3N0dNckd6OEovNDhYcUcwYXo5WXUyejVBSDJNYWFSQ1RQdHpDRmh0U1pZaGtuYUJRczBMRktEUUlOSXF3MUNJMGdiaEZ1cGhrVmF1QlUzZVNmWFRFeG1Tei9nY2JhbGtHc1ZHZ0NKTmxpRE14R09KT0oyaHpQUkJiaVk1UEZ2ZXdoNjdYNUNFZEhPOTBYc1NZM05tYWo2Nk5hcGRLUnI2N2F0Mi9pWnNYUnp4OXlPTzNZZU8zYnM1cjU5Ky9lekRROU1HY25YSFpPREE5c00rL2RyR3U2ZnFtUC9IL2NVUHpHdDMvK2pjYzlLRGRrMTZuNmpCbllTOXRuR01Kbysxc2VGeVdPd3p4SHlLTGtNbjNyeUdMbXh0aDJ3RDc1bmZZQ0hVVGl2YWVaMXhYbVZsbTJHaGxsYXRnTWFEbUdUTmJESnNKRlZoYXlaVzZuRDgxam5ySXZVOFhWVGRYTjF4K3ZPMUoycnUxaEh6MlBkdFRwMklWdGZ5TlozWnh2eDdPYXZKRllUZU1JVHJrUTBrVXBNSitZVGk0bE1ZaW14REVjNDErcElVTWpWYzltdVFtNndxeEVhT1cvcklQMkk0QWVjN2lRZkFoQ0dxdlIrT01tOG5XSjhoUDVLOVBFSVlQRjRPeUxpZ1EvemVMQ2g0VXlTVERPYnZCVFg5UUx3amZWbVd5Z1duVGl4Ky9pcDlzRHNlSHJyUUhydlIvWk84alA4TG50SEtOVGxiZC8vVXJLZjUzZHNDdG5ZZUZXd2VXTG4rRnk2UFJGSVRBd2syc2ViZGlYYlJyb1MzWnQvNFc4TUJoeHQwUjQ0UW5pK0RyTmhnTEMxN0hTejErbFIxWWRjMDF5VURlZGhMTCsyamJuSnpqTUdwb0VwblN1VGtrVHFodS9zNmVWdHpoQmRYcndxazBrLytXUTY4L1lQTHVlKzgyZGZ1Z3ozWU9BZXE4cDc0R1VtNVVFVjd0RVhpUU5jOUtHa2RJOGJsNy8wWjkvSndUM1cvb1g1VnhLSE9kY3pmV1Z6cnJxZUkxVU1CYjllK0tqUkU3cEJOVnhXaTZmWUNBaHUxZk5PcEVvUlBzSTdJMSt1ZjlUMm9UdFRJMlBKdVEvYXozQnMrS25FdU9OSTlKRkhva2RjbzRtbjZKd1pHN2xNcmdJRnNqTlhDV0VBb2VCV09xUURlcmpoRUluRERzTWV3eW5KcC9QNTlGdDhQZy8vS0h4dGE1OWxubWVPQVh5cm1SelJhTnJoZ0FGQnNFVjNqZTMvMnRlUWpNSFBLcE5uYnNJWUE3MC9xNFZCRkdYeStaczgvUjVwTUhNUFBMOWZXSzhCMW11Z1JGZERpYTdtbk9haWhoSmR6U0hOU1EwU1hZMVRFOUh3R2twME5kYzBsT2p5Q29JYmxZaHRyMFJvNmI1OGxyaGdYelFNcDRDcGlXNEZwZGZYMDlmVDdQeTdPNUQyd2xra0x3SHRyV1djekwzQ2FBMk0xa2prVnA2ZUNVK2J5V21LbUhqVGxHbk9kTngweG5UT2RORkVUNXZwbWdsT200WmJzZE56WmwrMTR6bXp1K3hSZThvK2JaKzNMOW96OWlYN3NyMm1iUHE4Z3YzWjdydHp6NzBuNXU2NGQyeDhNRDAyTkpJZXYvbmcyUS9lZi9MYzB5Zm5qOTA3dC9mdWd3aGZoc25BZkhWTWM0WFo0a0lwM1lDcEVQSk9UMi9jREFmV25FNW55QlcrR0lUcmdVU1J2WEM5ZzltcW9MMjNYRzlDQ3B1L1VyMWFqVXVwZGxWSHExUFYwOVh6MVl2Vm1lcWw2dVZxRUFvWVhIQlBieXRKVUY0UGk5QUQya2hVSUU3MkZxODltV21QZDdVTVRPM1l2UHV4ZTI5MkgzNTVvTEhEMGovWFB0WS8vdG91M0tzbG5FK1kyU1hNeHdWVGNNRjhycktrR1pEVHhhMlk2VVRNcTJhY2lObGxqcHBUNW1uenZIblJuREV2bVpmTlFMdXFtODBDQ3dCQy9FN09YMTJENU1vdXdyYWRKQ1FnbCthbkZ6aEFxQ2t5T2o0K3ZXazg1T2dmNnVucWpneHMzckZsN3U2aFRXY09qZysxTzBZRysxT0pGTi9aWlUzTnRXOGJ2YXVObUdaU3MwZHRBdDllK3liNUFNeTlCdVNKSnZWdVhLM0RvMVduUEZwQU82MXhNeDZ0U0R3UjB0KzgrWXZlMmRuMDcvd08rNFd4SG5LeXVNdy9tWC8zRjNqT0JKaTRtVTZteE9ZRm1EaTE3VmZOcEZyYm51T3F5VUsybGxzeHdvbzVNd0hFY3NxNHBEYzN3bU5rTkl2WVVqMmJaMmEyaDFxSjYzdG02K0hGeCsvdWkzVlp0MDF0M2x4RmF2aFgyY04zSFh6SVZEb1BjSFljd0tFZkZwNXVnNmZiVEVwbUpEWHFvVkZQT1ZNMUNjSnFIUnpLSG13aFYxVnZveFRyRUoxaVBiZml3YlBqY1hvaUh0NHo1Wm56SFBlYzhaenpYUFRRcytPNTVtRVhjb2VDZEFXRW5nTzlzM1Era0tjNENXVTN3c3JJWXJQbitIMDZUWHJ2OU4xSDl4MDRjZUUzZkkzRmY5U05wK09iaHBNemJJUDJnNCtUa2NQVE8wNDlmL2JWcks3NFc3dFBUQXdtTjR1MENlQzZDSERsWUpXbHd3MXdYZEZSTEhZT2EzaEs5aHJ0OVJyOS9XeExjalR3VC8xa01UZ2FheVNaNlFzdm5FM01uTzNpbjNwaFdlVGhDQ2NuN0h3bjh3eFRFbDBrNEZSQm80cWVKUkJUd2hTRnc2dGhST0d3S3h3TnA4TFQ0Zm53WWpnVFhnb3Zod0dGRzZ2Q0ZJV3J1QlV2UXN2cjlFYTh2SGZLTytjOTdqM2pQZWU5NktYUThsN3pBclE2dkhSd2ptbnNvQisxK0FIUUV6R2E4cXRFaVIrYmlFUmtJbFZLZm13WkhYN3dqcjNISGsveEozWnZQM3o2cXlPRDZZbngzZmYrZEN6Uk56NDlmb1NrQWpPOUUzZnVHN3Rua0cyWTdCalp2VzFvLytDbHJrUXkwajRZN3YydjBlN09VT3Rnb0p2aURNRDFKYVFwamN3TVU4SU1BV050Z0xGQmlyR2dRMlFaT0EzZElrcmtyM2hXUFFnUmo4c1Q5YVE4MDU1NXo2SW40MW55TEh0cUpIem1JekllaU1oTXVvaXdobmdzM2VTL2QxR25HZGk3OWZEUnZRdUxMMy9ZMzBRczJrMUR5WkYwYWx0YTk4VDd5ZERkTXpzZitNalpUNzFaUlE3Tkg5dWNURTBKTXZjay9QNEN5R1dVN2oraW9JU0djcnEvVWJaRVNTYWwvcFRLc3dzU0V6QklURUFMZjQvYVorMkg3US9CMzJvbVlGYjhQU254czNLK1J2WkpEQTduSHdWZUxNemZ4SXdyYUEvTVAyYzBhYWlZdUdJQVJESXNHaktHSmNPeUFTWjZ4YkJxd0RrWlhJYW9JVVc3UmcyekJ0UmpGRlBRQUUrWHArRUg1azRlRWg5ZDNBWnNIdWdUNHdjWjRncWpsL2lyRHA2c002Q29vN08zSkZyc3VsbWcvUStSbDRwdmZQOWMrdlhrRjlKTGdwN3pKRnkzRlU2UEhtamJWUjNSQW1xZ0RKSWJaY2hDYnBSUUdtQ0dBNmlESDNLNWVCY010L0w4S3p3dnloWit3RFBGYzFIZXd1ZDJrb1FPcm1xQng3NEJqMzJJN1AzaFV2b0x5ZGZUNXdUOWl2a1p5TnRlSnNJOEtWekp3WldjSkcyM1FLT0ZubFNPVzZtbGVGbTdXb3Q0V2V1cWpkYW1hcWRyNTJzWGF6TzFTN1hMdFhCU2pTMGN5c2I0a1czaFZnSVVSUUxuQWhjREZFVUNod0luQTRnaUFXY2dFdUFERkVVQzF3SW91VkJFNWlWZUtYUEtlamkzVHFVYU9WWVQ4dm9idXpzNk9tTTlZN3ViUXcwaDNZeTBJNjg3M0ExZERsZEhReWhpU1ZySEJscjdQWTVPYjUzNThUTDhXR0x2aHpQWnhRd3dyeklsSTBCdEdlbkdoaFVhVmtySE82akFkdFZOZW1GTHpQWFZkSm1jVzZEaFFhUktRV2N3RXVTRFU4RzU0UEhnbWVDNTRNVWdwVXJCYTBFNEFkVWJJblJjTDl3d3lHVjVZSW02OHJNZEtoRjlhalNRWlNOQm5kRElmeVo1OHM2KzNSOTU3VE1mZWY4bjc5ZzBvOWRFTjNYR0RtenZHRERvd3FING1hTVBQUFBFWXp0MjM5OWc3ZVdkenRDQS9wRDc1YlBQZnZYVjAvUHZQM0JneTlpQlU1WlRndzBUdXlhUG5ibnd5SWtuM0dTaWF0ZEVXOGVKQ1lUZDJqY0IyVzRBdnBoQWo1aFZZSGhGcFZRaUZGZXR4SWpDTlBKQVRZRUs2ZnBDdHJxUXJTMWs2NmdXdnNKUkxzTURoNGxiNFgvNkdRbnByYUJsWi9MOGx6ZmxrL25obnJlN1A2bmQrd2JQOCtTSFJTL1BuejFMZnV0SE1DZkJ4dk1Tek1uSytKZ1dacTh3cXpwNGRwMnhqTjljYlNBZTJMNXVENXlvN2diNHhYZ2FSTTVDbGVZNmxKR290bXdyVUowZjFJbFFJZHRja05nSEZaYW8wSWc3WWlLaUFHVzNTbitRMEVEOHZnZFcwK25mUFhGWHRQZmVMVnRHcG1jblJrWUhkZ3lTZ0dsemJHWUhUNzdJRDArMkQzTC8wQjN2U2I3RnJMWDNkTGU4U2MrdkczNTlHOWJnWkI1U1lHUzVXWXFpa1ltaWtXblZoR2hrY3BtaXBwUnAyalJ2V2pSbFRFdW1aWk5na0xJalN0cWQ5b2lkdDAvWjUrekg3V2ZzNSt3WDdSUWw3ZGVBL3VhY2JMV2d1WmJ3aXFyL01rYVJiOC92UC8zOGk0L096YWNUbXhidVhseVlYWWpIUC9iK0Q3L1E5dHd4OThsajl6N2FKOXBuL2hEbVhRYzYwNEF3Y3kxTVZtc3NzOExnem11NUZSWStHRFM2Z1A3TklxRHRCYW9HeVhCdEo3d2ttcWJUWDNuNkk2OThPSnNaUG5iLzBmdEhLUFErL01FWFgrQlBQclI0WEpEM2NkK2R6QlJUUWo1aitjR3RWaUlmaUp4VmhWeDNOVVVBSXh3Mkt3SVU1cEIxRkFUNkdrcUU3RlRQa3o0YllXN2twZlQxWStuMHNldnA0a05wOGtQKzBvazMwL214dDA1Y2dpbEp1cDB3Rjd1a095REtHY3QwaDZ0R1lNSHRWRGVnY0FDczA4SkhEVDBHT0p0Y3Q0VXNLS0FTRHlGY3l1WUVpbWRhbWxDYXdrU2NEU1BpRWRwUEdwaEhiNE5IVnozRUxaZzMvNjJ3aVZxVmZJWDFrU21CeGhGeTQ4REJKeTY4OHNTQnU5S3A2YVBIVHg1TGphVHo2ZloySlZiWm4wV1dKc0FVMStKbFBsVGhUS1BvWFg3QXNlR0Job2V1MGt4Sk5nVXozWGtDTUdZQnZFQjdkRWg3REFYcHdBTXFtdUJiVUJTbzdjOUtjWUVhL2d4YzFsWEl1dW1xNHJBSlNKWE11QTVBQ3Z5a0dndFpUQmZmaGxYQVA5S0JuL3hiYi9GMFgvZzMzK1Q1NG01ZVhBdVRSenMwWCtHVTFFQ2pwdXlVVkNHTmhMT0NVNVdPaVBETXRQQWMrZ3poL212ZlcxdkMrNXVaRHZXK2c1UnBVc3FYc09kVkV0TDE5T3BSK2hWdmpGd21hdVFpUWJnOVAyVTFqWkwyWHZJdGVNYmd0bTJha2oyVzBuOGpZTnFwQ2hpMnZvVVNsVmZSUWxsaUE4cnB3TXFGclFEVmpWcGp6UVhoSUlENEtPd0liQVJ5QnNIU3BuYzJLa0JDYnVUYi8veXYrdkxKLys4dmkvdEUrUEQ4OTc3TDgzLzYzMHB3d3ZsZnh2bFgyZ2RFc0EzdkF5VU85RWszMDhXN3hMMDRjVW5FMnd1SXQrK3ZRSmZRWWkwMVZCWnJ5Y2F1SWw4VVhCcTBXbE5OakNKdFRTRlhoK2F1SENkWXZRU1ROWkl3YWdFRnpIVlJVRmxGeU5BSmErQi9zNHpBVnJMejJvdDA1dHJWOWk5ckthd3U1dThodjB0aHhKT2w0aGo1ZWpHREdGemNvanlIZG1hL1FyYXN1T09xY3loQmsxSVFCQ2llUE9XWm8vWjMzR2pnc0FKUVEwUXhUeElubCtuc2l0L0RTV1pJVkF2RWx5OTZ5WnZGSldHQ3V3RW5LYzNUNE5sUzI2bU01ZnJLdjUyZHlycU9uY3E5ZE9ya2g1ZE9QdmpNMk9HOSt3NGRtSjg3U0V5UFgzZ2g4OVFyTHo5MUxKTTVkdWlSazZWemRBWG16TUhzaHhRYXR6Um5YQUNsWVc0MGxnZzJLNEY3QVYyaVhoaHBuL2tTWVJKbXhFdmlTSVlDN2ViZDg4Y1BhVVkycGNjZXVibUtNSnVlM0RITGQ4ZDZPNzVHWVFleWNBL3ViYU9rS3lFeE1xTFVKa2k4SEV5Z0JrWDUvSlhBYWdEaEVuQUZvb0ZVWURvd0gxZ01aQUpMZ2VVQWhRc1ZXaU5LYzdjZEpRa0ZoTmllMW81UEx0ejFJQVhVeVlYaDk3V0ZpMjBTck41bmZNTDA0c25NeDE4ODg4aEhqYnAwTFptNEJXYVU5Z1NaVm1iaE5qQlRld1phMXdOZ2ptTmFCZUZQSkRONkxoc3BaS08zd3BUYXd3SUV1cnBJTituU2xFUDR5TnlMNXFCamRPUStvN08yeWVMMStLejh5S2JCY1JuZTB4OXdhUXpCOEVuZTFXcE5ONFp0T3I0clRxRlA2Zll2NE5jRHNLWk81clN3SWlmTTIxa3VOOURwQXVhS1ByWXAvWnordUY1d3d0VkkvcmFzazF2eDB4M3lyL3B4aC93dWY5U2Y4ay83NS8yTC9veC95Yi9zQnczRHhQZ3A1UWpyblNqN3hadlFCNFM3MDhWR3VqUmxyTnZQT3YwYTJNZFA3ZHlaN2hvZTJXd0t4a0wrb1hqZ2ZYZnUzcFFPRDZaSHpFMnhKdjlRci8vQnhnL3ROL1UwMjN3T1cyMk5xeW5lUERiYjlNRTd1ZDRtUjRQVENqMk52YUhKN1FyNmE1TG9yMHBPa2pRdkpCZFZBdjBWV0FQUVgxQVVxRm1maDIyeGkwSVJKUldaZENZTlpDS0QvUERFcFVzbmtOSXI2Wlpib2dvcWJFRUVrUnFvODRvbURRQzBhTUNZMHN4cGptc0VDMGVOYk13UWo1K2d1Z2lZSTRvSklpVlFzTk93Mk1qTVRrenRBbVI1K09paGgrSGovOTB5dTJlYU9JQ1UvZmpnSS9jZkloNFFlWWhDdDVwYWp6ZEpEZVM1RlJtVkFDNmtyaFJXVm53OEpmLzA4enZhaTJQNS9tdWJjcW44OENUNUxTU2xQNVNlcmFtRFovc2tXVXVsMWVHK1ZBU2Npc1ZMZ2hkVjZKQm5vWnhGME5wQ3RTcmNRWkd6ZzNBbHlGcG1UZzFFSWswV0ZNRklpQmYra0ZaQmpqMjI2VTJZL01lMW1kQUFteDkrVGZzeUxDaTM2VEV5VlB4OTVBMTNrN0dEK0NHc2JrakV1UnZJajUrcHdMOVVTQ0hoUWVrb2x2T3ZYQlhIVXFxaDBGOXpOdXpLR1cxVjlCdU9XNm1uSGxoY25jQ1YzWVdzcDVEejR2ZkFQSEExVGttS0ViUmRQWDd3L2YzNXhPbEgwL24rajM4Yy9ucjBOUHgxZ2E3cjlkZDUvaS8rZ3VldlhPSDU3eXB3eGM3c3FjRHgwRWRhTGx5cWFXQ05xUExpbGxSSkRuQXJ4V2lZb1RBM2pVQUdFOEorT0wvN1luOCtMZjdmOVJ4eC9qRkErSmN3cjgrVEtwNy9ZN1VlWkdUYUsrQ1JMQkhvaEtuVTRTUkFwaUtOZUtSSkk1V3B5SFR4SGRCd2lsOG1kYUJ2OVpMOGlVdTl4VzBnV3NIOTA2SnZVaS9kWC9KZmxZaUpqamFVR2haMWJZbHljejZUeWJQei9MdEhlSlNaUDR2MzBxaHNadWdMYzRZMDhadnA2K245YkU2eWoyOEQrWm8rTjZxZ1d5WWxuWWJucWg3cUZEbEluajQwejdPZm9zLzhNWE9UakFKOFpEdWRkTVlwV3VnUjFTK3lKMGJQcDgrUGtzSU4wbEY4RzUrL2xsMTdqV2pYL2hqbTZoUjloM21HY0lSZHlETXN4MUw3bWI3UjNraE5pMi9FWW10clRBMjV3YnpDem9PRXVJTnNaUVRiRGVVMXA4aGxvSWROa3Y5Q3NoS3FpSXBLR0wxcW9TWVRVVTdQMVZZajhzT0JjRkplNDF4MUlxOXh1cHhSWjhvNTdaeDNMam96emlYbnNoTjRqVnNZRE1oRll5YXNWQ1Jvb0Z4VXNtUU5pclkrWjVPb0k5cG1ka3hzVHAvV2FwSmIwNk4vM3RiYU9iNGo5MXhMYURSSlBod2EzdnozL05EUVVQTFp0dVp3YUdrbUdCemFJY2tFMU5kUXczaVlEek1sQVZ2bGhwRVdpQ3FqUnRnbW9QS3NrNDJ3UER2RnpySEgyVFBzT2ZZaVM2azhlNDFsMGF6MzNsNitYQjBhQWtINXBmQUFlbHZ5TWlYaUpjc2R4WUpNYy9PV3lhRmtzb3NreDdiTW5UZzZOSlBPREZYUDdwamEwOXJYY2VxT3U5OXZaZXRGdmtYOUo0dXdUMnBia0xTSS96dTJvTVdSTFFjZVByT3dhU2pkMEw1NTY5YnBzZEZnOFA2NzczM1ljekJWczMxNmRqWWsrc2N1dzE3WW1JREVSWkE5bUpURVZWb0cwZ1ZOT1ltU3JEVElQM0xWT28xSVVEZUFiVmFPaWpSVUFXcWcySlpBZDZMU2FCcFAyRXNMdXBrQlBHTjdocmNjT3JHbnE0TnQ3UjRaSFVvTlJ0aEcvdDIvNXVQeFUvTkh6MWhmK2dQTDl1M2JacnNsM3gvZEV3dmpZaDVUZUI3TGx3TkNNMVczZGJnT2dEcHNZZ1JFblNsbWpqbk9uR0hPTVJjWkNuWG1HZ05RWjNXMWRNcTFHL1NOaTFFbGduRGRRQnI5aEVlZjRGK05qWXhON1Y4OHZuZkxiUEVubXJHWGRZZGl2SjV2SFd4NStNQzlwNDdPQnpiditOYjkvZkVTZmU2QVBmSXlMMWM0TFNwRXc5TmlHRlpMWnJrQUlkVFlRMGxjL29wMlZZc3oxcnEwVVcxS082MmQxeTVxTTlvbDdiS1d5cHA2YW1HbGZzNXFVZWZEd0J4UkFLZ1JCWUFjWTROaEpnZjZPQVdjUXlwUlVnTkZSMmNIYjNPMlI0NGRvekozZW1ZODNrTnVERmIxZEFiNTRyZEF6azd5anRrZGRzRlB1N1pOUEQ5TnpPY1VPbzFCaVljNnNZSDBsOUtFOXpiaTUxaHRrUEo1SzFjam91VUc3R0kxRy9QbnRTUVVtQ3BZWWhLVW1KZ1ZaN0FEOFhYeDhQQ09PdzZsQi9uUmNiNjFZM3gwT0pWcU5UZDBuWm83bW5FV256NXhsM25BMWs4K1Y3Tjl4L1lkN2FVOS95THN1US9RcjdSbWsxTCtrVUNEZmo3cFZIcWg0VlVMbVRtOVNVdlhMcHR3QmRzRGlNUU91a2pIcWdNWDZYQTVvbzZVWTlveDcxaDBaQnhMam1VSGtDSUxKd2hDc2cwbExyTUV1c2tZZ29ER3JRenBuMG4zd3o1SEd6ZkZxRnovdy9SUCtpZlNQK0g1SDNXR2h2K0ZGLzFXZVhhWU1aVFpuY3Q1MlZVanNRcnNTMjJBUm1GWm1naEZOYVZHbjZiYVJOUnRzN25wRDhXdDRzczhhM1I2UERhSHg0Tzg5TWNnRDV5RjU1dmdKQzB3dDdJYUZNZDBTdUtnUStMZ0ZuVFJha1NjYW1kMXBKcXZucXFlcXo1ZWZhYjZYUFhGYW9vNDFkZXFCUVpVaDJKRUNSbFFtWWdvSnByaGs1eXB1cTdabGM3TVN0UDE3ZG1zU1pET0h2SThmMEthTVN2cVhmTk1IZU5nN21aS1FxSkpPVVdEVXB5UnNBRERMVzhSNmhuaFJJdElJQmpSNnpsSmZteU1pQVpmS3QyMnlEQW0wMzl3WVNEZjk5SnI2ZUpkQ09QdlA4ZnkvTE5aT0w1L1QrbXViQ2VsY1dPOUZYQzFrdHBUYVRQVGdqb28zRlRXQlQ4Rk5LR1QrUThWc0VWMUJpcUtETmlRZ3l4cG93TWFIZVdudzBaUFI2N09KaDBTcFRtWjViSmUrRU1NSXMwMkZhaHp5WXMyaHhBTnljeTJ5MnR3eHBGaFZUd2U2cU1DVEN5eGRhZFBrOXJaUHdnSEpod2E2WlUvS09MMjk0K1Bqdzc4bE9mL2UwZGs5SitsRHdWZEFKajRnRFc5QjB4K1RickFvdUcyL055dnM3QjArbEZOK2NGUDhvT0Qwc0VYNXkzRnBWMit4ZDUzUzN6Qy80RzR0QWYzN2IzbmZYZnNQVDQyUGp3NE1qTGFQMTQ0Y3VwOWg0ODkrdENKMmQxQWdiZFBZU3pVTnB3dmpRRjVSaEZSS2MwWHRTS3BnUktUUkRqUXRucUx6Vnd3QmVkcTlEb0tjaUhTRjlicGRyb2pidDQ5NVo1ekgzZWZjWjl6WDNUVGRicXZ1WUYxMlMxdU9sZ255T0pPaWJVNkZWS3EzcDRvaWEvVXlYUmFxKzBibnQ1L1luZDNCOXZTTXp3eGxFeDBQNGxudGFmbjRUdnZmdHhLWHZ3djVpMnpNN3Zqak14M0w4TTZ6WUJSejFXZ2lhcWx5Y3BHdVR0Z0F3RlJWZFVlSVJ4M0E5SDVQYjA2UkRNbGU5VW9tT3JsZkZwbXEybUpuOElxdnlCdzFIZi9tZHdvNTZWYVdLT04yY21VOUNTRGNyOHF5aytTb2I5a3hNOGFNYUlpeCttTlFvUlM2WUNYU0FEUjJtMFRnVFJ1Qmh1Wk1ISGtrSGJrSnlqdURBMXBZRDUrakZtOEROcndtUW9uUVRiSWFKQmM1Ni9Vck5ZZ3FHcGNOZEdhVk0xMHpYek5ZazJtWnFsbXVRWVl0SWRiYVVUb056b2JJNDE4NDFUalhPUHh4ak9ONXhvdk5sTG9OMTVyQk9oYkdqVVkrT3dSSWdtdGxTMkdJWVZsTVJ6cDB2Z1BiQm5lbkE2MVJwTkdFSURjc2FqNzRQYk5ZK21XdHJiQlJJODczdVlodlh6YWNhVGY0UEZ5ZGxOOWRiWEZFMmxJalhnWCtnM2Vob0N2WG0veFJrWCs4SE8wZXp4V3dhYUhTcm0wZUpYTUo3TTBRVHZQelJwQUxCV01Id3lHVWNLcXpVNXp4TXlicDh4ejV1UG1NK1p6NW90bXVtcnpOVE9zMnNvWVJJdXBZTk5Mb0kzWWpFaGtyL3FkM2xFUVNzK2ViZlkwaGxwNllxU1dmNkEyd3hmWGZHNUxncEtydFgrbS9CZjJ5Y1VjcUtCNUl5czJLQmRSbnNVZzJhREU2UnVxV0pIY0NuWWJMWWYrYXhKU3FqMUQyQlJseDdTZzhNd01qYVl6SGFHSmR2SUFGV29HQm9ZSGZzWVgvNlk3bUJMc0ROK0RYeCtBZVpva1A3YUtKNmdvbFF4U3BmMHhaMkNRRWFqTWtQR1NSUTgvdnpWeXR2ZFN6ejJhK3p2T1IyRWVmUEg3SkNERU1kSG5zL2NqVHpxampwKzZsWnlnSFZKRlcyNXJoOHpWRUtTWENpTmt6aXAwcWV5UExYcDV0bnhFTlcxTktFTGFqd3dMY3o5cWlsM3F2UXVYOE56UTdNOS9McXpqZjNWS3F5bSsvSFBaM3dqcmFaQWk2VlRuRTVVdkZiNXF5aW4vdWthN25LbEcwSTRWanRJcTBmdEhCUTNxalI4aEtodGpTRFF5Q3N0eS9zV0Jya3ZKRDJRRzhoMjcyZjJ4UzkwZmZJelA5K3o2MTlNOC80blhlUDZ4eDNqK2s1L2srZFBDdmdCdHAzamhWMFcrU2xQM1FjTlhjU3RVQmxYWlBPZVRrZGtnV05MVm9sTE9YVVZqWkVGa2dJVlFpM0M5UmhTQmgxbGVqVXRrNzI5eXdYQmZrOHZ0Y2xtOVhwOVpMNk1XZWFENFV2dW1EbWRWVXFkMzkzWW9FVTNVZzJFOWFqdWxDczhyMlNtdGd1dEJnNzdmdi9ydE5PbUFYOFczTzhub3pObk80amRtemtxMlFtcFhERWt5ckVySFJvS2xROE9hR1pRQjBadmd4dGhXRURUOG1QNDFTT3g0Z0lFWEoySkorRXhpRDJqR3RpcjlTRGppZDNiSGtxbjJscGIyZ1dSUGo4c1hDUmNNaVo3WC9VNCsyZjk2UjZRdjBubWxIelRpd0pYZXZocEdzcHRtME5iWlVNRnVXc3Jwc0FMekFVckd6di95SGFiaVduRDZKaVgrNmpEU3dsSmhMVjJFcmdCRHpCMlkxR1lYVmlBRW5kTlY4U3VWMXZMMjdkZkNNSytBZmwvUHVKa0ljOVZBM1pOWE5jU2hiYytaTktJbElWZm5RQjdsNWdTaW5jRHNPaWVHU3ZQMmVrSnpjekJTVnUrSnV4dmF6T1pHbXk5aDlmUjZHbHJoYjRjM2FmMXZIcWZkYUxTMmVEWjdIRGI4UTVCeEltdEx6SG5BRzVvbk42Q1dBT2phODB2NlpUME5jZFd2NmpHY1ZPL1NSL1VwUFlhNDZtZjFoL1VQNldtSXE1TlNsMUlVdCtPc01qY3VRMDRwQWhhcFhQVlpXRzhSNUVjdnM3c0N0cXFzTnFyVEordHUxV0tZRXdiYTVTeDJ0Rm9Da2ZCMll5SVlEWXFXMDcvTUFLSXF2VjBEek55NStwblA4TU1EYVUvVDROREFNSC9zMlA0RDlxOWNheml3bjNVZFRGV3p4VDlpUStrR3pYN3lCK2FubnpjellnNEwydjlibUFjcStQZjgwUEFMVmpJYjdGZVBGU093c2t3aFIveFZZaUNla2NvcHhsVWp5aWxHbHpGcVRCbW5qZlBHUldQR3VHUmNOdFlzNUhwc2NKMGZSY1dzamNNQVBXdTgzR3hKYVI3NmJvVWdMaEJESXFIb0VIZDBadXVtL3JhZVdNTDgwck9hc1IvMEY1ZG5OTk9rYVNneXZjUC80S1NwcThNL0U3UFk5dlBzdnZPeHhJTGJpcnF6QldqNGx4Z1BFNFpkditvbnRZQnhMcHFDQWJUSnFhY1BjZW9qS0VKSCtIQWZ6VGJDSUUxbCt1WVRiZHM4bm0xdDJ5S0paSGliL0hjaThvMUVkMWN5MmRXZElGOFNPbWJhWmp3ZStCVzVMNExqbnUwZUhPenVUYVVrR1FKZzI4Ujhza0xralNwUnNBRWFEUlRRTG1weHVLcERoNEhKRlhDQnl1T2lBQWZsSjhCMnM1cUZheVpkUU5ldDB5eW9RbkZ5ZFEySUlrcGxUb2ZxUGFoMDlrTGU1QTZBVnBGdHdKTk90ZGxnZ1VhQU5hTFBNWUc4UnVuam9pRlQ0ZzhWeGFQbno1OThNUDU2MzRsN2twZTZUengwL3Z6NTBkOGJQWjlQeDM2ZjU3LytkWjcvL1ZnNk5zUHpNd0Q3TkVBL2czbXBlb0QrclI2bEVycGpTcWYyT2thUkRyRnhleWFkdm43OStySHIxNFhZZ2JVbGNpZmNwNWZaeE13TDkrbUNTN3RvbklPUDJJRjRkYUdza0wraVdkVWc2bWxjbXFnbXBabld6R3NXTlJuTmttWlpBNmhuOEhWUnd0SmtSL3JTTDdUR3NRWElJRm5NVVFUV095cUl3WERTSkVUVkM5S3l3eW40M3NQRUVJbDBESXdrWFgydG5ySE9BN01nSFdOSHdoT1hPdjRxYlBHM09wc2I4S09OdkRSVDR3ODFOZHNNRG4rN2YxT29LVGt3NFh4MGV6WHRzOWJRdnZHV0lEOHc0VHA5eU5kdTg5ck1odnE2aGphckQvN2dtTFcxTlZCdFFKYnU1L1JrbitnajBqRHV0Vyt5dndmMG51clczY3hkQ3BrRmFQNVZFekVBTm5WU2o5RFZJSWtJdHF6MzFwOHhneVhIMEYrSEl2U3ZDTGxOREExWnh3ZmgvdXFGajMvMXF4Ky84RlYrK1RmT0xpK2YvWTFsY25sdzIrRUhIajA4T3NJM1I2WjJ6azVPREpQNmw3N3lsWmRlK0wzZmUrR0pUMzNxaVNjLzhZbmlqWmI3N3p6OFBzK3BuYlV6MDlPN291Z0h5Nk1QcnR3UHBuS3U2NVYrTVAydGZyQ3FmMDgvMlBCUVAycDhiWDI5NlRjYS9lSDQwUFAzTkxtanJhVG9IK1MvR1l0RStyb2ZEZ2NhZ3FlR3ZKN0FIcHBYeXpCcDRCR0xYSmc4Z3ZtMGp6QjVrVmZhZ0Z1dE1Ub2g1NUNoTkdzSXZhM2tjdm90L2gveWVDM21KVnFxR0VyRHRTb2NTRElqa2wrdERBdmNJaFlFNERkUEVodkZCU0ZRTkhjb1FKUm93ZkR3SzVyZ3hmemtqZ0xvb3RtdVFqYkFaWWNLNjZPS1ZSMzZKTWZwaEx0SkYya25jcHhPT2VvODg4cjE2UGxvOVBLZUxaMER0VFpqdkcyZnlSZzFlMXhOZmFtK3JzVFFyVWowazFpTWRNU1N5Y2hRSGF1MU9QZkVnbzRKdjZXN3FTbmtmd2J6bXFtLzlVZXNCU0MvVy9LM1Vna1RaQ2NoTGkydDl0SUxNTnlvOWNtOHp2STNKUktiNkE4Zjh2dEQ5SWRjcGgxOUV4TjlnVWdrRUF5SHhiZ3B2NWpYU3EzVlY0MmtUc290VWVlM21oT2wvRlk5U0xtWTQ1cUhTN1Y4SmdQL2ZpVG5tdVNKQzlhbHpwTlV4U3pSMC9PcjVVbTJORmJPazNRVi84ZmRENGVqYmY3WXdGUjY2dGdkMzh4M2ppeDJlTDNHL3ZsZ1gzdmlSRCtqbWxPTGxNV0M0YWJTbkVMUUNORkRYSXZwZ1V6SVJSRXR4RzNFRWJ5eExFdC9kYTBnYWQ0K3IxSmtDYkdSbnNHK0FiODkwZFVVanZwaS9FUnFhblR2d1MxalBiK3crL3h1VDZmZjUzUWIyN1lFZTlyNlhTdzMzajFnb3pqbUJ4eDdIWDM2TzBINlpTUzVIdlZMdXlyV3RLSmtLQVVwcURVYzJmd2dHcWNBSERxbkxxTGpkVk82T2QxeDNSbmRPZDFGSFFXSDdwcU8rck5RUERBeEdJQnF3dzhRSWMxeE02VmM1cEwxSVJLeXA5T3VvYUVtU3NnMHpYeS9sODJ6ODhXM3g0WkpkL0ZsZm1pSS93Y3A3MUNJQi9Nb0xLT3diNmdab3ZoQmI0OGhoVlFGTXRQLzgzTUwrdy8rT0UwZFJZdnNqcTBUTy9oM1A4MHV2UHRwZ0ZHVXVjUThUM1JXUFdNQitGeGlna3hPWTlDMDU3czFJOERXY3lkQlE4aDNHMFlNOUc4RDVVSndqUU4wbkV0TURjRDFMaml4TWo2aDNLR1Q4aUdsa3l2a0R2TlM3bkNlSkdQRlpja3UvUnJaKzI5eDN0Y2pkN2FEazVOMzdKK2VtaHVMZDNYMjlQUzB4OG4rL1l0SDVnKzg3OTdEVzJhbUo2ZW14dFM4NERUeWd0T1VGMkEvdzg3VDJndk1COFRhQy9YNC9SblNzYlpkL1A0cDFmZGErajN6S0ZtVXZ5L2c5MUx0aG1mRjZ5K3ZiYWQ4RlhTam00Q0xOSmRzV2xnL3BvOFo4T0NCbXBZNzFBS0N1NUFWbHFjaG8xUlRFaUpLRFZKRUtXcEtnZG5BNGNCREFVd0dsTFBBSFBHU0F4enp4Q0pLRGVyTjI2U0YvZnc5MHNKQUZoTGlxUXFXTUZBUXVxYVAwcm9VRmZvL3RrNy95NnIrVmJuLzQ2citGYm4vbFhYdTh3bmFMK1JaMGIwQWJiMVJ5dVJZUDg5S0NsUzcya2k4UU5ycjBMQ2dzcXZyME5LUzY2NEQrSHZSYUdqcUZoSWV0S0xUVG5EUjBMQThzY2FKa0l4Vk1SOG1JYWRtL1V5VkdYTjE3SjJHSnk1aWhsWXBRK2JzV2ZMRm55SCt1WUZXZlp2MXdWb2p1TmE3Z0o2SmVBazZJNFZCcXhMMnQvUi9iSjMrbDFYOUszSy9CT01mbzArUmp1OFU3OThoaldmZVV2Ui9UT2luTmtqbXVxTC9aYkgvYjZEL08zai9UdkgrOG4zSUQyRmRWY3lmeWVmTWh6Z1FFM0ZBV0tjUXAwN3ZHeGZuVWJuL1krdjB2NnpxWDVYNzFmZGZrZnRmb2YxSXl3VDl0WmJXcG1DMEdrRnRsU3RqZ0c3NitjOUwvMEFOL2Z6bjJqNEgvNkNCK3NCMXVPY29ZNFZUSFdJK3FxYlJLaEtuNGlRbDBabkdqRGpNZWlFMGgzcXE4bGZjcTI2a2ZtNlhPK3BPdWFmZDgrNUZkOGE5NUY1MmcwQmc1Rlo4eUlaOFRsL0V4L3VtZkhPKzQ3NHp2bk8raXo3S2huelhmRUM4Ry9HV2t2ZUJkMHJLRnRYQWVadlRpdElocFpzUmpjTzlkR29yMzlYYXUyWHA1QXpmRTQxdkcrdit1K2pnM01IOHZrTWQvOUJLQS9RYk4zdTJUSC9vcVZkQ1UrNlpyUis1WjRETWVVNFcvMVBtMktGVThZcFBzYWQwTC9wVmUxZmUvN0YxK2w5VzlhL0kvYThJL1FvNk1GVENkZEZ2LzNHZ0F6YWdCQWNyUkFXck9MeWM4bWJISUNRcmQwdDRjQzVnSWxUbUVsVDZYTUF1Qk9lZ3VVNU9icEx5OEtnb0tJdlFORjNrR00wbG1Fdm52MFBUQ1E1aHlzdlk5T1NPbVVrKzN4YnI3VmdGWENOaW5NRTRzNlN3anFuaU05Y1hUalJLY1UxVEN1T3NGaExsZElWY21ERUtlbGMyaWc2MEVZcFBJNnNqaUU4anJwSG9TR3BrZW1SK1pIRWtNN0kwc2p4Q3VXbGNEaU1hWm5GcDlhekFUMHFPS3FWK1Bzenl3L0JCMWM3TW1jSEJRVmZyUUdocXl1andHRzJlU01UUzdMZnNuVzVyYSsvcUNiZUd6U0d2dWRic3FLdXpjNFk5UURKSmt0ZjJiR3F6anZXN1dqeFdnOUZyODNpdEJxdTN5WlVjTmZhYi9DNS9nN25hNG01eVdSdnM1dXBxenVxeGJFa00wdjNIMkV4Mkh2Wi9NKzcvRG5LS3FkUy9jNTMrV1ZYL21OeS9TOVhmTC9mdlUvVS9MUGZmUWZ0cExTb3FLd0FPdGpEZFRJTDVxc0tPYlZEYThtNGJ6WGUxaHpUOUNyRncxRUdkcThhUGJBL3lLUGRHSEx3NWgzQ2xUN2l5aWN1R1VhTnBMMURiWUl4NmRBUzVvVnpkVGloaUxCcjlKQ0pxMytGRUMwYlZrVCthR0J1ZlBoMW5wKzlLai81NWQzdlArSTZaSGZlNDJMNkRXM1lWZjZDZCtOcHpMYUV0UTdYRXFqM2MyMTlGdyszbTVzVHdWRDQwUG41MFBqSzgvVGRuZ3NHWkpqOS9lbUNBMXI0UzR0SUExbE1pLzdzczFjUUNPWmJ1NVJaeDd5djM3MXluZjFiVjN5LzM3MVB4UHpyK0hmSCtTdjVYNnQrcDRuT2wvbGtWWCt5WCsvZWh0RnlxaStLQjdWMnFFSTJ1TWdHcjRubFVoYVhraWlrMktzWGtTRDNHMG1CMElPT0ZYMDZ2VGZUNnY3ZVRtb2F3aCtGY2x6aURhRkdDWHIxVFNwUUg3aEQreU9UZy9KbHRVNEdSKzQ3ZXRXL3h3ZjN4YnRiYXQ2dG5mR3h5WUdoSXk1TnZKWUlzcjRrbnc5MUgzamoxR3cvc21ydkhRWFoyREIwY0d4K2QyWFZQWXdQMUM0Z3l3QmZ4M08wV3oxMXBUMTVDV082NVpXK1YvVHZYNlo5VjlZL0ovZXI3OTh2OXVPZVlFMjlUNlB4MjVxb0dqVFlZZ0NaWUFOUkJMUkhROTFzVTdkLzJPQjBlcjlQaC9tMXl1VmlVR3VNdXI4Zmg5SGcrd2ZOZkZ2K2s5VjdXL29hOFJQNXpCUmxCRlExbitMOGxJL0NWWlFRTW5uVWlGdWdkdGdmM3BhTGg1a2p5Zlhla1dpUE5VWDdNOC9tR3R2N3hwd1pIM0o5dktCdzU1ZVpkL2Nranh4NzFwRnlEL0FQVDBaK2FwLzVweC9iTjRYY3NlRFlFMnp6ZHR6dkZmZjVFeGY2ZDYvVFBxdnI3NWY1OVlqLzZYM0g4Z25pZlowVzc5amE1SnRHbktuajJWTzU3VmVDcjdHN1dZZ0dML0pYZ2FoQkJIblFGbzhGVWNEbzRIMXdNWm9KTHdlVmdqUlQ3cWs1dVlaQStpeUd1N3hHMEF5ZlNyZ28ya2t4M1ZydXM0R2FFMkhnYWI0VDVua0xRVVpLZHY5RnhhdTRJalRmaWFScEY4Y2UvTkcvWnRXVlBDUzc5TWx6MlViakk4dFJ6c2w1MVVhU0ZBcit6eVB4dXQ4Z0h5L1d3WmRYNEVwL2RnL3dSOURONDdnM01sd295VDFmUXo5QTlycXVrck1sRk1ZSm9VSzVRRk1QR2JTQnlMV2UyNllTSXJwV0dzdG9aVlNwZG1WY1gwamd5Yk9mc0RrK2dxZmUrUG5WRmpkWk9tN1UyYm9wR1p6YTlLTlRXb091SGRaNUNuaVdzZjRFV1BCQjBEZERsQ3JJdUo4bTlKZDQwcGFKcjVlTmZYbWY4ckdyOE5YbjhxNnJ4dy9MNHZldmMvOEk2OTU5WDZJcC9pT09qNHZnU1BmMVhkcDRMTTlQWXZ4OTFLRmJTOFJnTzVQQTdLbmcyNVhRWkRkYnM2YVkxZTdvMUlGMkxSUjZNZ2dOVzhLUnB4Y0lDTkZuQmc4S0tUNmlCaHE0elVmcE9ETEtTN0kzQmtlbjBOMTc2K0tlZi8xSTZ2ZmxrNXNITVpDYnpNMzYxVkE5amxaZDU4V1hreFMwU0pWYlJBMVdFbWlyN3ZHUVJwUFZSVWU2K0pkQ3dnZEtKaHRVR3BCTU5yb1pvUTZwaHVtRytZYkVoMDdEVXNOeFFRd01ORzhRMEREbnExWVcrd3hDTjVMQ0xnZjNxdkF5NmNHV2crMkk2cmNyT3lHVGsvSXo1eVZoeGpvL0hINTY3K3pIcjN0aGtzV2padG0zcnp1NlMvditjclA5ZlZNbEZGbGt1MnIyT0hXRjVIZmxxajJyOE5YbjhxNnJ4dy9KNENTY0YydXlUeHkrUWJ6UEsvSVFtd0wzZlZWaXJWWUZBNVNHZ1YwUEVKK1JodjdlUk5xZXZjWWs3dG9Hc0JzNkNXUTFOd2pVdWJxV0Y3bkxMYWd2dWNvdXJKZHFTYXBsdW1XOVpiTW0wTExVc3QyQytRam1SS2N0TWdhOGlnaGg5Y0ZZaU9FUEVFN2hUVGxQWlBEWVN3MHlWbHRGQmdmQTA5eWZZYWpsbnBmVS9ZdEpLaFgyNnNNNCt6WmRvZ2FoN3Q0dTA1aDFoUElVN2pwOHBweldxOGN2cmpOK2pHbjlOSHYrcWF2eXdQRjZtVFd2YmFCNnlQUDZBYXZ3UmVmeWRKVHdUNTlOUmJqc0FHZk1IMEw5TjdQOE13SUFWeC90QTlvb3dmOGlVWXVOVVVSZkdTZ1FBQStXa1JoTTBtZ3hLdWFHY05GeHR4bHAxVGJmYUZmSk1OVmNOdU5SRHMzMFVzWCtVbUFnQmFnNUJWaERvbmxCUE9WaklOaFp5UGMxa0ljODBjODNzQXMwRmJpbUEva1lqR1lYOEgyWGRsWVNxOW9vOVRuMVVySThhSm9RQ0xLVVNMSm5pMitRQm1oYTB1b3F4c21NOFAwWi9ucHljVk9URE5ER3ZWTWd4VUFYMHlsVTRhQ01BallBZ01XV1o2eGhaV0ZXcURKS3J0V0xrb3hYOVJXTGlyM0VqMlQ4QUd3b09Qd1ZIdHFrZ0pBaUxucmoxY2dEb2FqTmxlVEpwY2lNMk9SbDdvbjhpL1Q5NC92dWRvZUdmOHJ5b3ovMHAyZ3M3Ulh0aFNjLzdVOVFwM2hGMWlnNVpYM3dMNldpblNFZVYvUlo1L0c2eC93ZlFYMURZUzVmRmZscWQ2NDhWZXVRZVNlL0VYRnFmUEg2QnVhbm9wK2RudTdvZjlkZHI4dmhYU1NjajE5U0JNNlBPRlNuUEFOcGdyZ2ptK0lpNm5PQ1Q0c1RuTVYybCtZRXNPTXlKODJOMkNQMVllMGV3RjNlcDdjV3dIdFNqaVdTamtkZFBaVWNZM3kzU2cvOHM5d3M2d1U2eHY4UjNMdVA5ZTVSMmFsRi8vMGZvbjVYNy9mSjlmUEw0QXlWK0pOb0Jac1grRHNYOVMrTmZVOUFiQThwQ3d2ajlkTDF5TGhIMWM3bVowUW8xQTZWS1A0TE9TVGtLWnYwcE5ZYzZ1Y1lWVVNpZE9sVnBIZUwyT3B4ZUg2aWV4YitWeXV5UVBwZlBaM2Y2Zkg4bjE5c1I1dE9BT1VQcVhMRHlyS0ZmUHhmczkwdTVZSmhUUkRwS3VXQ2xtaFp5THI0cUxrdE9Pb2FINWxnYkZnN1U0RWRaeEpYd2xWSDRpcEVMNDhDNTF5ZkVkQ283YnhmajJRUnFkLzQ4MWg3Nkk2NlBXK0g1VDRmN3duOUIwK1NGV0RIbWF3QVRNM01rNTZrbEN4VlNWbkdXcXR4Y2VaYWNVTjZRQlNGV0kvNnRJVktFV0s2R2s2WW94bmNEMUtRcHdnVHhVRTFPcGpQd0F3ZXIxaFAzdk1IL2lUZnVMWDZmTCtOdnNYS2JPYVhMc2cxbFp3bHZSZjRaRS9IMmhueGV2b2k2eWU3eTg2SzYvNFYxN28veWd1Q0RSdjRaWkk0cE11T2svVk1WWktrWW13OTQ3Z2U4cXVWS1Btc3hKUzVucThMaXk0b3FFRDI5T2tjTWl6U3FDaDBwUzNDUlVYMTlkYkJab3loN0JKK3BTVnFRcTZGWlVmdUluSUV6MERVaTFPWWlBbjFDdWZKM0tsUnRWUVZzWXdxWEpHSmlzS0N1VEQybFd1aDc1L2lxaTZGb3hleXZuTVdMYnhyd2JrVCtCSUNZRll4TmtaV2tTSU1sU1pIRlNUbGlVdUpqa0F4aFpwaVVLbGI4aHBEK1dQS0hQU2Y3d3k0cWRNS1hrSS90VWVrRDVmNjJaZFg0a2sxdXp6cmpQN25PK0RuUmwwUEgvd3ZnbVIvazJNVUs3OWpBS0hwam1keGZFdWNvcHVtcDVZN2FYV2dTU0RmTnIwYVhya09ncmFaQ3p1YW9wNUFQNEdaZzVjcEtIdHlTOHFXSjhaTG1SUzZUdmJJejk0M3gzWTg4dlhSbSs4akg3a2luOTk1MThCRHJrMTI2dmIwWDN2LytqN1VYSjlOa0lIWHk2TkhIeGZjMlhNRDhnRmJnYXBjclJDbXIwbkhrMGlyeXV1bnEya2c5Nk03VlRsUTNuZHlLQlpISDRyUkVMTHhseWpKbk9XNDVZemxudVdpaHlHTzVaZ0dCMDRhRGN4N2htaWIwZEVjbzJrWldJNGkyRVZja0drbEZwaVB6a2NWSUpySVVXWTRBMm5aUWZSdjlRUW9QUUZ6cEo1RGlMZ0EyT2xSa2JMN1k1cmFqdld6ODZQVE80azNONk9iUjRkR3ArL3ZZNUpFOVI4YUcwNm5CeC9raFZxTmJBSEpkNk4zQiszZnVGTlNZd1pZOWUwN2V0MnZYOWgyZm5Bd0xlZmdpTFJMc1RjbGJmTnRheEowN1JCcTR0VXhtU0piemRKcVBKbzlYOG5UbC9TK3NjLzk1NGY1aUhTbzZuaGZuZzNZMEliOE14OCtWN0k0VnhyKzh6dmhaYVR6TTh3R2NQeS82UGo0Z2pJZit2VGovT1dYL0xmZS9zTTc5NThYK2tzeVRVdmxXcU16emMreWZGL3NYeTJTcVZBaytvaXl4R1htNVc4cGhYTDlxMUw5N3VobFY5MTM0cm9LS1dXZjB0UjJZZVRaeTl6SE1QT3NlQzhYS3M4L2c0Q3BrRktka3ZaS3F2S25wQ3dhS2k4WHFjejJVLy9mb0NCWXhxQ3FyMmNkeTRudHlSRGxPQ1B0T3lLVzVwSGp2REtncFFvR3VESld6djhhdjBocGRxL0NITE1QZnhEaVhTd3Avc2JFU1RGWEpYM0pGVlQydGxKMC9xZjBRY0tuY1RpM01lQ2VReGZ4Si9ZZjBRdldGYWdwK1d1cFYwRVAxbkdpQnMrRldiQ0IxMXNzWXBjdy96S2hMeVB1QVArSmVmSzVyS0Mwb1pabE1veXNRRFBYRTNzZWZ3STA0d2Q4dDVBR3FZa1A2bGJFYm90MS9UTGI3N3hMcy91TDQ1K1R4RjFYakxmTDQzYXJ4cGJpRFpkWDRrcjloenpyalA2RWEvN0E4L281MXhuOXluZnZQMGZHQ1RJS3lWYnRrNlZLZHBpZzBvbElEalJHU0dDTHIyckpsNHRlcHp1YlpXUEViRHoxcnVXQVQ1dFBWb1FNNVVwQXk4c3VMdXVrcldyN1VaZDZta2pPUzBXdU1WRmVYMTN6YmV0eWM2QkZ0WG9NZExCRXJ3Q0VjaFhoT0dZNExwZmdRVFIzQ2ZWQ2d0MnhZOHNteTl5UGNENGowOXAweWY4YVFTSjh2Vi9RanphcjhKU3Z5K0ZkdXNaRU9pM3hCeGdOYVJ3YjZENHA4WVZFeC9wbzgvbFhWK0dGNS9GN1YrTkw5TDZ4ei8zazZYcWh6aXpHV0FXYWtncWRaY3NGY2RWRk5EL1M5ZWlIK2dCS3Y2Z0l0VU9Hak5wbXNueHBaYUU2WUUwc0NtYWg5UlUvVHdnUnBFOU1tUDZTZjNlRzF1ODJwbUU3MzJPUEc2aDNUUGh2bmlYWHA2L3ZUWkhGdVFjdHJVMXRTc1UvZGMxS1gxRzdiL1I5aUZmbmNnWFg0bk5SZnpyY09yTU8zRG9qcnAzVkhNcGlmTzdmUnFpUC9QK3VOS0dxTUtFcUw0QndCTjI5aVBQS3NFUE91NnB1WCs3VFE5MlBzMnlQM21hRHZCRHVNbUZBdjlnV2hyOEErak5SR3ZoK3M5enpHNWk0d2J5bWU4VS9zR0ZKSmFaeWYzQ0JOK0l3NU1mNmVGTDlCYmdEMW9UbVBUZXI2YnJsWldnaWF1WjVqcUp1R3dWY3JhRUtSZUQ2MmY1TGN5RkE0YzNEdGE4cHJKUzlLYnBhaE5icmhXc29kR1ExZUMzejQ5Y245TVhhZVhsdThCdGQrRm12RmhkU1pFN2xacWtXVDYvaElJYVVYTHRhSCtMZ3pGSGw3SUwzUWQyaG9rTzNlbWNuc2xPN3pHWGFNc1lKRWZiV0tTdjY1MlNwMEtWRmV4blVMc1ZFRlVPUnpzMVFMcUVQV1p1a0dvWitLOXBSSXhWR2dwZHBWcUhqTjE5Ym9kQU1OTThFZkxwZTltVE94dmhhbnEzT0EvaExoOVJwcmdUVzd4QnB6dVZsQ015cnBTaW5JNE1ad1VJcmZ1SDZkdGNRRUdIOEZydmx0V0t0Y1QvbldlbndtMUpCcjZOMG91Q2tNY0IyNTJScThwWkNWR1JleU1vdC9wMnZ5QnhwMTNicDBQRDRFa21wVGMwdGphblNVNXI4UmVOWUJkcGlwcGJrc2FGc0M2Q2xNTld1U2xVWlpxb2RoaTIvQWRWbTJIK095QStLVjRqU29XQ2E4L2MvQTNXS09Vc1pIRk45dzJXMHV0OTNxK29MTGJuVzc3VFluVzJkenUrZ1RyZUluZmRaMzRWblBzZy9qczB5TW1DcWpvUWxtWmZkV2hIVVh2eHRyalhUMXRrVTdZemFMeldLeFd1eHNGSFl0Mk5qV0dqVGJIWnpaWnFIM2ZodnUvVDNFU1Qxd2dYVjgvVEtLZ21nbVltbFdVOGpOYWluaUNJWXVpcTRSK0xsdmZIOHNOcmFQb20wbW84TGJaSVhxYlVoTzhPNFVlUWwxRWlMNm82ZzRxOE56d09PZG5RVUpsUTBDS3NQZTFjSzlEN05IRUxjcW5rVjZBdmw0SGdSWWN1TXM0aFo5Z3hUanh0eS9TdStzbzZ1SXduQ1ViNHUvWE51MnRndTRvUVoydUhSL29INW94Y3JQc29kcExnZDlESDF4NDAyNExucWU0dS9mdzNXbm1ScDRRbHBoKzZFcHpRYjBkWmcza2lOQ2JUcmliZ0lFcEhkbkZmL2VhclBZL1I1ZkwrZnpwbG9kMXZmcmpmVVd5L2F1cWhaWGMydTFzTVlVUFArYjhId3pjMWdobCt2SzFRalpta01iRy9VQjBqZmowZHJwM0hVMEpKYkhCU1RpYWRrMU41dnViQlVGa25SYlhRVjU0NlByeUJzN1N2S0dhdnpIMWhtL1V6VitSUjcvaW1wOHZ6eCszenJ5ekVmWGtXZDJZRndNdm1zUE9HYlp1L1lhN1kxa3NiaDhVNjUvdE1vV0tveGhDKy8yeUdQSUtlWmt4ZmNtRXZyZVJLRGRKNk5UWTJ5WXZnV3c0dmhTN1hjWWJ3YjBnT0hrVko2K1o5Ry9scTMwemtBL2pKakYreUd2TzhYOExYMHZLdVgvWEJWWnpKVDNuOEQrRTJJLzNKUG9tR1BRZngvMjM1Y1I1b1h2b2NLY3Zra0ZucW5xbDViSDVlWU9DV1JFR1QxTTM1dEIzMXdtbGxRTm9VNGF2M25wVWhyK2tjdENQZUc4NG5sV0NhOVYxdWFLaXJNWU9oR29vYytvRWJST01lejNFR1VYZ1NwWmg5YWc2Umx0NUtXNENjbGpSdlBYOHBjdTRaemdWNXIvT1gxTkkveWljR2hodnNaOEcyQlp5NFNGektEY0lTd2FRSC8xMEY4UFlkTkE1MkFvejFKdDZZeTJkSFpHd3gyRWErM3VhbW50Nm1Kb3JCM05lZjluZkcrakV6aitYUW85NTVZOGZOckF0NW5TaGdFempwWHZ5NUpmb2lXL1ZrdCtnNVpRQ29OZmh6MVZmTzFqM3VkeStPQVA3NWVFSG9kWGVtR1dvK3lUa2V5VzJ0ZHVlVGRyUkhnM0s1eXR4elRUYTBJTjd6U1RCeGpxS042eW1FK1FBTHgxaGg2Y2ZQREJ5ZSs4OHNvcjB2bFNqTk15ZEJ3ZjRvRS9UTkp4RDZhRmdXU05RdkU3U09jYktsaEZwZUFwMkFvU0l0OHBYaHdrOTdHK2QzOEFGMkM4UzE3T3VWcTM5ci8rLzBqdGY5dityVnYyME95c2RGOVBkeUpHcXhvZjMzZjQ4TTQ3amg3ZGs1NmVUZzl1M3NTSU5xWTg2RGErVzk2TmFLejhia1JyQ0tCcmw5Nk5HTkhuODErTHBkUHB4eDVqSHlYMW5kKy9IdHQvL2p6NVRmSDlsZlFkUXEzTTV4WHVudkkzZVYzMWtRYVFTYXJ4cmNnK0xMN1FyYU00ajcvd3hUamkyeE10RkJpV1ZRc0N3K0t5UkMwcHk3UmwzckpveVZpV0xNdVdtZ1h4VlVrNkRQWnAyVkMwU1ZNTDFqeHQ0SVJDKzdSc0EzMTVzcUNNWWJvM1pkQll2MEVma3RrVnpTWWtaSFB0bUNWemJQTllmNmo5UmYvL3JQMHhDSVExZjlKMGZuaHEwOFE5ajNQYmJ4cE5IQmZiZDhKek1GbDdMbVkwV3JqWU9VL0tmZDllQWVhYVljd3piR2V1Vm9qZlFoK0lVWGxDVmJYUHBXeHdsQTZrQmhxeHBVWUVHaEhhcU9mV3IxNmZzOVZYbGZtRDZMdE9zRnBQTGloOGgyK2NvdW5QR0FtUmJTM2cyNXJMcTk1amxYU2huSTlWRHZ3VFg1eVZUby94cElNZlMrZlo1OCswUHFTcGpsMGFxQmxZZXBBOS9jRllUZXlWanVvZkVlMWtKak5aL0dXTU9JdC9SOHgvSFlzUmJhejRVMktNUVYvc2gzaDIzOEs4Y1UxWjNqaTUvQmJHRklobjFsSkZIcFhzZUt3UDZIMmMrVE9tQkVPSjN2ZENvN2Rpa1ZsVjVTQXNxVmhlY1ZabG9NejJicWp5N0hzV25TMnJPaytMa0dDeG9SempFM0xpb29XY3FaMHFlQjNyMWFVdHIwOXJsOGNJYmRaWHFsZWJ4L0NVTGVPdFVkNVEyOTZXdjdWNmJhbUdiZjE5STJ4YlBJalZiQ1c3N1R6VEtKMXBWZFZPVlQwdUZTaFZqa3E1YnFYd0tpUmhrVDdaLzYxOEl4TExpZTVvaG1xVVpqUS81Nis0VmwwSWJaZkxGWFdsWE5PdWVkZWlLK05hY2kyN2FKMWZMMWxRSmc3ZUZqajBtNXNpUVBiZXNYa283VzhiNnI2SkVSZ2xHRmp2UWRoZ1JJWVNCam1teEU0bEdHQzB3ZnJoemhXcmEwa2VKMW9RaDZFTFpGWVpYQ0JvSjFFbXhVd3o4OHdpazJHV21HV21ScFFPR0MxaWh1Q3hMeXVlTDd4QWl1RUlEVTBYTUVtQ2huV2Rjc1o4WE93Si8yVzhXeXhxdkhkTFcydXNCdjVzWVJ2VmhZME5obmYvR3Y3K3ZrRTZheGNBSHYzTVAxV29MOVVLalZhcG9YTDZOa09qV1dyMFFhT3ZJcmFvRGw0S0dpa2w2dlRCR3Z0dWl6b1VGWlJ2ZXFoVkZucW1PVDBiaURZM2hTakVtMkY4RDU3VlpBSGZpZGlpUUszM09uOXFsQ00zcERjWHFBNWlSUXlzZEJhVkdLbmVnMTlXME1URDBBaExqU1Ewa2hXank1QkdHcFEwVW1YSXUrVlZVTExuL3BiQ2NFbU1QWkRlWW1xWDNtSTZiWmlYWDNKS3lhSVJFUlFqa2FzNDFYdWpURkxsT0lkWXJGV01TSE54UW5XZkhOTW9IUEpPSUl3OWRITjZrVEJLU1B5clVrZWVuYWQ0M2luaS9pMzdRazhDT3k4aS9lM0pwTUVneG14OW1TMklNVnNSSVdZTFpGZU1sVUo5Vk03anhCaXpLaHJESmRwZnY0d3hUdS9nK00zaWRUdkY2M2JTNjZTNm4xZzMvZWxmcTI3NkJrdW1iNnhhK25zVVN0ZnlWVFhOalNKTkdVODNoOG1OVVFLd1V0Q1RPdEhYeVQ0RmE0b3dNYUIvdDJJeFNvd1ZDMFNybG9qY1JXckk5U3Bsanc1dHRHRGRzZndWYnBYRHhYTXVMc3FsdUdsdW5sdmtNdHdTdDh6UlEyK2xlRVdKaEEzcmlWUDNEYkFmTVZyVUlUSVlMQmhENWNjMmtJeTYwU1NwZk5YQ3VtQ3hsb3Jia29NMThsc1laQlFVeUc5YWVrMERKcDNnYXhsMGhqSmEvTzQvQ3U5dEVHR29lUWhnT01Kc0pScEZMTGNFTnZSd1NZMTJhTFJYMUxueGlFc05USCtWR2ozUTZLbVlacWw2WFJ3U0dacEh4WWhLTzVGZm95Qm1sUmlRUElQQUxyakdoTHFoTlZJbU1FTkxzYmsyOHBLdm5LbUpiaE1RNk93ZzNJUExqaGV5NDkyMHlQTTBSdmh2bkFSVTJqamxMbjE3WGNxZzNyNmI4cXMxTHQrV1RLZzJ0UGlxdUlsNHRqVXZ3QjV1STNzcm5JSithUFJMalMzUTJGSlIyRkNkQWhWem5ZREdSRVV4UkpacVpaNGhOYkEyR2QxT1ZyRGlxUVFPN1VZcTBsQkJSQ25oYnNHVXVmd1YzNm9QTC9LNWZGRmZ5amZ0bS9jdCtqSytKZCt5cjBZb3hrVDVyVkNjM0UxRGlLZ2VFa1U5UktwU25tM0ZDazJkQmNxY2U2R0hwdGxtNHdWQk9BQ1ZjaFI0eENhS0pCTklxOVlOWXY2MTJFWlp6UE43c1JEVml3TTJ3a3hrdnhQbDc1WXcrWkRnaDJVTFVyOW1OK1VYUWoremcvYUxmdTU1U2dlSStGNGZQTVFTcHNTaEVaY2Fxc1JwM0dpcE1ReU40ZHY3OG1TNVZzSVUrYldhRy9MeTVaaGgyS0xoMjBUa1VsVkl5TndSeEZnN0o5RGZIT09ISzBQY1NodkZvcmJWTnNTaU5sZGJ0QzNWTnQwMjM3YllsbWxiYWx0dW94U2lrMjUrRjR3Zm9QR09Lb2Zpcnk2K3NmT1NCL0wyRWx6Sk8vbWVZcHhraDJFMFQrTTdFU1pKZTRWcUJhcGQyd1NOVFJXWm9TcUpZdjM5Vk5ueVZWdW9lcTBBTW96MVhyY2dCT0FJRzdacEkrL2N5REVlRkNoRUhtcFZ2M3lnUVRyZklWWE1BN0JyNFh3TGV3aU1kd0FPOUJBUnNLZnM3UTYvdmdTb2ljcHZnM2o3UFEreTlLYUlEY3VFMGpzZllILzdtTC8rOWZWR05BeFZwTjZsS2hYUTZJWkc5NytMUnBuejF0aXhGQ2NucEllSWRpR2d2bDFJZldPM1ZUSnZRM3ZMOWM1eXducXJEbm9MTFdVVU1ReVVWajZwakZsQm1uZ0VhZVdUQXEyVTZ0RUllVlVnZC80UlU5SnBURXFtYUZBeXhWK0JJbTZRQ0lZQjhPSGJFTUVjNDhCQ1NTdE5kQ3ViVnB0d0s1dGNUZEdtVk5OMDAzelRZbE9tYWFscHVZbHVaUXM5RTVXSjNLMjRUeGFWeEV4cEFpa25Yd283aUNpclgwQWJTSmVFelNvcEJabEtSU1ZUVmJRRHJaVHZyV1JLQVZkcUpkTy9JU1hUVkVjMnBHbm1HRGVNaVhBcllSalRodkk5RXAzYktKVXlXbHRWRkdoUlNUMUViUDVMaWJaVUlCaWlRZVh6RWszQldCRjJIckMxVVBKUHk3NXZ6WFU4cmFVSUVZenl3QmdSdU9ZMTVUV1NUNXVHbHBnWVZXUklRYmltK0FaY2s0VnI5SXkvOG5PRWtveUtzSkR4NGNYWWZhUGo3S2RuTXBtWnNudDQxZkVsTkxURUpJU1dLSnp4MGcyZUVXNUFpdGZnK3Mrd3E0d1ZkT1dTR1JHdVIwcFVGbHJ5NjBTVlhDaEZsZEM0QmZxOHo3SXI2dmdMaytSbjIyRDh4VFVwL3VLaUhIL3g5QzN4RjhJK3ZzWStoLzVYTVliRkpNV3dLTUpYbm92QldORDcxeTRESEkxU2pUL0pKMG9aN3kyQktYK3JhL1lIUXJwdTNYQThQcUpsQzNKZ0N1N0pHdHpyQUhzTjFtaTlaWVhxVlJYWFBEYWJoLzZ3ejhqdlp5cCtseDFaZXhibVFtRTBwY2plRUlKbjdEU2xuQ0tIU1hVRVRlckRwMS9JMHpNSkJLN2JYdjdVOTRvM09WY3AzZ1RXOUQzRWJ6M1FuWW9ZVGcyQUxDZkVNWWxSSlNmR3hLaVNBbzBxb2Vka0cvbkEybis4YlJ6SEpTR09BM2hHQks0NGo3WFVqakVaSVE2Y3hnZEQreXh0TXp5dE1jaGVnSFlka3hic1Bzd3F0bzNZVHN2Zmo4amY1N0U5SnJlRjd3K1Z0ZThXMnN3YWt5ZEpLNjJGTzBuOWxvY1FjVVRiMFcyL0k0djBPM0p2cGUvWUFuNTN2TUozR1pyRENOODl3cVJoRFRsT0p3WmR3d0RWOTZmRjcya01WUStqK0o3bWttUGQzN1JacVB1YkJoektjVFFVdW9mKzRtcnBYN1hDSTlYWG5NWnJUc3ZYU1BmT2NkVGgzbE1sWHZPL0FiZ3RJL3A0bktXVXkyN1RRQlNHZnllOTN5Um9CUkppTVVLaWFsRTd1WlNDbEYxYktXcXJpRklTVld4TjdDUldYZHZZazVxK0JVK0F4SUlYWUlmWXMrQUJ1b05YNEEwUS8weUdOaTBGUlNLVzVXL0c1emIvT1E2QSs4NFJIQXgrVHhCWmRqQ0R6NVlMbU1TNTVTSWVPbzhzajJIRzZWZ2V4MTNudmVVSjNISytXWjdFV21IUDhoUVdDKzhzVDJPMjhOWHlMUGQvV3A3RFlyRm1lUjV2eHhMTEM3ZzMvcFRabmJGcHJrSlRpV1lIUy9oZ3VVQ3JMNWFMMk1kM3kyTlljcDViSG9kMFhsdWV3QVBuaytWSnZIUitXSjdDY3VIVThqVHVGRDVhbnVYK3VlVTVMQmR2VzU1M1JQR1o1UVU4SG5ld2d4Z0p6cEFpUUJjOUtBaXNvSTFWUHFzb280SU5ySkZiZkovU1Z0TVpQWHprWEtVNFJzYTlCdjA4NDVtYlMzSTlzSmVNRmVPRThTU3dFeWRuYWREdEtiSFNYaFhWY21WalRiU0NOQmF0czhUUDQvUTRFdzNsaVpVOHo2WGl2bXpISjZ2MGExSkdGNjlNZWwxUWdqZmNETjFYc2Foc0pPUVhyS2VMdmpGTHVmUzcvZEFsakZLMVJJMThVNHJha0FiNHMwNVpFNWMxMU14eFJpajFpRVdrVEIvUUpESkdraW1xcEcwZUlLQzdGckxNYTVPQmNPU25XUkJIb2lMTFZiSGREMEpQbE11YjduQ2kzMm5Xcjh0ZzB1cXM2eGVDREpjWEdCRmMzb3JXTHZQNmJKUnI1QkcwNkl6WWRxbGJPemhpa0FsWHFOVDEvQk0zUFJaeDU0YjJTamxxWDI3U0hQeGFZczZwbG02WFIvWG9vWVhFZnR5THhHN2Z5Mkl1OUJ3cnhxMmh4T3R2TTRtZVVrbXRWQm9ldC8vemJkRjdJR3ZkVktYTVpHa3BGYU5vYWYwTDRVTSsyMXhIWFBtbTZYMnlaOFpEdDZSbmJKdllveDRDQjBhbDZFcmt4cFVJK2l1OWFiajBMWVlxdTVyM2NneE9lUWQyUEVMekp1ZGExekVZa2pxMmNHaFltUy9qcWs0Wlkrci9rSVI3R1RObUpwWTBYZTN5L1FIOUd4U294eEdweDVFU3piaWpjamYxOWN5RVFkdVBNdDhUL2NqelU2RjZ2bWp1TmNSQjRrY0Q0OGJBWUUxY2ZnNFZLVXd3NjJ0Rzc5UU5PSWFoTC9KQTlUaUo5YTFENGFxYXNMM0sybW1RcUV4bVFTamp0RnM2cURldXQzdkVZL3dqNEMrN29VWU5BQUI0bkcyVkIzUlRWUmpILy84MlRXalRzc1V0d3dHSTFDU2R1S0FqbEE1YkxBMFZGUEUxZVUxZSsvSlNrdmNveFFIS1V0eDdLOE90TEhFRDdyMDk3cjMzbmtjOXJ1VGRhL0k0eDNmT3U3Ly9kOTgzN25mdmV3bnlZRi8vWElrQS91Zmloc3lBUE9ZaEh5NFV3QTBQQnFFUVJmQ2lHQ1VZakNFWWltRVlqaEVZaVYwd0NydGlOK3lPUGJBbjlzTGUyQWVqTVFaak1RNzdZai9zandNd0hoTXdFUWRpRWc3Q1pKVGlZUGpnVDFjdlF6a3FVSWtxVkdNS0RzR2hPQXlINHdoTXhUVFVvQloxcUVjUTA5R0FHV2hFRTVyUmdpUFJpamJNeEZGb3h5eDBJSVRaNk1UUm1JTzVPQWJIWWg2T3czd2NENFg1V0kvbFdJRWR1QmlmWXlYT3hobTRDamZoV3Jxd0dtOWlHUzdBai9nSlo3RUFwK0ZodklzZmNEVnV4aS80R2I5aUhUYmdTVHlPamVoQ0dPY2lncWVoNGdrOGhlZnhESjdGYy9nQzNYZ0pMK0JGYkVJVTMrTTh2SXFYOFFwaStBcmY0SFQwUUVNdjR0QmhZQTBTV0lBK0pKR0NCUk1MMFk4dnNRaUxNWUFUY0JKT3hOMVlpeVU0R1V0eENyN0d0N2lYYm5vNGlJVXNvaGQvNFc4V3M0U0RPUVQvRUJ6S1lSeE9jZ1JIY2hlTzRxN2NqYnR6RCs3SnZiZzM5OEZ2K0oyak9ZWmpPWTc3Y2ovdXp3TTRuaE00a1FkeUVnL2laSmJpRDd6R2crbWpud0dXc1p3VnJHUVZxem1GaC9CUUhvWVA4UkVQNXhHY3ltbXNZUzNyV004Z3A3T0JNOWpJSm16R0ZqYXpoVWV5bFcyY3lhUFl6bG5zWUFoLzRtTjh3dG5zNU5HY3c3azhoc2R5SG8vamZCNVBoVjBNTTBLVjNZd3lSbzA5N01VMjZvelRZQUtmNGpQMmNRR1RUTkdraGRmeEFkN0MyM2dINytNTnZNZUY3T2NpRG5BeFQrQ0pQSWtuY3dtWDhoU2V5bVZjemhWY3lWVThqYWR6TmMvZ21Ud0x0MkVyN3NSZGVBUzM0dzQ4aWxQeEVGYmhGanlHKzNBL3R2TnNuc056Y1NhKzQzazhueGZ3UWw3RWkza0pMK1Zsdkp4WDhFcGV4YXQ1RGRkd0xkZHhQYS9sZGJ5ZU4vQkczc1NiZVF0djVRWnU1Q1p1NWhiZXhxMjhuWGZ3VHQ3RnUza1A3K1UyYnVjTzNzZjcrUUFmNUVPdTFsQkxpOGN5TkordnhpZFpMMWhiNGFtSksrRmt3dkFvZ3U2YXJxUzZVSFVyTmp3MWlXakNVSHM5aXFDM0xxd2x3MWE4VzFjWGVjTTVYVlFYU1poS09Ld2FabEU0SzkzMVlTV1RNaUpRbjg2dm1KNmdMS2pLZ2tGUlVMVlJGTXdsVXJQU0U1VExVQVhkUVpGUnRlRnRjQ3dxNmxoVVF5NVhOQ3VMRzhLSmVGeVJSdFJoZUdjNDhzUnkyaldqUzBtNll1bkIzV2hxZWtSMWF6WThqYklUVFhiU0tEclJ4TlkxeWpWcmdubU5UWGxhajdmSlVhTW5wNHVibmF2cWRSanVGaVZzbWFwYnQxSGM0dlRUZC9JVGU2TGJjTFdrRzNicDZjSGRLdUlORWQvcWpEZWM4YTBpM3JDUkh6U2krYW9SOWJUSkhoT3l4emJSWThKR1NWdk1NcUpLMG9ycmltV1dKSnlXdTEzVVRZcTY3YzY2U1dmZGRsRTNLVEJMUktWc2VHYzVkaXVWMC9iTDY2OElDbFlHQnBsaE5hTHB1dUx1RUZsTXNRa2RtWU16TXdjWEVnZG5pWU1MeWFZczJWUklOR1haS0FnbE5TTmFZR1hHa3RCT0RWcE95eE9TQjJ6SmI2UFRzZGgraDU3ajBBTTU3WjRyV2wxc28yaHU3bVZkbkh2eDdRYW5CR3dHL05YRktlYzJkamdOMDJFSTk3SXFtMlUrbjZSZk1pQlpKbGt1V1NuNVgxeTFaSTFrcldTZG9GL204VmNJQm1SOFFNWUhxdDJkMGFTUzN0aCtnVTdSY0wrTndzNklwaWJWbEpZcTdQOVB1ZWNJeHdFYm1Td0JYNVZQc3R3VnRKSUoyd2o0Sy9LNzUzZW5ieTE5NndWcFBWK3pSOTFyNzFoWklOTnVnVmJhMGQ0c1o4b3lHMUhRWGFyb1pqcW15L1lXWTh4cng4dWZGbHYzMkEvRTJKdDJqeFZtSFZ5WngrbXB6TjNybFJ0Y0dsYjZwUFk3ZE1DaDZ4eTZ6S0dySGJyY29Tc2R1c3FoYXh5Nk5xZjlGUms5UkYwVTFwVjRKTkZ2cE0yVU9teUJwYVpNTFdGa1p3YjNLVW5WME5WdTB6YUgyR1pTaThhRVBiUXIvYjMycW1iV1laaWN5TGtNenN5b3VReTJtWHZzalEzMHhWUlJyRmorMllnSHFoRlJVakdwNDFrOVBHcHBlaXI5c2VuWm5DT3lVN204dHB1dXhoUG16bTcyVk03dFg1bmdJQ2tBQUFBQUFBTUFDQUFDQUJRQUFmLy9BQU40bkdOZ1pHQmc0QUZpTVNCbVlnRHlHTmNBU1JZd2p3RUFDd0VBMndBQUFIaWNWVkxaUzlSUkdEM25OeTVqaTZodDBvTU5LVDNWUEVSRmlHam1JREhOaGtpRVJEV011ZFJvNGhhNGphUGxWcGtQMGx1YjdRdTAvQWU5OVZmMDBGTkVSQWdORVpHZDN6Yy9TaC91T2Q5eTczZlAvZTRIQXRpRUVYd0UwOG5CWHZpeEY0Vk5qYTBCQktQeFNBQjFzVWdvZ0hCTFBDcTd0ZVZrQUczQTJocDhPdWREZ2RsQ2NJUG4yb1htQ2VHWVg3UWhXd3gvS2psd0FRZFRxWjQrSERXczcraFBwaEJLZDNjbUVVNWZUcVhSWW5qYThLemRVdXpkNVdMK1hyL2RVT2pXbDBkREdEcDYyVTVVWVIrQ09JSjZOQ09HVTZxVFA1Znc5dlo2UE9uRnIzcTg3SEZPbGYwZ2IrZjNPVlg1dUhQZTdxYnpRVnhsZDIwM1RUOWtCODNLeVlxWmpnT0lDa3RSd0VZZVp4TkRicDU3R0dBMWEyUVg4YkJwajJwVjVPc3E3K2pNaU1WZHJXM1NVUUg5QzJyMWtvVHR5R3JGRWRSeXZXbnpZcDZYVlpmK1ozenI0czYvYU40cU1uMUxlQ1B0T2ZrcnBxQWNOZGlQUTZoRENCRzA0Z3phY1JGOUdNWVlwakNIUlN4elVuWERTUEM2Y1p3THhqSE9HK2M0Wjd6S2pIR1VzOFlSemhnM2Mwa3ZqUE9XMnljdUNuTzhLVnpsdURES0c4SUlKNFFKamduRHZDWnN0bzZFdlJsd3UxVnBQMVBpeGFuK3VOTlFnczNZcXA1WDR4Z2FrVVFQaGt6N09ETDY2NnhlK1ZvdmZvdDNlSy9wLzRUUCtJS3YrSWJ2NnNGUC9NSnYvRkZCaHdYY3pRWjJzWnVYbUdZL2gzbUZHVTV5aXRPYzRTem5PTThGZGNEUm5KWHhIdS96TVI5d2hRLzVpSGY0a2svNGluZjVsTS80bkMra3JneGJwS3NjRFZKMVRycmFOWUY5bU1BVU85akpBUTVxVDVmTjB3bTlvblRkQkx2ZDNpWmZ6Q0dQUjhVWmkxZTZySGllUjhVKy9XS1pPT3ZsczE0KzYrWGR5ZHlCWFRaL3RmbnUvUVZBZlpFQUFBQUFlSnkxMU10TFZHRVl4L0hmODg0bzRzQXdEYllURWNWTlJMVkl2TGRReE5SMklrSVhNVEZRSEFJamRSYXpDTHh2K3dOQzBDeXRqUEpTNHRMeGdvaUlpSWlJaUlpcmlGYlJidnJPR1kyZ2NCRTBQejZQWjk3em5uUGU4NXc1eWlSbEtrZFhaWkdIVHg4clEzNUdsRWdvdWNjNkh6MUpqaW4xalgyT2IwNlp2bkdaTCtMTnZheWJwTldlMlhQYklOL2RyRHQyczdiQjMxbHZKTGwxN1BQN2JpbWc5TVN3QXVoT3hOV0RXQ0p1N1lsaDYwQW5JbURjZXBsVG8weG1oTmdLbzREdGF0VGdObXBSandZMG9nbjMwWWQrREdBUVF4akdDTVl3anBlWXdDdTh4aVNtOEFadjhRN1RtTUVjNXZFSm43R0FSU3doam1Xc1lCVnJXTWNHTnJHRmJleGdGM3ZZeHdFT2NZUmpuT0NVdXc0aWhEQ3lrSTBjNUNJUGxlaWlROG0xKzFWTUxVVVpLaENrVjNGNkZmZDZkVkVmbHM3V3ZlcWRMODR2SUYvbDZrWVBZdmlBai9pQ3IvaUdIN2grWWYvdjRoNGUvRU0vLzNmZmtqMEwvSEdmN3krNDF3eWxVWU9LY2xTVW82SWNGZVdvcUhHMDlYcjdralBTRWZDK2xaL04vSFYrYTBjSE9oSEIrWkVCRlZENzBJOEJER0lJd3hqQkVwYXhDdU10Q3ltc0s3ckJ1MWFxTXNZcVZLZFJLN1FpSzdGbWE3RldhN09ZOWRzTE9kdjAzc3c3bW1kOTZmcjdKK3E5NS9HVTgwOXFPeEZQaFUyblN5b216cnVxajZ0V2NPNDZZaG9sZnN1M2ZLNVlZQVhVUWl1VWp4VVZNVjVpSmRRcXEySzgyWm9aYjdFV2FxdTFVdHVzamIweGk4bFljejluYzdyR1d0TlpjWUNrY2I4aHJoUW1mbFVUNC85QkxiUHFpVk1EY1dva1RrM0VwekZOTW1kSzA0ek1FS2M1TFZBWGlSUHZLbnRYaUdtTm1OYUowd1p4MmlST1c4UnBtemp0RUtkZDRyUkhuUGFKMHdGeE9pUk9SOFRwbURpZEVLZFQ0aXhvUVdySVF0U3doYWxabGtYTnRtenVQTWR5cUxtV1M4MnpQR3FsVlZMYitaMmtXU2Uva2pUcnNpNjZNMkVUbk5Qb1FMSFgvZFFUejZmWHFhZGU5ZnR6L3duMjV1RE9BQUFBQUFBQkFBQUFBTlFZRmhFQUFBQUF6dWxwaHdBQUFBRFBybVE1XCIiLCJpbXBvcnQgeyBDbGFzcywgX19ub25OdWxsLCBhYnN1cmQsIGFzLCBhc3NlcnQsIGNsYXNzTmFtZSwgY2xhc3NPZiB9IGZyb20gXCIuLi91dGlsL0NvcmVcIlxuaW1wb3J0IHsgZmxhdHRlbiwgbnRoLCB6aXAgfSBmcm9tIFwiLi4vdXRpbC9BcnJheVwiXG5pbXBvcnQgeyBDb25zLCBMaXN0LCBOaWwsIFBhaXIgfSBmcm9tIFwiLi4vQmFzZVR5cGVzXCJcbmltcG9ydCB7IEN0ciwgY3RyRm9yLCBleHByQ2xhc3MgfSBmcm9tIFwiLi4vRGF0YVR5cGVcIlxuaW1wb3J0IHsgRGF0YVZhbHVlLCBFeHBsVmFsdWUsIGV4cGxWYWx1ZSB9IGZyb20gXCIuLi9EYXRhVmFsdWVcIlxuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSBcIi4uL0RlbHRhXCJcbmltcG9ydCB7IEVudiB9IGZyb20gXCIuLi9FbnZcIlxuaW1wb3J0IHsgRXZhbCB9IGZyb20gXCIuLi9FdmFsXCJcbmltcG9ydCB7IEV4cGwgfSBmcm9tIFwiLi4vRXhwbFwiXG5pbXBvcnQgeyBFeHByIH0gZnJvbSBcIi4uL0V4cHJcIlxuaW1wb3J0IHsgR3JhcGhpY3NFbGVtZW50LCBQb2ludCB9IGZyb20gXCIuLi9HcmFwaGljc1wiXG5pbXBvcnQgeyBEYXRhRWxpbSwgRWxpbSwgTWF0Y2gsIFZhckVsaW0gfSBmcm9tIFwiLi4vTWF0Y2hcIlxuaW1wb3J0IHsgTW9kdWxlLCBwYXJzZVdpdGhJbXBvcnRzIH0gZnJvbSBcIi4uL01vZHVsZVwiXG5pbXBvcnQgeyBBcHBsaWNhdGlvbklkLCBOdW0sIFN0ciwgVGFnZ2VkSWQsIFZhbHVlLCBmaWVsZHMgfSBmcm9tIFwiLi4vVmFsdWVcIlxuaW1wb3J0IHsgzr0sIGF0LCBuZXdSZXZpc2lvbiwgbnVtLCBzdHIsIHZlcnNpb25lZCB9IGZyb20gXCIuLi9WZXJzaW9uZWRcIlxuaW1wb3J0IHsgRXhwckN1cnNvciB9IGZyb20gXCIuL0N1cnNvclwiXG5pbXBvcnQgeyBHcmFwaGljc1JlbmRlcmVyIH0gZnJvbSBcIi4vR3JhcGhpY3NSZW5kZXJlclwiXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSBcIi4vUGFuZVwiXG5pbXBvcnQge1xuICAgRGVsdGFTdHlsZSwgYXJyb3csIGFkZEJvcmRlcl9jaGFuZ2VkLCBhZGRCb3JkZXJfZm9jdXMsIGNlbnRyZURvdCwgY29tbWEsIGNvbm5lY3RvciwgZGVsdGFTdHlsZSwgX19kaW1lbnNpb25zLCBlbGxpcHNpcywgaG9yaXosXG4gICBob3JpelNwYWNlLCBrZXl3b3JkLCBlZGdlX2xlZnQsIHBhcmVudGhlc2lzZSwgcGFyZW50aGVzaXNlSWYsIHNoYWRpbmcsIHNwYWNlLCBzdmdFbGVtZW50X2ludmVydGVkLCB0ZXh0LCB1bmltcGxlbWVudGVkLCB2ZXJ0XG59IGZyb20gXCIuL1JlbmRlcmVyXCJcblxuaW1wb3J0IENsb3N1cmUgPSBFdmFsLkNsb3N1cmVcbmltcG9ydCBDb250ID0gRXhwci5Db250XG5cbmV4cG9ydCBtb2R1bGUgVmlldyB7XG4gICBleHBvcnQgbGV0IGRpbWVuc2lvbnM6ICh0ZzogRXhwbFZhbHVlPEdyYXBoaWNzRWxlbWVudD4pID0+IFtudW1iZXIsIG51bWJlcl1cbiAgIGV4cG9ydCBsZXQgZGVmYXVsdERpbXM6IFtudW1iZXIsIG51bWJlcl0gPSBbMzIwLCAzNjBdXG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXNlIChyZXNvdXJjZVNlcnZlclVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBNb2R1bGUuaW5pdGlhbGlzZShyZXNvdXJjZVNlcnZlclVybClcblxuICAgICAgLy8gU2hlbmFuaWdhbnMgdG8gY2FsbCBhbiBpbnRlcm5hbCBmdW5jdGlvbi4gV2lsbCBleHRyYWN0IHRoaXMgaW50byBhIChyZXZlcnNlKSBGRkkuXG4gICAgICBjb25zdCB4OiBzdHJpbmcgPSBcImdcIlxuICAgICAgY29uc3QgW8+BLCBkaW1zRXhwcl06IFtFbnYsIEV4cHJdID0gcGFyc2VXaXRoSW1wb3J0cyhgZGltZW5zaW9ucyAke3h9YClcbiAgICAgIGRpbWVuc2lvbnMgPSBmdW5jdGlvbiAodGc6IEV4cGxWYWx1ZTxHcmFwaGljc0VsZW1lbnQ+KTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgICBjb25zdCB0djogRXhwbFZhbHVlID0gRXZhbC5ldmFsXyjPgS5jb25jYXQoRW52LnNpbmdsZXRvbihzdHIoeCkozr0oKSksIHRnKSksIGRpbXNFeHByKVxuICAgICAgICAgaWYgKHR2LnYgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0di52LngudmFsLCB0di52LnkudmFsXVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICAvLyBQcmVmZXIgZ2xvYmFscyB0byB0aHJlYWRpbmcgcGFyYW1ldGVycyBldmVyeXdoZXJlLlxuICAgbGV0IF9fY3VycmVudEVkaXRvcjogUGFuZS5QYW5lIHwgbnVsbCA9IG51bGxcblxuICAgdHlwZSBMaW5rID0ge1xuICAgICAgZnJvbTogVmlldyxcbiAgICAgIHRvOiBWaWV3XG4gICB9XG5cbiAgIGNvbnN0IF9fbGlua3M6IFNldDxMaW5rPiA9IG5ldyBTZXQoKVxuICAgY29uc3QgX19zdmdzOiBNYXA8VmlldywgU1ZHU1ZHRWxlbWVudD4gPSBuZXcgTWFwKCkgLy8gbWVtb2lzZWQgcmVuZGVyIHdpdGhpbiBhIHNpbmdsZSB1cGRhdGVcblxuICAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlciAoZWRpdG9yOiBQYW5lLlBhbmUpOiB2b2lkIHtcbiAgICAgIF9fc3Zncy5jbGVhcigpXG4gICAgICBfX2xpbmtzLmNsZWFyKClcbiAgICAgIGFzc2VydChfX2N1cnJlbnRFZGl0b3IgPT09IG51bGwpXG4gICAgICBfX2N1cnJlbnRFZGl0b3IgPSBlZGl0b3JcbiAgICAgIGNvbnN0IGc6IFNWR0VsZW1lbnQgPSB2aWV3KGVkaXRvci50diwgdHJ1ZSwgZmFsc2UpLnJlbmRlcigpXG4gICAgICBlZGl0b3Iucm9vdFBhbmUuYXBwZW5kQ2hpbGQoZykgLy8gbmVlZCB0byByZW5kZXIgbWFpbiB2aWV3IHNvIGxpbmtzIGNhbiBtYWtlIHVzZSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgIHJlbmRlckxpbmtzKF9fbGlua3MpLmZvckVhY2goKGxpbms6IFNWR0VsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgIGVkaXRvci5yb290UGFuZS5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgfSlcbiAgICAgIF9fY3VycmVudEVkaXRvciA9IG51bGxcbiAgIH1cblxuICAgY29uc3Qgdmlld3M6IE1hcDxWYWx1ZSwgVmlldz4gPSBuZXcgTWFwKCkgLy8gcGVyc2lzdHMgYWNyb3NzIGVkaXRzXG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBleGlzdGluZ1ZpZXcgKHR2OiBFeHBsVmFsdWUpOiBFeHBsVmFsdWVWaWV3IHtcbiAgICAgIHJldHVybiBfX25vbk51bGwodmlld3MuZ2V0KHR2KSkgYXMgRXhwbFZhbHVlVmlld1xuICAgfVxuXG4gICBmdW5jdGlvbiBpc0V4cHJGb3IgKGU6IEV4cHIsIEM6IENsYXNzPERhdGFWYWx1ZT4pOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBjbGFzc09mKGUpID09PSBleHByQ2xhc3MoQylcbiAgIH1cblxuICAgLy8gVW5wYWNrIGV2YWx1YXRpb24gbWVtby1rZXkgdG8gcmVjb3ZlciBvcmlnaW5hbCBleHByZXNzaW9uLiBUT0RPOiBtYWtlIGdlbmVyaWNcbiAgIC8vIGFuZCBtb3ZlIG5lYXIgdG8gbWVtbyBjb2RlLlxuICAgZnVuY3Rpb24gZXhwckZvciAodDogRXhwbCk6IEV4cHIge1xuICAgICAgaWYgKHZlcnNpb25lZCh0KSkge1xuICAgICAgICAgcmV0dXJuIGFzKGFzKGFzKHQuX19pZCwgVGFnZ2VkSWQpLmssIEFwcGxpY2F0aW9uSWQpLnYsIEV4cHIuRXhwcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gcmVuZGVyTGlua3MgKGxpbmtzOiBTZXQ8TGluaz4pOiBTVkdFbGVtZW50W10ge1xuICAgICAgcmV0dXJuIFsuLi5saW5rc10ubWFwKCgobGluazogTGluayk6IFNWR0VsZW1lbnQgPT4ge1xuICAgICAgICAgcmV0dXJuIGNvbm5lY3RvcihfX25vbk51bGwoX19zdmdzLmdldChsaW5rLmZyb20pKSwgX19ub25OdWxsKF9fc3Zncy5nZXQobGluay50bykpKVxuICAgICAgfSkpXG4gICB9XG5cbiAgIGFic3RyYWN0IGNsYXNzIFZpZXcge1xuICAgICAgcmVuZGVyICgpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgICAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSB0aGlzLnJlbmRlcl8oKVxuICAgICAgICAgX19zdmdzLnNldCh0aGlzLCBnKVxuICAgICAgICAgcmV0dXJuIGdcbiAgICAgIH1cbiAgICAgIGFic3RyYWN0IHJlbmRlcl8gKCk6IFNWR1NWR0VsZW1lbnRcbiAgIH1cblxuICAgY2xhc3MgRXhwclZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgICAgIHBhcmVuczogYm9vbGVhblxuICAgICAgZTogRXhwclxuXG4gICAgICBjb25zdHJ1Y3RvciAocGFyZW5zOiBib29sZWFuLCBlOiBFeHByKSB7XG4gICAgICAgICBzdXBlcigpXG4gICAgICAgICB0aGlzLnBhcmVucyA9IHBhcmVuc1xuICAgICAgICAgdGhpcy5lID0gZVxuICAgICAgfVxuXG4gICAgICByZW5kZXJfICgpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgICAgIGNvbnN0IHBhcmVuczogYm9vbGVhbiA9IHRoaXMucGFyZW5zXG4gICAgICAgICBjb25zdCBlOiBFeHByID0gdGhpcy5lXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuQ29uc3ROdW0pIHtcbiAgICAgICAgICAgIC8vIG91Y2g6IGRpc3JlZ2FyZCBkZWx0YS1pbmZvIG9uIGV4cHJlc3Npb24gaXRzZWxmXG4gICAgICAgICAgICByZXR1cm4gaG9yaXoobnVtXyhlLnZhbCwgZS52YWwpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuQ29uc3RTdHIpIHtcbiAgICAgICAgICAgIC8vIG91Y2g6IGRpc3JlZ2FyZCBkZWx0YS1pbmZvIG9uIGV4cHJlc3Npb24gaXRzZWxmXG4gICAgICAgICAgICByZXR1cm4gaG9yaXooc3RyXyhlLnZhbCkpXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5GdW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSBob3JpelNwYWNlKGtleXdvcmQoXCJmdW5cIiwgZGVsdGFTdHlsZShlKSksIGVsaW0oZS7PgykpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXNlSWYocGFyZW5zLCBnLCBkZWx0YVN0eWxlKGUpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuRGF0YUV4cHIpIHtcbiAgICAgICAgICAgIGlmIChpc0V4cHJGb3IoZSwgUGFpcikpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBwYWlyX2V4cHIoZSlcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgaWYgKGlzRXhwckZvcihlLCBOaWwpIHx8IGlzRXhwckZvcihlLCBDb25zKSkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RfZXhwcihwYXJlbnMsIGUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDb25zdHJfZXhwcihwYXJlbnMsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5RdW90ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoZSlcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeHByLlZhcikge1xuICAgICAgICAgICAgLy8gb3VjaDogZGlzcmVnYXJkIGRlbHRhLWluZm8gb24gVmFyLnhcbiAgICAgICAgICAgIHJldHVybiBob3Jpeih0ZXh0KGUueC52YWwsIGRlbHRhU3R5bGUoZSkpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuQXBwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXNlSWYoXG4gICAgICAgICAgICAgICBwYXJlbnMsXG4gICAgICAgICAgICAgICBob3JpelNwYWNlKGV4cHIoIShlLmYgaW5zdGFuY2VvZiBFeHByLkFwcCksIGUuZiksIGV4cHIodHJ1ZSwgZS5lKSksXG4gICAgICAgICAgICAgICBkZWx0YVN0eWxlKGUpXG4gICAgICAgICAgICApXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5CaW5hcnlBcHApIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBvcGVyYXRvciBwcmVjZWRlbmNlLCBidXQgYWxsb3cgZnVuY3Rpb24gYXBwbGljYXRpb24gdG8gdGFrZSBwcmlvcml0eSBvdmVyIGFueSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXNlSWYoXG4gICAgICAgICAgICAgICBwYXJlbnMsXG4gICAgICAgICAgICAgICBob3JpelNwYWNlKFxuICAgICAgICAgICAgICAgICAgZXhwcighKGUuZTEgaW5zdGFuY2VvZiBFeHByLkFwcCksIGUuZTEpLFxuICAgICAgICAgICAgICAgICAgdGV4dChlLm9wTmFtZS52YWwsIGRlbHRhU3R5bGUoZSkpLCAvLyB3aGF0IGFib3V0IGNoYW5nZXMgYXNzb2NpYXRlZCB3aXRoIGUub3BOYW1lXG4gICAgICAgICAgICAgICAgICBleHByKCEoZS5lMiBpbnN0YW5jZW9mIEV4cHIuQXBwKSwgZS5lMilcbiAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICBkZWx0YVN0eWxlKGUpXG4gICAgICAgICAgICApXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5EZWZzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXNlSWYoXG4gICAgICAgICAgICAgICBwYXJlbnMsXG4gICAgICAgICAgICAgICB2ZXJ0KFxuICAgICAgICAgICAgICAgICAgdmVydCguLi5lLmRlZsyFLnRvQXJyYXkoKS5tYXAoZGVmXyA9PiBkZWYoZGVmXykpKSxcbiAgICAgICAgICAgICAgICAgIGV4cHIoZmFsc2UsIGUuZSlcbiAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICBkZWx0YVN0eWxlKGUpXG4gICAgICAgICAgICApXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhwci5NYXRjaEFzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVydChcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2Uoa2V5d29yZChcIm1hdGNoXCIsIGRlbHRhU3R5bGUoZSkpLCBleHByKGZhbHNlLCBlLmUpLCBrZXl3b3JkKFwiYXNcIiwgZGVsdGFTdHlsZShlKSkpLFxuICAgICAgICAgICAgICAgZWxpbShlLs+DKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV4cHIuVHlwZW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVydChcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2Uoa2V5d29yZChcInR5cGVtYXRjaFwiLCBkZWx0YVN0eWxlKGUpKSwgZXhwcihmYWxzZSwgZS5lKSwga2V5d29yZChcImFzXCIsIGRlbHRhU3R5bGUoZSkpKSxcbiAgICAgICAgICAgICAgIC4uLmUuY2FzZXMudG9BcnJheSgpLm1hcCgoe2ZzdDogeCwgc25kOiBlfTogUGFpcjxTdHIsIEV4cHI+KSA9PlxuICAgICAgICAgICAgICAgICAgaG9yaXpTcGFjZSh0ZXh0KHgudmFsLCBkZWx0YVN0eWxlKHgpKSwgYXJyb3coZGVsdGFTdHlsZShlKSksIGV4cHIoZmFsc2UsIGUpKVxuICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoYFVuaW1wbGVtZW50ZWQgZXhwcmVzc2lvbiBmb3JtOiAke2NsYXNzTmFtZShlKX0uYClcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgY2xhc3MgRXhwbFZhbHVlVmlldyBleHRlbmRzIFZpZXcge1xuICAgICAgdHY6IEV4cGxWYWx1ZVxuICAgICAgc2hvd192OiBib29sZWFuXG4gICAgICBzaG93X3RzOiBib29sZWFuXG4gICAgICB0X3Zpc2libGUhOiBib29sZWFuXG4gICAgICB2X3Zpc2libGUhOiBib29sZWFuXG5cbiAgICAgIGFzc2VydFZhbGlkICgpOiB2b2lkIHtcbiAgICAgICAgIGFzc2VydCh0aGlzLnNob3dfdiB8fCB0aGlzLnNob3dfdHMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yICh0djogRXhwbFZhbHVlLCBzaG93X3Y6IGJvb2xlYW4sIHNob3dfdHM6IGJvb2xlYW4pIHtcbiAgICAgICAgIHN1cGVyKClcbiAgICAgICAgIHRoaXMudHYgPSB0dlxuICAgICAgICAgdGhpcy5zaG93X3YgPSBzaG93X3ZcbiAgICAgICAgIHRoaXMuc2hvd190cyA9IHNob3dfdHNcbiAgICAgICAgIHRoaXMuaW5pdGlhbGlzZSgpXG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2UgKCk6IFtFeHBsW10sIEV4cGxWYWx1ZSB8IG51bGxdIHtcbiAgICAgICAgIGNvbnN0IHRzOiBFeHBsW10gPSBzcGxpdEV4cGxzKHRoaXMudHYudClcbiAgICAgICAgIGlmICh0cy5sZW5ndGggPT09IDAgfHwgIXRoaXMuc2hvd190cykge1xuICAgICAgICAgICAgdGhpcy50X3Zpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy52X3Zpc2libGUgPSB0cnVlXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50X3Zpc2libGUgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLnZfdmlzaWJsZSA9IHRoaXMuc2hvd192XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gW3RzLCBzcGxpdFZhbHVlKHRoaXMudHYpXVxuICAgICAgfVxuXG4gICAgICByZW5kZXJfICgpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWQoKVxuICAgICAgICAgY29uc3QgW3RzLCB0dl06IFtFeHBsW10sIEV4cGxWYWx1ZSB8IG51bGxdID0gdGhpcy5pbml0aWFsaXNlKClcbiAgICAgICAgIGxldCBnOiBTVkdTVkdFbGVtZW50XG4gICAgICAgICBpZiAoIXRoaXMudl92aXNpYmxlKSB7XG4gICAgICAgICAgICBnID0gZXhwbHModHMpXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmICghdGhpcy50X3Zpc2libGUpIHtcbiAgICAgICAgICAgIGcgPSB2YWx1ZVZpZXcodHYhKS5yZW5kZXIoKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGcgPSB2ZXJ0KGV4cGxzKHRzKSwgaG9yaXpTcGFjZSh0ZXh0KFwi4pa4XCIsIGRlbHRhU3R5bGUobnRoKHRzLCB0cy5sZW5ndGggLSAxKSkpLCB2YWx1ZVZpZXcodHYhKS5yZW5kZXIoKSkpXG4gICAgICAgICB9XG4gICAgICAgICBpZiAodGhpcy50diA9PT0gX19jdXJyZW50RWRpdG9yIS5oZXJlLnR2KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkQm9yZGVyX2ZvY3VzKCF0aGlzLnRfdmlzaWJsZSAmJiB0cy5sZW5ndGggPiAwICA/IGVkZ2VfbGVmdChnKSA6IGcpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9nZ2xlVmFsdWUgKCk6IHZvaWQge1xuICAgICAgICAgaWYgKCF0aGlzLnNob3dfdikge1xuICAgICAgICAgICAgdGhpcy5zaG93X3YgPSB0cnVlXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmICh0aGlzLnNob3dfdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd192ID0gZmFsc2VcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9nZ2xlRXhwbCAoKTogdm9pZCB7XG4gICAgICAgICBpZiAoIXRoaXMuc2hvd190cykge1xuICAgICAgICAgICAgdGhpcy5zaG93X3RzID0gdHJ1ZVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy5zaG93X3YpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd190cyA9IGZhbHNlXG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBFeHBsVmlldyBleHRlbmRzIFZpZXcge1xuICAgICAgdDogRXhwbFxuICAgICAgYm9keVZpc2libGU6IGJvb2xlYW4gLy8gaWYgSSBhbSBhbiBhcHBsaWNhdGlvbiB2aWV3LCB3aGV0aGVyIHRoZSBmdW5jdGlvbiBib2R5IGlzIHZpc2libGVcblxuICAgICAgY29uc3RydWN0b3IgKHQ6IEV4cGwpIHtcbiAgICAgICAgIHN1cGVyKClcbiAgICAgICAgIHRoaXMudCA9IHRcbiAgICAgICAgIHRoaXMuYm9keVZpc2libGUgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZW5kZXJfICgpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgICAgIGxldCBnOiBTVkdTVkdFbGVtZW50XG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5WYXIpIHtcbiAgICAgICAgICAgIGcgPSBob3Jpeih0ZXh0KHRoaXMudC54LnZhbCwgZGVsdGFTdHlsZSh0aGlzLnQpKSlcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2VcbiAgICAgICAgIGlmICh0aGlzLnQgaW5zdGFuY2VvZiBFeHBsLlVuYXJ5QXBwKSB7XG4gICAgICAgICAgICBnID0gdmlldyh0aGlzLnQudGYsIGZhbHNlLCB0cnVlKS5yZW5kZXIoKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5CaW5hcnlBcHApIHtcbiAgICAgICAgICAgIGcgPSBob3JpelNwYWNlKFxuICAgICAgICAgICAgICAgdmlldyh0aGlzLnQudHYxLCBmYWxzZSwgdHJ1ZSkucmVuZGVyKCksXG4gICAgICAgICAgICAgICB0ZXh0KHRoaXMudC5vcE5hbWUudmFsLCBkZWx0YVN0eWxlKHRoaXMudCkpLCAvLyB3aGF0IGFib3V0IGNoYW5nZXMgYXNzb2NpYXRlZCB3aXRoIHQub3BOYW1lP1xuICAgICAgICAgICAgICAgdmlldyh0aGlzLnQudHYyLCBmYWxzZSwgdHJ1ZSkucmVuZGVyKClcbiAgICAgICAgICAgIClcbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKHRoaXMudCBpbnN0YW5jZW9mIEV4cGwuQXBwKSB7XG4gICAgICAgICAgICBnID0gdmVydChcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2Uodmlldyh0aGlzLnQudGYsIGZhbHNlLCB0cnVlKS5yZW5kZXIoKSwgdmlldyh0aGlzLnQudHUsIGZhbHNlLCB0cnVlKS5yZW5kZXIoKSksXG4gICAgICAgICAgICAgICB0aGlzLmFwcEJvZHkoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5EZWZzKSB7XG4gICAgICAgICAgICBnID0gdmVydCguLi50aGlzLnQuZGVmzIUudG9BcnJheSgpLm1hcChkZWbigpwpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50IGluc3RhbmNlb2YgRXhwbC5NYXRjaEFzKSB7XG4gICAgICAgICAgICBnID0gdmVydChcbiAgICAgICAgICAgICAgIGhvcml6U3BhY2Uoa2V5d29yZChcIm1hdGNoXCIsIGRlbHRhU3R5bGUodGhpcy50KSksIHZpZXcodGhpcy50LnR1LCBmYWxzZSwgdHJ1ZSkucmVuZGVyKCksIGtleXdvcmQoXCJhc1wiLCBkZWx0YVN0eWxlKHRoaXMudCkpKSxcbiAgICAgICAgICAgICAgIGVsaW1NYXRjaCh0aGlzLnQuzr4pXG4gICAgICAgICAgICApXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmICh0aGlzLnQgaW5zdGFuY2VvZiBFeHBsLlR5cGVtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQodGhpcy50KVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhYnN1cmQoXCJVbmtub3duIGV4cGxhbmF0aW9uIGZvcm1cIiwgdGhpcy50KVxuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIHNoYWRpbmcoZywgXCJ3aGl0ZVwiKVxuICAgICAgfVxuXG4gICAgICBhcHBCb2R5ICgpOiBTVkdFbGVtZW50IHtcbiAgICAgICAgIGNvbnN0IGFwcDogRXhwbC5BcHAgPSBhcyh0aGlzLnQsIEV4cGwuQXBwKVxuICAgICAgICAgY29uc3QgdHM6IEV4cGxbXSA9IHNwbGl0RXhwbHMoYXBwLnQpXG4gICAgICAgICBpZiAodHMubGVuZ3RoID09PSAwIHx8IHRoaXMuYm9keVZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBscyh0cylcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnOiBTVkdFbGVtZW50ID0gZWxsaXBzaXMoZGVsdGFTdHlsZShhcHAudCkpXG4gICAgICAgICAgICBnLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXY6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICB0aGlzLmJvZHlWaXNpYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgX19jdXJyZW50RWRpdG9yIS5vblZpZXdDaGFuZ2UoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBjbGFzcyBWYWx1ZVZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgICAgIC8vIFdlIG5lZWQgdGhlIFwibGVhZlwiIGV4cGxhbmF0aW9uIHRvIHJlbmRlciBhIHZhbHVlLCBmb3IgdHdvIHJlYXNvbnM6IHNvIHdlIGNhbiByZXRyaWV2ZSB0aGUgb3JpZ2luYWwgZXhwcmVzc2lvbiBmb3JcbiAgICAgIC8vIGVkaXRpbmcgcHVycG9zZXMsIGFuZCB0byByZW5kZXIgY29tcG9uZW50IGV4cGxhbmF0aW9ucyBvZiBkYXRhIHZhbHVlcy5cbiAgICAgIHR2OiBFeHBsVmFsdWVcblxuICAgICAgY29uc3RydWN0b3IgKHR2OiBFeHBsVmFsdWUpIHtcbiAgICAgICAgIHN1cGVyKClcbiAgICAgICAgIHRoaXMudHYgPSB0dlxuICAgICAgfVxuXG4gICAgICByZW5kZXJfICgpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgICAgIGxldCBnOiBTVkdTVkdFbGVtZW50XG4gICAgICAgICBpZiAodGhpcy50di52IGluc3RhbmNlb2YgTnVtKSB7XG4gICAgICAgICAgICBjb25zdCBlOiBFeHByID0gZXhwckZvcih0aGlzLnR2LnQpXG4gICAgICAgICAgICBnID0gaG9yaXoobnVtXyh0aGlzLnR2LnYsIGUgaW5zdGFuY2VvZiBFeHByLkNvbnN0TnVtID8gZS52YWwgOiB1bmRlZmluZWQpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50di52IGluc3RhbmNlb2YgU3RyKSB7XG4gICAgICAgICAgICBnID0gaG9yaXooc3RyXyh0aGlzLnR2LnYpKVxuICAgICAgICAgfSBlbHNlXG4gICAgICAgICBpZiAodGhpcy50di52IGluc3RhbmNlb2YgQ2xvc3VyZSkge1xuICAgICAgICAgICAgLy8gdHJlYXQgY2xvc3VyZXMgYXMgdGhlaXIgZnVuY3Rpb24gbGl0ZXJhbHMsIGZvciBub3dcbiAgICAgICAgICAgIGcgPSBob3JpelNwYWNlKGtleXdvcmQoXCJmdW5cIiwgZGVsdGFTdHlsZSh0aGlzLnR2LnYpKSwgZWxpbSh0aGlzLnR2LnYuZikpXG4gICAgICAgICB9IGVsc2VcbiAgICAgICAgIGlmICh0aGlzLnR2LnYgaW5zdGFuY2VvZiBEYXRhVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR2LnYgaW5zdGFuY2VvZiBHcmFwaGljc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IHRnOiBFeHBsVmFsdWU8R3JhcGhpY3NFbGVtZW50PiA9IHRoaXMudHYgYXMgRXhwbFZhbHVlPEdyYXBoaWNzRWxlbWVudD5cbiAgICAgICAgICAgICAgIGNvbnN0IGRpbSA9IHsgd2lkdGg6IGRlZmF1bHREaW1zWzBdLCBoZWlnaHQ6IGRlZmF1bHREaW1zWzFdIH1cbiAgICAgICAgICAgICAgIGxldCBnMTogU1ZHR0VsZW1lbnRcbiAgICAgICAgICAgICAgIFtnLCBnMV0gPSBzdmdFbGVtZW50X2ludmVydGVkKGRpbS53aWR0aCwgZGltLmhlaWdodClcbiAgICAgICAgICAgICAgIG5ldyBHcmFwaGljc1JlbmRlcmVyKF9fY3VycmVudEVkaXRvciEsIGcsIGcxKS5yZW5kZXIodGcsIF9fbm9uTnVsbChkaW1lbnNpb25zKSh0ZykpXG4gICAgICAgICAgICAgICBfX2RpbWVuc2lvbnMuc2V0KGcsIGRpbSlcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMudHYudiBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgICAgICAgICAgIGcgPSBwYWlyKHRoaXMudHYgYXMgRXhwbFZhbHVlPFBhaXI+KVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBpZiAodGhpcy50di52IGluc3RhbmNlb2YgTGlzdCkge1xuICAgICAgICAgICAgICAgZyA9IGxpc3QodGhpcy50diBhcyBFeHBsVmFsdWU8TGlzdD4pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgZyA9IGRhdGFDb25zdHIoZmFsc2UsIHRoaXMudHYgYXMgRXhwbFZhbHVlPERhdGFWYWx1ZT4pXG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZyA9IHVuaW1wbGVtZW50ZWQodGhpcy50di52KVxuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIHNoYWRpbmcoZywgXCJsYXZlbmRlclwiKVxuICAgICAgfVxuICAgfVxuXG4gICAvLyBWYWx1ZXMgYXJlIHRyZWF0ZWQgc2xpZ2h0bHkgZGlmZmVyZW50bHkgYmVjYXVzZSB0aGUgXCJrZXlcIiBvZiBhIHZhbHVlIHZpZXcgaXMgdGhlIHZhbHVlICh0byBkaXN0aW5ndWlzaFxuICAgLy8gaXQgZnJvbSB0aGUgdmlldyBvZiB0aGUgRXhwbFZhbHVlKSwgYnV0IHRoZSBFeHBsIGlzIGFsc28gcmVxdWlyZWQgdG8gcmVuZGVyIHRoZSB2YWx1ZS5cbiAgIGV4cG9ydCBmdW5jdGlvbiB2YWx1ZVZpZXcgKHR2OiBFeHBsVmFsdWUpOiBWYWx1ZVZpZXcge1xuICAgICAgbGV0IHc6IFZhbHVlVmlldyB8IHVuZGVmaW5lZCA9IHZpZXdzLmdldChfX25vbk51bGwodHYpLnYpIGFzIFZhbHVlVmlld1xuICAgICAgaWYgKHcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdyA9IG5ldyBWYWx1ZVZpZXcodHYpXG4gICAgICAgICB2aWV3cy5zZXQodHYudiwgdylcbiAgICAgICAgIHJldHVybiB3XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIHdcbiAgICAgIH1cbiAgIH1cblxuICAgZXhwb3J0IGZ1bmN0aW9uIHZpZXcgKHR2OiBFeHBsVmFsdWUsIHNob3dfdjogYm9vbGVhbiwgc2hvd190czogYm9vbGVhbik6IEV4cGxWYWx1ZVZpZXcge1xuICAgICAgbGV0IHc6IEV4cGxWYWx1ZVZpZXcgfCB1bmRlZmluZWQgPSB2aWV3cy5nZXQodHYpIGFzIEV4cGxWYWx1ZVZpZXdcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHcgPSBuZXcgRXhwbFZhbHVlVmlldyh0diwgc2hvd192LCBzaG93X3RzKVxuICAgICAgICAgdmlld3Muc2V0KHR2LCB3KVxuICAgICAgICAgcmV0dXJuIHdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gd1xuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiB2aWV3X2NoaWxkPFQgZXh0ZW5kcyBEYXRhVmFsdWU+IChDOiBDbGFzczxUPiwgdHY6IEV4cGxWYWx1ZTxUPiwgcHJvcF86IGtleW9mIFQsIHNob3dfdjogYm9vbGVhbiwgc2hvd190czogYm9vbGVhbik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgaWYgKHZlcnNpb25lZCh0di52KSAmJiB2ZXJzaW9uZWQodHYudCkpIHtcbiAgICAgICAgIGNvbnN0IHByb3A6IHN0cmluZyA9IHByb3BfIGFzIHN0cmluZ1xuICAgICAgICAgY29uc3QgdzogVmlldyA9IHZpZXcoRXhwbC5leHBsQ2hpbGQodHYudCwgdHYudiwgcHJvcF8pLCBzaG93X3YsIHNob3dfdHMpXG4gICAgICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gdy5yZW5kZXIoKVxuICAgICAgICAgaWYgKHR2LnYuX1/hup8gaW5zdGFuY2VvZiBDaGFuZ2UgJiYgdHYudi5fX+G6ny5oYXNDaGFuZ2VkKHByb3AgYXMgc3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gQWxsIGEgYml0IGhhY2t5LCBuZWVkIHRvIHJldGhpbms6XG4gICAgICAgICAgICBjb25zdCB0X3ByZXY6IEV4cGwgPVxuICAgICAgICAgICAgICAgdHYudC5fX+G6nyBpbnN0YW5jZW9mIENoYW5nZSAmJiB0di50Ll9f4bqfLmhhc0NoYW5nZWQocHJvcCBhcyBzdHJpbmcpID9cbiAgICAgICAgICAgICAgIGFzKHR2LnQuX1/hup8uY2hhbmdlZFtwcm9wXS5iZWZvcmUsIEV4cGwuRXhwbCkgOlxuICAgICAgICAgICAgICAgdHYudFxuICAgICAgICAgICAgY29uc3Qgd19leGlzdGluZzogVmlldyB8IHVuZGVmaW5lZCA9IHZpZXdzLmdldChleHBsVmFsdWUodF9wcmV2LCBhcyh0di52Ll9f4bqfLmNoYW5nZWRbcHJvcF0uYmVmb3JlLCBWYWx1ZSkpKVxuICAgICAgICAgICAgaWYgKHdfZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgIF9fbGlua3MuYWRkKHsgZnJvbTogdywgdG86IHdfZXhpc3RpbmcgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRCb3JkZXJfY2hhbmdlZChnKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGV4cG9ydCBmdW5jdGlvbiBleHBsVmlldyAodDogRXhwbC5FeHBsKTogVmlldyB7XG4gICAgICBsZXQgdzogRXhwbFZpZXcgfCB1bmRlZmluZWQgPSB2aWV3cy5nZXQodCkgYXMgRXhwbFZpZXdcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHcgPSBuZXcgRXhwbFZpZXcodClcbiAgICAgICAgIHZpZXdzLnNldCh0LCB3KVxuICAgICAgICAgcmV0dXJuIHdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gd1xuICAgICAgfVxuICAgfVxuXG4gICBleHBvcnQgZnVuY3Rpb24gc3BsaXRFeHBscyAodDogRXhwbCk6IEV4cGxbXSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuQ29uc3QpIHtcbiAgICAgICAgIHJldHVybiBbXVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuRnVuKSB7XG4gICAgICAgICByZXR1cm4gW11cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkRhdGFFeHBsKSB7XG4gICAgICAgICByZXR1cm4gW11cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLlZhcikge1xuICAgICAgICAgLy8gdmFsdWVzIG9mIHZhcmlhYmxlcyB0aGVtc2VsdmVzIGhhdmUgZXhwbGFuYXRpb25zLCBidXQgaWdub3JlIHRob3NlIGZvciBub3dcbiAgICAgICAgIHJldHVybiBbdF1cbiAgICAgIH0gZWxzZVxuICAgICAgICAgLy8gZG9uJ3QgcmVjdXJzZSBpbnRvIEFwcCBhcyBpdCBoYXMgaXRzIG93biBleHBhbnNpb24gc3RhdGVcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5VbmFyeUFwcCB8fCB0IGluc3RhbmNlb2YgRXhwbC5CaW5hcnlBcHApIHtcbiAgICAgICAgIHJldHVybiBbdF1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkFwcCkge1xuICAgICAgICAgcmV0dXJuIFt0XVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuTm9uVGVybWluYWwpIHtcbiAgICAgICAgIHJldHVybiBbdCwgLi4uc3BsaXRFeHBscyh0LnQpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoXCJVbmtub3duIGV4cGxhbmF0aW9uIGZvcm1cIiwgdClcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gVGhlIHZhbHVlIHBhcnQgbXVzdCBiZSBhbiBFeHBsVmFsdWUsIGJlY2F1c2UgaW4gdGhlIGRhdGEgdmFsdWUgY2FzZSB3ZSBuZWVkIHRoZSBleHBsYW5hdGlvbiBhcyB3ZWxsIHRvXG4gICAvLyByZW5kZXIgdGhlIHZhbHVlLlxuICAgZXhwb3J0IGZ1bmN0aW9uIHNwbGl0VmFsdWUgKHR2OiBFeHBsVmFsdWUpOiBFeHBsVmFsdWUge1xuICAgICAgY29uc3Qge3QsIHZ9OiBFeHBsVmFsdWUgPSB0dlxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkNvbnN0KSB7XG4gICAgICAgICByZXR1cm4gdHZcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLkZ1bikge1xuICAgICAgICAgcmV0dXJuIHR2XG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5EYXRhRXhwbCkge1xuICAgICAgICAgcmV0dXJuIHR2XG4gICAgICB9IGVsc2VcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5WYXIpIHtcbiAgICAgICAgIC8vIHZhbHVlcyBvZiB2YXJpYWJsZXMgdGhlbXNlbHZlcyBoYXZlIGV4cGxhbmF0aW9ucywgYnV0IGlnbm9yZSB0aG9zZSBmb3Igbm93XG4gICAgICAgICByZXR1cm4gc3BsaXRWYWx1ZShleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIH0gZWxzZVxuICAgICAgICAgLy8gZG9uJ3QgcmVjdXJzZSBpbnRvIEFwcCBhcyBpdCBoYXMgaXRzIG93biBleHBhbnNpb24gc3RhdGVcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRXhwbC5VbmFyeUFwcCB8fCB0IGluc3RhbmNlb2YgRXhwbC5CaW5hcnlBcHApIHtcbiAgICAgICAgIHJldHVybiB0dlxuICAgICAgfSBlbHNlXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEV4cGwuQXBwKSB7XG4gICAgICAgICByZXR1cm4gdHZcbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBFeHBsLk5vblRlcm1pbmFsKSB7XG4gICAgICAgICByZXR1cm4gc3BsaXRWYWx1ZShleHBsVmFsdWUodC50LCB2KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gZXhwbHMgKHRzOiBFeHBsW10pOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiB2ZXJ0KC4uLnRzLm1hcCh0ID0+IGV4cGxWaWV3KHQpLnJlbmRlcigpKSlcbiAgIH1cblxuICAgLy8gVG8gdmlzdWFsaXNlIGFuIGVsaW1pbmF0b3IsIHdlIHJlY29uc3RydWN0IHRoZSBwYXR0ZXJucyBmcm9tIHRoZSB0cmllLiBMaXN0IHN5bnRheCBpbiBwYXJ0aWN1bGFyIGRvZXNuJ3QgaGF2ZVxuICAgLy8gYW4gYW5hbG9nb3VzIFwiY2FzZSB0cmVlXCIgZm9ybS5cbiAgIHR5cGUgUGF0dGVybkVsZW1lbnQgPSBbQ3RyIHwgU3RyLCBEZWx0YVN0eWxlXVxuXG4gICBmdW5jdGlvbiBjb21wYXJlQ3RyIChjMTogc3RyaW5nLCBjMjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgIGNvbnN0IG46IG51bWJlciA9IGN0ckZvcihjMSkuYXJpdHkgLSBjdHJGb3IoYzIpLmFyaXR5XG4gICAgICByZXR1cm4gbiA9PT0gMCA/IGMxLmxvY2FsZUNvbXBhcmUoYzIpIDogblxuICAgfVxuXG4gICBmdW5jdGlvbiBjb250ICjOujogQ29udCk6IFtQYXR0ZXJuRWxlbWVudFtdLCBFeHByXVtdIHtcbiAgICAgIGlmICjOuiBpbnN0YW5jZW9mIEV4cHIuRXhwcikge1xuICAgICAgICAgcmV0dXJuIFtbW10sIM66XV1cbiAgICAgIH0gZWxzZVxuICAgICAgaWYgKM66IGluc3RhbmNlb2YgRWxpbSkge1xuICAgICAgICAgcmV0dXJuIGNsYXVzZXMozropXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGNsYXVzZXM8SyBleHRlbmRzIENvbnQ+ICjPgzogRWxpbTxLPik6IFtQYXR0ZXJuRWxlbWVudFtdLCBFeHByXVtdIHtcbiAgICAgIGlmIChWYXJFbGltLmlzKM+DKSkge1xuICAgICAgICAgY29uc3QgY3M6IFtQYXR0ZXJuRWxlbWVudFtdLCBFeHByXVtdID0gY29udCjPgy7OuilcbiAgICAgICAgIC8vIGRpc3JlZ2FyZCBhbnkgZGVsdGEgaW5mb3JtYXRpb24gb24geCA6LS9cbiAgICAgICAgIHJldHVybiBjcy5tYXAoKFtjeHMsIGVdKSA9PiBbW1vPgy54LCBkZWx0YVN0eWxlKM+DKV0sIC4uLmN4c10sIGVdKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoRGF0YUVsaW0uaXMoz4MpKSB7XG4gICAgICAgICBjb25zdCBjzrpzOiBbc3RyaW5nLCBDb250XVtdID0gemlwKGZpZWxkcyjPgyksIM+DLl9fY2hpbGRyZW4gYXMgQ29udFtdKS5zb3J0KChbYzEsIF0sIFtjMiwgXSk6IG51bWJlciA9PiBjb21wYXJlQ3RyKGMxLCBjMikpXG4gICAgICAgICByZXR1cm4gZmxhdHRlbihjzrpzLmZpbHRlcigoW2MsIM66XSkgPT4gzrogIT09IHVuZGVmaW5lZCkubWFwKChbYywgzrpdKTogW1BhdHRlcm5FbGVtZW50W10sIEV4cHJdW10gPT5cbiAgICAgICAgICAgIGNvbnQoX19ub25OdWxsKM66KSkubWFwKChbY3hzLCBlXTogW1BhdHRlcm5FbGVtZW50W10sIEV4cHJdKSA9PiBbW1tjdHJGb3IoYyksIGRlbHRhU3R5bGUoz4MpXSwgLi4uY3hzXSwgZV0pXG4gICAgICAgICApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBjb25zQ29tbWEgKOG6n19zdHlsZTogRGVsdGFTdHlsZSwgc3JjPzogRXhwci5EYXRhRXhwcik6IFNWR0VsZW1lbnQge1xuICAgICAgY29uc3QgZzogU1ZHRWxlbWVudCA9IGNvbW1hKOG6n19zdHlsZSlcbiAgICAgIGcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldjogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgIGlmIChzcmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3UmV2aXNpb24oKVxuICAgICAgICAgICAgaWYgKGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgIGlmIChldi5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIG15IHRhaWwgaXMgYW5vdGhlciBjb25zLCBzd2FwIHRoZSB0d28gaGVhZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgY29uc3QgZTogRXhwciA9IGFzKG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3RvKENvbnMsIFwidGFpbFwiKS52LCBFeHByLkV4cHIpXG4gICAgICAgICAgICAgICAgICBpZiAoaXNFeHByRm9yKGUsIENvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICBjb25zdCBlMTogRXhwciA9IGFzKG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3RvKENvbnMsIFwiaGVhZFwiKS52LCBFeHByLkV4cHIpXG4gICAgICAgICAgICAgICAgICAgICBjb25zdCBlMjogRXhwciA9IGFzKG5ldyBFeHByQ3Vyc29yKGUpLmNvbnN0cl90byhDb25zLCBcImhlYWRcIikudiwgRXhwci5FeHByKVxuICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3RyX3NwbGljZSBvbiBzcmMsIHJlcGxhY2luZyBoZWFkIHdpdGggaGVhZCBvZiBzcmMudGFpbFxuICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3RyX3NwbGljZSBvbiBzcmMudGFpbCwgcmVwbGFjaW5nIGhlYWQgd2l0aCBoZWFkIG9mIHNyY1xuICAgICAgICAgICAgICAgICAgICAgbmV3IEV4cHJDdXJzb3Ioc3JjKS5jb25zdHJfc3BsaWNlKENvbnMsIFtcImhlYWRcIl0sIChbZV06IEV4cHJbXSk6IEV4cHJbXSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2UyXVxuICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKGUpLmNvbnN0cl9zcGxpY2UoQ29ucywgW1wiaGVhZFwiXSwgKFtlXTogRXhwcltdKTogRXhwcltdID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZTFdXG4gICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3NwbGljZShDb25zLCBbXCJoZWFkXCJdLCAoW2VdOiBFeHByW10pOiBFeHByW10gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgY29uc3QgZcq5OiBFeHByID0gRXhwci5hcHAoRXhwci52YXJfKHN0cihcInNxXCIpKM69KCkpKSjOvSgpKSwgRXhwci52YXJfKHN0cihcInhcIikozr0oKSkpKM69KCkpKSjOvSgpKVxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdChleHByQ2xhc3MoUGFpciksIGUsIGXKuSkozr0oKSldXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKHNyYykuY29uc3RyX3NwbGljZShDb25zLCBbXCJ0YWlsXCJdLCAoW2VdOiBFeHByW10pOiBFeHByW10gPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZcq5OiBFeHByID0gRXhwci5jb25zdE51bShudW0oMCkozr0oKSkpKM69KCkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2F0KGV4cHJDbGFzcyhDb25zKSwgZcq5LCBlKSjOvSgpKV1cbiAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2N1cnJlbnRFZGl0b3IhLm9uRWRpdCgpXG4gICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIGdcbiAgIH1cblxuICAgZnVuY3Rpb24gZGF0YUNvbnN0ciAocGFyZW5zOiBib29sZWFuLCB7dCwgdn06IEV4cGxWYWx1ZTxEYXRhVmFsdWU+KTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCB0dnM6IEV4cGxWYWx1ZVtdID0gRXhwbC5leHBsQ2hpbGRyZW4odCwgdilcbiAgICAgIC8vIGEgY29uc3RydWN0b3IgZXhwcmVzc2lvbiBtYWtlcyBpdHMgdmFsdWUsIHNvIHRoZWlyIHJvb3QgZGVsdGEgaGlnaGxpZ2h0aW5nIG11c3QgYWdyZWVcbiAgICAgIGNvbnN0IGdzOiBTVkdTVkdFbGVtZW50W10gPSB0dnMubWFwKHR2yrkgPT4gdmlldyh0dsq5LCB0cnVlLCBmYWxzZSkucmVuZGVyKCkpXG4gICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gaG9yaXpTcGFjZSh0ZXh0KHYuY3RyLCBkZWx0YVN0eWxlKHYpKSwgLi4uKHR2cy5sZW5ndGggPiAyID8gW3ZlcnQoLi4uZ3MpXSA6IGdzKSlcbiAgICAgIHJldHVybiBwYXJlbnRoZXNpc2VJZih0dnMubGVuZ3RoID4gMCAmJiBwYXJlbnMsIGcsIGRlbHRhU3R5bGUodCkpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIGRhdGFDb25zdHJfZXhwciAocGFyZW5zOiBib29sZWFuLCBlOiBFeHByLkRhdGFFeHByKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBlczogRXhwcltdID0gZS5fX2NoaWxkcmVuXG4gICAgICBjb25zdCBnczogU1ZHU1ZHRWxlbWVudFtdID0gZXMubWFwKGXKuSA9PiBleHByKHRydWUsIGXKuSkpXG4gICAgICBjb25zdCBnOiBTVkdTVkdFbGVtZW50ID0gaG9yaXpTcGFjZSh0ZXh0KGUuY3RyLCBkZWx0YVN0eWxlKGUpKSwgLi4uKGVzLmxlbmd0aCA+IDIgPyBbdmVydCguLi5ncyldIDogZ3MpKVxuICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZUlmKGVzLmxlbmd0aCA+IDAgJiYgcGFyZW5zLCBnLCBkZWx0YVN0eWxlKGUpKVxuICAgfVxuXG4gICBmdW5jdGlvbiBkZWYgKGRlZjogRXhwci5EZWYpOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLlByaW0pIHtcbiAgICAgICAgIHJldHVybiBob3JpelNwYWNlKGtleXdvcmQoXCJwcmltaXRpdmVcIiwgZGVsdGFTdHlsZShkZWYpKSwgcGF0dGVyblZhcihkZWYueCkpXG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHByLkxldCkge1xuICAgICAgICAgaWYgKGRlZi5lIGluc3RhbmNlb2YgRXhwci5GdW4pIHtcbiAgICAgICAgICAgIHJldHVybiBob3JpelNwYWNlKGtleXdvcmQoXCJsZXRfXCIsIGRlbHRhU3R5bGUoZGVmKSksIHBhdHRlcm5WYXIoZGVmLngpLCBlbGltKGRlZi5lLs+DKSlcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShcbiAgICAgICAgICAgICAgIGtleXdvcmQoXCJsZXRfXCIsIGRlbHRhU3R5bGUoZGVmKSksXG4gICAgICAgICAgICAgICBwYXR0ZXJuVmFyKGRlZi54KSxcbiAgICAgICAgICAgICAgIGtleXdvcmQoXCJlcXVhbHNcIiwgZGVsdGFTdHlsZShkZWYpKSxcbiAgICAgICAgICAgICAgIGV4cHIoZmFsc2UsIGRlZi5lKVxuICAgICAgICAgICAgKVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwci5MZXRSZWMpIHtcbiAgICAgICAgIHJldHVybiBob3JpelNwYWNlKGtleXdvcmQoXCJsZXRSZWNcIiwgZGVsdGFTdHlsZShkZWYpKSwgdmVydCguLi5kZWYuzrQudG9BcnJheSgpLm1hcChkZWYgPT4gcmVjRGVmKGRlZikpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gYWJzdXJkKClcbiAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gZGVm4oKcIChkZWY6IEV4cGwuRGVmKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwbC5QcmltKSB7XG4gICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShrZXl3b3JkKFwicHJpbWl0aXZlXCIsIGRlbHRhU3R5bGUoZGVmKSksIHBhdHRlcm5WYXIoZGVmLngpKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoZGVmIGluc3RhbmNlb2YgRXhwbC5MZXQpIHtcbiAgICAgICAgIGlmIChkZWYudHYudCBpbnN0YW5jZW9mIEV4cGwuRnVuICYmIGRlZi50di52IGluc3RhbmNlb2YgQ2xvc3VyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhvcml6U3BhY2Uoa2V5d29yZChcImxldF9cIiwgZGVsdGFTdHlsZShkZWYpKSwgcGF0dGVyblZhcihkZWYueCksIGVsaW0oZGVmLnR2LnYuZikpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhvcml6U3BhY2UoXG4gICAgICAgICAgICAgICBrZXl3b3JkKFwibGV0X1wiLCBkZWx0YVN0eWxlKGRlZikpLFxuICAgICAgICAgICAgICAgcGF0dGVyblZhcihkZWYueCksXG4gICAgICAgICAgICAgICBrZXl3b3JkKFwiZXF1YWxzXCIsIGRlbHRhU3R5bGUoZGVmKSksXG4gICAgICAgICAgICAgICB2aWV3KGRlZi50diwgZmFsc2UsIHRydWUpLnJlbmRlcigpXG4gICAgICAgICAgICApXG4gICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBFeHBsLkxldFJlYykge1xuICAgICAgICAgcmV0dXJuIGhvcml6U3BhY2Uoa2V5d29yZChcImxldFJlY1wiLCBkZWx0YVN0eWxlKGRlZikpLCB2ZXJ0KC4uLmRlZi7OtC50b0FycmF5KCkubWFwKGRlZiA9PiByZWNEZWbigpwoZGVmKSkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBlbGltPEsgZXh0ZW5kcyBDb250PiAoz4M6IEVsaW08Sz4pOiBTVkdTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiB2ZXJ0KC4uLmNsYXVzZXMoz4MpLm1hcCgoW2N4cywgZV0pID0+IHtcbiAgICAgICAgIGNvbnN0IFtbZ10sIGN4c8q5XTogW1NWR0VsZW1lbnRbXSwgUGF0dGVybkVsZW1lbnRbXV0gPSBwYXR0ZXJucyhmYWxzZSwgMSwgY3hzKVxuICAgICAgICAgYXNzZXJ0KGN4c8q5Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgIGNvbnN0IGfKuTogU1ZHRWxlbWVudCA9XG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXhwci5GdW4gP1xuICAgICAgICAgICAgZWxpbShlLs+DKSA6IC8vIGN1cnJpZWQgZnVuY3Rpb24gcmVzdWdhcmluZ1xuICAgICAgICAgICAgaG9yaXpTcGFjZShhcnJvdyhkZWx0YVN0eWxlKGUpKSwgZXhwcihmYWxzZSwgZSkpXG4gICAgICAgICByZXR1cm4gaG9yaXpTcGFjZShnLCBnyrkpXG4gICAgICB9KSlcbiAgIH1cblxuICAgLy8gSGFjayBqdXN0IHRvIHN1cHBvcnQgQm9vbCwgT3JkZXJpbmcsIGV0Yy5cbiAgIGZ1bmN0aW9uIGVsaW1NYXRjaDxLIGV4dGVuZHMgQ29udD4gKM6+OiBNYXRjaDxLPik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgY29uc3QgdHY6IEV4cGxWYWx1ZTxEYXRhVmFsdWU+ID0gbnRoKM6+LnR2zIUudG9BcnJheSgpLCAwKVxuICAgICAgLy8gZG9uJ3QgdGhpbmsgdGhlIGNvbnRpbmF0aW9uIGlzIG5lZWRlZDsgYWxyZWFkeSBzdG9yZWQgaW4gdGhlIHRyYWNlXG4gICAgICByZXR1cm4gaG9yaXpTcGFjZSh0ZXh0KHR2LnYuY3RyLCBkZWx0YVN0eWxlKHR2LnYpKSwgYXJyb3coZGVsdGFTdHlsZSh0di52KSkpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIGV4cHJfIChwYXJlbnM6IGJvb2xlYW4sIGU6IEV4cHIpOiBFeHByVmlldyB7XG4gICAgICBsZXQgdzogRXhwclZpZXcgfCB1bmRlZmluZWQgPSB2aWV3cy5nZXQoZSkgYXMgRXhwclZpZXdcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHcgPSBuZXcgRXhwclZpZXcocGFyZW5zLCBlKVxuICAgICAgICAgdmlld3Muc2V0KGUsIHcpXG4gICAgICAgICByZXR1cm4gd1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiB3XG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGV4cHIgKHBhcmVuczogYm9vbGVhbiwgZTogRXhwcik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIGV4cHJfKHBhcmVucywgZSkucmVuZGVyKClcbiAgIH1cblxuICAgLy8gUmVhbGx5IHdhbnQgc29tZSBraW5kIG9mIHZpZXcgdHlwZWNsYXNzLCBzbyB0aGlzIGlzbid0IHNwZWNpZmljIHRvIGV4cHJlc3Npb24uIEFsc286IGNvbnNvbGlkYXRlIHdpdGggRXhwckN1cnNvci5cbiAgIGZ1bmN0aW9uIGV4cHJfY2hpbGQ8VCBleHRlbmRzIERhdGFWYWx1ZT4gKEM6IENsYXNzPFQ+LCBwYXJlbnM6IGJvb2xlYW4sIGU6IEV4cHIuRGF0YUV4cHIsIHByb3A6IGtleW9mIFQpOiBTVkdFbGVtZW50IHtcbiAgICAgIGlmICh2ZXJzaW9uZWQoZSkpIHtcbiAgICAgICAgIGNvbnN0IHc6IEV4cHJWaWV3ID0gZXhwcl8ocGFyZW5zLCBlLl9fY2hpbGQocHJvcCBhcyBrZXlvZiBFeHByLkRhdGFFeHByKSlcbiAgICAgICAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSB3LnJlbmRlcigpXG4gICAgICAgICBpZiAoZS5fX+G6nyBpbnN0YW5jZW9mIENoYW5nZSAmJiBlLl9f4bqfLmhhc0NoYW5nZWQocHJvcCBhcyBzdHJpbmcpKSB7XG4gICAgICAgICAgICBjb25zdCB3X2V4aXN0aW5nOiBWaWV3IHwgdW5kZWZpbmVkID0gdmlld3MuZ2V0KGFzKGUuX1/hup8uY2hhbmdlZFtwcm9wIGFzIHN0cmluZ10uYmVmb3JlLCBFeHByLkV4cHIpKVxuICAgICAgICAgICAgaWYgKHdfZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgIF9fbGlua3MuYWRkKHsgZnJvbTogdywgdG86IHdfZXhpc3RpbmcgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRCb3JkZXJfY2hhbmdlZChnKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnXG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGxpc3QgKHt0LCB2fTogRXhwbFZhbHVlPExpc3Q+KTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICBpZiAoQ29ucy5pcyh2KSkge1xuICAgICAgICAgY29uc3Qgdsq5OiBDb25zID0gdiBhcyBDb25zXG4gICAgICAgICBjb25zdCBlOiBFeHByID0gZXhwckZvcih0KVxuICAgICAgICAgcmV0dXJuIGhvcml6KFxuICAgICAgICAgICAgdmlld19jaGlsZChDb25zLCBleHBsVmFsdWUodCwgdsq5KSwgXCJoZWFkXCIsIHRydWUsIGZhbHNlKSxcbiAgICAgICAgICAgIGNvbnNDb21tYShkZWx0YVN0eWxlKHYpLCBpc0V4cHJGb3IoZSwgQ29ucykgPyBlIGFzIEV4cHIuRGF0YUV4cHIgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgc3BhY2UoKSxcbiAgICAgICAgICAgIHZpZXcoRXhwbC5leHBsQ2hpbGQodCwgdsq5LCBcInRhaWxcIiksIHRydWUsIGZhbHNlKS5yZW5kZXIoKVxuICAgICAgICAgKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoTmlsLmlzKHYpKSB7XG4gICAgICAgICByZXR1cm4gaG9yaXooY2VudHJlRG90KGRlbHRhU3R5bGUodikpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHJldHVybiBhYnN1cmQoKVxuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBsaXN0X2V4cHIgKHBhcmVuczogYm9vbGVhbiwgZTogRXhwci5EYXRhRXhwcik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgaWYgKGlzRXhwckZvcihlLCBDb25zKSkge1xuICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZUlmKHBhcmVucyxcbiAgICAgICAgICAgIGhvcml6KFxuICAgICAgICAgICAgICAgZXhwcl9jaGlsZChDb25zLCBmYWxzZSwgZSwgXCJoZWFkXCIpLFxuICAgICAgICAgICAgICAgY29uc0NvbW1hKGRlbHRhU3R5bGUoZSksIGUpLFxuICAgICAgICAgICAgICAgc3BhY2UoKSxcbiAgICAgICAgICAgICAgIGxpc3RfZXhwcihmYWxzZSwgZS5fX2NoaWxkKFwidGFpbFwiIGFzIGtleW9mIEV4cHIuRGF0YUV4cHIpIGFzIEV4cHIuRGF0YUV4cHIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZGVsdGFTdHlsZShlKVxuICAgICAgICAgKVxuICAgICAgfSBlbHNlXG4gICAgICBpZiAoaXNFeHByRm9yKGUsIE5pbCkpIHtcbiAgICAgICAgIHJldHVybiBob3JpeihjZW50cmVEb3QoZGVsdGFTdHlsZShlKSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIGhvcml6KGV4cHIoZmFsc2UsIGUpKSAvLyBwcm9tb3RlIHRvIG5lc3RlZCBTVkc7IG5lZWQgdG8gcmV0aGlua1xuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBudW1fIChuOiBOdW0sIHNyYz86IE51bSk6IFNWR0VsZW1lbnQge1xuICAgICAgY29uc3QgZzogU1ZHRWxlbWVudCA9IHRleHQobi50b1N0cmluZygpLCBkZWx0YVN0eWxlKG4pKVxuICAgICAgaWYgKHNyYyAmJiBOdW1iZXIuaXNJbnRlZ2VyKHNyYy52YWwpKSB7XG4gICAgICAgICBnLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXY6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIG5ld1JldmlzaW9uKClcbiAgICAgICAgICAgIG5ldyBFeHByQ3Vyc29yKHNyYykuc2V0TnVtKGV2Lm1ldGFLZXkgPyBzcmMudmFsIC0gMSA6IHNyYy52YWwgKyAxKVxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIF9fY3VycmVudEVkaXRvciEub25FZGl0KClcbiAgICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gZ1xuICAgfVxuXG4gICBmdW5jdGlvbiBwYWlyICh0djogRXhwbFZhbHVlPFBhaXI+KTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICByZXR1cm4gcGFyZW50aGVzaXNlKFxuICAgICAgICAgaG9yaXooXG4gICAgICAgICAgICB2aWV3X2NoaWxkKFBhaXIsIHR2LCBcImZzdFwiLCB0cnVlLCBmYWxzZSksXG4gICAgICAgICAgICBwYWlyQ29tbWEoZGVsdGFTdHlsZSh0di50KSwgZXhwckZvcih0di50KSBhcyBFeHByLkRhdGFFeHByKSxcbiAgICAgICAgICAgIHNwYWNlKCksXG4gICAgICAgICAgICB2aWV3X2NoaWxkKFBhaXIsIHR2LCBcInNuZFwiLCB0cnVlLCBmYWxzZSlcbiAgICAgICAgICksXG4gICAgICAgICBkZWx0YVN0eWxlKHR2LnQpXG4gICAgICApXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhaXJDb21tYSAo4bqfX3N0eWxlOiBEZWx0YVN0eWxlLCBzcmM/OiBFeHByLkRhdGFFeHByKTogU1ZHRWxlbWVudCB7XG4gICAgICBjb25zdCBnOiBTVkdFbGVtZW50ID0gY29tbWEo4bqfX3N0eWxlKVxuICAgICAgZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgaWYgKHNyYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSZXZpc2lvbigpXG4gICAgICAgICAgICBpZiAoZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgbmV3IEV4cHJDdXJzb3Ioc3JjKS5jb25zdHJfc3BsaWNlKFBhaXIsIFtcImZzdFwiLCBcInNuZFwiXSwgKFtlMSwgZTJdOiBFeHByW10pOiBFeHByW10gPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlMiwgZTFdXG4gICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jdXJyZW50RWRpdG9yIS5vbkVkaXQoKVxuICAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBnXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhaXJfZXhwciAoZTogRXhwci5EYXRhRXhwcik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIHBhcmVudGhlc2lzZShcbiAgICAgICAgIGhvcml6KFxuICAgICAgICAgICAgZXhwcl9jaGlsZChQYWlyLCBmYWxzZSwgZSwgXCJmc3RcIiksXG4gICAgICAgICAgICBwYWlyQ29tbWEoZGVsdGFTdHlsZShlKSwgZSksXG4gICAgICAgICAgICBzcGFjZSgpLFxuICAgICAgICAgICAgZXhwcl9jaGlsZChQYWlyLCBmYWxzZSwgZSwgXCJzbmRcIilcbiAgICAgICAgICksXG4gICAgICAgICBkZWx0YVN0eWxlKGUpXG4gICAgICApXG4gICB9XG4gICBmdW5jdGlvbiBwYXR0ZXJucyAocGFyZW5zOiBib29sZWFuLCBuOiBudW1iZXIsIGN4czogUGF0dGVybkVsZW1lbnRbXSk6IFtTVkdFbGVtZW50W10sIFBhdHRlcm5FbGVtZW50W11dIHtcbiAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICByZXR1cm4gW1tdLCBjeHNdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY29uc3QgW2N0cl94LCDhup9fc3R5bGVdID0gY3hzWzBdXG4gICAgICAgICBpZiAoY3RyX3ggaW5zdGFuY2VvZiBDdHIpIHtcbiAgICAgICAgICAgIGlmIChjdHJfeC5DID09PSBQYWlyKSB7XG4gICAgICAgICAgICAgICBjb25zdCBbW2cxLCBnMl0sIGN4c8q5XTogW1NWR0VsZW1lbnRbXSwgUGF0dGVybkVsZW1lbnRbXV0gPSBwYXR0ZXJucyhmYWxzZSwgMiwgY3hzLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgY29uc3QgW2dzyrksIGN4c8q5yrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKHBhcmVucywgbiAtIDEsIGN4c8q5KVxuICAgICAgICAgICAgICAgcmV0dXJuIFtbcGFyZW50aGVzaXNlKGhvcml6KGcxLCBjb21tYSjhup9fc3R5bGUpLCBzcGFjZSgpLCBnMiksIOG6n19zdHlsZSksIC4uLmdzyrldLCBjeHPKucq5XVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBpZiAoY3RyX3guQyA9PT0gTmlsKSB7XG4gICAgICAgICAgICAgICBjb25zdCBbZywgY3hzyrldOiBbU1ZHRWxlbWVudCwgUGF0dGVybkVsZW1lbnRbXV0gPSBbY2VudHJlRG90KOG6n19zdHlsZSksIGN4cy5zbGljZSgxKV1cbiAgICAgICAgICAgICAgIGNvbnN0IFtncywgY3hzyrnKuV06IFtTVkdFbGVtZW50W10sIFBhdHRlcm5FbGVtZW50W11dID0gcGF0dGVybnMocGFyZW5zLCBuIC0gMSwgY3hzyrkpXG4gICAgICAgICAgICAgICByZXR1cm4gW1tnLCAuLi5nc10sIGN4c8q5yrldXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmIChjdHJfeC5DID09PSBDb25zKSB7XG4gICAgICAgICAgICAgICBjb25zdCBbW2dfaGVhZCwgZ190YWlsXSwgY3hzyrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKGZhbHNlLCBjdHJfeC5hcml0eSwgY3hzLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgY29uc3QgZzogU1ZHU1ZHRWxlbWVudCA9IGhvcml6KGdfaGVhZCwgY29tbWEo4bqfX3N0eWxlKSwgc3BhY2UoKSwgZ190YWlsKVxuICAgICAgICAgICAgICAgY29uc3QgW2dzyrksIGN4c8q5yrldOiBbU1ZHRWxlbWVudFtdLCBQYXR0ZXJuRWxlbWVudFtdXSA9IHBhdHRlcm5zKHBhcmVucywgbiAtIDEsIGN4c8q5KVxuICAgICAgICAgICAgICAgcmV0dXJuIFtbcGFyZW50aGVzaXNlSWYoY3RyX3guYXJpdHkgPiAwICYmIHBhcmVucywgZywg4bqfX3N0eWxlKSwgLi4uZ3PKuV0sIGN4c8q5yrldXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgY29uc3QgW2dzLCBjeHPKuV06IFtTVkdFbGVtZW50W10sIFBhdHRlcm5FbGVtZW50W11dID0gcGF0dGVybnModHJ1ZSwgY3RyX3guYXJpdHksIGN4cy5zbGljZSgxKSlcbiAgICAgICAgICAgICAgIGNvbnN0IGc6IFNWR1NWR0VsZW1lbnQgPSBob3JpelNwYWNlKHRleHQoY3RyX3guYywg4bqfX3N0eWxlKSwgLi4uZ3MpXG4gICAgICAgICAgICAgICBjb25zdCBbZ3PKuSwgY3hzyrnKuV06IFtTVkdFbGVtZW50W10sIFBhdHRlcm5FbGVtZW50W11dID0gcGF0dGVybnMocGFyZW5zLCBuIC0gMSwgY3hzyrkpXG4gICAgICAgICAgICAgICByZXR1cm4gW1twYXJlbnRoZXNpc2VJZihjdHJfeC5hcml0eSA+IDAgJiYgcGFyZW5zLCBnLCDhup9fc3R5bGUpLCAuLi5nc8q5XSwgY3hzyrnKuV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZVxuICAgICAgICAgaWYgKGN0cl94IGluc3RhbmNlb2YgU3RyKSB7XG4gICAgICAgICAgICBjb25zdCBbZ3MsIGN4c8q5XTogW1NWR0VsZW1lbnRbXSwgUGF0dGVybkVsZW1lbnRbXV0gPSBwYXR0ZXJucyhwYXJlbnMsIG4gLSAxLCBjeHMuc2xpY2UoMSkpXG4gICAgICAgICAgICAvLyBvdWNoLCBpZ25vcmUg4bqfX3N0eWxlIGNvbWluZyBmcm9tIHRyaWUgYW5kIHVzZSB2YXJpYWJsZSBpbnN0ZWFkIDotL1xuICAgICAgICAgICAgcmV0dXJuIFtbcGF0dGVyblZhcihjdHJfeCksIC4uLmdzXSwgY3hzyrldXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFic3VyZCgpXG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhdHRlcm5WYXIgKHg6IFN0cik6IFNWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIHRleHQoeC52YWwsIGRlbHRhU3R5bGUoeCkpXG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlY0RlZiAoZGVmOiBFeHByLlJlY0RlZik6IFNWR1NWR0VsZW1lbnQge1xuICAgICAgcmV0dXJuIGhvcml6U3BhY2UocGF0dGVyblZhcihkZWYueCksIGVsaW0oZGVmLs+DKSlcbiAgIH1cblxuICAgZnVuY3Rpb24gcmVjRGVm4oKcIChkZWY6IEV4cGwuUmVjRGVmKTogU1ZHU1ZHRWxlbWVudCB7XG4gICAgICByZXR1cm4gaG9yaXpTcGFjZShwYXR0ZXJuVmFyKGRlZi54KSwgZWxpbShkZWYudGYudi5mKSlcbiAgIH1cblxuICAgZnVuY3Rpb24gc3RyXyAoc3RyOiBTdHIpOiBTVkdFbGVtZW50IHtcbiAgICAgIHJldHVybiB0ZXh0KHN0ci50b1N0cmluZygpLCBkZWx0YVN0eWxlKHN0cikpXG4gICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTpmb250L3dvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFHVmtBQkFBQUFBQXJuZ0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCYkFBQUFCd0FBQUFjY1FxbTBrZEVSVVlBQUFHSUFBQUFIUUFBQUI0QUp3RHNUMU12TWdBQUFhZ0FBQUJaQUFBQVlHc2oyd0ZqYldGd0FBQUNCQUFBQVhnQUFBSEtBL0ZBNTJOMmRDQUFBQU44QUFBQU9BQUFBRGdMWEE4L1puQm5iUUFBQTdRQUFBR3hBQUFDWlZPMEw2ZG5ZWE53QUFBRmFBQUFBQWdBQUFBSUFBQUFFR2RzZVdZQUFBVndBQUJZQ0FBQW0yREw5TXQwYUdWaFpBQUFYWGdBQUFBMkFBQUFOZ0xocldOb2FHVmhBQUJkc0FBQUFDQUFBQUFrRDBFSWMyaHRkSGdBQUYzUUFBQUJoUUFBQTVpQjVtNTRiRzlqWVFBQVgxZ0FBQUhIQUFBQnpzZXhvbnB0WVhod0FBQmhJQUFBQUNBQUFBQWdBZ01CN1c1aGJXVUFBR0ZBQUFBQmd3QUFBeElvdjJkeGNHOXpkQUFBWXNRQUFBSGVBQUFDdFA0MnZZMXdjbVZ3QUFCa3BBQUFBTDhBQUFGT3U2aEkwd0FBQUFFQUFBQUExZTFGdUFBQUFBREJXWFlPQUFBQUFObkQ2d3Q0Mm1OZ1pHQmc0QUZpTVNCbVltQUV3cWRBekFMbU1RQUFEWFVCRkFBQUFIamFZMkJtZnNmNGhZR1ZnWVhWbUhVV0F3T2pQSVJtdnM2UXdpVEF3TURFemNiSnpNRE13TURRd01DZ0Q1VFBab0NDZ0RUWEZDQ2xvUHFIcmY5ZlB3TUQyMXJHU1E0TURNS3RWNENxVGpEbGcrUVlHQUdwZkE5ZEFBQUFlTnBqWUdCZ1pvQmdHUVpHQmhBNEF1UXhndmtzREN1QXRCcURBcERGeGxESDhKOHhtTEdDNlJqVEhRVXVCUkVGS1FVNUJTVUZOUVY5QlN1RmVJVTFpa3FxZi83L0I2cFhZRmpBR0FSVng2QWdvQ0NoSUFOVlo0bFE5Ly94LzBQL0MvNzcvUDMvOTlXRDR3OE9QZGovWU4rRDNROTJQTmp3WVBtRDVnZm05dy9kZWdsMUR4R0FrWTBCcnBpUkNVZ3dvU3NBZXBHRmxZMmRnNU9MbTRlWGoxOUFVRWhZUkZSTVhFSlNTbHBHVms1ZVFWRkpXVVZWVFYxRFUwdGJSMWRQMzhEUXlOakUxTXpjd3RMSzJzYld6dDdCMGNuWnhkWE4zY1BUeTl2SDE4OC9JREFvT0NRMExEd2lNaW82SmpZdVBpR1JvYTI5czN2eWpIbUxGeTFadG5UNXl0V3IxcXhkdjI3RHhzMWJ0Mnpic1gzUDdyMzdHSXBTVWpQdlZpd3N5SDVTbHNYUU1ZdWhtSUVodlJ6c3Vwd2FoaFc3R3BQelFPemMybnRKVGEzVER4MitldTNXN2VzM2RqSWNQTUx3K01GRG9Femx6VHNNTFQzTnZWMzlFeWIyVFozR01HWE8zTmtNUjQ4VkFxV3FnQmdBTVp1RHVBQUFBNmNFL0FCNkFIRUFkZ0IvQUlZQWl3RFNBSkVBZkFDRUFJZ0FqUUNSQUpVQW1nQ2VBS0lBcGdDckFOUUFaZ0JTQUYwQVJBVVJlTnBkVWJ0T1cwRVEzUTBQQTRIRTJDQTUyaFN6bVpER2U2RUZDY1RWaldKa080WGxDR2szY3BHTGNRRWZRSUZFRGRxdkdhQ2hwRWliQmlFWFNIeENQaUVTTTJ1SW9qUTdPN056enBrelM4cVJxbmZwYTg5VDV5U1F3dDBHelRiOVRraTFzd0QzcE92cmpZeTBnd2RhYkdiMHluWDcvZ3NHbTlHVU8yb0E1VDF2S1E4WlRUdUJXclNuL3RIOENvYjcvQi96T3hpME5OUDAxRG9KNlNFRTVwdHhTNFB2R2MyNnl3LzZndFhoWWpBd3BKaW00aTQvcGxMK3R6VG5hc3V3dFpIUnZJTXpFZm5KTkVCVGEyMEVtdjdVSWRYemNSUkxrTXVtc1RhWW1MTCtKQlBCaGNsMFZWTzF6UGphd1YyeXMraGdneXJOZ1FmWXcxWjVEQjRPRHlZVTByY2t5aXdORWZaaXE4UUlFWk1jQ2pubDNNbitwRUQ1U0JMR3ZFbEtPK09HdFFiR2tkZkFvRFpQcy84OG0wMXRieDNDK0ZrY3dYZS9HVXM2K01pRzJoZ1JZanRpS1lBSlJFSkdWZm1HR3MrOUxBYmtVdnZQUUpTQTVmR1BmNTBJdE83WVJEeVh0WFVPTVZZSWVuN2IzUExMaXJ0V3VjNkxRbmR2cW1xbzBpbk4rMTdPdnNjRG5oNEx3MEZqd1p2UCsvNUtnZm84TEs0MGFBNEVRM28zZXYraXRlcUlxN3dYUHJJbjA3K3hXZ0FBQUFBQkFBSC8vd0FQZU5yVXZRbDhXOVdWUDM3dmUwLzcrclI2dHhiYnNpMWJzaVhic3J3N2laYzR6aDVuZGZhRUJHZmY5NFFzaEpCQUEwMUlFNkJzWlNrd3BlL0pEdWtBYmROU1dscm9TcHVadG5RNnBaVCszSDA2N1ZDSXJmek91VTl5N0N3UTVqK2YrWDMrRUZsUFQ3THV2ZWVlNVh1V2UwdzRNb0VRYm9XcWgvQkVRMEl5SmVHR2hFYkkrbU5FVnF2ZWJrandIRndTbWNmYktyeWQwS2l6aHhvU0ZPOUhSYTlZNkJXOUV6aFBzb0NlVGE1VzlYejQvQVRodXdTK2ttNjZNZ2pmT3hlK05ZdDBrSVNHa09BQXJ5T2lFS1JTZGxpaWx3WlVMbnlWZXVxM3FhZzJLR3RkZzVJMkxOdGNnM0lPRGNvMnJXanI1OVFhdnNBZEp4V1ZCVlUxRVpkRDdlT3JZazAwR25HNVhVNEh2T25uUTVSdTZsalIyYmtpWWpaVjV1VEhERnFSSzF5VkoxZ3JWblIwck9nUWZsSlY0UEdWbFhtaTVVOWxETC9CVmJlZHdUbVNkL2xKZkJtczNVTHlTVGVSTEdFcFB6cWcweEd0RUpReUkxVHloQ1gra3FTT3lFYkhvR1MweW5ZYWxGd1JPY2N4S0h0aGRrWmV0TWs2U3p3dTJVWEpHcGR5YkhKbWZod25hby9WVkZjVlZWZlZ3Q1NkRGd0dHBtTmZ2MXZtTU5YNC9QRUprYitVTzB6VmVGWEpyenJlRkhYTmR0WEdtMXM2WHo2V00rWVZZZk9ORWlmL1BSVlBza2srUFVVU1dvNEVKVTFVSXVHRUl5TTdHbzBPVUlHVUNzRUVKK1pFSXBFRW9mcGdmd3ZKMGdVbElkelBXL1B5Qzl6UkFSWDdUTDlhcHpjVnVKVkZabDJTTXcyRFVxWlYxc0N5dEhDcHRjb3V1SFRDcGRNcUczQ3hCclpvcVNicnBlWVQvNWhQbkVHOUlHVlo1VXorZzVlYWovOWpMdDZRWENISkdKSmNWdmpGRDVCZ0JzTUhLdmhRUDVlbHNRZjdlZlpUalQ5aHJINWRwaFl1WE5aK3Zjc0FGMDVydjhscGhBOVkyVStSL1hUZ3o1ZWE3L25IS3ZoK0EzN1lqUjlXNGU5bnNOK0hiODlPZjJNTzNobno2VnoyNmY0OE5nSjhJaDgva1lEdjhCejNIUGVyemFJdEx1WEd5WXNHbzlQbHpzd05LZi9SRml2SEk0R3Nvc09ka1oyVG01Y2Z1dVkvcVNXTEVoQVgwU2JaNDVJZ1NyWTRiSHN6dFd2Z0VlTmorTEJROXREWU5mREF0Nks2YjVmK1V2UHJrcjNCZDRvUGxMeGtlTG4wRGNPYjVYdkxmMTIyTTNqazF5Vy9vb2NYOFhRaHQ1U25DMVRKeDNuYXJVNStrVi9PSlo4Umx2REpUMm5vRGlGNVdrVTNMQlhvUEk2QXhPNis4amovZ3FxYVZKSTRhU1dQRWFraUxKVkhaWTFxVUtxTEpDbzB1UDBWWWRqKzNMQVVDMHNGVWRrR2IyVkZFcllZdm1XejYwQVl4NFVseXlVNVlocVVJbFk1VElNSmphMEd1RWNPR1FZSEhLN01nanJnRWlsa2xSdGg4L01qY29seFVCNFAvQkN4QVBOVFBoNlhTeHJoS2pjSEdGL1dWQUE5S29HazRnVkNMWVVsa1pwV2tGd3BacE55Z0R6TkZKamY3WEtMUllFUUQ4SVFxNDZpQU9kU2wxdFRGS2dLMDZLQXlHVGFURFZPZjNXUm5YM1lUR2tUcmE0S0ZBVjJ6OVZwYmpzM3NiaHhkcW1ZdVBjSVovN3lscmw2eXVuYTk2N1AvRjdIb3h0Mi9xSm9nNjlvUVM4Tkw5NTRtNy85YTd0VlpxdG1uVWhmemJMbGRrNXE5bXo0dkcyUHdHdHNoaW4yNHhzNG8xa3c5dGlTMjRvTUM3NDArY1E2OHgxN3pmek9SUzEyQzExbTZCMTZ5YmF6YzJXdDNRVnlweUoxVjM3UHY2MnlFejB4a3p4U0RITDRCRWtZUUtNbEF2QkRMaE1HRTBhUVJkQ1c4Q3BIR0J5SStBSzhDV2dFbHc0ZHUzUUlnMVNxQ2t2a2ttd0JvYkpZWlRjUVVXMGNsTlJXMlFPWEpYQzNoRzJBWEFpaVZnM1BGdVF1UTF4eWkvMWFuUmwxb0J3dUVXMEpZOEFYQjZWVEtFb21vSG1rREhTa3B5Qy9FTi9QY2NCZXFFa2NtVEdsYmRTK0lqdU5VdDZSeDBVam9JWkNuTituSnV4Tmg5cnY0eDB1ZHJ2SXA2NDd1bWp4WFhkKzVhNEM3dFhqdzlXbExwL1hXdFRrS3NpM0ZEWFQzcnNXTFQ0S0QrTzRZRW5MdUJuakJNMldjdzl0MlhUdXdhRTF3dEJsUVRCWHRudk1IZE9pblI1ajUxREJPdytlZStjYzFjK2MyalZ6WG5jM1FWN3R1dkpiL2w5Vk91SW5GYVNlOUpHRUYwZ241VWJsZ0dhUWFUSTV6Z09KR2hpSkNzVEJmbFVCQVlOUWFSNlVDcXh5RFpEREFKd0hUQ2pYVklxMjgxcmVHd2laa2JrTW9weFhqc3dYOElySVoxSmNmSkdvRE5sNW9TaTh6ZWdRRzFHOWFvMjlKcVdiWTI2MXhxMEptS25mVnhSRElqUnh6WlNhS1hBZDhsc1JVS25ybnUzM1A3bDk2MmQzcm55dk9aZm5kVWZhWnAvY3Vhbmx4UlhIenorMFpsclJ0UHF3MFpUOGNQckNGWHM2ZW1iVjFVNm53UjF2dDBpZjJ2elFROXRYdkJSTFh1eGNxTlVLVnNHc1diQjN5MHZ6ejA5ZGR1SHMzQzI1cGFWbUMxMWEvUWkzZnNXNTRpUHRIZk5uRVVMcDAvd2s3bDVtaTByUkVxWE1FSldzbzJ5UUxJNjJPbUJuNkRWMmhqNTlNM05DY0l5YzVLUDhLdFVzNGlCMlFpVW5JN1haUElpcUhyL01Tb0FtUUEyL1Q2UG1uQTRiU0NXaE9UVGpUMDBhbldEaGRmcis3L3p4QitQL212d2RKOUpNK3ZYVit3Uk8zWmM4K2ZaL0pIdDNyVGxBZjQ1amtOUEpoN2pmcVdZU0V4dkRqTE9YOWZwQjJjTEdjTmZZcXF1NFFBeHN2cFZvVHYvZzczOTZNL0FoTFUzKzRNcmdlbnJ5dCsvU1kydnYySktNSlArYy9FT3llRGQrWHcvNUtmKzhVRVJFUXV3eEZSOEYzY0FYdWxWVVk2QUIybE5OdS9LZnBub3VuN2JGa285UmJ1UGI3MjJrQnU2dEl3L1JQbU9lS2ZuZDAvdjZrbS9NbzdPU3p5MmdVZnkrWHZKai9pa2hUQXhrQmdITENmWlRwdXBCU1RWaUx2VzZZSUlTdktRODZrZGpXTkpma3JpSXJBTmhGU0lKblI3ZjAybmdZM29kWHVxSkxpaWIyUExzMVY0UlVKSFRLL3JGWHRwM2tDNUtQbkdRbTdVUG4vY2w3NkIzRUxZUE01TFBjSnZKajJBZmlvbmtDQTlZVW5zTk95SmNrbTNpWUVLd3dUY1R3UWpmbk5vY3hyWWhHZ2h4NmUzVzBCbnhVSjdkWXJaYU05c3E0ejAvUy82bWVsSkZvZDFyMUJtTXBabmg5a1hkVC82QzdjbjlYQXUvbVhzZHBOQ05hNWFwWmhBZkZHQ0JyRXBQM0hrLzl5dXU1ZGd4bU45R3dHN0x5SStKbGxSZlJXNDJBQmFqcnFta1EvNFppK0prUGZ1MndoUk9LNkliT3hnQVcxelIxcmFrdlEzbmN2aktzL3grMVhTWWk0VklORHhxRG03cXBvZTVnN3VIOTJXcjFqWjlpQkFOUG5YYmxVSCtuRW9GdE1vblFUS0pKS3lvY3YyZ05GU29OTExWc0l3eXhzbE9Jd01ySlNsVlVZNUsxUW02MGFySzhDQitsTFA5b20xQWJ5RHVZRW94TklGR3pPTWRadDd2QzNFeGg1dUdRQm1ZT1hzZWdNc21zRkNCMnpxM25acGN2L1gycWVIS2FYMGI0NU5QYlo5NE5KZCtyYmd2VnJGMGVyUzdaRU9kdjdPanhwZkZiVDA5OUZSdnphYUhmNTY4ZEdwVnhiekhoMTY0WXhQWE5tUFdoTDJ2SlRObUx2QjJyMzl1MWFmWDQvcGZ2cExrTzRVazJKSnhKS0hHdFdpRVFZbVBBS1FtUUZSRFdOSmVrbm5UWUlMWEluUHhLdUF6TFkrWFdqVndneEZXeFFNcWxpakRtWVZSTWVyMFZrZEZ6Y3UwWThsN3cwLzljVmlZOFUrWE4yM2F4TC9keWZZZXlNZ2ZBZnFGeUVLU0lEaGVzWHBRdVNqWERpWXlrSWhtSkdJNExCa3V5ZG5td1lRaEc0Y3pJRnRYd0hEWkJsQTR3VEpVc2NXRWpTeVZpMUl3THBsdEE0TERtZTFsMUl4V045RllrMHBSbkJxUTBnQ0Q2R0RNT1kxWnJmRkdZalZ1NTVsSjBrNWYvamh2aWUza2JaTzI1S2cwNnRXMUY5Yzk5Qy9Ga3h0RDZvNjhDY0c2U2hmbk51cE5sdmtQL0d4dGZtNXI1WVRPd3R2dTZTelQ1dWxtTHRud3d6T3R1L3JHQjFYamNzZEhPaVlXNlV6Q1NiYkdlNi84anI5TlJXQ05QU1JSaGt2VHdSbzl1TFFzOWVDQXpWTG1BUk5zRTVSVkdpL0pKWUIyM0o1TG91dzNEZUlhaVd6UmdXRWx0QVFOcTAyVWl1SlNsaTJSayt1UHh4bHd5YVB1UEY2eGs2QWRxeU94bElrWVdhVmFrMGVkYUUrTDdsMnIwMnUxN3FwSkpldFBmZjVJcnY5d2Uwdm4vaVYzOUU1dGVHejJBOSs1ZmZieVhmOHFMLzNpM29QNklyM080WGVmVzdQeHNHcUxKMmRqNDh5dHkrYTFkbnpsem9WblBRWDlteC82MlNTRytaZkQvajNDK01WRWxwQ0VEbEVIQnlzYklBWWRad0prSDVVSjZDOTFoQ2xiNHlWSkY1RUYvYUNraVNRRUkrNmpBR3lUTUFwNGFjUXRCVVVzQzBiWVJ3NDIxSkRhVUE2eEJLb0JpZ3psQi9VRmp0MXlMbi9uazA4K2tEeEJkOUNsYS9qSTBLOE9nSTVkdXArclozSTh5TjhuREJFZjJVRVNualROSFVoek45QTh5K0p4QU0yelZFQnpQNk41TGhpQmdwUUQ4WCtHN21MK2dpTmtsdXdYVmZBYkg1aWxqSXRFdG1jQSt1NEhFNXlSQnRseUxzeFZkcnFRL1hDVCtnbTE1VEtPdTJaWDFKcUFIVFF2bnpMMHNCT0hEK2c1WHZEVnphOVllK2JjMm5FSFFyMWwzRjNEZjNXc1dQdk16OS83d3BiWHY3QkVVNmpTZXNzOW43djN2c2ViNndxNXV3OG03NHU4KzgzWDMxbWwrRnZIQWZjZFVlbEpBWW1RemFsVm92UXd6V09CVldaVWVGU3d5Z3lVbjZpaWhNeE1DUVdCeUxsZ1dhdlFpVUlhQTBNRnhmTjZVRVdGeFloYWNtMnlWb05ycWloR3hzdDFBcVBKbGd6NHBEWXVxVVJKd3hRVWMzUGRHcWIyUVRQeEdueWR4eW5MQ3hURjFLNnJrTzU0VGUxUDl6eXhmYm5Cb3RKNE9vdDg0K2VQajNDbG41NDVZZCt5K3A5OFp1NWpOVXRPbXo2emZkN0I0dkhkSlIzSHVMYS9uSHZra2EzcnRWNlZ4cGtwTnQzMnl0Nk9tZkhWankzOTZoL216TGovZC9MZlBuUHYxSjBUdkwxTXZoNEhIdHdLZTIwa0plQjFJZ2Vpc3BJSm1oQVRVMWdhKzZCc1JqbGlIaEVmVnl3S3gzTzgzMmF2c1QvT3ZYVncwL2JaaisvWTE3Wk4ySHBzYXZLbnllOG5MeVovVDFmVGNRUFVoWHArRDlENm1Nb0lGc29IL2d6Z1F5ZFIxSHRDaDJPRkVSeEdHSWt6Z0xzenJKSWY1VmNOZ3F3T294akRMVGtQUXdid2JobStaUVR5UitGR0dXajk4enJlbWUyeE1Dc1F6b2JYUkcyMGVVcEc4R0dJWGdXSWFUbG1tTENtcWlpQWtEQVBFRVlhRmU2NWQvUGN2dGZ2ditmaWhvWHI3MzdubVNmLy9kUjlxMWZlODhEZVJidXJRdVBHdWQyVGwyM3ZtYm1KdHE1N3RhYjg4WVdIdmlUdDczMm1Nbkp4dzZmZi9OWVRTNDRkZXVtemdjQTVMaEtlVzFlbTE1Y2M3Wnkyc1E5NTdSNVkvd0dWbG5oSk9mS2FpU2lDcFBnVVFlQzEvRUlUT2hMNXlHc2hSZ2dmOEpyUHlnSWxXbGdzdWc0K0lMOXNzWUlTeXhIUG0yeDhmakhhT2tscmswcGc2VzRUYkk0bEx1Vmp1RUlPRmdMbmFVbE8vS3EzZ002WEJoRnhJSWF5aFE1RHJDWjJGU0xESzZUQVBUODV1KzRyNGJLYTJFLzNQcjExdWRHazFXUk5LK20rT3hCU2w5MHo5Yjd2bmJpenQrMXdxWGhxYys5aGZ0bUxmemwrL0k3M0J1Ly85R2UycnRjVXFGWFdyTm56TjczUk92RlhYN3JyZ1o2T2wzNzdNT0VVdk1FdkE3d2hnaWM3R21VQS9CMHdwdkNHRFJjTjZpMkZOU1JUK2dyak1xTlJoM2d0L0JnRFFyaXZWclMxTDJscmczRVpEb054SFNTWFRDTlNUbmdnSXpWV1hocUpTVGFybEFYc05PQlVCZ1dJWm93T1pDbmo1cU1xUllpaGM3aHprTTVaWXNLU2tSMVhzUGtORUJzL01yTnJvRnV4TXNVYklUaWhQVFZmU2pySVVsNFM3aVlBRyt5MFdrZXJhUWQvKzNBVjk2MmhoN2xGU2Y1QmVvcjIzWitzWmJxcmwvYnlUL0dIV0Z3dlMwRjlZQ1lRYkNFRGFjT3liZ1Q0VVhqMDhoT0hMdkFUYWUvKy9mVHorL2N6bkVxbXczZ3ZLZVBGMkhETzZkeWJ3M1g4OHFYcG9aYXpzUTVmK1EyL0N6Qy9EeERhQ2lLVmhnZUtsTjNMRDh1OFJnRm90a3V5YUJ6c0YyMStjM0NnV0NHbXFEQ3YycTZnTmRFR2tzbm5GeGFWbENJeGkwVXBBNE5xa2hGWU43OElWYjlhOUNreW04WVdBbkJyTHZWak1LRkpTSmtCZTVySWg4ZjllTnN6MzNEbFZubnJkSEhQVVYrVHBqVy8zTEduZDhxWnlrUW4wcnRUMkxkeTAxdWZDYzJzYmNnTGE2TUx4dlgwek5nMFFUdXVhRng3MFlMOVM2WVBOVmUwdHpQY3lwRVdzSGYvckxJQ0l1NGc5NUJFQmNwblVEV1lVS044ZXNEUnQ4VXIxQXJLR01nWnh5NXpFSEIwTWxFRmwxNHF0TXBPZEYvaHNzYkt6SEJ1U3lRaW04SGJuNGplZmcyZ1U3WE5FNnpBeFp0RnVUeUU5aUdJSVpVUUF5WGw0TnZhWkROSzl6Z3g0U3drS2NsdDRsRjB3U3lJL21yVVhJd2FYRDFGY3BqQldLQ05aSjVkaUM5VXBMaUphMFNrU3pYcWxvYWxoNDYxYmZweXBkTXA3SjIyYi8zRHEzcUxldXVyOGg3YlBPRmdYMnYxN00wN21uWXRqOTM1NE5UUDNIdDdDMzE2MFlUUURMZkZUSDJWOVhNOTA3bkRSMzk1ZWxYNXpqV2g5ZDNOeWFWVGxqeThvZWVCQW91RjIvekV1QU52M2JubHEvdG1GNDFmM2hOYS9abGZyeHUvc0tJOHQ2ZWlJU0M0WExWQXp6ekF3Zittc2dOMzZrbVpna3dsUHNvTXk0QmFTeWpRVDQzME00UVI4NEpoUWRDcmo2T2JFS1YrM3N2YnZYd2VmZFZLLy9qQXZjazFlOC9TZVFPY3l2bmhIK20yNU4zMFBmb2UyaFRFVHMrQTNYS3hxTVB5RlA1RnJjcnNWd1UvT0ZEZ1owTVZvSG1wWkZ2bHhvaERSSEpiNVZ6Y0ZldWdWSXJtUkFmd0pRSTNTdDJpd3BGK3Q2Sk1DMFI0S1ZYWUpCMmlZTkViUWMxSlJ5eUp4c3o1QTlFVVlBd1VCV24xNkJmTGFWK2thWDdoM0tXclpxODVzbkZseWJMeHRXLy9iVzI4dGFPN2JkeStINzYrdmI2K2RVSlRmT04zaENGZXRCYWRtZHQ3emw5d1llUEs1NE9pamQrWGxidTl2V092TjM5WFp0YVMydml5VERmSzdFeXdJeGRWR2hJZ1RVcU1SYzdpVTF6cUVBYjc5VjYxRnZSYmNYcXA2QzRSV1orRjB1WE96VVBXYzRoc0tXbSswaUEvZ1MrRXZoRkdCWkIvM0dnU1FzTE1sdVZIOXJjYytFblZNVDNWRkIvcSt0UzN2bnQ2MHIxbGZRMnZiNDZ0M2JDNHE1VGJjZXAzSnhjWDNyMTF2TmJJNnptOWNjSzA1Sy8vOWtIeTdWbWRiY3MyNWpiY2Z1SjFsSzMxd0FzdndENlpTVGFwVGUyU1JVanRValp1VFk0U09UT3h5QmxLa1JhMkl4ZW5ubTFobUFuNEFrZ1BCc3ptZEhCb3dnTE1Xb2xXbUhlUXJxZWxTNCsxN05qKzZXTk4rK1lkUHpScGZjMkZSNm8zVFRySENjbnNraW5KU3hmZlNuNm4zV1BmNUNyWVN6dnA1RU5sV1V6LzdRVCt1UXV3dHdFekdDU05jZG1zQkxESUtvVk5WYWpoakd5Q09wTVNJbURoQTUxQkY1UzRpQklyU0FVSWxPQ0E4dGpKVzRaM2NhN2gzM0dIaE9TQjVNTER5YUlEaXQ1OUZNYmREK1BxU0lzeTd2VmpJbEgweXBqNjBXUHl1bFJ3QW9QMll3WjhsUHZsY0lMK0l1a1hrdnVURy9ZTzM2dU0xWFhsRC93TDhLMGxaQ05KRkJERlpWSUNjaUtNbDVkZm9JWHg4bkM4VWphZUMrVERwU2h1TDNqY2hrZ2l4NHRENStUQm9JaDdjMXlBS3l6YUFuU2x2S0prQmxuSkEvNlN2SEZaekVjK014aGRhUWRjcFhBWVl5NjFSdTIwdWtFL3hVQ1BlVVhHWW54WFlWUFAzQlV6aXJkL003YlNZc283TkhQV1F4VXR1NWJkdjJQOWIrbmF1ZDlZMEg3MDhMSUdic1BXcngrOXZhbll2SG41S2wzKytGbUw1dTM4ZnZMUzNSdW4wSXE5U1ZQcmhPSWxKMytGYTkwQWZIWUcrTXhOcHBLRUF6VU9VVFFPMm5TOXk0R1UxZU5LTXhUeHNBNG1PTFV1RW1IYXdBRytpeUVpMnpHV1pSdVVNNWxTMGpNZGdHU09PbGcyeWlsNnhhaHk0WWZMRFk5U3prVC85akJudVQ5cEZvWW9KM0FhcHpGcDRYdzhHQ3JENVFwdTJmQmpiQitlaHJuRllXNk0xd3lNMTFTREVvMG96b2JBbzBmSDJJeGpXdzZvZUlUSDFKRUV4eUpSSE1GVVR5VEZhKzdxS0JJU3ZEbXY4K25MZitSMkRWTWR0MU13Nzl4NStUOTJzREZYZ2sxRC9lZ2huU1NSaDJOcVllL3RPS0FOQm5UQ2dONndaR1dLSXVHMjRoQnVKM2lUVmpkZVdtMnc0VDRrQTZicFpFS3Z1c29jNmppK3FqbzFQZ2IwR1loY3VWak5DK3JTSlJWTGE4dzJuZkIzcnVNYmd0c2RmR2hoejBQYnQ2bXpWTnBBZUxxanh0Y2xsbkkvMjdsenVMaWhjMDNwakxsZE9OYzVWOTduWHdPOTVnQmZUTEVXWW1ydnRORjBMTk1ob2lQTUltYk1FVWxvakRabUkyRjdYTUJkSW5YVlV4MzFxUzJVYXNRNXozTm1EZWNNTmxjbjh6aWhmSUhiblp5d1FraWFSSjE1K0xmY0hNUHdUNGRMQkk1eWQ2MGYvb3NpSzhkZ2o0NEF2WFNrUHFVUE5QeGdLbkNqQ0tNR1dFYkRKRkdqZzcwZ1ZwbHpETEw4R2FjQlZoRVFHTHBUay9FNmp6ME4rOGF0QWkxa3R0bnNsMS9keS9RMzZzSWsrRnJkcVhXcVUrc1Vvc3piZ2xHTVJwYU94R1FkT0VEb2VNbEd3ang2U1NPQzl5V3AyVkNNQmpLdmpUUHRHTldCYis4WHFaK0s0SjAwMHRhMXg1Si9pQ1dUTVByd2Zkem15NFIvYlRoSkx3K05VOWE2Q3VieEpNekRSS1lvL0lpeUl1QThxUExNNGcwd0dSUG9QSk5WNW1FU2VoTUdVaG0wNFUzS2ZQU2laSUNaQ0JoRDRvMnB2YUFwQ3NCVVZwM2dNczV5V3UzbTRlOEpRME5UK1g2OTFXeTVIT1AvTk9SUWZQQ0dLMytFZmRmRHZwZVM5bFQwTDF1YnNtaUZxSHFEbUUxT085NllTakdBaUpiQnN3ZWd1V3hWSTRvcUJLY3ZRWW1CY1lQTnFsZzJsNmc0T3lIT3pqQVNBK3hNRlpuNWhvYUYrM1kycm4rdGNVcDN3N2ZXTiszZXUzQkdvS1ZuVG5uN2tkSjRwT1JUM2NHWk01dUw2VitvNTdkZzMzWnZQNXY4NE1xNTNYdUxsMzZhbnRqMjVaM1R2RDF6ZDczeGs3MnJsdWQyclpQWU90Q1dQQVc4STVJOE1tRzBWcy9UREE1WWJVeXJXeEdhNXpPcWlvQTdiQkZFeUJtd0VnUWZIdVRxUElESXNsWVhIdzAxR01ZSVVwSDNqZ0lXTyttZDBaYTVSWE1YTDVwZDJOTlVlUm40ZUdtMHBxRzVybmJsWDRRaHdXRXZmLzcxejVmWjdNTHdtNXljbGQzWDFMSWhONGZSTzNtSjBidU1qQ2UzRTRYTVRacEJoUEpPY0NBeVFDZE1ZRE1zQjRLWFcrVkNtSjRWSUszVktzZVI5c0NQYlhnTG5VdDF0QW1OUUJ6QWFuWXVYaGxzQ1hkR0p2cEhjcE9UbVlMQ2RKSm05SlpvbE4zUStEUStjRVZEWEFBZ1NIVklpTEZkWW9IWjBadTA0WnNOazdzamp5Nmd4dHltVU9hbUhDR3p4bTdPTlRzNnd1N2Q5ZXZXVHFtOHA2aGwxcnh3NGNUWnJXVlZwZmQxbDgyYTFSVGc3cmovdDU5YVhMaG41NFBKb1N0bmI5c3A1bGRVWnV2cFBaUlNsZG5RZUY0bDZLcFduL3pYczl1K3NtZW0zelcrNytWZGJ4MjhmVmwrMTRZWGdFWmJZQzh2cFBaeUFVbVlSMW1TMUhhYXI5MU8vUTIyVTg0UTBWc0hxWkIwaXAyMFdSbTRsUExFNjlFa0NLNC9rNDRHajF2b3ptanIvS0xaaSsvYlNnT1BKMy96L3Z2cExmNHQyK0t5cDVZZCtGYis4TGU0cWpHYlRFa2ZZTVFuVlR5SmtrVWtVWm5XKzA3bXlhaVVQQ1c0YTM2WXM1OGwvNlhzaUJ3MEswbEp2eTJWOTVVTTRvRFc0Z3hVSW1ZTTJzQlhJN0pIaTdFVmFzdklES1pDZEpqeHhYQTZTbFpSUVNDVnEyS2dVakg2K0Q3SGtyNDhHSWkrSHAwNi9OaXlRdytzS1VyK2ROeXh0NSs5L1o5YjVodFVnYnRtMzc3dlVQRHpweXVYNTdRdVBqVi81L2RQbmhLc1ptM0R0SHNXckIrWHNhTnk1ZW03THM2WXZKczNHN1h4dHZXVHQwektiSjBZV25naXNtSlpWMmdtMDJjdG9NLzZRWjlwU0owU2QwL0ZzTlFZZkVlSFdGSmZrbFZnV0ZWcVZOOHFBRklKdFFvdjFSZzF2ZW90WTI2bmhkK1NQSGEvc08vZ3djc0hoUU1wZlRuSVB3RTg0U1dOSkpHRE5EV25iSVBrQU1YdFU3QWFFRkd3RDBvNlZrc2l1MEJZL1BCc0Y0Q201aHlsZElUQkI5U09LY0tCVWhLaklnbzVXbEFnMnFySE9KTTIzM2Q0eXVRalB1OHh1NmY2RzF1MmZiM0tJOUl2OFJQVWdzWnBzQTVkM2pXK2Mrcmt6cllEZk12UXEzUDJOaXk5N2JZbDlUdlpQS05nUjk4Q09xakpaSVVPa2lxYUlFZ0tYb2pDUkRVc1l5ZkFSTFZLc0xaUitNTUxHS3cxUzd4VjRpNnFKTUVxcVM3eVJPSkNWT1pVTEVxTDgwYjdRdjNSTTdTRDF0eWJuTlVxSkllQy9Gc2ZYb1l4L1REbWIxbjg4QVdTTURKc1k0aW1ScVhxNkloZG8yRFhxRlZXQTBrMEJtYlhjQUlYdi92MzM3Tm9NYkZLeG90bStBUk00NlhHUzM4K2dIZFZraUZrbHZRWFpjcHBaYzc5QVV6ejRrdGZELzk1bmZLbUxnVG1RQXZ2bTJXVitnTkp1RWdHT0Y1UTZaVTZqd3Q0cmRNYmpLUExPbUI4NWxLd1JXVlQvTWY3RGRUdnYvUDRkOHUrdjNYWGQycmYvcmQ2TUZaUDhHUm9pRi8yNFdWKzB0QjVSbHZnTlA0cnpGOG9VaUwxcUJVd1dBODBSdXpHZ0puTTZXQzNCVDNUNFVBejlzK3ZvelBwd3VSekQxSVQxWnhNZnBuMlBaNThOL2xuN2dTM0pabE5mek44My9CbSttRlNEV1BVd1JqZmhqRzA0Tkd5U0Jrakk3ak9MQ0dudVNTcnhVRk13OGxxVFNyR1Q1U0w5QllCKzlaOWpzWnA5dG5rQXcrQjdUL0ZyUmthU21ycFA2N2EvWDYyVjlWcGpLTm1LRjlnUEtKbUlWOGwxcXRKSlE5NEVSeHpTYkJKYWdRYTFkUmI3ZFZRYjZURzdWekZIUjUrZ0hkeXczZHo4ODErRTdkU3lEaTQ4dko3RnU0ZWxnYzFYZW5pNTZoNlFTYkRMRUtsVXJFSUZlVlpoQW81UW1VRWdTUnBnVVJ3cHdpaUt1WFdVQk0zTVJtbnI3K290dTMrOEJmYlBqSy9hSTlSemVIZDNNR2RLbnZUaDZjYjRMUFBYZW5pL3BZZVh4T1dDWXpQaHhGc3MvRUJWYWhoZktwT0o0TWxraDdmRFlPRGorSjlqcjZlakhNVGgxOXNWZmwzZi9BbitNNnZjbDloT0Y1Tnlra3FtcUVVbEFrUkpsemswZ0R2SWhvaGlQSUZFRTBOTkZUaDVzRFdhQXowcXpSZVJwM3J2dmtyN3MrY2FmanZVWHBiOGtHMkx4MVhldm1YcnZ4VXllSENKRUZ4NFdOMC9oUkkwc0Z2R2JvM3NBOW9tOHR2NVhhcEZoRWI1cGhONFFHcUl6cU1iTnJaRkhRdVlvUXBPTmdVRUtxUk9GWVR1RjF1Wm05UTJhQ3FDZERjMjJPWlhrdUxPY05rdFlybFRUbFpsUUZWTUhxME1TREd4ZHo2RXJOWm0rM042MXVqWUxVVm9BUDM4SytBRG95VGRZb1dUT1FqQ3hXQ00rK2c2Tlh6Z3dPYWlueE1EV2t3dWxPbkJMS3RWd1BaWlpFSUppSGwrbFEwVzdKaExIdEFkT1FYVnJENGZVVWhPaHU1bUM0QnhwWkZHd3BTaklXODNGRVdjR1Y1T1dabXdIS21ZbUt4MFlFdjVYOWM1SXAxZmJIUExsaVp4NW5OTlNjK3Y2THp3UGZXUDErZUs5NXo3c0s5THp5d1p0NzBBMFc1ZVNxZnZ0bmpjcG15NXVYTm1QblhtZmNISEE2Tytnc0tXekxtcjE1NGVOcWt5cFVkdzYrczJ2L1o3ZU9XdEJmbnQ1ZDZtelFheHhLa3gyNmd4N09xbVNRRFpIVk9Ddk9oMnlsN05ZTUpQZEtqWEszRW5TaHpIYVRNaUtTeHlnR01PNGxLdUVtRHVnZ01iRURzNTNpOWcxR2czSXNPdGxzenhyVkpaNGJNSEZvSmpjM3F6aE1Vc0JUaWNhMjd2OENaakdVUHplczRzcTUxd3NhN3UyYWRDbFhGMUpxU3lxYXcyOU02dGI2a3BINWFjMzc3MWl6VlRMMUpieHIrejhuejZqZS9zbjMzYXp1YnAwN1l5KzFPL3FVeU9yazBTMk11NzlnL1k5RjkweUtXaWMzSWwxdlFoK1JmSXZtQUpoSzV1RGdYTEk3SHhUSDg0MkU3YkJkWjlTQ1JyUzZNY2hKTlpsWUs5eEVHQnpCTUxqQTA0QnFKTDVFdFZQdTlEUmRxVitzb3o5bExxMmFVSDVFdkhPODRGTzRaTjdEOFc4a1A2WS9mb3ZZRk0zWnIvR3BWUnFFbjR5c1BmKzZIOVRYTE83dXBHK1BmZ0hIT0FPMXpZVjZBMGV4SSsweWNYZ0ZBSFRWVlVrb0pkWmhaZUQwV2VpalZXWG1BZXZLc0tPYXl2UVI0MFdKU2NJOHVEeXVyTWhHNmhnc3daZWZTalFtL0t0dGdkN2o5UlkxVThTcGlvNzBLek45eHZSVlRibDlUdS9oKzMyZXBVY3RwUDYwcmUyaCsrNkUxclNmOU5aMFRmTjBIcyt4V2NjNzhVTm1zYVpYMDdWV2ZYemN4ZjA0WFY2VjNtaXlYbTJ1OGVZSHBVM3NidG4zajlOeDdlMnFkUzJZMHJMKzN2blZPdm5maUNTWjd2K2MveFgrRlZVbmNSaExadUZTbkNyUW5MalVnREE1NExObVlxL1FJSXdVVEZsaXFKNElSTlFRaFJyMFNoZmRiWUhVcUoyWXhKS09ZTUxzekdGNjNvRE9GMTVKSGxJa3hmcldBZ3FFM2pSZlpMUlVZNUdKZWh2ZHd5U3M2ZHAyZDNiang5c2tXUFQrOG1pOXY2WmxhY25yUmpQb1hibHZ5dVYxdHB6aWVhK2pjVkRKOVdnUDk5dDV2N0dqeWRSMmRYMStYbno5dGYzZWw3ZmFwSFYzTjJ5LzgxRzdyN2VqSmFkcUsvSFlRN04rL2dWN3prUm1wR2pJU2x2S2lNZ1hkblJPUkhHR01tN0NjczVkVjdYakFUY21PSkR3c1J1WEpBMVRuOWVDbEYxRmRBYktrQTBRTS9CYTJvdW9vQzU2enJLc2FRSFlxTUdYbWNxbUMvQTYrWWZkV1BML2lmTjk0bFlGeVF2N2Exb1lWT1ZZclJ5dVQzLzhVTjdTMXQzdDk5WlNlTzQ1Um5jNm1EamRVUjNLbmhDc21iaDBXdUNHbG5tVnE4akgrVGY2YllNZTd5U3p5QnVBaDJDREpHcFZud1FMc0Vha21MRGNMZzFKbkdEUE5VazVZbm9iTDZRbEx1a3Z5RlBDdkNRYWo2K0ZpaWxYeTRMVmdZRWJUWThCYjhnell3VXpqWVAvNHpCbmFvRndCekRzYjdreXBWN3h4andnMldwcGhhOUhsR0l0cm1qc21UWjJGNkgyOEtKdmRvRkFyTXRGaGR1SjJkellERjFTUWV1U0NZbEhtSnNWWmZiUGdnZWRwb3F6T2crZFpObG1YeWJnRW5CZXdQMVZZWjVmT3BicmhrVTlSRlN2WitBQWlmUXp1d2Yxb3lxa1pLYnhoOTVsWDR3T2FxMjBPRjJaZWZWUFBUdXByN2ZyaHZZY1hMRDlvc2RveTh1WlBESC9yZUZOOFhHM0ZiSHQ5TUZ1bnlaM3Y2K2pLYVYxeVpzRzJMeXdvdmF0MzZ1YWozWE9yNi9OUDJ6ZVZiUzNiOWR5dVhjOGRYcjgwTUx0M1h1bGQzY2RlblRlTDdoVEtPK1llK29xelBsUnVOVktPbXMyNTYxc0NreWZIQ3dManU3cW5GT1NYVkhRWE51dFVWS1Z1NFg2TFg2RGc1cE93ZVRzQVYzZ0I1U2x4R1Z1VTdSM0dTeG5RVUNDK0Y5UzROaUlMemtISnE2QjhtMzRVeWpkbUlYV3owTERwNGdCNFJRVTFSVWRRZjdxd0hYZ3RaY3ZRVGpuRms4OVJremIyMUlMcGQvcDk5L01aR1pISjQvYjRjK3lxNlp5Z00ybU53Ky9NdUgzT2xNa1BESCticXdwVlRjK3Bud2tPYjNUNE44d3VmeGZtSGxRMUV4MTRySXRUcUE3bFJSTlIxQU5HRjBWQXA3cEJsbVhsVW5Fc0xoM0hTbkNha2ZBaVorMTNjQVl6V0NqWElGdWVoZ05IM21peWlrcU5mbFNKT29wUkowbmw0Yjc3NTEvVEhUOVBibTJhMjlRMGR6djM4czZoNzI0WG5wdmIyRGkzRWV0YmtnL3hEcGhiTnZHVGVTUWhNc01CODhrTVk3QWQ1RmpPeDJrVmhDVXptQkdZbHRtT2N6RmJZUzVtbUF0NCttQlBZUzRZaUxDYllTNTUrVDQvczVOVzNVaFkwaDFMMTRxZ080WFFMZTFRcFdlNWZMRkd4NmxkNWUyQnhwVlpHY2tuNlg5WXNrT0oxWE1lb00remliOXpRSjBqNk55RkdVMjFWVXQ1L2U2aHM5MTkxZk9YdHFtK282eEVpUSsrei84RWVNUkphbEk4WW9vbXRDamZ5Qjh1cFVERXltS1VidFE4V296UGFld2dRbFNVaFBqVjBLQVNwL1NuQXBYSFBzK1pOZlRIeGUzVnlXMzBUWFBaWExjcmVXZ1BwNXBwRkhXV29WL1FmbjN5M3VIdkN4eWx2OWlTL0d5cVhtTXh6RU5IR3Nic05zT0tLaVZ6OEZHYm5NNGRWS2RRcnZOeDZreStUeCtoanUzQ2loMlhDN2ZER0ZQQVQzZ1Y3RTBJYXpVWXFDRSs4T2tvckphWlY4a1lsVXRBa2VWR1dORVZyRHdFM2gzSFNzbFJHbndtaHZrY2JOZFlFWmJzRHpGcGtId1kvWkFjU3BxdHhBR0tpTmU1MDJCSG93Z0lVOUVzNVNsVzFXQ0VDSXRXMlN1bXN2RjZ5akhPZDF0dFU2OGhlOHVFcFpWMkd6MUJLYWRXdWFvYUt3TEg5WWFLN0hIaFBQNlozbWpMNVBxbXJxN2MyZVgxd3l1NWM2b1NoeWZMVURXcmRjYndBOXp4K2Q2Q2dqazEwNGJ2WS90N0Q5YkJ3SnF6MC9rZ1dPVFZGY3NPOVVpbUt0dksxcHB0UlplUG1WWk1KcHF5MlFMQjVLU3JaTERhNm1ZU2Y4K1pzZUsrMTU5dDU1OTU4bm81NzZ4S3lmbk1LNy9sWHdEOGJRY1VNSUVrTE9sc0p4UHkzS3RvRE9Qa0RxdWNoU0ZicTNLV0pRc0x4MVZZVlN6bnVsRnM5S010dkFJclVWVzdSc3F0Wm5idS9OemM2YWUzdGJkdCs4eXN1WS90NkhqNDZXMGJIbjk2NCtiUDBlLzJ2WFN3cTJYblY3ZHRlbm4zK0luN0wyeDk1czFYbmhuNCt0Y1pKazQrei9mREhCMmtERFVwbTJNT0lFYUNaR1FUUmJ2bkFIa3BUOHVMVEcyUkNBWjNmVGhoUUpJaDVCL255SVNMYzRCRjlEWk93V01LUWE5Q1lkRnZkekI3TXhvTnEzZWZxWGhrZnNlUjllTW1iTHE3cStlQjhKblRuTkdVdmEwOXYzVjZVMmxaNDh5bXZJNGQyWm44TXllNzU5WnRlbVhIM3RkMk5rMXRUNGI1V2JPNlorYzFqVGVYZFJ5Y3RmVFRVeXBOWFUxMWpQWnpZRjEzOHhmQk95dkJkWTFVTDVsSDFsWEl0R3c2alpaaFpTVkxXTkZ0OGdET3RBS1BZUFpNek1CMU9VZUMxc1JtaW8vYUNpR2Zvb0psMlRFdVhaT1REb2h5YzlxMjNEZWx0THVtUE1jdUNQZWNLajgzNzdGL1AvM1l1a2tBTEYwNVJ6c3FGMHdPZ1k1NFpWdXpMY2Z2eTlYcWpsMFc2TytuOWxMblgxOTZBL0hrb3kzVHBoVlBPWWE4L2diSTkvUEE2NWxZa2FORXEwY1kzWUtzbE1XV2tja1lYYzVtTlpRczNhQlQxSm1Ta2xYRUZmQTlwNkJCUUZKTzhZMEhWV1gvdk9iTXlqYU4wU2pVck15dDY1eVlsNWV2NHZobkI1YjJyYnBYWTNHbzJrMzU0eXJDY3lvTGtyVXdsMjJBYmUrRXVkUmdCV1ExaXg4QmRzL0JxUlFobkkyRnBjeExjb21WbmFEQUN0a0tZSnBhclAvTlRBY3JqZUo1blRXbnFMd2E4VTZGTFpIdjlURllXNlJqRWN2TWZFL0Y2SWlsY2xRQ1BlQ1FlaVJrT1NwaVNWbkVFdmhyMnl5OXl0VjgxOFRiVGl3cWZpblQ3cXdwcU1oMXZ2N282dk10c3cxQzRWMXpwMjlkV1BCaDNkM1JSV2Q3ZjMvZ2xNcHNWV2RHWWpOYko1WFo2blVhYlVaR1NiRFJ1L1pjZDhkQlBrZFZNWDFpcksxY25PaWRmTFJtMWF5b0VvODVlZVZQL0tlRVY4QTZ2cEpDOWVoZk1kRElSZEdmbHZ3UlpoNjlMR21RRUJuUUZjMmd4UXRUMVpZL3Yvd0ZGai96aHpBNHBnTGMvNEZaMGwxVVNYNXJQK2ZuOGNqVVR5K2ZZMGVtTE5aK3ZVVm5EL1liOEtlcTM0aFBDWGd4NnJ5VVBrNzZlWU5PbjQ2Z0dZd1d2L0xxNnNFb0YycTZ6TGhrRWVVTUwyUGZXQlJJeS9LQUZvVFM2bFJjbU5XbHNCS3AyRW51bCtMakhLZW5nbEVRYUNUNXBrMnRuMWUvZUhQbzVNTW4yek96QkRzZjNuazV5MlJ3YTkzcnk0SzdMMXc0VWpGbFlzL1cyMWNVTEJrZisvdnZnRllId0JlOWszOEdNTnJrbE1mSENLYkZRQ3dTekt3RVlvRlNQUEFLenlvSkpCUElubFZCYUU0ZVpwME5YS0cxdzRXVDhYRUdURDZiUnErSnhvS1hWMTFWSFV1RlpMa0QzR2x2OXBMYTF1M2V3Z2YwRHdsYzZLRzVDeDhwRm0wY2ZZVFREYjkvYkZ5c1lVcmpoRzBjTi9SQ1RYNVd0azdmTVhuZWlnVkZpeHBTZFZaWFBnQWYrbGxpSWNXS1JtVGFVTkpIMmZFUC9TVld6eTZpaUJHc2RtQzFvVkVYa3BEYWEySlJQQUk1WGVaMEFqV2ZXWnAzWjhIcWQ3Znd6K3F6QkpWMmVCYnQvZFdUei96bjhPL1lPQjZRNlgrRmNWemtQRW00Y0J5YjNSbkZTS3ppZzFESnJVVGQ5Smg1eGxRRjhrOVQ5QzlLL05VSi9PTzRLS3N6UHBBMEYxLzYraGYvK0t3U1k3V0haS2REQzIrWlFTNC9rTFFYWDJxZTlsK2ZVOTZ6d2U4WXJMSldwNVZzNEZWbmZxRENsOWJNRDNoeVhxM1I2Z3lPOUpFN1BYdHB0ZGtkempISDdHUVZTV2RPN1lpTzNMQWJkbHVzSmxCVkhlVllZTlp6UnRDb2hXT1B6LzltbmRWRWp6VXNQdjZGcDQ3d3o1cXo3YmJoaGR6WjRUNTZ4L0d0MDYzbVpIbXlsRnMwL0FTanhWTE14d0V0eHNacTZVZkhhck5ackpieVMrbkU1SmNmKzYvQnp5Ui9RT2QrUHBuOEczMmJmamY1RkYyUXJFM20wN1hKMDhxK2hwSVA4K2RoREIvbXJDMzQzWmxSeVJ0RzdjVThWRkJhV2VLZzRvWHF2Q3dLaHhKRFhZckVnR2ZOTXVrMXpaU08yVzRLQmd6TWNiZEt6WE9DcXpwL1lwM1hrNWM4Y29IcUJXcnJyN0k5R0lnbGYxRllOdisrWGNuZkh4RU1GbDdyem1yMGQ3WHhuOU5uYXdUajhGVDZYL2V2dnVQazBORHl5dHZTTWQ5ek1NL3JZNzcwRThSOG5lbVk3L2poMzNML092d2FWODVDdnR4ckIxY094NVdRTDR5MU52a3lQMEdWUWFhQkxwY2F3M0lkWUVRc1RoUVE4dU41TUJjQzFPbk0zNTNZRFliUmkzR0pDcmlZZ2VQWE5jTDRiWEdKaUhMNVJMUTBOcWs0TG1XS0NWME9Lemh4MmZwRmh6MWJDUzVWcDl4S1VDNU5tanBhVDUwZ3JtQ0VNTXlFM3BZbWo4ZEtEUkJ0UVhtM2xBdXBBcWw2cHlMLzJ1S0Y1ZFhxbFdaZlRrbFcyRmxsclZVMWRaZzdzc0plNnd5MUo3VENHNnZKMTh3eXVyMWl1VEd1NnU3U3RkaHIzT1ZaQlhubXpkcWEwcm4wcmMzaDJJNk1KVmt2OXBwY1ZwTld6ZE90RkhTYlBucFB4dUxNNWEyTGc0YlNqaDNkM28xWjUrcTBSbzJLMjBJRmxkNW9NOHo5VWVtUnZMdXFTNVN6UXE4azMrRGFWTFVzN292QlhwUlBIdHg2ZkNoeFh3b0tpYjV5ZC9JTjlib1BUakVhZnhsby9BQ2o4V3dDTUVvT01lTEtyaFNwVXdUdXZDVEhHekRDaGVqVWt5WndxQndJWElna2xUME5qS0JTS3lPM3BVMGh0MWFoYkIyWHAxWXFYc0I5WjVSTms5V3NMcVZZNWxiSE5mRXA4amR4c2FJMFhVTzgydi9sSmxXdHRjb1p6aXJKOFpsWHFxckxlNHRMNTViV2FEZWI4d3F5eXQwMTloWmRWN2NxYml3WHZXN2pMRTErVGN5N0l1UlJ6N0I2dzFrZFp1SEpyWlJYYTAxV2w2bjN4YXdsR1R0aTRjMGwxWGZsSFNuOTBWeUR6YWhYQ1hRTHA5SVl0WFhuc2paNnUzZDBsQnFDaTF1WFp5N091Q2VxTndwZ0N2QmNHZmNaL252OEJaSkJxb2dTcm5RQnoxdEJPTEdtQUtpVnhhVFNpaERNZ1NFd21YZXhpcElVSEdNZ2s3OWFEQWV3VXRNVFBqTXJQTE1oMXV3SlRZa3Nxanc5SnpRMVh0M2lXemladXpKOWxhZTgzTk02WVVyM0psKzR3cmYvdWpQeW5TbU56Q3k3SnZ5UlorVzE3S3k4bURva0wrSWhlVjZ0NFJRSG5Jd2NrcStKMmFOMmpMT2tVb2RGcVVQeWRhbkQ4ZW16OHNJWFdQSHhVS2o4cVF5dWV2aU50ak9lMUhsNTlNK3ZMT1lmRnBLa2tKUlJuaWdWSU40d3ByVTlVZG10R1FRNEsvUElVUXBjTHdMVFVhUWc5UkF6SDFKUkZwVzl2dEMzaWV6emhyN05BTW0yOTJYRk92aXNrbkRSTEhtdERJNzRyUDI4VDBBNHN2WDlaeGdjOFFJYzhTSWNjWGtaSEhHekZ4NzgrVkx6b1grSTdFUHdhMzc4dGY0Uy9LbnFMOFduQk53YWhWbEs0Z240aWhSNkdkRHBYZjZTdE5uaEJYanA5dmhMU3E4OTNZMmxuZ05HWXNwbXRkMmc4VmdTcmNyV0RPaFBBNjU1cWpZU3cxYUJOQ2NFcVNZUUswSms3cmFiNmZMTGIrWWVwMW9kNTNwczVud2RGWVM2eFl1NXJudXJ1MW9IVmxyeXR1ZWV2WEQveHNYekRqM05oWDVBcmZyM3pDYXJhUGk4NThCV3Raa3pxblZDVys1d3RDRzJ2S1A3WGZQL0tTVlhYajM4Y2hIM0RlMHJUTWFuWFhtSGYxVVlBa3dzazBRTjJxK0txQndFYUdobHg1NVVnM0pWamRWemtZVVJCL1M2R3FzSjlpMHE2MVdEVW42RVFXYjFKYm5BTkpnb1lPbXRBcTh1Mko5Ym9BYStZZ1U5WVRrWG5vb2lDVk11dm0zU0FaNnNaZlZHV0lCaUFIRW95QVcyeS9jVlY3RllTMVdOVXFZY0ZOR0lGZHV3V0ZrbnltcFF5bktXSG43SGhHRU9xM0pPUGdiNkFGV0J2enFxRkFTTUhIRkJiUkoxK2xHTklPaE8xeTJqUnordHZpaGc3Y2cvMm1kKzYvUzVUZk4xSnBYV016RXc3NUQ0aHBRektTK3ovY2UxUGVOaWZXdHFkaDFvN3Z2MHlteUhKM1A5aVVsM2JCdmY4c3licXpkcDhsUTZkL2FkTytQZDI3WlBQN2RMMVJQdjZ5a1BUUWIrUGtHbjhWdUZXdkJ6dkdRemtWeXdjRkNUYUtUUnMvQ3hiSGkyWVJCZCtYeWwxSVZCeFd5QWl2MVVVR2NpYStTTC9ScURJd012cmJaK28xbTBNNXJrZ3NMb3R4SGxEYS9ZTDVoRmlwYzZXNzlLWXpBcE5pcFdWQlVMeERCYTZvNjVOUzRIbmtsR1NLeEpCMEZQYkttcjN6cHg2NHpWSzJadW5yaXBzV0hqeEkwemIxczljOHVTWGMvdDNQa2NQYnRseHBzenQwemMwbEFQNzg3OHdZeE5uUnZyR3pmVDE1WElKU1ZkZ0hOZUF2bk5JRHZUMkZMSkZ3K0lOZ3N4SWNxVVJWaXhNVExnZExFYjZpZ21EaVJ0Qk5VZzlnYXd1N0ZNM1F6MlJoZUpKTXdXRm4vVDZyQWNNbUV4NHl1TEUxNkpFUlpSTUZ2U2VXZlhtTHl6MDV2NjMxL3RUZjNmOVNndG9kYXp5WWVvSS9rSGZKeEkvb3JtNDBOSUR2K09jd3d2S2QxMmNNdTN2NzNsNExaUzFKZFhiYUdHNUpKVWpoZ0xIbmtUQzZwcHdDYnFSbXdpcjlqRnU4RXljdDhjcnVQdjU5NGVMbUMrK3AxWDd1Zm5xcGFRSmpLRkhDQlNRMWpXZ3lJcmhxMUhZRGFWTmNRSWdvZmd3UGg2TTF3RVdSeEg2b2pJY1RDV1VjQnMwMkNselZrSURtbWNjVDNzcThuV290ZUx1Y1hoaHZFVEpuWGpUc2ZGaExlZ0JuRkoxQ1o1TUZRQm9uQ0IwQ3lQTno2aE8zMktqVXVmWWtOL2sxWHZwODhqTWNkNWxOTTVxcTRjRkxxZDNXUE5FZUFYemZUT05Sb0FHVUpPVFcvMWdnMkxpdCtxUHRRN3FYMzgxejYxOHRtS0xZQXZPT3V5aWRQNjF1V2RLbGt4ZDlhRTF2R3ZuVjMxOHViMTNudDh2dUx0ZWZzelNxcGE5dkZHRzYvM1Yvb1hqNThmeTJqT243eHJ3b2JzNE43V0hmKzBkTllxbGRrdWxFMWUyTHFvemxwdEQrOXVhbDZiWGJaL3dwNUVML2Zxc21wcndDeU9DNnlxc3hUcnplMk14dThKaDNpdmFqcnNsRVhKcm9QM0pmTzZRVWtmd1NmbTJWQndOVnlEa2twSnQ1bGNpcE5UVVdsTG1iQjB2NWYzR21ZM05zNm1rWVpaalkyemhLL09ibUN2OGFlU1U4a2hBWDVJYUNSbWtPSmFzb01BZkIrd3NUWW5tRTRKQTNlWEtHS2RBWGFWM2FkU25PWEJMUWJpZ2s5WmxHQllHY2g1R2ZNS0I3VHNEYmtPdmNJeTBkYWlNeGg1VzBhdUoxckRSTHNralBlMEZtZVdoM2dqMGF1NVRCWjNvcDRRSFFtVmVkVHU5RjdTYWhaOUdwM2tMTXFoaFcrdWVQSG8xS1B2SnYvMjd0R0ZmM3JtNlQvL0tUbndsODN5dnNYM09QbzBsTFBrMXZxbmJ0dzR2V0tHZTBId3JrbDd2OGhWL294R3BwLzQrdHI3L3VQRThmKzQ3OFhoNFFzdkpwTURoNzdRTjdORTY2WGFESTlyMmZ5RmQwUktHMW9udmN6bzh6Q044YXVFeTNBVklIR3loeVN5MFVhNHJpTHZ3ckFjaEtkSVdMWUtDUHhaWWw2NEpCY2JRU3dVYXk0aUJQY2FsY1I4TWFZeXNKQlA4b25uRGE3c3dxQmlCZkJJbWV6MXcvMElCclJCRzhvbU00SklrWDA2ZGR3SU0yd3FCTnhLampDVnEzZU5TZFhIbWlobTZvdFlMUFJoN28zaHZzWUdzVGkzeXRsczZLUjVya0R2dm5FZEsxK1lmU2cvNCtDaXZhdnZQdElabjlPV1ovVVpHdndSZTFNRGpXM1lRTDhRVytYUm1YVWFuc3ZzOERYT243VzFiVnhrYWJLMWJlNitSZVV0clRsMVpRVlU0QTNqOFp3bjJjZC9tcThpYW1JaXhGNU4zUnFxU1QwZHA3R3A3MVAxakFvYW0vWVBlS2FYS21pbzU2L0pkMmJRZWVrclpvOWZwdVA0YWR5M2lJcFVwRTlicFRzS0NKaGRWak9DOHNiQmhNQk9jd3NZWjllTWRBM3dpeTl6RHh6aTJnNGw5d0RNK3NSbjlvVXhNbEFDbVBiRjBWSlFIQjRvVlZvREZaZmk0TVhZRTZncVBKQ3R2RDFLTEtxdkY0dUJFZ01wZ0ZlbGtWU0RrZ0d2OHJaM2pLaGdpNDRTMUloR1RCS0h4UUVEYndzVU1OTm5rOTFGY004cGdtTUJPaEFyQ0F2eFJxazRRQ3pPQWkxK3FBb1BDSHlFRU5sRkRQZ3ovV2ZYOEg2bnFQaDJXQWQ1RXhGNjdXdTlsWkhhOGRWM0xqdHd0RytpdHlUa25ianl4cktUREhDem5jNlpsYkU1bGl2RVRNa3duZUxNTEN2UHRzTStEQXRIZVVINEFQYkJSMUxpZ2crMkR3Uld6N3V3dW1mVWxneHpHdUhvbGkyb0E5L24vZ3QwWUE3UkVodHBZeFZHUm9GbDJuajhBcnRTRW1oZzVZQll3NjBDYklINUVMTnVWTmNyV1RTQzJ5R28wb2U5VW1mYllvZ09XTmVXOTU5NDd3bjR0My8rL3Zud1Q5QnRldUtKZDU1NGZPdUVKVXZhNEtHY0JTUisvbG5oSERHQUxsNU1XSEJEUFhoTHpTK3NOMjUrWVZGT0hhVDZYeGlWeWlqeHVoWVk3R0JodWcxRzhpdy9pZnZLMVZZWXd5c1BIZ1Q2dnN1cCtTcFZKdmdYTXdpUUJDbUVCMC9ZMFVHa1VsRll5cmtrcXcyRGlSd0dWSFBzSURkWUlhUE9ZV2N2aUd6RVlKMGpMb2tpTzl0cUd5QjZkVWJobUhPQ0duRDZsUTRFM21wd1N0TW5lYkhVK04zeUp4YnRQTGM0YitPMkNOMW0wSnNzdzY4Vzk3WGRybzdHWnJYWExzMVY2d1ZodzdUNVJ4ZXZtcHN6ZFdHdHppUWNuQjliVnpkZFZkb1ZqSFpGQ3JYWkdpV3U4UjdIOGMycUxKRCt1VVFLaFdXdGdON2tnRk9Sc095dzdCT1VVaDhEWUF2WTh3ekVGdGpwQjZ0OERIand1eGhUbGxyV2hpQVlWOFNsT0M1bDJ4SjUrWVh4VkVTSXVrZDE4ZEZVdTBZZGZyK3VFY0Y3aTJHM0RKNFpaWlA2VFA3Sk1XZHhsbVhCMU5uanEyNHJtRlQxcVNtYkhtcXBhcDM5MHQ1Wm4rSHU2dE1WNlEwWm5pa3gwVmVVSWF6aW1vSVZFeVBsM1kzakRzMnZuU01hVnJRc1A5Nk9zWWpIaFhMdWt1b3N5SUlIYTlDd3BzeUlTb05GSlFZNEZ6R1BTQUsxdTNuNitNREI3d2xyYVBtYzVCOFlqU3FUei9QL3lUOURTb0VqRTRYb3MrUkhaUU1ReXEyRW1pUVJtNW14aW42ZTFkNHAxUTZsQnRZbHlZcXBRcU5TMm05VksxRUt1eWo1VXNjTCtyTnpmTVhLcnRmWWxDRHRtSWd0MGdvOE44VVZWbjVhTlpXMCtHaCsxb0pJN1lyc3JNT2lxelMvMW1TS2VSYlZ0Q3pSK3UrZU9tbS9oMHMrdjVFTzNjWHBobit5dWFXbW9iT3BZVDJYUDl6ZWxsOWNtWm01dXJLbGQvekV1Vk1uSkwvOW9OTGJaQ3UvVHpXVGlLU0ZTWmxHTlpnd3NxeXEwUVF5b291dzlMcjVrbXd5NEptSkFlTENtandVUkpPVjFXeUNNa2dkWnJhemdyWW9TaEgrSDZLSDE2OEliZXBzb1hUSFE3c2Zlb3QvZitsVFFZZUQvOUNyNnZ2d0RKK3Yvejd1ejBhdWdsdkdaNE8rQ1pGVURNRW0zRXJERm5ydGlXbnU2WFRIRnZ6ZWNja3p2QjJ1M05oREJPdDNCd3c2NG9lWkc2d0Rab0Zrd1pYcnFnbkp3SFlQQXliRlJwaVVjbDY3Z1oyWWtrMm96SGl6aStWZU1LQ0MzcUpCbEtrOXpnb1FYYWxLOFNDTlJUVnVwY0dmMzBmSFJlZHZxaTV4T1dJTjdya0dYelNuY2Z2dFI1UHY5RXpNdDd2TXBpOHU1VGh6WG11RDBxdGdHUFNKVjJVbGVqdzd4OHF2MWVGVWk1V1I3aXFHVDl4ZFpaaWE1M3gxK0wvZWZFM1k4OER3U2dBWC80aU00S29QNGNwTzhraEgyajZnaG5lREI1VWJWb29jODVucGR4aEdrcTdZUzgrVFRycHF4SkdrcTJBY2haRkc1VEJqVjN0MElSUmErTXFSK09xZWFNMzh0WFVIQnZadW1OUzFZZDNaOVFoNXVLYm5meGFhODZsNWk4OHVDSC96bjNZZU9iaG4zNGtUMStLYkdBM0VxSk1XS2svSHFlcjlhVFNXZklYNnFQb2Y3T3I3Tk8rdlBja2ZWU1NmbVRGeWhYd2dFT09WVGZ3UFZXdFlIN1JNUUJ6ZllqMFRuZEdCTElVSjdPQVBaakYvTUFQb21zVWN4U3dSYlVWNFFLTW9RaDQ3U0xLU0F3cjNqU0RzdWJnbkF6ekRHRGZlRnN6VVpJUDdsUkVac0N0YzVZb2s3S3hKalIyUG8yV3ppcEJzTUVxc0F3UnVvRXdSZG1hTFVoYm9DSUFrak1aWjZKbGE0NUphbEhMaXNoR3JSNGtwbFp4S2I3U2R1bWtzMVFVRlBOVkF0TnI0MDdaenljVlBmSFliZDNEcDhMNy9RenViVjYxYStOV0x3dCszRC85KzNqeDZLbkE1UjdVbDl1SEoxWFgweWVUNktZODgxdjFYeE56R0sydjR2NlZvRlNYbmllUWJnVnVlaUZRK0FzMCtpalJWdDBTYVVrQWhUdVV6cFU1OG85UUhsS2dlUTRsUzhielJaTEZsWW1CY2N0cWtQR3lINU1OVEJ3ald5d0hFVzV6NXhlakgzSnd1T25wamExcHoxWmlPcFJYTkx6ZzBhY21leVJuekZ4YlRVcjNXWUVqV2VIcHFlb1NlOGJYbGt6TlVHdjQ2SXRJdnRuU3U2WjdSN21ycEt0Y1loRldkWlhOQzQvaTJ1cEw2NGx5MVN3MDg2R1k4dUJNMFhJUTBnb3kvUjVURU5HdU1VNEkySlJxVzR0R0JKb1VsWTVGRXRBbUpFbTBBd2pWRjhiS3BHZ2hYRmg1UUszUTNod2ZzeW9jcnd2MVpGUjV6Y0NBenBjcGFNUTJSeHI4dWJBUGhWNjRCQ0RjRFJ6WkVCbUlLUjlaRkVyRm0vUEpZSE1acFp2MFZtNk93RCtOUXJidFlCeGk1dVFTZW0rSlNUSlFycXRraHFDamNxSXBMWmFMVUVsZHF3VW1jVlRGaHc1aE1zVDhuMTErWmloTmh6dmxXVGYvMVhPenUxbWkxRGQwTlBZYnNwckxNRElOellrdGJUZW4wM0lhU3pVM3o5MFZMcWlhY1hqRis5M0x1RU96Ykw5STh6dC9lbzhuWFZqZVZtYlB6N1B3TUd2RVYxUmNYTkZSV3IrNHNiemZwcGxaTlhWODc5TXoxM0svMHp2a05mMGVxSjhRMmtqQ2dlZmVFNVV6TklKajNWSCtJZENHcXk4Nk9GT3VaZ1VETDJDK2FpbUViQ3BRMkVRWGhWTU1JVnA5YTRGS3FoUFFZUzVSTXR2T1puc0tpMGlERHlvWk1oRTg1dWVtS0NZRzVrVkYyREY4WTQzYXpFQU0yUnp4K3cvNFFxOGU5dGUyWjF3Wlpsd2c2OWFZTklwYXUzUFFXLzNld2s1VVZiU0R6cktlQnVvZG9BR21icis5cVlMemExY0FTUmpoRGxBSkE4K2l1QmpHVmhvN3BiTEJqT28xWEpMODF1citCNnZXVFgrb1plcGkrOXo4MFpxRmJ4WThaOHhTTlQwOCtIUnd6NXFOZk9ybi91akhOZ0hXdUc5TnlkVXhibU9FWm1hTHFGY2VNR1hWckFwcXhUUnlLcUxGc2VQeVAzNjBkTS9DSk4xK2ZjditKb1VlVm5nN0sySDB3dGc5OGh0blhqdTFQankxbHdYSlZ6SS9RcTVnZmdWNER6TVRQa0tOc3pjTHVON21zazJZK0M5L3BiUWt6OXBrYVBVdTB3a3p1UU0rbGFwdFppNUV4MDFadjNGSFVsZWRxTExWa1pGbzgydTZHK2RYRms2dGE4d3ByZ2pWalZ2S3lYSmp0YnRWbDJrTDZHWlBhSytvcmF0dUgxdUt5UUs4cDY1cks0bVUya2tWV1hic3k2OGpLd09abUFtN1dLU2UwczFtcTFPUmlwM0RSZmN4STVZVk1tTHRXWTdjUWh3amZnU2VocFF5YnJHSzJrRnJaMFlxclMwM0gzT3hYTDBjdHNZQkYzSEJmZWxnUTd1cWFXRFN1WVdnNWZZLytKN3NjMmFOZTRBM3NySFBiU0Mwa3B0ZHNBbFkxcDJ4ZXF0Rk95bnhoaVJmR0czVHNGUXUzT3dYbEJFaVdPS0RXVUlkUkNaOUxkbGhCRG5hTEVYVFU2SEF6RFluZCs2cFRVcTFKZFFneDBGUVFYWjFIdjlTeGVOM0Q2NWQzMG5kR0dvWk1pN1JINEI4bi9KZDJWVnRYWDE5WCsycjFaV082Z3dqOVpTQVdteEtyVWZRWjJCZiszNFVrN0k2ZG5FbWRZaU9XYVBScVN3ZzdPMG80WUxZYWNhUE1LbXpXWUJ4cEVPRlFTdTZOcklNRnVNcVNNY0k2TFlOVHJSV1pPZWV3ZFlNV1d6YzRVeWZ2REg5NExYM3dqVjZFMzVQc0Yvdk5GanYyU01hZmZEODFXKzJwZkJYV2EySmhqVDMxRUdIOVVkR3ZvL2R6N2NtSEJScE0vZ3RQZTVLbHliK3ZPL0ZIOTBqRENUby8rVFQ5SWZlQ2NuNE5jRDcyRG1ra1c4aEl5eEJzNXhOT0IxTUhmSXFsMUFNNmFScHBsK0syTWk4MkFMQzJHVnNEdXpFNHFuWmtlWDJsWmJGYXBldFdLV3hrV1Z5cUVlVkFlVHd1NjMyb3FkMjE4Zml0Tmh5eDBCRi9JRERhVDdoNUc1S3FaNWZyVXM3QzJoRUh3dEc2YStlODJOWEdKQnJUdFkxSlpxOHpUazE1Rk4wcEYrTWhWY1dLKzM0K2NvNzdMdEI5R0V2NTJLNGcxby9yQ2lKZTF4V0VnZ0VZMVJsaytERlUveVBicGZvbWFQNy9uWG1BVVJnOWoxL1MrSXprVTFjbjhsa3dCMlBuWWNPdUdoODlEL3ZIelFQMWw0NG9IWGF1blE4ekdLT250SVNhbUxtNE9xbTdtYWxnTVc5bFhsTmhYbmFTamIxTlBtcG1PTEdzcUd3QmxlcUtwR3Q0YnpoTms0NG9xWGNNMm1Fam1rd1hTejFoZWErSUN0ZHNqMTg3ZFhKTk9tUDBHaGFNU1cyTUxPVExUSlVxL3hUOXcvcURYTjN2bTNZSXNkNVNoeER4dWc0aHlIZnBMaUhEZzhoMEk3MUNHTno0WDVrRDhGeDZEc2xpeG5CWEo0SDRZOHdjYkZobmU5TTUyRzlwRG96Zk9GQkZKck9vdEcwYk94L0djeU5rT1VPTjVVUEFjRmNuZFNMRmNIeHFYcVA0N1NZenU1N1ZQbjZhL2FLTzB3WVZHeCsraHZsWUY2U3gwNzZXMzBibS85blJ6SFoxRVY4ZHkyd2NhWUsxdk16Nkd4UWhEbUUxMmpaVnFoZWhqeDhjb01UQ200SlNvWExzQ2d0UUE5Z25CZ1BGTnJCd3ZrakN4cnJGMkFxeFc0eU5kWXZCcGRpc0xBcWtOdzNLeGVrbUxiSStsUm1Lam1yZ3BQWjdSVHM3c01tYUhZVDRJRVZmcG1rNXpWdDBwR245K2tkTzlweEtYajZ5ZThLU3lnWExxbVA1N1ZPcUEvZGZ1c1RkdnAzTHpRdE5ULzc0aFI4bFh4eGZ6SzFKR3UzZXhyODl1T1ZmSnBYV09OWEpCZHR4ZmF5M0NXQklFeWtoeDIvYzNRUXJBRENHVThSUVpMcG8rL3BlSjFpeWJTSU1VRXU4T01CWjNWNXNLNGxnMHBDVHg4SmNJNzFQWkRjZTNEUVhzQ2F6UmFMc3hFTlVWbHZDa1hKWXhuWkc0UlhzcWRTdGp3YWZvMXFtMUNqSU15K1VsWUtlalhOVDBETVd2TGFkaXVxZkVYMTZ2S1BnWjd4TnlaK3lIaXNnVTloakpVUW0zckRMU3ZoR1hWWXFVbDFXK3EzcVlEbXo4NSs0MFFvNlBMZlViR1VlNnFSYjdMakNwY3prLyt1MWdUNjdwYldkWmJydVZoZW5tTjVyMWxaNWs3VkZiclMyNktpMWhmNjdhMk82OFphV2w1L3k2MjUxZ1NObWZHU05mYkRHQ3RKT0RxZldHRXV2c1ZVcDNNZ0RVUzFuRWt1bERyWmkvTU1CbFZhNUliWGlUbml1cEVwVmQ0TjQzdW91S0s1UXN6OGZZR05KeWRiWXlQcmxQR3pKNnd4V3hGbG9UTTRwaEdlM0xaSHRMN2daZFc0bXF2d3Q5QlVhL3hFeTNIMXJQWWNFK1FhaVBaeDlnMFpFUW9xZVV4blBSRWdkV1hzRHJrR21pVWZsRU5pb2F0RHQ5YU5aQ0xNdkZXQ0JLcXlzdVhFdFhOWmVaU3drZDFVRk1sYTJ1dkMveDFqWEZuL2NFb2M1Umx1MlcyV3phMEFXSlYrZ0pmeEdRUTAybk5oMU5LYkRtS2RHUjc5QXVXUnlLYmxDdWFYSjk2bXdKSm04UXVnOTFFakZoY24vcEtiNXlUOGwvN2lJaXNsL0tQeDZnSDlOMVFjZWZDRnc3THJVMmJqaU5IVTltcEZHazlsbVZsV0dNUzA4aWEyUE1DY3FHMDJpTzFPSnltb2RMblZlRWJLcHhTYnJET3l3a3dPWTJJVkhlYzhiTEpra2wzVUxWYWZLY3BrSHhlcklSa2djd0hwRXU4T05SM0ZCYXRNSGhzSlVvZXZodmtYck56bnRqTGFIMXQ3V3QvUG92ZTMwaVNuTEdGWFBkQzlpVkZaeGQ5eUhCSjB1MTcrVlU1UWk2dlN2eG43MVJUcjVsL2Z3dGk0azUvQ1gyeFRxbW9oaVl3ZjVKMEEzZVlFT0xUZnFpRk4wczQ0NGdkUloyWDV6anE5QXFXbjkrS1k0YUVadTFoam5aV1k1UHE0N2pyQWlaVFArOStjT1p1Sm1jLzlRc1F3Zk8vbDZ4U2FNbm5zeG1YYWp1WmZjYk82bGFkL0xGMmRyT0cvTzhSY1VzVzdsTGxhNWNXdHJZV2JoWnNzNW1MWUVIN3Vnd0NnYm9LeHBLcXlwQk96Y3R1dFhoWXVxaU1xRm9MREtJdWsrNGFrbDl2dVp5eFp3alY1c2Y5aGxoNXRCRjBhajViQkxNWWtCTEd0Q2VDWUZRZTFqM3NSdWs4c3JickV2MDdXSzYyWTBPTVkwRHExc25OWFFNT3ZqQ2JGZ3RKYmlsUDQvc0w5YVlyeStBNUJwcEFPUSthTTdBT0dmVUxuYUJXaFp5cmUvMmd1SWZ5ck5UK20rZFc1U1FLYVA2bHMzNE1wZzNyTUxIR2xkQWJ0a2xmT0ZTbFFJYklFMkl4SmhQT1pXT3JQakNjY2lSUDBGR2FrbTVWZlB2ZWRTcFYwTEkyZVFadEl4dmV3ZXB3YjEzN28zMUdBM3UrbzFFNjlRUVdsMFZyUHFiOElRcjlMYWRjWXZXWFBLbjMvOW1iSXNhL0xMOUd1cFhtZlpvTk0zWGZrOWYwRTFuMVNSTzBaM1lNRThoQzhzK3dFM2xJVmxMZUlHVnZva1Y0RldybEo2MFlqQUp3WXhCL2lreE14S0NBM213VVNKQWIyWkVreXhzWXFuS3RFMm9IV1lNMTNNMm1VU1JUdjdSRmwwQS8vNG1XTlFoazBRY2JGVitEY3lya25XcElOWlk1c0RLMTBubk9JbTN1RUluVjl6OXVkenVyY2MvOWtqT3haTnJKKzYvT1NraG5HYm0rcnJDdW82RC9kV0xmZG41d2o4c29iT3ZyTGJ0MTA2TmZkVW9PRGJkeno5cStZdDRUUHJweDR0TE5sbXpkclZ1Zko0VmJTNGIyTEQwSU1nVDZ4UGorb3N5Rk0xaVpNTk4rL1VFL3JrblhwZVpKMTZhcFNvWCtqbXZYcXcrdTlXZXZVVXNUT0Q5cGhkYzR1OWV2WlhZWitlblFmUHIwcjE2dkY5VktzZVNyRlpqMkNhazN5cmllbWEvLy9SSnB1NitVOUVtODhQSFB6ZXJkT0dqNlVLZU5LMDJjTm8wMEMyM3hKdEdtOUttNll4dExtUW9rMGQycHRzbXhUL255VlIxQTVXNlJOUktmQnUyYStYUFByMEp5QlVnSHFTLzliK294K004TkVoMVdyV0QzQTZlWFkwclZySDBLb3JUU3VwS2l5WDRwL3VDOHNGcUk5bU1NbzFBZVdhVXBUclZDZ25WVWJrbWZDNkNhR2l6Y2YrMkVPTER1aFhVRnJWMk5xdEVGQU9vOTJTdTFxdkk2RmNDanBMOWpYQzc5V0pjbVV0UEJmWUVzWDQrVnNoN3cxeVlyemk2MXhIOW8raTkrMGJkeFpOeW5FM2xGNzFlcnhObGVYUnpNS2FZTVcxZTNIelRSQXE1YUtzakphMDUrTXBEM2xxMjRlT1hyTTE0UGNvdkR1ZDhXNGphU01EdDhDOXlMd1RvbkljWUVVTHdJcjIwYXdjZ3cyb0IvaFFQNWFyQWRGTDQ5bXhBWGl2T1N5UEIyalJjWlhSNVhyME04WENmUFF0bThXRW84SVNaNTExRW9hV05yd2FMOHF0RS81SGVmOWFXUEtKaEVEVE9BcXJmQUpST0hGTmpYNmEvaWRTOUc4blg3czErZyswS3FtbnR2QkFQSlV5N0xobUd3YWFsT3doU01sNGVGV3Z2THBtWDFnQUlLMXRZcUlreHFVbW01U1BCTC9nS0t5b2pUYzBXdGdmVUt4bmYzUHhodlNYMjBDWSttdnE2bU1zNGZqL1pUTUM2YnprSjlxTnVlc2ZYcmZ1WVpXU3Rmd0V1ekh2ZEYvZjZiN3pnWnJZbEpvYTBFMU8ySXUvODYrUUdqS1I5SkIra2doaEJMUXFLaGZ6N0MrSDJwV2p5cXhhZVhwa1FOVVdzcHVDa2krS2JlZWxyZ2dlMlBDaWJwL05kaUptSEpSaWpQYVlDUEViMkVmOFZua1NCcGtNZy9JY2VJNk4vRjJhOFdMQ2FLK0tNMndrdXlyaGVaS1l5Q3dPNFIyUFRTcEZGeGY3d0FUalVwdVlJS1dWR0pFeHF2RFhYZW0vdEt2UXZxYVpwcHZJcGtwZzNNclBQQzZYcWtiNkM0d3ErRXh2Q0YvVVNEV0lOR2xoOVVpL0dPZmkzdTQ5NVNiNzlJcmd6TnpPNE42MnJsMWUzN2JXK2cwRldabDhjcll6YTNYajR0akVzajNqcHh3djllN3QydkRJNFhuTlpWMmlTczFSV3JZMlVoR2h6NEdWc1k4TGRFVUR3N1BPbHZoVVhQV0V3bWhqdUdSK1RmMkVldmpYVUxLeHJYV0tiZkc4VVAyRXJsbFZkWlBHdFhZL3ZuZmNva2pJbkZlVVdXMmF3Z2xaR2JPbzJsZ3lzeXhZTWJsK0JldXZsenpEK3V0VjQvbXRLTzVUVG5STWl6MUEzS25pZnFreVBKREw4ck5VcWttMzNaUHNTb2pCQnp1Qk9xdmNqc2xaM3VyS3lTME1zSk1yUkM0RlhwY0NjYWxTbEgzRlFPNWJiTktudmxsS3RvaTdhZXUrbmYwM1NNbGUrUDFOZXZrZEZMdXZ5Y1ErYUtWaXlyNytuajhGT0MyWEZKRlNNcDRvemYzczZZNTNQbUZ3SU0rVWlSM3Y4Z1NsU1RqRzc3RzVYd1JqV0VRMjJWTi9Wd3k3TFpNeDdleXVhMmJIZXBjd0REclN6YzZpdldFM08vTjlySm5kUm9DZlZ4dmFMWmc3cHAzZGx1ZHltclp5WDA5Qnp2OG5hMkdZOFJiWDhoakF4WTllQy8xRHVzWTd2Wlk5YkMzbEg3K1cwT2kxaFArYmExSEEzUzB1UjN5MzdKM0Zqejc5TVN0Nit5cVdFMUpybWc1cktpUWgwSnBIcmwxVktheXFTRmxWRVR0T0pWVkhaYThPa1JvN2FwdGFZbEdrUDkrRXdRaS9VcTJES1lZcWw5S3F4bzhIYXowWWFxNFErKzJacWxMbFVFekNHU2htV2FTclpDbjZhTEtrVFF5ZklrODZHL2pSOUxtVDJlcndDSlhvYkNVOGNSTXE4YXVaYVI5K1FlSGxsclNoVC9lYU8wdDB4SVJuMm0vVWE0Nzk1WUNQN0Q5bVNmV1ZrL0cwL1ppbWNoU0VVR2tvTi93MnlGaXFuWnlxTlNWTS85UGpHNjRiMys3bVV3M3RWcHcvK1AxME83djBJWWYwK0h0Z2ZDdnB1dG40NHNlTWIwdU5uekFZTGZIclpzRFlQVVdFTHlNM1AvWjBlaDRMcnJJdHlLSXlsK21zNzE4bVJ2cHYwdmxQeW9oaTh6L0pFV0Z0blF5WDhEaVB4Y1ZLbFRpY3lwaUo5dHMxbUkxMkErTm1ZK3dhMDVzcUFkT2JDSlFjbWZFYnR3RXNHTk1PY1BqcDBWR3c5UFRISE8xVStwbDlVYldVWkpNeThrNUs1dkxWS2RPSGJjSzBZY2s2MGlrc0I0eGRqbktVVktUQmZwZm9NQWZsQW9DSkJXSFpZUjBjM1k5QXE4TitCRHB0Nk50VXRvcDRMVnFWM2dUaW5xOXZZRjBGdE5aK2pWYTBCeVdkdFYrdnM5cUQvUmI4aWZkdGVEOEJOMGMxR0xERUUvQnh2TExGU2I5R2I3R3g5Z0lqVjZ5eGVFRU9kbXBRR1RPWjFTM09SM0tST0dzdG9GSmFDMFFqN3FLQUtoQXJBbnVLY1h4YktvcFBVbitodWtycEl6c3orVStubGpkdVNWNHUvTW5pelU4dm12VUwveGNIcDhVR1ZwOVBEajM4ekxid3ZGblJtdGx6eTZxWHo2aWtyLytBRnE3NTdONnVwWFhUb3I3cVNZMjlrZVQ3eVFNL3U3TjNCYlg5K3ZudkZFMC8rNTFUazd4bFBYaE9nUFczQTU4MW04VElYVGZwY0lkbm04QTlSV2MxRDczVTJwdjB1NHVuY3hrNU1WaWhTUnhRNXhXRThKU29aTFRKSmNINDFTNTRja0VvL2JFcVVRNUdVUFBiRXI2UzBuUlMvS1lkOHZpYnVLSTM2cHkzNVNQOHpadDIxUk11M01DN1ZHU0w5ZG9EUFlPOTl2eFlEWE9EYm5zRk4rcTJWNWc2K05HdnNuaDhTcCtBVzJ1NGgvamo1azMzRGlIaXVGbmpQZTRiSS9HdC8vMTVJOWE0K2J3VGlDNXVObS82cDVIWWt6THZQV3plUlRlWmQrQkc4eTRlTlcvL0o1czNVN1EzbjdvL2hTUnVPdnQvRzlIRzZmbXZodm1IU0IwNWtKcC9KRDMvV2pXck5jbFJzWVFFNjRGVXoxWVRodFdFcmV3NEI2NEdFNnhob2h4NHJCYlBxMXplb3BCRktUaVIvTEMyMmtocWJYSk9FZGdQUndsenJJSWl2Q201YklrczF2YnUrblhmck5DWi82aUdqNnMyN3JoV3BOS0o2NktiOW9Ma1o0d1JLU1ZWdlR6ZElGSkkwV2s2cTZJS2tQQUlwZkxUbENvRVNtV0hwVkJVZG9QSktnV1RWWkZXLy8zT0hFUlhXSktYaytvV2FSM3NMOWY3TUlUdllpSDhjckJhbFZnNUJhcFlkbVVEYlVyRS8xdmMyY2UyZFZVQi9ONzMvUHdSTzdhZjdUaDJuUGdqOFVlY09ISGlseVoxMGlaZEVtY05kYjBtYVpaK3FJVk9NZDJnb1N6UVJXSU5FNEpKRzR5eWtsWWFpQThWV2pxQmdQY1NDNnFDbUJqYW53Z0pvY0xLSmtBQ2lmdzFHT0lmeEF6MzNQdWU4L3lSTHJBL0pyVjY5bnVLNzd2bm5IZnV2ZStlOHp2RU1rS3dXUzEzdXBSZVduUXhGdHJWUWlyVEs1MWt0Q0d1VGtJYmREU1RLc0lvc3YzcE9wbWNZck9wSmUxeG5kVG1Venk2aXJiNVZZT1BmSUxJc2lFa1c5TWxrd1dsYU40Z1pJVExibHBBUGdXclBrOWFGdTVCWkxHbFpWdDJaaUJHVE0xSzFtNlJVNDlYdVQrVkR3N25oN1Yva0VWZS9nUDl3bjJmSHFqTnJ2TS9NTVNSRDRXSkxqNktOa1ZhZTEzVFJCQ2VPVlpKMEUrczFPK0U3UjNGNXFSRkJlbFdpRFpoL1pGWkVEMU43UkhtL21VTGxFK0UyamR1TnMzZlFyWkFBcTRKTHNXa2t6cmR5V2FDaDIxc3lBZW4rOWhHdW8zdFREQjVQNUpmbVhzSkpMNThjdUVqcHg4KzlyVnBQSmJadi9ydGJ4dzhkUEZHbmdtNzg0WFI2OCtYUWR6OUw0M2NubnhsL2RveWwvTy9XbTZPL2hRWGlqQnZvK3hBNGhmQkt4N1I4K0tyNklIRU00WWEwUU5qS2oxdzB4OW1YRWxhcnRLN0d6dHdBbXZrUUhEcTFmUkFJN2VERDN3Ym5Ib0RoR0JuWEFNSThxOVR6LzYrM1QvTWgzZS9mOXdKM3YzQkhlQzF0YVBXaDZlcGh6KzVheDhTdS9RQkhEMVBIbHc1RExuVEpYK2tNeHBuU0I3cUdmZmFJOVh0Nzk2cERkWHRQN0JiM0Q5MHZwLzFhNDcwQ3p6YVozYnBHWFNNZUxXdUhhL0d1cmtWNFVQRWdjVzhOUjNlNm5PMjFEdTJHQTh2OXhQVXNTbCtNK1NSYTE1dHJ4S29mV084dXlqT1Y0WGRQRmpQUzlWemU4cEdKUGJhU1hUZGdJNllxTkFSdS84L09pSVk1bDRJaVRoQ1RQVGRNWW5DcnpRekpmZCtHUmpHUkordFJKc0xUSnRLeUxTOWFjR3NWamRrZEFQeGU0QUdUdm1naktUZ2hUS1NQbFl2elM2cXVvS05jSXVibHZrTlFXaW8xOGhHWjFIeTFKWDBFUGtHR09QTDM3SlhjNHk1Umhqajh2ZU0zN0ZIeFhMVG5tREd2S3FiT2FJYmlCRmJyZFVPQk1NT1NrcWNHR3BmaGhhK2o5NVR1cjBVRmFPR2gyMzVCMUxFTmtGL0VDWFdIUlZkSll0VGpBQVlTMDZKaWhlQ0svd3VwWDhRT3YrL2E3ZldSUGVpNlEvcmpmWGROVzdzcXRuRDRKRDdQMi96ZnhUc3FBMzFvUTFWNzA0eUdnSzRUd2xyWlZPdE1EN0NoNlN3WGJJNXZQQld5R2Fxdk9zSzJHallGMERFVEc0QVA3TWlxczR1R2lVdFVrNEErUUFBWDZqbzNoV0E1YlVYeEJSbW9BdkY1b0RaU1lDV1lKT2pXY1djMUtDd1RsYTZZdDlPN2tHRTdrUWs0bTZuK3J5THF1VzRjK2tyczh2VCtINzVGbzZYNzBOcTBLSHpqMzQ5MmYvWmJHaXBaOStjbzZrdG1ZMmtGd1BkM0RNNGZHUGwzQWRHMWVTRVE0Vm5ubjBSdThwL2V5SC8wR0tPKzExdy80SG8vTEZMTk9mNXIvdy8rWitnWGpTRjVpQkxxaE5Xa0hGSjZSRGdWUmlkTmNoV1Naa2dOblEwVTVyMmRZSnNwbmMyTzFVQUV4UVE5RmkzTjNNZWtFbHVQeEVGN0hmbUtJaEpzSFoweG4xREIrYlVXc1VobU5GREtuTTRDZ2x1b2hJYUpzZHAxNVlIcFdDblhaNFFGVGVRTEFVdFNHNmthclBBMEk0N2NNU3JveEZUNGx3aVBsS3BYQWVKWlpXb0RLTVFZV1hkV2NsYTIyanFpL25zY2lTeGNxRHdmTmpVWkRUZ2NoL3VhQ3NlL0dSdTlzSlhQMWM4OVdScThVUkg5bkxRZjJvb09kN2NiTEdNSnZzV0ExRzhnWmM0dThON3BLZC93ZXZEZi83NWhZV2x3YjYrd1JNbjNkM3BydEgyeWFiV0h6NDBObnJzeE1YakM4SEMyTnJmdjNubTZHd3FhaXA4dmpEMWlXbExJak9lelUrNWVudHkvbmhpYUl3K3R5dzI2QkZrUms0eVoxdXVqZzZDckl4V1NiRlpvTXdJUmJzMTNWUHM1S20xcTVWRXlmelpaVFNScDlaTGhoSktjbXVpSkFURnhjS0hGSzhScG15K2JNT0lJcTdtaWR5SkxxcW1kK21EakY2ckNzREUyR1Z3OHdZeS9odUpCUUZVeENpVk9CVXhVcW1jWmRFcVozRUd0WEtXK2tJTXU5aTRYUFVPREtPN2hwUDh4OGk2cXcwTkkwaEhOUk5UYkUwckhCaGRJQTE3aEVneHV5QVpyYVVObGtxdGxDTER1VGFOUUs2aU5KSEdTNk83dTY5K2FsNGJxSkgyZXFZVDBzT2IwSHU4WnJpcXUyWkFWZGZNK212bW5XdjRFdmNXZDExb0kydUtiaVNMYVJDMFdWMUNRQjFiVWExamkweDJscEJJS1NIaytRREthOURBMHN6eHBmc3pZNm1nMng1MCtYS0QyVVgrS3pmZkhCK2VIWWk3dzFhUHZjZWZuamxMMjVvbmJhMlN0anpRbG9jdVYyaGJMUlNNNFNKdEdTQkhCQmxzcEMwdmE0dEdxVklxSkVQaHRYaE1lQjRhYzlpZFRqKzBkcC92bzIxRmJCYXJqVGFXdi9rbWE2OThtMXRGdjM3djdXWDc5ZTJWLzdMdnlFQ3NyajBPM2VEZTRwK2dza3lnQWtoVGprbXFRR21TVDNjRG1VS2hMOGcrQ3BDekFmQnpLQUF4WmJCeThzQjdWSTVuWVllMU1vL1Zucmp4K3NONkhlQ1hhM1Z5NjQwYW5lVHJ0Y1NoZGRLSEdhcWpKUFNCbUVGU1VnVW5Sek0wQWFaT2RsbytUNEtjOVNmZ3JEK2lGZ0gzQStTckpjbjYwRUMyc1FibjFzZFNJWjI0OFdQMTZzNUVxOFUvM3NBQ1NGL0t0L2tacXYvM3J5L1ovdXErMUp0U3BxdW1MdzJzQytPenVNVGQ1WnYwVEI4YlkvcllWS1lQd3dQYkdOUEhWbUg2cUN0K01oTStXL3h5c1RoN21QTmRXVjYrc2t5OGdaMnNSMzZCZmtOK1V5Uis4VGdiSnhTSFQ1SlVWcEJpOVdReTlHd0ZIaFRRd1lOVVltUEp6cjZSQWNSRnZyVXlSa003YlgxRUl3ckY2ajdZR1dJSVA2WWV6N0hqQnhseGFMRHF3SHhWa2xqbnp5aS94b3Uwb1lEY2lWVWRDc2pUeTJCOU9GbEg2YXY1KzJDRHY5Y0I1bFVvRHZtZE9oWU8rTk1wSXJjZkMwWXlrcEE1OFFESXJKY3MzeHd3MTJzbGN6MkVCeHpOdlhLWFJBdEp4aklsazVHZUNFcEFncExiMlY0Z2YwOGV6aWdSSzJ3SHltWUlGV3EzMGkxQXNnZ1lZQkJkSk1wOWJEc0ZvbFVjSWlVbnVFZWtmVU1qWFNNU0JEQ295RncySVRGRlRMU2VBam5vcGpIOWZHSXFNQytzQmg3M0RjYUxLK2VIWGw2UnpJSndldjJKT3owbUh2OHJWWTRJR04vcUwxOXJtWkJlekgvNnpPamE3ZUVMbnpwWGNPSlgxc0tGNGFmV0ZpWS9KTFZlL0lLcHczajZ1YXZ0dHFkR0p6cnNhK3ZIWjZhUG4zL2NOMW44N2dyNHZpajNKZjROd1lOTVJEZnJqTGlrV0pxSkphRUsxVVpseXdGZ3lleklaR2lWQVNQUkFDV25OSzYzQ3haR1ZGUHlNcnBLVXdiNElFNXlncEVKYVJWbGlGS1FyVlErelZuMU5SZXdzckFvdVNkb3JYTUhXWVNKVWZ6YW5UUDQyT0dObzBlbkhoMC9HSDdTOE9yOC9EdS81Q1R5LzlueWI2OWRmK2RwZk9maks5enZ5NGRCeC9EUzdTWi9rendsS2dzZktHY21jcCs2enhyeGpCWHkxT3A1TXZEWm9CZ1I0UWYrRFRpcS93SW11em5vQUFFQUFBQUJBazNlOWw4YVh3ODg5UUFmQ0FBQUFBQUF3VmwyRGdBQUFBRFp3K3NMQUFEK2xnaVJCbW9BQUFBSUFBSUFBQUFBQUFCNDJtTmdaR0JnVy9zdmo0R0JVNTZCNGY5L2pva01RQkVVOEF3QWUxUUZ4M2phZGROTlIwUlJHQWZ3NTh4VURCV1Z0S21abURadElta3prbEZSV3ZRMjBxSkVlaGxHcWpHR01aV1J4T2hGTG1tUlNHSVdRMStnS1gyQTNHOHhXclZ2RmYzUE9mL0xPT3J5ODl4N1BPZmM1enpuM3RDWFRBbXVVRldrU1RTVlJhekRDQlFoQWJNWXIwQXY3bTlnR2Rid3ZJVG9JUjRnbnNJTzFPQVdybUNUNCtmd0NJZHdhZlBOM0dtN2ppd3lMd2xSemt2QkhoVGd3ZFlnKzRBNlpCdFdvTXk4Tkl3eFY4Y2NaTGhlbW51Sk16ZGh4MVFiMzFtRmQxdUw2a1BjNHI1enJFMC9uOEE4WElQUCtzcmMwNXpkazFtN3lMbytJTS84RXZmWER4c3d4SnAyOGI1WHhEZjJNK2k5WG5zQkx0aDNuWE1HbjZEN2Y4OSsxbXp2emRnUGZMUGV1czFWdXJaaHUwZlQ3d25tQmZOYnFZZlAwWDlFdUxlQ28rSVliemdIMXpOajJwSGdXbG4yK1MvZFBBdDMzSGVrR3M3QjVUR1dIUG9zamhpNzJBL1VwRG9SWDhLaklpMFprU0NHNGlMcURqb3M4UkZuRUZmTnYrTUZtbVBpUldMbXY4amI3OXg4Ni9vOGppMjFqdGl1NStKK1VOUHJZbXdTQnNKUElyK0hZV0x3QUFBQWVOcGpZR0RRZ2NJNmhtdU05NWdtTVpzd0gySCt4cUxCRXNCU3diS0w1Uk1yRjZzRmF3RHJEdFlQYkVsc0Y5aGwyUHM0aERoY09JNXdPbkhXY1Y3amZNUEZ4NlhFTllYYmhqdVArd1dQRTA4Znp5bGVCdDR5M2lPOC8vaEMrS2J4bmVEbjRRL2czeUxBSVRCTDRKZGdpZUFTd1I5Q1JrTExoRzRJY3dqYkNXY0kxd212RUw0aS9FWkVUV1NkcUlKb2p1Z1RzUWl4SGVKVHhEOUpPRWdzazNnbEtTTTVUZktabElYVUVta2U2U0RwQ3pKcE1vZGt2c25XeUs2VFk1S3prTHNnOTBxK1JuNmYvRDRGQVlVN2lnMktINVRDbEtxVWRaU1RsRCtwTktrc1VUbWo4a1IxZ3VvNjFVOXFEbXBMMU1YVXpkU1hxVC9URU5MSTBKaW44VWxUVEhPTlZvUzJqdll5N1FjNlVqb1JPa2QwdFhTbjZMSHB6ZEM3bzYrZ242Ti94VURNSU1KZ2lTR1hZWlVSazFHQjBUM2pBT01mSm0wbUsweDFUTHRNWDVnRm1kMHdGekF2TVA5bDBXRXBacm5HcXNUYXhQcVh6UVhiR050RGRocDJrK3cxN0RQc1Y5aS9jL0J6WkhPYzQvakRLY1JwaTdPSDh3VVhQcGNXbHlldWJxNmIzR3pjWnJsenVVL3pVUE40NXVubVdlQzVEUWM4NG5uSjg0SG5PODgvWGtaZVdWNkx2Rm04czd3dmVQL3lDUUxDSXA5cFB0TjhGWHc3ZkRjQUFNZDVtdzBBQUFFQUFBRG1BRllBQlFBQUFBQUFBZ0FCQUFJQUZnQUFBUUFCa3dBQUFBQjQyblZTUzA3RE1CUWNKd1VKcVdMWkJTc3ZXRUw2QVFwMFc2a1NVcUVTUlpSdEMya2JxU1FoU1VGY2hDTndGaWduNEFxY2dubTJDeXlJck5qamVYbno1cjBFUUJVdjhLRXFXNEJxQXc0cjFIaXoyRU5WOVIzMmNhRnVISzVnVjcwNnZBR3RWZzV2TXZmTDRUZlV2TFhtT3hwZXplRVZ0cjJld3gvRVZ4Wi8rdGp4SnVnaVE0Z3hDdTUzMEpqZ21mc2xtUlJ6b2o3NVIwVGNZOTZXeUlsanpJam5SRG5QQkU4bVZoQWxXQmh1VEViVWVtUmlSdVRNbUJVaUlOdmxMV1dkakFvejZoVGtXbWh3dFV0ckJ5WVNVbC9jNXM3dDB0UUpxU1QxNTBRYVE1d3hVMk5BRmV0NjdVSVVJOXdhVmhUMlRCY0ZWNG9PNmx3NW8rSXFKWmV6cG5TNzRHbmQxNm5abzBiQUNqSGZUSXlPOUN6ekcrUGN1SXJvNnY2ZnpxWEhnRDFxMXRJbENqYld4QkgyY2NMSFR1VzQ5TzIvRmEvTkhNUnhZcnFXekthcDJNQnBhY1VSc3lhWS9reklab3pjZkFmTUVGWWJCZkhWNGRQaWZvZ0Q5OVdhak1rM21GSnRTZDNDekQwekU1Yi81WGY2UXp5UWlSaVRmMjd4RGNhY2Qwc0FlTnB0MEVsc2pIRWN4dkh2cjUzT3ROTjlYK3c3VmJ6dk81MHU5cG0yWTk4cFNsSGF6Z3pWMXRTZ2FCSDdHaUxoUkdoZEVQc2Fnb00yOWkxRmNIQVVleHh3azZEdjM4MXorZVQzSEo3RGp4RGE4OHRQSmYvTE81QVFDU1VVQzJGWXNSRk9CSFlpaVNLYUdHS0pJNTRFRWtraW1SUlNTU09kRERyUWtVNTBwZ3RkNlVaM2V0Q1RYdlNtRDMzcFJ5Yjl5V0lBQXhtRWhvNkJnMnljNUpCTEh2a01aZ2hER2Nad1JqQVNGMjRLS0tRSUQ2TVl6UmpHTW83eFRHQWlrNWpNRktZeWplbk1vSmlaekdJMkpjeGhMcVhNWXo0TEtCTUx6V3hpTXpjNHdIdTJzSWVkSE9JNHh5U01IYnhoSS92RktqWjJjNUJ0M09hdGhIT1lFL3pnT3o5cDRoVDN1TU5wRnJLSXZaVHpnQXJ1Y3A4blBPUVJqL253NTN0dFBPVVpaL0R5algyODVEa3Y4UEdKTDJ4bk1YNldzSlFxcWpsQ0RjdW9KVUFkUVphemdwVjhaQldycVdjTkRhemxLa2RaUnlQcjJjQm52bktOczV6ak9xOTRMUkZpbDBpSmttaUprVmlKazNoSmtFUkprbVJKNFR3WHVNd1ZXcmpJSlZyWnlrbEo1U2EzSkUzUzJTVVpWbTlWZmExUE56RnN3V3EvcHJrMFphR3BXL1Z1aHpML3I0YW1hVXBkYVNnZHlteWxVNW1qekZYbUtmL3R1VXgxdGF2cjlrcS9OeGlvS0Mrcjg1bVY0VEYxZWl4RndVQk4rK0gwRlB3R1pnYVQ5UUFBZU5wRnpEME9na0FRQldEV2xRV1JmeFk3RTZ5MzhRVEdRaWpFd2xoQjVCekdTbTBvOVN5RGxmRTRYZ1FIWEpkdXZwZDU3MFhhR3NoZHk4SGNGdzBoajdMSm1DZ1c0SmM1OEFNZXQzSU9URlNGQmpSSmdZb042RW42MWlpSnRaSG9QVTdTcDM2UllBajZrVEFRckpJd0VjWldZb0l3K1E4RUxMbnNkc3NXNGJqYzBPeUVpWU4vN2xuUlJqcVY0aFJwcnhXOXZuNXRoN3JmSlI2SmhpVEFpbDhyaHNqZ3FCZ2h3NTBpUjBZcnhSakpsNG96Wk16L0xJR0xMd0M5WFRzQVwiIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlcy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7IiwiaW1wb3J0IHsgX19ub25OdWxsLCBhc3NlcnQgfSBmcm9tIFwiLi9Db3JlXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW48VD4gKHjMhcyFOiBUW11bXSk6IFRbXSB7XG4gICBjb25zdCB4zIU6IFRbXSA9IFtdIC8vIG90aGVyd2lzZSBUUyBpcyBjb25mdXNlZFxuICAgcmV0dXJuIHjMhS5jb25jYXQuYXBwbHkoW10sIHjMhcyFKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnRzPFQ+ICh4zIU6IFRbXSk6IE1hcDxULCBudW1iZXI+IHtcbiAgIGNvbnN0IGNvdW50czogTWFwPFQsIG51bWJlcj4gPSBuZXcgTWFwXG4gICB4zIUuZm9yRWFjaCh4ID0+IHtcbiAgICAgIGlmIChjb3VudHMuaGFzKHgpKSB7XG4gICAgICAgICBjb3VudHMuc2V0KHgsIF9fbm9uTnVsbChjb3VudHMuZ2V0KHgpKSArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY291bnRzLnNldCh4LCAxKVxuICAgICAgfVxuICAgfSlcbiAgIHJldHVybiBjb3VudHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHppcDxULCBVPiAoeMyFOiBUW10sIHnMhTogVVtdKTogW1QsIFVdW10ge1xuICAgcmV0dXJuIHppcFdpdGgoKHQ6IFQsIHU6IFUpOiBbVCwgVV0gPT4gW3QsIHVdKSh4zIUsIHnMhSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHppcFdpdGg8VCwgVSwgVj4gKGY6ICh0OiBULCB1OiBVKSA9PiBWKTogKHjMhTogVFtdLCB5zIU6IFVbXSkgPT4gVltdIHtcbiAgIHJldHVybiAoeMyFLCB5zIUpID0+IHjMhS5tYXAoKHg6IFQsIG46IG51bWJlcik6IFYgPT4gZih4LCB5zIVbbl0pKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXM8VD4gKHjMhTogVFtdLCB5zIU6IFRbXSk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHnMhS5ldmVyeSh5ID0+IHjMhS5pbmNsdWRlcyh5KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVxPFQ+ICh4zIU6IFRbXSwgecyFOiBUW10pOiBib29sZWFuIHtcbiAgIGxldCBuOiBudW1iZXIgPSB4zIUubGVuZ3RoXG4gICBpZiAobiAhPSB5zIUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICBpZiAoeMyFW25dICE9PSB5zIVbbl0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudGg8VD4gKHjMhTogVFtdLCBuOiBudW1iZXIpOiBUIHtcbiAgIGFzc2VydCgwIDw9IG4gJiYgbiA8IHjMhS5sZW5ndGgpXG4gICByZXR1cm4geMyFW25dXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+ICh4zIU6IFRbXSk6IFQge1xuICAgYXNzZXJ0KHjMhS5sZW5ndGggPiAwKVxuICAgcmV0dXJuIHjMhS5zbGljZSgtMSlbMF1cbn1cbiIsIi8vIEEgbm9taW5hbCB0eXBpbmcgaWRpb207IHNlZSBodHRwczovL2Jhc2FyYXQuZ2l0Ym9va3MuaW8vdHlwZXNjcmlwdC9kb2NzL3RpcHMvbm9taW5hbFR5cGluZy5odG1sLlxuZXhwb3J0IGludGVyZmFjZSBUYWc8VCBleHRlbmRzIHN0cmluZz4ge1xuICAgdHlwZW5hbWU6IFRcbn1cblxuZXhwb3J0IHR5cGUgQ2xhc3M8VCA9IE9iamVjdD4gPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUXG5cbi8vIFBvc3NpYmx5IGFic3RyYWN0IGNsYXNzOyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY4ODYwODIuXG5leHBvcnQgdHlwZSBBQ2xhc3M8VD4gPSBGdW5jdGlvbiAmIHsgcHJvdG90eXBlOiBUIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzT2Y8VD4gKHg6IFQpOiBDbGFzczxUPiB7XG4gICByZXR1cm4gKF9fbm9uTnVsbCh4KSBhcyBPYmplY3QpLmNvbnN0cnVjdG9yIGFzIENsYXNzPFQ+IC8vIHdlaXJkbHkgZmFpbGluZyBvbiBDaXJjbGVDSSB3aXRob3V0IGNhc3Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzTmFtZSAobzogT2JqZWN0KTogc3RyaW5nIHtcbiAgIHJldHVybiBjbGFzc09mKG8pLm5hbWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzPFUsIFQgZXh0ZW5kcyBVPiAoeDogVSwgQzogQUNsYXNzPFQ+KTogVCB7XG4gICBpZiAoX19ub25OdWxsKHgpIGluc3RhbmNlb2YgQykge1xuICAgICAgcmV0dXJuIDxUPnhcbiAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0KGZhbHNlLCBcIlthc10gRXhwZWN0ZWQgXCIgKyBDLm5hbWUgKyBcIiwgZ290IFwiICsgY2xhc3NOYW1lKHgpKVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNPcHQ8VSwgVCBleHRlbmRzIFU+ICh4OiBVLCBjbHM6IEFDbGFzczxUPik6IFQge1xuICAgaWYgKHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geCBhcyBUXG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzKHgsIGNscylcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCAoYjogYm9vbGVhbiwgbXNnPzogc3RyaW5nLCAuLi54zIU6IHVua25vd25bXSk6IGFueSB7XG4gICBpZiAoIWIpIHtcbiAgICAgIGlmICh4zIUubGVuZ3RoID4gMCkge1xuICAgICAgICAgY29uc29sZS53YXJuKFwiQXNzZXJ0aW9uIGRhdGE6XFxuXCIpXG4gICAgICAgICB4zIUuZm9yRWFjaCh4ID0+IGNvbnNvbGUud2Fybih4KSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgXCJBc3NlcnRpb24gZmFpbHVyZVwiKVxuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWJzdXJkIChtc2c/OiBzdHJpbmcsIC4uLnjMhTogdW5rbm93bltdKTogYW55IHtcbiAgIGFzc2VydChmYWxzZSwgbXNnLCAuLi54zIUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZDxUPiAoeDogVCk6IFQge1xuICAgcmV0dXJuIHhcbn1cblxuLy8gVXNlci1sZXZlbCBlcnJvci5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyRXJyb3IgKG1zZzogc3RyaW5nLCAuLi54zIU6IHVua25vd25bXSk6IGFueSB7XG4gICBpZiAoeMyFLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGRhdGE6XFxuXCIpXG4gICAgICB4zIUuZm9yRWFjaCh4ID0+IGNvbnNvbGUud2Fybih4KSlcbiAgIH1cbiAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgZXJyb3I6IFwiICsgbXNnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm90WWV0SW1wbGVtZW50ZWQgKCk6IGFueSB7XG4gICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpXG59XG5cbi8vIFVzZWZ1bCB3aGVuIGEgbm90aW9uYWxseSBhYnN0cmFjdCBjbGFzcyBuZWVkcyB0byBiZSBjb25jcmV0ZS5cbmV4cG9ydCBmdW5jdGlvbiBhYnN0cmFjdE1ldGhvZEVycm9yPFQ+ICh0aGlzXzogT2JqZWN0KTogVCB7XG4gICByZXR1cm4gYXNzZXJ0KGZhbHNlLCBcIkFic3RyYWN0IG1ldGhvZCBpbiBcIiArIHRoaXNfKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19ub25OdWxsPFQ+ICh4OiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgbXNnPzogc3RyaW5nKTogVCB7XG4gICBpZiAoeCAhPT0gbnVsbCAmJiB4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB4XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydChmYWxzZSwgYFVuZXhwZWN0ZWQgbnVsbCB8IHVuZGVmaW5lZC4ke21zZyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGBcXG4ke21zZ31gfWApXG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2xvZzxUPiAoXG4gICB4OiBULFxuICAgbXNnPzogKGl0OiBUKSA9PiBzdHJpbmcsXG4gICB0cmFuc2Zvcm06IChpdDogVCkgPT4gVCA9IChpdDogVCkgPT4gaXRcbik6IFQge1xuICAgY29uc3QgeF8gPSB0cmFuc2Zvcm0oeClcbiAgIGlmIChtc2cpIHtcbiAgICAgIGNvbnNvbGUubG9nKG1zZyh4XykpXG4gICB9XG4gICBjb25zb2xlLmxvZyh4XylcbiAgIHJldHVybiB4XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NoZWNrPFQ+ICh4OiBULCBwcmVkaWNhdGU6IChpdDogVCkgPT4gYm9vbGVhbik6IFQge1xuICAgYXNzZXJ0KHByZWRpY2F0ZSh4KSlcbiAgIHJldHVybiB4XG59XG4iLCJpbXBvcnQgeyBfX25vbk51bGwgfSBmcm9tIFwiLi9Db3JlXCJcbmltcG9ydCB7IEJvb2xlYW5MYXR0aWNlIH0gZnJvbSBcIi4vT3JkXCJcblxuLy8gQWN0dWFsbHkgYSBib29sZWFuIGxhdHRpY2UuLi5cbmFic3RyYWN0IGNsYXNzIExhdHRpY2VJbXBsPFQ+IGltcGxlbWVudHMgQm9vbGVhbkxhdHRpY2U8VD4ge1xuICAgYWJzdHJhY3QgYm90OiBUXG4gICBhYnN0cmFjdCB0b3A6IFRcblxuICAgam9pbiAoLi4udMyFOiBUW10pOiBUIHtcbiAgICAgIHJldHVybiB0zIUucmVkdWNlKCh0MSwgdDIpID0+IHRoaXMuam9pbjIodDEsIHQyKSlcbiAgIH1cblxuICAgbWVldCAoLi4udMyFOiBUW10pOiBUIHtcbiAgICAgIHJldHVybiB0zIUucmVkdWNlKCh0MSwgdDIpID0+IHRoaXMubWVldDIodDEsIHQyKSlcbiAgIH1cblxuICAgYWJzdHJhY3Qgam9pbjIgKHQxOiBULCB0MjogVCk6IFRcbiAgIGFic3RyYWN0IG1lZXQyICh0MTogVCwgdDI6IFQpOiBUXG4gICBhYnN0cmFjdCBuZWdhdGUgKHQ6IFQpOiBUXG59XG5cbmV4cG9ydCBjbGFzcyBCb29sTGF0dGljZSBleHRlbmRzIExhdHRpY2VJbXBsPGJvb2xlYW4+IHtcbiAgIGJvdCA9IGZhbHNlXG4gICB0b3AgPSB0cnVlXG5cbiAgIC8vIEltcG9ydGFudCB0byBhc3NlcnQgdGhhdCBhcmd1bWVudHMgYXJlIGRlZmluZWQgc2luY2UgdW5kZWZpbmVkIHByb3BhZ2F0ZXMgaW4gYW4gdW5oZWxwZnVsIHdheS5cbiAgIGpvaW4yIChiMTogYm9vbGVhbiwgYjI6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBfX25vbk51bGwoYjEpIHx8IF9fbm9uTnVsbChiMilcbiAgIH1cblxuICAgbWVldDIgKGIxOiBib29sZWFuLCBiMjogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIF9fbm9uTnVsbChiMSkgJiYgX19ub25OdWxsKGIyKVxuICAgfVxuXG4gICBuZWdhdGUgKGI6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAhYlxuICAgfVxufVxuXG5leHBvcnQgY29uc3QgYm9vbF86IEJvb2xlYW5MYXR0aWNlPEFubm90YXRpb24+ID0gbmV3IEJvb2xMYXR0aWNlKClcbmV4cG9ydCB0eXBlIEFubm90YXRpb24gPSBib29sZWFuIC8vIGZvciBub3dcbiIsImltcG9ydCB7IEVxIH0gZnJvbSBcIi4vRXFcIlxuXG5leHBvcnQgaW50ZXJmYWNlIE9yZDxLIGV4dGVuZHMgT3JkPEs+PiBleHRlbmRzIEVxPEs+IHtcbiAgIC8vIFRoZSBhcmd1bWVudCBpcyBhbHdheXMgb2YgdGhlIHR5cGUgaW1wbGVtZW50aW5nIE9yZC5cbiAgIGxlcSAoYTogSyk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVxPEsgZXh0ZW5kcyBPcmQ8Sz4+KGE6IEssIGI6IEspOiBib29sZWFuIHtcbiAgIHJldHVybiBhLmxlcShiKSAmJiBiLmxlcShhKVxufVxuXG5leHBvcnQgdHlwZSBDb21wYXJhdG9yPFQ+ID0gKHg6IFQsIHk6IFQpID0+IG51bWJlclxuXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5TZW1pbGF0dGljZTxUPiB7XG4gICBqb2luICguLi50czogVFtdKTogVFxuICAgYm90OiBUXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVldFNlbWlsYXR0aWNlPFQ+IHtcbiAgIG1lZXQgKC4uLnRzOiBUW10pOiBUXG4gICB0b3A6IFRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXR0aWNlPFQ+IGV4dGVuZHMgSm9pblNlbWlsYXR0aWNlPFQ+LCBNZWV0U2VtaWxhdHRpY2U8VD4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJvb2xlYW5MYXR0aWNlPFQ+IGV4dGVuZHMgTGF0dGljZTxUPiB7XG4gICBuZWdhdGUgKHQ6IFQpOiBUXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGlmZjxUPiAoeMyFOiBTZXQ8VD4sIHnMhTogU2V0PFQ+KTogU2V0PFQ+IHtcbiAgIHJldHVybiBmaWx0ZXIoeMyFLCB4ID0+ICEoecyFLmhhcyh4KSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVyeTxUPiAoeMyFOiBTZXQ8VD4sIHByZWQ6ICh4OiBUKSA9PiBib29sZWFuKTogYm9vbGVhbiB7XG4gICByZXR1cm4gQXJyYXkuZnJvbSh4zIUpLmV2ZXJ5KHByZWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXI8VD4gKHjMhTogU2V0PFQ+LCBwcmVkOiAoeDogVCkgPT4gYm9vbGVhbik6IFNldDxUPiB7XG4gICByZXR1cm4gbmV3IFNldChbLi4ueMyFXS5maWx0ZXIocHJlZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4gKHjMhTogU2V0PFQ+LCBmOiAoeDogVCkgPT4gVSk6IFNldDxVPiB7XG4gICByZXR1cm4gbmV3IFNldChbLi4ueMyFXS5tYXAoZikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb21lPFQ+ICh4zIU6IFNldDxUPiwgcHJlZDogKHg6IFQpID0+IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgIHJldHVybiBBcnJheS5mcm9tKHjMhSkuc29tZShwcmVkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pb248VD4gKC4uLnjMhcyFOiBTZXQ8VD5bXSk6IFNldDxUPiB7XG4gICBjb25zdCB5zIU6IFNldDxUPiA9IG5ldyBTZXQoKVxuICAgeMyFzIUuZm9yRWFjaCh4zIUgPT4ge1xuICAgICAgeMyFLmZvckVhY2goeCA9PiB7XG4gICAgICAgICB5zIUuYWRkKHgpXG4gICAgICB9KVxuICAgfSlcbiAgIHJldHVybiB5zIVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbjxUPiAoeMyFzIU6IFNldDxUPiwgecyFOiBTZXQ8VD4pOiBTZXQ8VD4ge1xuICAgY29uc3QgenM6IFNldDxUPiA9IG5ldyBTZXQoKVxuICAgeMyFzIUuZm9yRWFjaCh4ID0+IHtcbiAgICAgIGlmICh5zIUuaGFzKHgpKSB7XG4gICAgICAgICB6cy5hZGQoeClcbiAgICAgIH1cbiAgIH0pXG4gICByZXR1cm4genNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=